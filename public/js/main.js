!function (e) {
    var t = {};

    function n(i) {
        if (t[i]) return t[i].exports;
        var r = t[i] = {i: i, l: !1, exports: {}};
        return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
    }

    n.m = e, n.c = t, n.d = function (e, t, i) {
        n.o(e, t) || Object.defineProperty(e, t, {enumerable: !0, get: i})
    }, n.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
    }, n.t = function (e, t) {
        if (1 & t && (e = n(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
            enumerable: !0,
            value: e
        }), 2 & t && "string" != typeof e) for (var r in e) n.d(i, r, function (t) {
            return e[t]
        }.bind(null, r));
        return i
    }, n.n = function (e) {
        var t = e && e.__esModule ? function () {
            return e.default
        } : function () {
            return e
        };
        return n.d(t, "a", t), t
    }, n.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, n.p = "", n(n.s = 142)
}([function (e, t, n) {
    (function (e) {
        e.exports = function () {
            "use strict";
            var t, i;

            function r() {
                return t.apply(null, arguments)
            }

            function o(e) {
                return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
            }

            function a(e) {
                return null != e && "[object Object]" === Object.prototype.toString.call(e)
            }

            function s(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }

            function l(e) {
                if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
                var t;
                for (t in e) if (s(e, t)) return !1;
                return !0
            }

            function c(e) {
                return void 0 === e
            }

            function u(e) {
                return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
            }

            function d(e) {
                return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
            }

            function h(e, t) {
                var n, i = [];
                for (n = 0; n < e.length; ++n) i.push(t(e[n], n));
                return i
            }

            function p(e, t) {
                for (var n in t) s(t, n) && (e[n] = t[n]);
                return s(t, "toString") && (e.toString = t.toString), s(t, "valueOf") && (e.valueOf = t.valueOf), e
            }

            function f(e, t, n, i) {
                return kt(e, t, n, i, !0).utc()
            }

            function m(e) {
                return null == e._pf && (e._pf = {
                    empty: !1,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: !1,
                    invalidEra: null,
                    invalidMonth: null,
                    invalidFormat: !1,
                    userInvalidated: !1,
                    iso: !1,
                    parsedDateParts: [],
                    era: null,
                    meridiem: null,
                    rfc2822: !1,
                    weekdayMismatch: !1
                }), e._pf
            }

            function _(e) {
                if (null == e._isValid) {
                    var t = m(e), n = i.call(t.parsedDateParts, (function (e) {
                            return null != e
                        })),
                        r = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n);
                    if (e._strict && (r = r && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return r;
                    e._isValid = r
                }
                return e._isValid
            }

            function g(e) {
                var t = f(NaN);
                return null != e ? p(m(t), e) : m(t).userInvalidated = !0, t
            }

            i = Array.prototype.some ? Array.prototype.some : function (e) {
                var t, n = Object(this), i = n.length >>> 0;
                for (t = 0; t < i; t++) if (t in n && e.call(this, n[t], t, n)) return !0;
                return !1
            };
            var y = r.momentProperties = [], v = !1;

            function x(e, t) {
                var n, i, r;
                if (c(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), c(t._i) || (e._i = t._i), c(t._f) || (e._f = t._f), c(t._l) || (e._l = t._l), c(t._strict) || (e._strict = t._strict), c(t._tzm) || (e._tzm = t._tzm), c(t._isUTC) || (e._isUTC = t._isUTC), c(t._offset) || (e._offset = t._offset), c(t._pf) || (e._pf = m(t)), c(t._locale) || (e._locale = t._locale), y.length > 0) for (n = 0; n < y.length; n++) c(r = t[i = y[n]]) || (e[i] = r);
                return e
            }

            function b(e) {
                x(this, e), this._d = new Date(null != e._d ? e._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === v && (v = !0, r.updateOffset(this), v = !1)
            }

            function w(e) {
                return e instanceof b || null != e && null != e._isAMomentObject
            }

            function M(e) {
                !1 === r.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e)
            }

            function T(e, t) {
                var n = !0;
                return p((function () {
                    if (null != r.deprecationHandler && r.deprecationHandler(null, e), n) {
                        var i, o, a, l = [];
                        for (o = 0; o < arguments.length; o++) {
                            if (i = "", "object" == typeof arguments[o]) {
                                for (a in i += "\n[" + o + "] ", arguments[0]) s(arguments[0], a) && (i += a + ": " + arguments[0][a] + ", ");
                                i = i.slice(0, -2)
                            } else i = arguments[o];
                            l.push(i)
                        }
                        M(e + "\nArguments: " + Array.prototype.slice.call(l).join("") + "\n" + (new Error).stack), n = !1
                    }
                    return t.apply(this, arguments)
                }), t)
            }

            var k, S = {};

            function D(e, t) {
                null != r.deprecationHandler && r.deprecationHandler(e, t), S[e] || (M(t), S[e] = !0)
            }

            function L(e) {
                return "undefined" != typeof Function && e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
            }

            function E(e, t) {
                var n, i = p({}, e);
                for (n in t) s(t, n) && (a(e[n]) && a(t[n]) ? (i[n] = {}, p(i[n], e[n]), p(i[n], t[n])) : null != t[n] ? i[n] = t[n] : delete i[n]);
                for (n in e) s(e, n) && !s(t, n) && a(e[n]) && (i[n] = p({}, i[n]));
                return i
            }

            function C(e) {
                null != e && this.set(e)
            }

            function A(e, t, n) {
                var i = "" + Math.abs(e), r = t - i.length;
                return (e >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + i
            }

            r.suppressDeprecationWarnings = !1, r.deprecationHandler = null, k = Object.keys ? Object.keys : function (e) {
                var t, n = [];
                for (t in e) s(e, t) && n.push(t);
                return n
            };
            var I = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                P = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, R = {}, Y = {};

            function z(e, t, n, i) {
                var r = i;
                "string" == typeof i && (r = function () {
                    return this[i]()
                }), e && (Y[e] = r), t && (Y[t[0]] = function () {
                    return A(r.apply(this, arguments), t[1], t[2])
                }), n && (Y[n] = function () {
                    return this.localeData().ordinal(r.apply(this, arguments), e)
                })
            }

            function O(e, t) {
                return e.isValid() ? (t = F(t, e.localeData()), R[t] = R[t] || function (e) {
                    var t, n, i, r = e.match(I);
                    for (t = 0, n = r.length; t < n; t++) Y[r[t]] ? r[t] = Y[r[t]] : r[t] = (i = r[t]).match(/\[[\s\S]/) ? i.replace(/^\[|\]$/g, "") : i.replace(/\\/g, "");
                    return function (t) {
                        var i, o = "";
                        for (i = 0; i < n; i++) o += L(r[i]) ? r[i].call(t, e) : r[i];
                        return o
                    }
                }(t), R[t](e)) : e.localeData().invalidDate()
            }

            function F(e, t) {
                var n = 5;

                function i(e) {
                    return t.longDateFormat(e) || e
                }

                for (P.lastIndex = 0; n >= 0 && P.test(e);) e = e.replace(P, i), P.lastIndex = 0, n -= 1;
                return e
            }

            var B = {};

            function j(e, t) {
                var n = e.toLowerCase();
                B[n] = B[n + "s"] = B[t] = e
            }

            function H(e) {
                return "string" == typeof e ? B[e] || B[e.toLowerCase()] : void 0
            }

            function N(e) {
                var t, n, i = {};
                for (n in e) s(e, n) && (t = H(n)) && (i[t] = e[n]);
                return i
            }

            var U = {};

            function W(e, t) {
                U[e] = t
            }

            function V(e) {
                return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
            }

            function G(e) {
                return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
            }

            function q(e) {
                var t = +e, n = 0;
                return 0 !== t && isFinite(t) && (n = G(t)), n
            }

            function Z(e, t) {
                return function (n) {
                    return null != n ? (X(this, e, n), r.updateOffset(this, t), this) : $(this, e)
                }
            }

            function $(e, t) {
                return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
            }

            function X(e, t, n) {
                e.isValid() && !isNaN(n) && ("FullYear" === t && V(e.year()) && 1 === e.month() && 29 === e.date() ? (n = q(n), e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), we(n, e.month()))) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
            }

            var J, K = /\d/, Q = /\d\d/, ee = /\d{3}/, te = /\d{4}/, ne = /[+-]?\d{6}/, ie = /\d\d?/, re = /\d\d\d\d?/,
                oe = /\d\d\d\d\d\d?/, ae = /\d{1,3}/, se = /\d{1,4}/, le = /[+-]?\d{1,6}/, ce = /\d+/, ue = /[+-]?\d+/,
                de = /Z|[+-]\d\d:?\d\d/gi, he = /Z|[+-]\d\d(?::?\d\d)?/gi,
                pe = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

            function fe(e, t, n) {
                J[e] = L(t) ? t : function (e, i) {
                    return e && n ? n : t
                }
            }

            function me(e, t) {
                return s(J, e) ? J[e](t._strict, t._locale) : new RegExp(_e(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function (e, t, n, i, r) {
                    return t || n || i || r
                }))))
            }

            function _e(e) {
                return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
            }

            J = {};
            var ge, ye = {};

            function ve(e, t) {
                var n, i = t;
                for ("string" == typeof e && (e = [e]), u(t) && (i = function (e, n) {
                    n[t] = q(e)
                }), n = 0; n < e.length; n++) ye[e[n]] = i
            }

            function xe(e, t) {
                ve(e, (function (e, n, i, r) {
                    i._w = i._w || {}, t(e, i._w, i, r)
                }))
            }

            function be(e, t, n) {
                null != t && s(ye, e) && ye[e](t, n._a, n, e)
            }

            function we(e, t) {
                if (isNaN(e) || isNaN(t)) return NaN;
                var n, i = (t % (n = 12) + n) % n;
                return e += (t - i) / 12, 1 === i ? V(e) ? 29 : 28 : 31 - i % 7 % 2
            }

            ge = Array.prototype.indexOf ? Array.prototype.indexOf : function (e) {
                var t;
                for (t = 0; t < this.length; ++t) if (this[t] === e) return t;
                return -1
            }, z("M", ["MM", 2], "Mo", (function () {
                return this.month() + 1
            })), z("MMM", 0, 0, (function (e) {
                return this.localeData().monthsShort(this, e)
            })), z("MMMM", 0, 0, (function (e) {
                return this.localeData().months(this, e)
            })), j("month", "M"), W("month", 8), fe("M", ie), fe("MM", ie, Q), fe("MMM", (function (e, t) {
                return t.monthsShortRegex(e)
            })), fe("MMMM", (function (e, t) {
                return t.monthsRegex(e)
            })), ve(["M", "MM"], (function (e, t) {
                t[1] = q(e) - 1
            })), ve(["MMM", "MMMM"], (function (e, t, n, i) {
                var r = n._locale.monthsParse(e, i, n._strict);
                null != r ? t[1] = r : m(n).invalidMonth = e
            }));
            var Me = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                Te = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), ke = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                Se = pe, De = pe;

            function Le(e, t, n) {
                var i, r, o, a = e.toLocaleLowerCase();
                if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i) o = f([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(o, "").toLocaleLowerCase(), this._longMonthsParse[i] = this.months(o, "").toLocaleLowerCase();
                return n ? "MMM" === t ? -1 !== (r = ge.call(this._shortMonthsParse, a)) ? r : null : -1 !== (r = ge.call(this._longMonthsParse, a)) ? r : null : "MMM" === t ? -1 !== (r = ge.call(this._shortMonthsParse, a)) || -1 !== (r = ge.call(this._longMonthsParse, a)) ? r : null : -1 !== (r = ge.call(this._longMonthsParse, a)) || -1 !== (r = ge.call(this._shortMonthsParse, a)) ? r : null
            }

            function Ee(e, t) {
                var n;
                if (!e.isValid()) return e;
                if ("string" == typeof t) if (/^\d+$/.test(t)) t = q(t); else if (!u(t = e.localeData().monthsParse(t))) return e;
                return n = Math.min(e.date(), we(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
            }

            function Ce(e) {
                return null != e ? (Ee(this, e), r.updateOffset(this, !0), this) : $(this, "Month")
            }

            function Ae() {
                function e(e, t) {
                    return t.length - e.length
                }

                var t, n, i = [], r = [], o = [];
                for (t = 0; t < 12; t++) n = f([2e3, t]), i.push(this.monthsShort(n, "")), r.push(this.months(n, "")), o.push(this.months(n, "")), o.push(this.monthsShort(n, ""));
                for (i.sort(e), r.sort(e), o.sort(e), t = 0; t < 12; t++) i[t] = _e(i[t]), r[t] = _e(r[t]);
                for (t = 0; t < 24; t++) o[t] = _e(o[t]);
                this._monthsRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + i.join("|") + ")", "i")
            }

            function Ie(e) {
                return V(e) ? 366 : 365
            }

            z("Y", 0, 0, (function () {
                var e = this.year();
                return e <= 9999 ? A(e, 4) : "+" + e
            })), z(0, ["YY", 2], 0, (function () {
                return this.year() % 100
            })), z(0, ["YYYY", 4], 0, "year"), z(0, ["YYYYY", 5], 0, "year"), z(0, ["YYYYYY", 6, !0], 0, "year"), j("year", "y"), W("year", 1), fe("Y", ue), fe("YY", ie, Q), fe("YYYY", se, te), fe("YYYYY", le, ne), fe("YYYYYY", le, ne), ve(["YYYYY", "YYYYYY"], 0), ve("YYYY", (function (e, t) {
                t[0] = 2 === e.length ? r.parseTwoDigitYear(e) : q(e)
            })), ve("YY", (function (e, t) {
                t[0] = r.parseTwoDigitYear(e)
            })), ve("Y", (function (e, t) {
                t[0] = parseInt(e, 10)
            })), r.parseTwoDigitYear = function (e) {
                return q(e) + (q(e) > 68 ? 1900 : 2e3)
            };
            var Pe = Z("FullYear", !0);

            function Re(e, t, n, i, r, o, a) {
                var s;
                return e < 100 && e >= 0 ? (s = new Date(e + 400, t, n, i, r, o, a), isFinite(s.getFullYear()) && s.setFullYear(e)) : s = new Date(e, t, n, i, r, o, a), s
            }

            function Ye(e) {
                var t, n;
                return e < 100 && e >= 0 ? ((n = Array.prototype.slice.call(arguments))[0] = e + 400, t = new Date(Date.UTC.apply(null, n)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t
            }

            function ze(e, t, n) {
                var i = 7 + t - n;
                return -(7 + Ye(e, 0, i).getUTCDay() - t) % 7 + i - 1
            }

            function Oe(e, t, n, i, r) {
                var o, a, s = 1 + 7 * (t - 1) + (7 + n - i) % 7 + ze(e, i, r);
                return s <= 0 ? a = Ie(o = e - 1) + s : s > Ie(e) ? (o = e + 1, a = s - Ie(e)) : (o = e, a = s), {
                    year: o,
                    dayOfYear: a
                }
            }

            function Fe(e, t, n) {
                var i, r, o = ze(e.year(), t, n), a = Math.floor((e.dayOfYear() - o - 1) / 7) + 1;
                return a < 1 ? i = a + Be(r = e.year() - 1, t, n) : a > Be(e.year(), t, n) ? (i = a - Be(e.year(), t, n), r = e.year() + 1) : (r = e.year(), i = a), {
                    week: i,
                    year: r
                }
            }

            function Be(e, t, n) {
                var i = ze(e, t, n), r = ze(e + 1, t, n);
                return (Ie(e) - i + r) / 7
            }

            function je(e, t) {
                return e.slice(t, 7).concat(e.slice(0, t))
            }

            z("w", ["ww", 2], "wo", "week"), z("W", ["WW", 2], "Wo", "isoWeek"), j("week", "w"), j("isoWeek", "W"), W("week", 5), W("isoWeek", 5), fe("w", ie), fe("ww", ie, Q), fe("W", ie), fe("WW", ie, Q), xe(["w", "ww", "W", "WW"], (function (e, t, n, i) {
                t[i.substr(0, 1)] = q(e)
            })), z("d", 0, "do", "day"), z("dd", 0, 0, (function (e) {
                return this.localeData().weekdaysMin(this, e)
            })), z("ddd", 0, 0, (function (e) {
                return this.localeData().weekdaysShort(this, e)
            })), z("dddd", 0, 0, (function (e) {
                return this.localeData().weekdays(this, e)
            })), z("e", 0, 0, "weekday"), z("E", 0, 0, "isoWeekday"), j("day", "d"), j("weekday", "e"), j("isoWeekday", "E"), W("day", 11), W("weekday", 11), W("isoWeekday", 11), fe("d", ie), fe("e", ie), fe("E", ie), fe("dd", (function (e, t) {
                return t.weekdaysMinRegex(e)
            })), fe("ddd", (function (e, t) {
                return t.weekdaysShortRegex(e)
            })), fe("dddd", (function (e, t) {
                return t.weekdaysRegex(e)
            })), xe(["dd", "ddd", "dddd"], (function (e, t, n, i) {
                var r = n._locale.weekdaysParse(e, i, n._strict);
                null != r ? t.d = r : m(n).invalidWeekday = e
            })), xe(["d", "e", "E"], (function (e, t, n, i) {
                t[i] = q(e)
            }));
            var He = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                Ne = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Ue = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), We = pe, Ve = pe,
                Ge = pe;

            function qe(e, t, n) {
                var i, r, o, a = e.toLocaleLowerCase();
                if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i) o = f([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(o, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(o, "").toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(o, "").toLocaleLowerCase();
                return n ? "dddd" === t ? -1 !== (r = ge.call(this._weekdaysParse, a)) ? r : null : "ddd" === t ? -1 !== (r = ge.call(this._shortWeekdaysParse, a)) ? r : null : -1 !== (r = ge.call(this._minWeekdaysParse, a)) ? r : null : "dddd" === t ? -1 !== (r = ge.call(this._weekdaysParse, a)) || -1 !== (r = ge.call(this._shortWeekdaysParse, a)) || -1 !== (r = ge.call(this._minWeekdaysParse, a)) ? r : null : "ddd" === t ? -1 !== (r = ge.call(this._shortWeekdaysParse, a)) || -1 !== (r = ge.call(this._weekdaysParse, a)) || -1 !== (r = ge.call(this._minWeekdaysParse, a)) ? r : null : -1 !== (r = ge.call(this._minWeekdaysParse, a)) || -1 !== (r = ge.call(this._weekdaysParse, a)) || -1 !== (r = ge.call(this._shortWeekdaysParse, a)) ? r : null
            }

            function Ze() {
                function e(e, t) {
                    return t.length - e.length
                }

                var t, n, i, r, o, a = [], s = [], l = [], c = [];
                for (t = 0; t < 7; t++) n = f([2e3, 1]).day(t), i = _e(this.weekdaysMin(n, "")), r = _e(this.weekdaysShort(n, "")), o = _e(this.weekdays(n, "")), a.push(i), s.push(r), l.push(o), c.push(i), c.push(r), c.push(o);
                a.sort(e), s.sort(e), l.sort(e), c.sort(e), this._weekdaysRegex = new RegExp("^(" + c.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
            }

            function $e() {
                return this.hours() % 12 || 12
            }

            function Xe(e, t) {
                z(e, 0, 0, (function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), t)
                }))
            }

            function Je(e, t) {
                return t._meridiemParse
            }

            z("H", ["HH", 2], 0, "hour"), z("h", ["hh", 2], 0, $e), z("k", ["kk", 2], 0, (function () {
                return this.hours() || 24
            })), z("hmm", 0, 0, (function () {
                return "" + $e.apply(this) + A(this.minutes(), 2)
            })), z("hmmss", 0, 0, (function () {
                return "" + $e.apply(this) + A(this.minutes(), 2) + A(this.seconds(), 2)
            })), z("Hmm", 0, 0, (function () {
                return "" + this.hours() + A(this.minutes(), 2)
            })), z("Hmmss", 0, 0, (function () {
                return "" + this.hours() + A(this.minutes(), 2) + A(this.seconds(), 2)
            })), Xe("a", !0), Xe("A", !1), j("hour", "h"), W("hour", 13), fe("a", Je), fe("A", Je), fe("H", ie), fe("h", ie), fe("k", ie), fe("HH", ie, Q), fe("hh", ie, Q), fe("kk", ie, Q), fe("hmm", re), fe("hmmss", oe), fe("Hmm", re), fe("Hmmss", oe), ve(["H", "HH"], 3), ve(["k", "kk"], (function (e, t, n) {
                var i = q(e);
                t[3] = 24 === i ? 0 : i
            })), ve(["a", "A"], (function (e, t, n) {
                n._isPm = n._locale.isPM(e), n._meridiem = e
            })), ve(["h", "hh"], (function (e, t, n) {
                t[3] = q(e), m(n).bigHour = !0
            })), ve("hmm", (function (e, t, n) {
                var i = e.length - 2;
                t[3] = q(e.substr(0, i)), t[4] = q(e.substr(i)), m(n).bigHour = !0
            })), ve("hmmss", (function (e, t, n) {
                var i = e.length - 4, r = e.length - 2;
                t[3] = q(e.substr(0, i)), t[4] = q(e.substr(i, 2)), t[5] = q(e.substr(r)), m(n).bigHour = !0
            })), ve("Hmm", (function (e, t, n) {
                var i = e.length - 2;
                t[3] = q(e.substr(0, i)), t[4] = q(e.substr(i))
            })), ve("Hmmss", (function (e, t, n) {
                var i = e.length - 4, r = e.length - 2;
                t[3] = q(e.substr(0, i)), t[4] = q(e.substr(i, 2)), t[5] = q(e.substr(r))
            }));
            var Ke, Qe = Z("Hours", !0), et = {
                calendar: {
                    sameDay: "[Today at] LT",
                    nextDay: "[Tomorrow at] LT",
                    nextWeek: "dddd [at] LT",
                    lastDay: "[Yesterday at] LT",
                    lastWeek: "[Last] dddd [at] LT",
                    sameElse: "L"
                },
                longDateFormat: {
                    LTS: "h:mm:ss A",
                    LT: "h:mm A",
                    L: "MM/DD/YYYY",
                    LL: "MMMM D, YYYY",
                    LLL: "MMMM D, YYYY h:mm A",
                    LLLL: "dddd, MMMM D, YYYY h:mm A"
                },
                invalidDate: "Invalid date",
                ordinal: "%d",
                dayOfMonthOrdinalParse: /\d{1,2}/,
                relativeTime: {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    ss: "%d seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    w: "a week",
                    ww: "%d weeks",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                },
                months: Me,
                monthsShort: Te,
                week: {dow: 0, doy: 6},
                weekdays: He,
                weekdaysMin: Ue,
                weekdaysShort: Ne,
                meridiemParse: /[ap]\.?m?\.?/i
            }, tt = {}, nt = {};

            function it(e, t) {
                var n, i = Math.min(e.length, t.length);
                for (n = 0; n < i; n += 1) if (e[n] !== t[n]) return n;
                return i
            }

            function rt(e) {
                return e ? e.toLowerCase().replace("_", "-") : e
            }

            function ot(t) {
                var i = null;
                if (void 0 === tt[t] && void 0 !== e && e && e.exports) try {
                    i = Ke._abbr, n(151)("./" + t), at(i)
                } catch (e) {
                    tt[t] = null
                }
                return tt[t]
            }

            function at(e, t) {
                var n;
                return e && ((n = c(t) ? lt(e) : st(e, t)) ? Ke = n : "undefined" != typeof console && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")), Ke._abbr
            }

            function st(e, t) {
                if (null !== t) {
                    var n, i = et;
                    if (t.abbr = e, null != tt[e]) D("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), i = tt[e]._config; else if (null != t.parentLocale) if (null != tt[t.parentLocale]) i = tt[t.parentLocale]._config; else {
                        if (null == (n = ot(t.parentLocale))) return nt[t.parentLocale] || (nt[t.parentLocale] = []), nt[t.parentLocale].push({
                            name: e,
                            config: t
                        }), null;
                        i = n._config
                    }
                    return tt[e] = new C(E(i, t)), nt[e] && nt[e].forEach((function (e) {
                        st(e.name, e.config)
                    })), at(e), tt[e]
                }
                return delete tt[e], null
            }

            function lt(e) {
                var t;
                if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return Ke;
                if (!o(e)) {
                    if (t = ot(e)) return t;
                    e = [e]
                }
                return function (e) {
                    for (var t, n, i, r, o = 0; o < e.length;) {
                        for (t = (r = rt(e[o]).split("-")).length, n = (n = rt(e[o + 1])) ? n.split("-") : null; t > 0;) {
                            if (i = ot(r.slice(0, t).join("-"))) return i;
                            if (n && n.length >= t && it(r, n) >= t - 1) break;
                            t--
                        }
                        o++
                    }
                    return Ke
                }(e)
            }

            function ct(e) {
                var t, n = e._a;
                return n && -2 === m(e).overflow && (t = n[1] < 0 || n[1] > 11 ? 1 : n[2] < 1 || n[2] > we(n[0], n[1]) ? 2 : n[3] < 0 || n[3] > 24 || 24 === n[3] && (0 !== n[4] || 0 !== n[5] || 0 !== n[6]) ? 3 : n[4] < 0 || n[4] > 59 ? 4 : n[5] < 0 || n[5] > 59 ? 5 : n[6] < 0 || n[6] > 999 ? 6 : -1, m(e)._overflowDayOfYear && (t < 0 || t > 2) && (t = 2), m(e)._overflowWeeks && -1 === t && (t = 7), m(e)._overflowWeekday && -1 === t && (t = 8), m(e).overflow = t), e
            }

            var ut = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                dt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                ht = /Z|[+-]\d\d(?::?\d\d)?/,
                pt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]],
                ft = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
                mt = /^\/?Date\((-?\d+)/i,
                _t = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                gt = {
                    UT: 0,
                    GMT: 0,
                    EDT: -240,
                    EST: -300,
                    CDT: -300,
                    CST: -360,
                    MDT: -360,
                    MST: -420,
                    PDT: -420,
                    PST: -480
                };

            function yt(e) {
                var t, n, i, r, o, a, s = e._i, l = ut.exec(s) || dt.exec(s);
                if (l) {
                    for (m(e).iso = !0, t = 0, n = pt.length; t < n; t++) if (pt[t][1].exec(l[1])) {
                        r = pt[t][0], i = !1 !== pt[t][2];
                        break
                    }
                    if (null == r) return void (e._isValid = !1);
                    if (l[3]) {
                        for (t = 0, n = ft.length; t < n; t++) if (ft[t][1].exec(l[3])) {
                            o = (l[2] || " ") + ft[t][0];
                            break
                        }
                        if (null == o) return void (e._isValid = !1)
                    }
                    if (!i && null != o) return void (e._isValid = !1);
                    if (l[4]) {
                        if (!ht.exec(l[4])) return void (e._isValid = !1);
                        a = "Z"
                    }
                    e._f = r + (o || "") + (a || ""), Mt(e)
                } else e._isValid = !1
            }

            function vt(e) {
                var t = parseInt(e, 10);
                return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
            }

            function xt(e) {
                var t, n, i, r, o, a, s, l,
                    c = _t.exec(e._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
                if (c) {
                    if (n = c[4], i = c[3], r = c[2], o = c[5], a = c[6], s = c[7], l = [vt(n), Te.indexOf(i), parseInt(r, 10), parseInt(o, 10), parseInt(a, 10)], s && l.push(parseInt(s, 10)), t = l, !function (e, t, n) {
                        return !e || Ne.indexOf(e) === new Date(t[0], t[1], t[2]).getDay() || (m(n).weekdayMismatch = !0, n._isValid = !1, !1)
                    }(c[1], t, e)) return;
                    e._a = t, e._tzm = function (e, t, n) {
                        if (e) return gt[e];
                        if (t) return 0;
                        var i = parseInt(n, 10), r = i % 100;
                        return (i - r) / 100 * 60 + r
                    }(c[8], c[9], c[10]), e._d = Ye.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), m(e).rfc2822 = !0
                } else e._isValid = !1
            }

            function bt(e, t, n) {
                return null != e ? e : null != t ? t : n
            }

            function wt(e) {
                var t, n, i, o, a, s = [];
                if (!e._d) {
                    for (i = function (e) {
                        var t = new Date(r.now());
                        return e._useUTC ? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()] : [t.getFullYear(), t.getMonth(), t.getDate()]
                    }(e), e._w && null == e._a[2] && null == e._a[1] && function (e) {
                        var t, n, i, r, o, a, s, l, c;
                        null != (t = e._w).GG || null != t.W || null != t.E ? (o = 1, a = 4, n = bt(t.GG, e._a[0], Fe(St(), 1, 4).year), i = bt(t.W, 1), ((r = bt(t.E, 1)) < 1 || r > 7) && (l = !0)) : (o = e._locale._week.dow, a = e._locale._week.doy, c = Fe(St(), o, a), n = bt(t.gg, e._a[0], c.year), i = bt(t.w, c.week), null != t.d ? ((r = t.d) < 0 || r > 6) && (l = !0) : null != t.e ? (r = t.e + o, (t.e < 0 || t.e > 6) && (l = !0)) : r = o), i < 1 || i > Be(n, o, a) ? m(e)._overflowWeeks = !0 : null != l ? m(e)._overflowWeekday = !0 : (s = Oe(n, i, r, o, a), e._a[0] = s.year, e._dayOfYear = s.dayOfYear)
                    }(e), null != e._dayOfYear && (a = bt(e._a[0], i[0]), (e._dayOfYear > Ie(a) || 0 === e._dayOfYear) && (m(e)._overflowDayOfYear = !0), n = Ye(a, 0, e._dayOfYear), e._a[1] = n.getUTCMonth(), e._a[2] = n.getUTCDate()), t = 0; t < 3 && null == e._a[t]; ++t) e._a[t] = s[t] = i[t];
                    for (; t < 7; t++) e._a[t] = s[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t];
                    24 === e._a[3] && 0 === e._a[4] && 0 === e._a[5] && 0 === e._a[6] && (e._nextDay = !0, e._a[3] = 0), e._d = (e._useUTC ? Ye : Re).apply(null, s), o = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[3] = 24), e._w && void 0 !== e._w.d && e._w.d !== o && (m(e).weekdayMismatch = !0)
                }
            }

            function Mt(e) {
                if (e._f !== r.ISO_8601) if (e._f !== r.RFC_2822) {
                    e._a = [], m(e).empty = !0;
                    var t, n, i, o, a, s, l = "" + e._i, c = l.length, u = 0;
                    for (i = F(e._f, e._locale).match(I) || [], t = 0; t < i.length; t++) o = i[t], (n = (l.match(me(o, e)) || [])[0]) && ((a = l.substr(0, l.indexOf(n))).length > 0 && m(e).unusedInput.push(a), l = l.slice(l.indexOf(n) + n.length), u += n.length), Y[o] ? (n ? m(e).empty = !1 : m(e).unusedTokens.push(o), be(o, n, e)) : e._strict && !n && m(e).unusedTokens.push(o);
                    m(e).charsLeftOver = c - u, l.length > 0 && m(e).unusedInput.push(l), e._a[3] <= 12 && !0 === m(e).bigHour && e._a[3] > 0 && (m(e).bigHour = void 0), m(e).parsedDateParts = e._a.slice(0), m(e).meridiem = e._meridiem, e._a[3] = function (e, t, n) {
                        var i;
                        return null == n ? t : null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((i = e.isPM(n)) && t < 12 && (t += 12), i || 12 !== t || (t = 0), t) : t
                    }(e._locale, e._a[3], e._meridiem), null !== (s = m(e).era) && (e._a[0] = e._locale.erasConvertYear(s, e._a[0])), wt(e), ct(e)
                } else xt(e); else yt(e)
            }

            function Tt(e) {
                var t = e._i, n = e._f;
                return e._locale = e._locale || lt(e._l), null === t || void 0 === n && "" === t ? g({nullInput: !0}) : ("string" == typeof t && (e._i = t = e._locale.preparse(t)), w(t) ? new b(ct(t)) : (d(t) ? e._d = t : o(n) ? function (e) {
                    var t, n, i, r, o, a, s = !1;
                    if (0 === e._f.length) return m(e).invalidFormat = !0, void (e._d = new Date(NaN));
                    for (r = 0; r < e._f.length; r++) o = 0, a = !1, t = x({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[r], Mt(t), _(t) && (a = !0), o += m(t).charsLeftOver, o += 10 * m(t).unusedTokens.length, m(t).score = o, s ? o < i && (i = o, n = t) : (null == i || o < i || a) && (i = o, n = t, a && (s = !0));
                    p(e, n || t)
                }(e) : n ? Mt(e) : function (e) {
                    var t = e._i;
                    c(t) ? e._d = new Date(r.now()) : d(t) ? e._d = new Date(t.valueOf()) : "string" == typeof t ? function (e) {
                        var t = mt.exec(e._i);
                        null === t ? (yt(e), !1 === e._isValid && (delete e._isValid, xt(e), !1 === e._isValid && (delete e._isValid, e._strict ? e._isValid = !1 : r.createFromInputFallback(e)))) : e._d = new Date(+t[1])
                    }(e) : o(t) ? (e._a = h(t.slice(0), (function (e) {
                        return parseInt(e, 10)
                    })), wt(e)) : a(t) ? function (e) {
                        if (!e._d) {
                            var t = N(e._i), n = void 0 === t.day ? t.date : t.day;
                            e._a = h([t.year, t.month, n, t.hour, t.minute, t.second, t.millisecond], (function (e) {
                                return e && parseInt(e, 10)
                            })), wt(e)
                        }
                    }(e) : u(t) ? e._d = new Date(t) : r.createFromInputFallback(e)
                }(e), _(e) || (e._d = null), e))
            }

            function kt(e, t, n, i, r) {
                var s, c = {};
                return !0 !== t && !1 !== t || (i = t, t = void 0), !0 !== n && !1 !== n || (i = n, n = void 0), (a(e) && l(e) || o(e) && 0 === e.length) && (e = void 0), c._isAMomentObject = !0, c._useUTC = c._isUTC = r, c._l = n, c._i = e, c._f = t, c._strict = i, (s = new b(ct(Tt(c))))._nextDay && (s.add(1, "d"), s._nextDay = void 0), s
            }

            function St(e, t, n, i) {
                return kt(e, t, n, i, !1)
            }

            r.createFromInputFallback = T("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function (e) {
                e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
            })), r.ISO_8601 = function () {
            }, r.RFC_2822 = function () {
            };
            var Dt = T("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                    var e = St.apply(null, arguments);
                    return this.isValid() && e.isValid() ? e < this ? this : e : g()
                })),
                Lt = T("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                    var e = St.apply(null, arguments);
                    return this.isValid() && e.isValid() ? e > this ? this : e : g()
                }));

            function Et(e, t) {
                var n, i;
                if (1 === t.length && o(t[0]) && (t = t[0]), !t.length) return St();
                for (n = t[0], i = 1; i < t.length; ++i) t[i].isValid() && !t[i][e](n) || (n = t[i]);
                return n
            }

            var Ct = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

            function At(e) {
                var t = N(e), n = t.year || 0, i = t.quarter || 0, r = t.month || 0, o = t.week || t.isoWeek || 0,
                    a = t.day || 0, l = t.hour || 0, c = t.minute || 0, u = t.second || 0, d = t.millisecond || 0;
                this._isValid = function (e) {
                    var t, n, i = !1;
                    for (t in e) if (s(e, t) && (-1 === ge.call(Ct, t) || null != e[t] && isNaN(e[t]))) return !1;
                    for (n = 0; n < Ct.length; ++n) if (e[Ct[n]]) {
                        if (i) return !1;
                        parseFloat(e[Ct[n]]) !== q(e[Ct[n]]) && (i = !0)
                    }
                    return !0
                }(t), this._milliseconds = +d + 1e3 * u + 6e4 * c + 1e3 * l * 60 * 60, this._days = +a + 7 * o, this._months = +r + 3 * i + 12 * n, this._data = {}, this._locale = lt(), this._bubble()
            }

            function It(e) {
                return e instanceof At
            }

            function Pt(e) {
                return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
            }

            function Rt(e, t) {
                z(e, 0, 0, (function () {
                    var e = this.utcOffset(), n = "+";
                    return e < 0 && (e = -e, n = "-"), n + A(~~(e / 60), 2) + t + A(~~e % 60, 2)
                }))
            }

            Rt("Z", ":"), Rt("ZZ", ""), fe("Z", he), fe("ZZ", he), ve(["Z", "ZZ"], (function (e, t, n) {
                n._useUTC = !0, n._tzm = zt(he, e)
            }));
            var Yt = /([\+\-]|\d\d)/gi;

            function zt(e, t) {
                var n, i, r = (t || "").match(e);
                return null === r ? null : 0 === (i = 60 * (n = ((r[r.length - 1] || []) + "").match(Yt) || ["-", 0, 0])[1] + q(n[2])) ? 0 : "+" === n[0] ? i : -i
            }

            function Ot(e, t) {
                var n, i;
                return t._isUTC ? (n = t.clone(), i = (w(e) || d(e) ? e.valueOf() : St(e).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + i), r.updateOffset(n, !1), n) : St(e).local()
            }

            function Ft(e) {
                return -Math.round(e._d.getTimezoneOffset())
            }

            function Bt() {
                return !!this.isValid() && this._isUTC && 0 === this._offset
            }

            r.updateOffset = function () {
            };
            var jt = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                Ht = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

            function Nt(e, t) {
                var n, i, r, o, a, l, c = e, d = null;
                return It(e) ? c = {
                    ms: e._milliseconds,
                    d: e._days,
                    M: e._months
                } : u(e) || !isNaN(+e) ? (c = {}, t ? c[t] = +e : c.milliseconds = +e) : (d = jt.exec(e)) ? (n = "-" === d[1] ? -1 : 1, c = {
                    y: 0,
                    d: q(d[2]) * n,
                    h: q(d[3]) * n,
                    m: q(d[4]) * n,
                    s: q(d[5]) * n,
                    ms: q(Pt(1e3 * d[6])) * n
                }) : (d = Ht.exec(e)) ? (n = "-" === d[1] ? -1 : 1, c = {
                    y: Ut(d[2], n),
                    M: Ut(d[3], n),
                    w: Ut(d[4], n),
                    d: Ut(d[5], n),
                    h: Ut(d[6], n),
                    m: Ut(d[7], n),
                    s: Ut(d[8], n)
                }) : null == c ? c = {} : "object" == typeof c && ("from" in c || "to" in c) && (o = St(c.from), a = St(c.to), r = o.isValid() && a.isValid() ? (a = Ot(a, o), o.isBefore(a) ? l = Wt(o, a) : ((l = Wt(a, o)).milliseconds = -l.milliseconds, l.months = -l.months), l) : {
                    milliseconds: 0,
                    months: 0
                }, (c = {}).ms = r.milliseconds, c.M = r.months), i = new At(c), It(e) && s(e, "_locale") && (i._locale = e._locale), It(e) && s(e, "_isValid") && (i._isValid = e._isValid), i
            }

            function Ut(e, t) {
                var n = e && parseFloat(e.replace(",", "."));
                return (isNaN(n) ? 0 : n) * t
            }

            function Wt(e, t) {
                var n = {};
                return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
            }

            function Vt(e, t) {
                return function (n, i) {
                    var r;
                    return null === i || isNaN(+i) || (D(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = i, i = r), Gt(this, Nt(n, i), e), this
                }
            }

            function Gt(e, t, n, i) {
                var o = t._milliseconds, a = Pt(t._days), s = Pt(t._months);
                e.isValid() && (i = null == i || i, s && Ee(e, $(e, "Month") + s * n), a && X(e, "Date", $(e, "Date") + a * n), o && e._d.setTime(e._d.valueOf() + o * n), i && r.updateOffset(e, a || s))
            }

            Nt.fn = At.prototype, Nt.invalid = function () {
                return Nt(NaN)
            };
            var qt = Vt(1, "add"), Zt = Vt(-1, "subtract");

            function $t(e) {
                return "string" == typeof e || e instanceof String
            }

            function Xt(e) {
                return w(e) || d(e) || $t(e) || u(e) || function (e) {
                    var t = o(e), n = !1;
                    return t && (n = 0 === e.filter((function (t) {
                        return !u(t) && $t(e)
                    })).length), t && n
                }(e) || function (e) {
                    var t, n, i = a(e) && !l(e), r = !1,
                        o = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"];
                    for (t = 0; t < o.length; t += 1) n = o[t], r = r || s(e, n);
                    return i && r
                }(e) || null == e
            }

            function Jt(e) {
                var t, n = a(e) && !l(e), i = !1,
                    r = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
                for (t = 0; t < r.length; t += 1) i = i || s(e, r[t]);
                return n && i
            }

            function Kt(e, t) {
                if (e.date() < t.date()) return -Kt(t, e);
                var n = 12 * (t.year() - e.year()) + (t.month() - e.month()), i = e.clone().add(n, "months");
                return -(n + (t - i < 0 ? (t - i) / (i - e.clone().add(n - 1, "months")) : (t - i) / (e.clone().add(n + 1, "months") - i))) || 0
            }

            function Qt(e) {
                var t;
                return void 0 === e ? this._locale._abbr : (null != (t = lt(e)) && (this._locale = t), this)
            }

            r.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", r.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
            var en = T("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function (e) {
                return void 0 === e ? this.localeData() : this.locale(e)
            }));

            function tn() {
                return this._locale
            }

            function nn(e, t) {
                return (e % t + t) % t
            }

            function rn(e, t, n) {
                return e < 100 && e >= 0 ? new Date(e + 400, t, n) - 126227808e5 : new Date(e, t, n).valueOf()
            }

            function on(e, t, n) {
                return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - 126227808e5 : Date.UTC(e, t, n)
            }

            function an(e, t) {
                return t.erasAbbrRegex(e)
            }

            function sn() {
                var e, t, n = [], i = [], r = [], o = [], a = this.eras();
                for (e = 0, t = a.length; e < t; ++e) i.push(_e(a[e].name)), n.push(_e(a[e].abbr)), r.push(_e(a[e].narrow)), o.push(_e(a[e].name)), o.push(_e(a[e].abbr)), o.push(_e(a[e].narrow));
                this._erasRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + r.join("|") + ")", "i")
            }

            function ln(e, t) {
                z(0, [e, e.length], 0, t)
            }

            function cn(e, t, n, i, r) {
                var o;
                return null == e ? Fe(this, i, r).year : (t > (o = Be(e, i, r)) && (t = o), un.call(this, e, t, n, i, r))
            }

            function un(e, t, n, i, r) {
                var o = Oe(e, t, n, i, r), a = Ye(o.year, 0, o.dayOfYear);
                return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
            }

            z("N", 0, 0, "eraAbbr"), z("NN", 0, 0, "eraAbbr"), z("NNN", 0, 0, "eraAbbr"), z("NNNN", 0, 0, "eraName"), z("NNNNN", 0, 0, "eraNarrow"), z("y", ["y", 1], "yo", "eraYear"), z("y", ["yy", 2], 0, "eraYear"), z("y", ["yyy", 3], 0, "eraYear"), z("y", ["yyyy", 4], 0, "eraYear"), fe("N", an), fe("NN", an), fe("NNN", an), fe("NNNN", (function (e, t) {
                return t.erasNameRegex(e)
            })), fe("NNNNN", (function (e, t) {
                return t.erasNarrowRegex(e)
            })), ve(["N", "NN", "NNN", "NNNN", "NNNNN"], (function (e, t, n, i) {
                var r = n._locale.erasParse(e, i, n._strict);
                r ? m(n).era = r : m(n).invalidEra = e
            })), fe("y", ce), fe("yy", ce), fe("yyy", ce), fe("yyyy", ce), fe("yo", (function (e, t) {
                return t._eraYearOrdinalRegex || ce
            })), ve(["y", "yy", "yyy", "yyyy"], 0), ve(["yo"], (function (e, t, n, i) {
                var r;
                n._locale._eraYearOrdinalRegex && (r = e.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? t[0] = n._locale.eraYearOrdinalParse(e, r) : t[0] = parseInt(e, 10)
            })), z(0, ["gg", 2], 0, (function () {
                return this.weekYear() % 100
            })), z(0, ["GG", 2], 0, (function () {
                return this.isoWeekYear() % 100
            })), ln("gggg", "weekYear"), ln("ggggg", "weekYear"), ln("GGGG", "isoWeekYear"), ln("GGGGG", "isoWeekYear"), j("weekYear", "gg"), j("isoWeekYear", "GG"), W("weekYear", 1), W("isoWeekYear", 1), fe("G", ue), fe("g", ue), fe("GG", ie, Q), fe("gg", ie, Q), fe("GGGG", se, te), fe("gggg", se, te), fe("GGGGG", le, ne), fe("ggggg", le, ne), xe(["gggg", "ggggg", "GGGG", "GGGGG"], (function (e, t, n, i) {
                t[i.substr(0, 2)] = q(e)
            })), xe(["gg", "GG"], (function (e, t, n, i) {
                t[i] = r.parseTwoDigitYear(e)
            })), z("Q", 0, "Qo", "quarter"), j("quarter", "Q"), W("quarter", 7), fe("Q", K), ve("Q", (function (e, t) {
                t[1] = 3 * (q(e) - 1)
            })), z("D", ["DD", 2], "Do", "date"), j("date", "D"), W("date", 9), fe("D", ie), fe("DD", ie, Q), fe("Do", (function (e, t) {
                return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
            })), ve(["D", "DD"], 2), ve("Do", (function (e, t) {
                t[2] = q(e.match(ie)[0])
            }));
            var dn = Z("Date", !0);
            z("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), j("dayOfYear", "DDD"), W("dayOfYear", 4), fe("DDD", ae), fe("DDDD", ee), ve(["DDD", "DDDD"], (function (e, t, n) {
                n._dayOfYear = q(e)
            })), z("m", ["mm", 2], 0, "minute"), j("minute", "m"), W("minute", 14), fe("m", ie), fe("mm", ie, Q), ve(["m", "mm"], 4);
            var hn = Z("Minutes", !1);
            z("s", ["ss", 2], 0, "second"), j("second", "s"), W("second", 15), fe("s", ie), fe("ss", ie, Q), ve(["s", "ss"], 5);
            var pn, fn, mn = Z("Seconds", !1);
            for (z("S", 0, 0, (function () {
                return ~~(this.millisecond() / 100)
            })), z(0, ["SS", 2], 0, (function () {
                return ~~(this.millisecond() / 10)
            })), z(0, ["SSS", 3], 0, "millisecond"), z(0, ["SSSS", 4], 0, (function () {
                return 10 * this.millisecond()
            })), z(0, ["SSSSS", 5], 0, (function () {
                return 100 * this.millisecond()
            })), z(0, ["SSSSSS", 6], 0, (function () {
                return 1e3 * this.millisecond()
            })), z(0, ["SSSSSSS", 7], 0, (function () {
                return 1e4 * this.millisecond()
            })), z(0, ["SSSSSSSS", 8], 0, (function () {
                return 1e5 * this.millisecond()
            })), z(0, ["SSSSSSSSS", 9], 0, (function () {
                return 1e6 * this.millisecond()
            })), j("millisecond", "ms"), W("millisecond", 16), fe("S", ae, K), fe("SS", ae, Q), fe("SSS", ae, ee), pn = "SSSS"; pn.length <= 9; pn += "S") fe(pn, ce);

            function _n(e, t) {
                t[6] = q(1e3 * ("0." + e))
            }

            for (pn = "S"; pn.length <= 9; pn += "S") ve(pn, _n);
            fn = Z("Milliseconds", !1), z("z", 0, 0, "zoneAbbr"), z("zz", 0, 0, "zoneName");
            var gn = b.prototype;

            function yn(e) {
                return e
            }

            gn.add = qt, gn.calendar = function (e, t) {
                1 === arguments.length && (arguments[0] ? Xt(arguments[0]) ? (e = arguments[0], t = void 0) : Jt(arguments[0]) && (t = arguments[0], e = void 0) : (e = void 0, t = void 0));
                var n = e || St(), i = Ot(n, this).startOf("day"), o = r.calendarFormat(this, i) || "sameElse",
                    a = t && (L(t[o]) ? t[o].call(this, n) : t[o]);
                return this.format(a || this.localeData().calendar(o, this, St(n)))
            }, gn.clone = function () {
                return new b(this)
            }, gn.diff = function (e, t, n) {
                var i, r, o;
                if (!this.isValid()) return NaN;
                if (!(i = Ot(e, this)).isValid()) return NaN;
                switch (r = 6e4 * (i.utcOffset() - this.utcOffset()), t = H(t)) {
                    case"year":
                        o = Kt(this, i) / 12;
                        break;
                    case"month":
                        o = Kt(this, i);
                        break;
                    case"quarter":
                        o = Kt(this, i) / 3;
                        break;
                    case"second":
                        o = (this - i) / 1e3;
                        break;
                    case"minute":
                        o = (this - i) / 6e4;
                        break;
                    case"hour":
                        o = (this - i) / 36e5;
                        break;
                    case"day":
                        o = (this - i - r) / 864e5;
                        break;
                    case"week":
                        o = (this - i - r) / 6048e5;
                        break;
                    default:
                        o = this - i
                }
                return n ? o : G(o)
            }, gn.endOf = function (e) {
                var t, n;
                if (void 0 === (e = H(e)) || "millisecond" === e || !this.isValid()) return this;
                switch (n = this._isUTC ? on : rn, e) {
                    case"year":
                        t = n(this.year() + 1, 0, 1) - 1;
                        break;
                    case"quarter":
                        t = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                        break;
                    case"month":
                        t = n(this.year(), this.month() + 1, 1) - 1;
                        break;
                    case"week":
                        t = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                        break;
                    case"isoWeek":
                        t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                        break;
                    case"day":
                    case"date":
                        t = n(this.year(), this.month(), this.date() + 1) - 1;
                        break;
                    case"hour":
                        t = this._d.valueOf(), t += 36e5 - nn(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
                        break;
                    case"minute":
                        t = this._d.valueOf(), t += 6e4 - nn(t, 6e4) - 1;
                        break;
                    case"second":
                        t = this._d.valueOf(), t += 1e3 - nn(t, 1e3) - 1
                }
                return this._d.setTime(t), r.updateOffset(this, !0), this
            }, gn.format = function (e) {
                e || (e = this.isUtc() ? r.defaultFormatUtc : r.defaultFormat);
                var t = O(this, e);
                return this.localeData().postformat(t)
            }, gn.from = function (e, t) {
                return this.isValid() && (w(e) && e.isValid() || St(e).isValid()) ? Nt({
                    to: this,
                    from: e
                }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
            }, gn.fromNow = function (e) {
                return this.from(St(), e)
            }, gn.to = function (e, t) {
                return this.isValid() && (w(e) && e.isValid() || St(e).isValid()) ? Nt({
                    from: this,
                    to: e
                }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
            }, gn.toNow = function (e) {
                return this.to(St(), e)
            }, gn.get = function (e) {
                return L(this[e = H(e)]) ? this[e]() : this
            }, gn.invalidAt = function () {
                return m(this).overflow
            }, gn.isAfter = function (e, t) {
                var n = w(e) ? e : St(e);
                return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = H(t) || "millisecond") ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
            }, gn.isBefore = function (e, t) {
                var n = w(e) ? e : St(e);
                return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = H(t) || "millisecond") ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
            }, gn.isBetween = function (e, t, n, i) {
                var r = w(e) ? e : St(e), o = w(t) ? t : St(t);
                return !!(this.isValid() && r.isValid() && o.isValid()) && (("(" === (i = i || "()")[0] ? this.isAfter(r, n) : !this.isBefore(r, n)) && (")" === i[1] ? this.isBefore(o, n) : !this.isAfter(o, n)))
            }, gn.isSame = function (e, t) {
                var n, i = w(e) ? e : St(e);
                return !(!this.isValid() || !i.isValid()) && ("millisecond" === (t = H(t) || "millisecond") ? this.valueOf() === i.valueOf() : (n = i.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
            }, gn.isSameOrAfter = function (e, t) {
                return this.isSame(e, t) || this.isAfter(e, t)
            }, gn.isSameOrBefore = function (e, t) {
                return this.isSame(e, t) || this.isBefore(e, t)
            }, gn.isValid = function () {
                return _(this)
            }, gn.lang = en, gn.locale = Qt, gn.localeData = tn, gn.max = Lt, gn.min = Dt, gn.parsingFlags = function () {
                return p({}, m(this))
            }, gn.set = function (e, t) {
                if ("object" == typeof e) {
                    var n, i = function (e) {
                        var t, n = [];
                        for (t in e) s(e, t) && n.push({unit: t, priority: U[t]});
                        return n.sort((function (e, t) {
                            return e.priority - t.priority
                        })), n
                    }(e = N(e));
                    for (n = 0; n < i.length; n++) this[i[n].unit](e[i[n].unit])
                } else if (L(this[e = H(e)])) return this[e](t);
                return this
            }, gn.startOf = function (e) {
                var t, n;
                if (void 0 === (e = H(e)) || "millisecond" === e || !this.isValid()) return this;
                switch (n = this._isUTC ? on : rn, e) {
                    case"year":
                        t = n(this.year(), 0, 1);
                        break;
                    case"quarter":
                        t = n(this.year(), this.month() - this.month() % 3, 1);
                        break;
                    case"month":
                        t = n(this.year(), this.month(), 1);
                        break;
                    case"week":
                        t = n(this.year(), this.month(), this.date() - this.weekday());
                        break;
                    case"isoWeek":
                        t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                        break;
                    case"day":
                    case"date":
                        t = n(this.year(), this.month(), this.date());
                        break;
                    case"hour":
                        t = this._d.valueOf(), t -= nn(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
                        break;
                    case"minute":
                        t = this._d.valueOf(), t -= nn(t, 6e4);
                        break;
                    case"second":
                        t = this._d.valueOf(), t -= nn(t, 1e3)
                }
                return this._d.setTime(t), r.updateOffset(this, !0), this
            }, gn.subtract = Zt, gn.toArray = function () {
                var e = this;
                return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
            }, gn.toObject = function () {
                var e = this;
                return {
                    years: e.year(),
                    months: e.month(),
                    date: e.date(),
                    hours: e.hours(),
                    minutes: e.minutes(),
                    seconds: e.seconds(),
                    milliseconds: e.milliseconds()
                }
            }, gn.toDate = function () {
                return new Date(this.valueOf())
            }, gn.toISOString = function (e) {
                if (!this.isValid()) return null;
                var t = !0 !== e, n = t ? this.clone().utc() : this;
                return n.year() < 0 || n.year() > 9999 ? O(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : L(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", O(n, "Z")) : O(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
            }, gn.inspect = function () {
                if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                var e, t, n, i = "moment", r = "";
                return this.isLocal() || (i = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", r = "Z"), e = "[" + i + '("]', t = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", n = r + '[")]', this.format(e + t + "-MM-DD[T]HH:mm:ss.SSS" + n)
            }, "undefined" != typeof Symbol && null != Symbol.for && (gn[Symbol.for("nodejs.util.inspect.custom")] = function () {
                return "Moment<" + this.format() + ">"
            }), gn.toJSON = function () {
                return this.isValid() ? this.toISOString() : null
            }, gn.toString = function () {
                return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
            }, gn.unix = function () {
                return Math.floor(this.valueOf() / 1e3)
            }, gn.valueOf = function () {
                return this._d.valueOf() - 6e4 * (this._offset || 0)
            }, gn.creationData = function () {
                return {input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict}
            }, gn.eraName = function () {
                var e, t, n, i = this.localeData().eras();
                for (e = 0, t = i.length; e < t; ++e) {
                    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until) return i[e].name;
                    if (i[e].until <= n && n <= i[e].since) return i[e].name
                }
                return ""
            }, gn.eraNarrow = function () {
                var e, t, n, i = this.localeData().eras();
                for (e = 0, t = i.length; e < t; ++e) {
                    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until) return i[e].narrow;
                    if (i[e].until <= n && n <= i[e].since) return i[e].narrow
                }
                return ""
            }, gn.eraAbbr = function () {
                var e, t, n, i = this.localeData().eras();
                for (e = 0, t = i.length; e < t; ++e) {
                    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until) return i[e].abbr;
                    if (i[e].until <= n && n <= i[e].since) return i[e].abbr
                }
                return ""
            }, gn.eraYear = function () {
                var e, t, n, i, o = this.localeData().eras();
                for (e = 0, t = o.length; e < t; ++e) if (n = o[e].since <= o[e].until ? 1 : -1, i = this.clone().startOf("day").valueOf(), o[e].since <= i && i <= o[e].until || o[e].until <= i && i <= o[e].since) return (this.year() - r(o[e].since).year()) * n + o[e].offset;
                return this.year()
            }, gn.year = Pe, gn.isLeapYear = function () {
                return V(this.year())
            }, gn.weekYear = function (e) {
                return cn.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
            }, gn.isoWeekYear = function (e) {
                return cn.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
            }, gn.quarter = gn.quarters = function (e) {
                return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
            }, gn.month = Ce, gn.daysInMonth = function () {
                return we(this.year(), this.month())
            }, gn.week = gn.weeks = function (e) {
                var t = this.localeData().week(this);
                return null == e ? t : this.add(7 * (e - t), "d")
            }, gn.isoWeek = gn.isoWeeks = function (e) {
                var t = Fe(this, 1, 4).week;
                return null == e ? t : this.add(7 * (e - t), "d")
            }, gn.weeksInYear = function () {
                var e = this.localeData()._week;
                return Be(this.year(), e.dow, e.doy)
            }, gn.weeksInWeekYear = function () {
                var e = this.localeData()._week;
                return Be(this.weekYear(), e.dow, e.doy)
            }, gn.isoWeeksInYear = function () {
                return Be(this.year(), 1, 4)
            }, gn.isoWeeksInISOWeekYear = function () {
                return Be(this.isoWeekYear(), 1, 4)
            }, gn.date = dn, gn.day = gn.days = function (e) {
                if (!this.isValid()) return null != e ? this : NaN;
                var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                return null != e ? (e = function (e, t) {
                    return "string" != typeof e ? e : isNaN(e) ? "number" == typeof (e = t.weekdaysParse(e)) ? e : null : parseInt(e, 10)
                }(e, this.localeData()), this.add(e - t, "d")) : t
            }, gn.weekday = function (e) {
                if (!this.isValid()) return null != e ? this : NaN;
                var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return null == e ? t : this.add(e - t, "d")
            }, gn.isoWeekday = function (e) {
                if (!this.isValid()) return null != e ? this : NaN;
                if (null != e) {
                    var t = function (e, t) {
                        return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
                    }(e, this.localeData());
                    return this.day(this.day() % 7 ? t : t - 7)
                }
                return this.day() || 7
            }, gn.dayOfYear = function (e) {
                var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                return null == e ? t : this.add(e - t, "d")
            }, gn.hour = gn.hours = Qe, gn.minute = gn.minutes = hn, gn.second = gn.seconds = mn, gn.millisecond = gn.milliseconds = fn, gn.utcOffset = function (e, t, n) {
                var i, o = this._offset || 0;
                if (!this.isValid()) return null != e ? this : NaN;
                if (null != e) {
                    if ("string" == typeof e) {
                        if (null === (e = zt(he, e))) return this
                    } else Math.abs(e) < 16 && !n && (e *= 60);
                    return !this._isUTC && t && (i = Ft(this)), this._offset = e, this._isUTC = !0, null != i && this.add(i, "m"), o !== e && (!t || this._changeInProgress ? Gt(this, Nt(e - o, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, r.updateOffset(this, !0), this._changeInProgress = null)), this
                }
                return this._isUTC ? o : Ft(this)
            }, gn.utc = function (e) {
                return this.utcOffset(0, e)
            }, gn.local = function (e) {
                return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Ft(this), "m")), this
            }, gn.parseZone = function () {
                if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
                    var e = zt(de, this._i);
                    null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
                }
                return this
            }, gn.hasAlignedHourOffset = function (e) {
                return !!this.isValid() && (e = e ? St(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
            }, gn.isDST = function () {
                return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
            }, gn.isLocal = function () {
                return !!this.isValid() && !this._isUTC
            }, gn.isUtcOffset = function () {
                return !!this.isValid() && this._isUTC
            }, gn.isUtc = Bt, gn.isUTC = Bt, gn.zoneAbbr = function () {
                return this._isUTC ? "UTC" : ""
            }, gn.zoneName = function () {
                return this._isUTC ? "Coordinated Universal Time" : ""
            }, gn.dates = T("dates accessor is deprecated. Use date instead.", dn), gn.months = T("months accessor is deprecated. Use month instead", Ce), gn.years = T("years accessor is deprecated. Use year instead", Pe), gn.zone = T("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", (function (e, t) {
                return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
            })), gn.isDSTShifted = T("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", (function () {
                if (!c(this._isDSTShifted)) return this._isDSTShifted;
                var e, t = {};
                return x(t, this), (t = Tt(t))._a ? (e = t._isUTC ? f(t._a) : St(t._a), this._isDSTShifted = this.isValid() && function (e, t, n) {
                    var i, r = Math.min(e.length, t.length), o = Math.abs(e.length - t.length), a = 0;
                    for (i = 0; i < r; i++) (n && e[i] !== t[i] || !n && q(e[i]) !== q(t[i])) && a++;
                    return a + o
                }(t._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
            }));
            var vn = C.prototype;

            function xn(e, t, n, i) {
                var r = lt(), o = f().set(i, t);
                return r[n](o, e)
            }

            function bn(e, t, n) {
                if (u(e) && (t = e, e = void 0), e = e || "", null != t) return xn(e, t, n, "month");
                var i, r = [];
                for (i = 0; i < 12; i++) r[i] = xn(e, i, n, "month");
                return r
            }

            function wn(e, t, n, i) {
                "boolean" == typeof e ? (u(t) && (n = t, t = void 0), t = t || "") : (n = t = e, e = !1, u(t) && (n = t, t = void 0), t = t || "");
                var r, o = lt(), a = e ? o._week.dow : 0, s = [];
                if (null != n) return xn(t, (n + a) % 7, i, "day");
                for (r = 0; r < 7; r++) s[r] = xn(t, (r + a) % 7, i, "day");
                return s
            }

            vn.calendar = function (e, t, n) {
                var i = this._calendar[e] || this._calendar.sameElse;
                return L(i) ? i.call(t, n) : i
            }, vn.longDateFormat = function (e) {
                var t = this._longDateFormat[e], n = this._longDateFormat[e.toUpperCase()];
                return t || !n ? t : (this._longDateFormat[e] = n.match(I).map((function (e) {
                    return "MMMM" === e || "MM" === e || "DD" === e || "dddd" === e ? e.slice(1) : e
                })).join(""), this._longDateFormat[e])
            }, vn.invalidDate = function () {
                return this._invalidDate
            }, vn.ordinal = function (e) {
                return this._ordinal.replace("%d", e)
            }, vn.preparse = yn, vn.postformat = yn, vn.relativeTime = function (e, t, n, i) {
                var r = this._relativeTime[n];
                return L(r) ? r(e, t, n, i) : r.replace(/%d/i, e)
            }, vn.pastFuture = function (e, t) {
                var n = this._relativeTime[e > 0 ? "future" : "past"];
                return L(n) ? n(t) : n.replace(/%s/i, t)
            }, vn.set = function (e) {
                var t, n;
                for (n in e) s(e, n) && (L(t = e[n]) ? this[n] = t : this["_" + n] = t);
                this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
            }, vn.eras = function (e, t) {
                var n, i, o, a = this._eras || lt("en")._eras;
                for (n = 0, i = a.length; n < i; ++n) {
                    switch (typeof a[n].since) {
                        case"string":
                            o = r(a[n].since).startOf("day"), a[n].since = o.valueOf()
                    }
                    switch (typeof a[n].until) {
                        case"undefined":
                            a[n].until = 1 / 0;
                            break;
                        case"string":
                            o = r(a[n].until).startOf("day").valueOf(), a[n].until = o.valueOf()
                    }
                }
                return a
            }, vn.erasParse = function (e, t, n) {
                var i, r, o, a, s, l = this.eras();
                for (e = e.toUpperCase(), i = 0, r = l.length; i < r; ++i) if (o = l[i].name.toUpperCase(), a = l[i].abbr.toUpperCase(), s = l[i].narrow.toUpperCase(), n) switch (t) {
                    case"N":
                    case"NN":
                    case"NNN":
                        if (a === e) return l[i];
                        break;
                    case"NNNN":
                        if (o === e) return l[i];
                        break;
                    case"NNNNN":
                        if (s === e) return l[i]
                } else if ([o, a, s].indexOf(e) >= 0) return l[i]
            }, vn.erasConvertYear = function (e, t) {
                var n = e.since <= e.until ? 1 : -1;
                return void 0 === t ? r(e.since).year() : r(e.since).year() + (t - e.offset) * n
            }, vn.erasAbbrRegex = function (e) {
                return s(this, "_erasAbbrRegex") || sn.call(this), e ? this._erasAbbrRegex : this._erasRegex
            }, vn.erasNameRegex = function (e) {
                return s(this, "_erasNameRegex") || sn.call(this), e ? this._erasNameRegex : this._erasRegex
            }, vn.erasNarrowRegex = function (e) {
                return s(this, "_erasNarrowRegex") || sn.call(this), e ? this._erasNarrowRegex : this._erasRegex
            }, vn.months = function (e, t) {
                return e ? o(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || ke).test(t) ? "format" : "standalone"][e.month()] : o(this._months) ? this._months : this._months.standalone
            }, vn.monthsShort = function (e, t) {
                return e ? o(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[ke.test(t) ? "format" : "standalone"][e.month()] : o(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
            }, vn.monthsParse = function (e, t, n) {
                var i, r, o;
                if (this._monthsParseExact) return Le.call(this, e, t, n);
                for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
                    if (r = f([2e3, i]), n && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(r, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(r, "").replace(".", "") + "$", "i")), n || this._monthsParse[i] || (o = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[i] = new RegExp(o.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[i].test(e)) return i;
                    if (n && "MMM" === t && this._shortMonthsParse[i].test(e)) return i;
                    if (!n && this._monthsParse[i].test(e)) return i
                }
            }, vn.monthsRegex = function (e) {
                return this._monthsParseExact ? (s(this, "_monthsRegex") || Ae.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (s(this, "_monthsRegex") || (this._monthsRegex = De), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
            }, vn.monthsShortRegex = function (e) {
                return this._monthsParseExact ? (s(this, "_monthsRegex") || Ae.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (s(this, "_monthsShortRegex") || (this._monthsShortRegex = Se), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
            }, vn.week = function (e) {
                return Fe(e, this._week.dow, this._week.doy).week
            }, vn.firstDayOfYear = function () {
                return this._week.doy
            }, vn.firstDayOfWeek = function () {
                return this._week.dow
            }, vn.weekdays = function (e, t) {
                var n = o(this._weekdays) ? this._weekdays : this._weekdays[e && !0 !== e && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
                return !0 === e ? je(n, this._week.dow) : e ? n[e.day()] : n
            }, vn.weekdaysMin = function (e) {
                return !0 === e ? je(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin
            }, vn.weekdaysShort = function (e) {
                return !0 === e ? je(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort
            }, vn.weekdaysParse = function (e, t, n) {
                var i, r, o;
                if (this._weekdaysParseExact) return qe.call(this, e, t, n);
                for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
                    if (r = f([2e3, 1]).day(i), n && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(r, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[i] || (o = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[i] = new RegExp(o.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[i].test(e)) return i;
                    if (n && "ddd" === t && this._shortWeekdaysParse[i].test(e)) return i;
                    if (n && "dd" === t && this._minWeekdaysParse[i].test(e)) return i;
                    if (!n && this._weekdaysParse[i].test(e)) return i
                }
            }, vn.weekdaysRegex = function (e) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (s(this, "_weekdaysRegex") || (this._weekdaysRegex = We), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
            }, vn.weekdaysShortRegex = function (e) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (s(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Ve), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
            }, vn.weekdaysMinRegex = function (e) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (s(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Ge), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
            }, vn.isPM = function (e) {
                return "p" === (e + "").toLowerCase().charAt(0)
            }, vn.meridiem = function (e, t, n) {
                return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
            }, at("en", {
                eras: [{
                    since: "0001-01-01",
                    until: 1 / 0,
                    offset: 1,
                    name: "Anno Domini",
                    narrow: "AD",
                    abbr: "AD"
                }, {since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC"}],
                dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (e) {
                    var t = e % 10;
                    return e + (1 === q(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
                }
            }), r.lang = T("moment.lang is deprecated. Use moment.locale instead.", at), r.langData = T("moment.langData is deprecated. Use moment.localeData instead.", lt);
            var Mn = Math.abs;

            function Tn(e, t, n, i) {
                var r = Nt(t, n);
                return e._milliseconds += i * r._milliseconds, e._days += i * r._days, e._months += i * r._months, e._bubble()
            }

            function kn(e) {
                return e < 0 ? Math.floor(e) : Math.ceil(e)
            }

            function Sn(e) {
                return 4800 * e / 146097
            }

            function Dn(e) {
                return 146097 * e / 4800
            }

            function Ln(e) {
                return function () {
                    return this.as(e)
                }
            }

            var En = Ln("ms"), Cn = Ln("s"), An = Ln("m"), In = Ln("h"), Pn = Ln("d"), Rn = Ln("w"), Yn = Ln("M"),
                zn = Ln("Q"), On = Ln("y");

            function Fn(e) {
                return function () {
                    return this.isValid() ? this._data[e] : NaN
                }
            }

            var Bn = Fn("milliseconds"), jn = Fn("seconds"), Hn = Fn("minutes"), Nn = Fn("hours"), Un = Fn("days"),
                Wn = Fn("months"), Vn = Fn("years"), Gn = Math.round,
                qn = {ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11};

            function Zn(e, t, n, i, r) {
                return r.relativeTime(t || 1, !!n, e, i)
            }

            var $n = Math.abs;

            function Xn(e) {
                return (e > 0) - (e < 0) || +e
            }

            function Jn() {
                if (!this.isValid()) return this.localeData().invalidDate();
                var e, t, n, i, r, o, a, s, l = $n(this._milliseconds) / 1e3, c = $n(this._days), u = $n(this._months),
                    d = this.asSeconds();
                return d ? (e = G(l / 60), t = G(e / 60), l %= 60, e %= 60, n = G(u / 12), u %= 12, i = l ? l.toFixed(3).replace(/\.?0+$/, "") : "", r = d < 0 ? "-" : "", o = Xn(this._months) !== Xn(d) ? "-" : "", a = Xn(this._days) !== Xn(d) ? "-" : "", s = Xn(this._milliseconds) !== Xn(d) ? "-" : "", r + "P" + (n ? o + n + "Y" : "") + (u ? o + u + "M" : "") + (c ? a + c + "D" : "") + (t || e || l ? "T" : "") + (t ? s + t + "H" : "") + (e ? s + e + "M" : "") + (l ? s + i + "S" : "")) : "P0D"
            }

            var Kn = At.prototype;
            return Kn.isValid = function () {
                return this._isValid
            }, Kn.abs = function () {
                var e = this._data;
                return this._milliseconds = Mn(this._milliseconds), this._days = Mn(this._days), this._months = Mn(this._months), e.milliseconds = Mn(e.milliseconds), e.seconds = Mn(e.seconds), e.minutes = Mn(e.minutes), e.hours = Mn(e.hours), e.months = Mn(e.months), e.years = Mn(e.years), this
            }, Kn.add = function (e, t) {
                return Tn(this, e, t, 1)
            }, Kn.subtract = function (e, t) {
                return Tn(this, e, t, -1)
            }, Kn.as = function (e) {
                if (!this.isValid()) return NaN;
                var t, n, i = this._milliseconds;
                if ("month" === (e = H(e)) || "quarter" === e || "year" === e) switch (t = this._days + i / 864e5, n = this._months + Sn(t), e) {
                    case"month":
                        return n;
                    case"quarter":
                        return n / 3;
                    case"year":
                        return n / 12
                } else switch (t = this._days + Math.round(Dn(this._months)), e) {
                    case"week":
                        return t / 7 + i / 6048e5;
                    case"day":
                        return t + i / 864e5;
                    case"hour":
                        return 24 * t + i / 36e5;
                    case"minute":
                        return 1440 * t + i / 6e4;
                    case"second":
                        return 86400 * t + i / 1e3;
                    case"millisecond":
                        return Math.floor(864e5 * t) + i;
                    default:
                        throw new Error("Unknown unit " + e)
                }
            }, Kn.asMilliseconds = En, Kn.asSeconds = Cn, Kn.asMinutes = An, Kn.asHours = In, Kn.asDays = Pn, Kn.asWeeks = Rn, Kn.asMonths = Yn, Kn.asQuarters = zn, Kn.asYears = On, Kn.valueOf = function () {
                return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * q(this._months / 12) : NaN
            }, Kn._bubble = function () {
                var e, t, n, i, r, o = this._milliseconds, a = this._days, s = this._months, l = this._data;
                return o >= 0 && a >= 0 && s >= 0 || o <= 0 && a <= 0 && s <= 0 || (o += 864e5 * kn(Dn(s) + a), a = 0, s = 0), l.milliseconds = o % 1e3, e = G(o / 1e3), l.seconds = e % 60, t = G(e / 60), l.minutes = t % 60, n = G(t / 60), l.hours = n % 24, a += G(n / 24), r = G(Sn(a)), s += r, a -= kn(Dn(r)), i = G(s / 12), s %= 12, l.days = a, l.months = s, l.years = i, this
            }, Kn.clone = function () {
                return Nt(this)
            }, Kn.get = function (e) {
                return e = H(e), this.isValid() ? this[e + "s"]() : NaN
            }, Kn.milliseconds = Bn, Kn.seconds = jn, Kn.minutes = Hn, Kn.hours = Nn, Kn.days = Un, Kn.weeks = function () {
                return G(this.days() / 7)
            }, Kn.months = Wn, Kn.years = Vn, Kn.humanize = function (e, t) {
                if (!this.isValid()) return this.localeData().invalidDate();
                var n, i, r = !1, o = qn;
                return "object" == typeof e && (t = e, e = !1), "boolean" == typeof e && (r = e), "object" == typeof t && (o = Object.assign({}, qn, t), null != t.s && null == t.ss && (o.ss = t.s - 1)), n = this.localeData(), i = function (e, t, n, i) {
                    var r = Nt(e).abs(), o = Gn(r.as("s")), a = Gn(r.as("m")), s = Gn(r.as("h")), l = Gn(r.as("d")),
                        c = Gn(r.as("M")), u = Gn(r.as("w")), d = Gn(r.as("y")),
                        h = o <= n.ss && ["s", o] || o < n.s && ["ss", o] || a <= 1 && ["m"] || a < n.m && ["mm", a] || s <= 1 && ["h"] || s < n.h && ["hh", s] || l <= 1 && ["d"] || l < n.d && ["dd", l];
                    return null != n.w && (h = h || u <= 1 && ["w"] || u < n.w && ["ww", u]), (h = h || c <= 1 && ["M"] || c < n.M && ["MM", c] || d <= 1 && ["y"] || ["yy", d])[2] = t, h[3] = +e > 0, h[4] = i, Zn.apply(null, h)
                }(this, !r, o, n), r && (i = n.pastFuture(+this, i)), n.postformat(i)
            }, Kn.toISOString = Jn, Kn.toString = Jn, Kn.toJSON = Jn, Kn.locale = Qt, Kn.localeData = tn, Kn.toIsoString = T("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Jn), Kn.lang = en, z("X", 0, 0, "unix"), z("x", 0, 0, "valueOf"), fe("x", ue), fe("X", /[+-]?\d+(\.\d{1,3})?/), ve("X", (function (e, t, n) {
                n._d = new Date(1e3 * parseFloat(e))
            })), ve("x", (function (e, t, n) {
                n._d = new Date(q(e))
            })),
//! moment.js
                r.version = "2.29.1", t = St, r.fn = gn, r.min = function () {
                var e = [].slice.call(arguments, 0);
                return Et("isBefore", e)
            }, r.max = function () {
                var e = [].slice.call(arguments, 0);
                return Et("isAfter", e)
            }, r.now = function () {
                return Date.now ? Date.now() : +new Date
            }, r.utc = f, r.unix = function (e) {
                return St(1e3 * e)
            }, r.months = function (e, t) {
                return bn(e, t, "months")
            }, r.isDate = d, r.locale = at, r.invalid = g, r.duration = Nt, r.isMoment = w, r.weekdays = function (e, t, n) {
                return wn(e, t, n, "weekdays")
            }, r.parseZone = function () {
                return St.apply(null, arguments).parseZone()
            }, r.localeData = lt, r.isDuration = It, r.monthsShort = function (e, t) {
                return bn(e, t, "monthsShort")
            }, r.weekdaysMin = function (e, t, n) {
                return wn(e, t, n, "weekdaysMin")
            }, r.defineLocale = st, r.updateLocale = function (e, t) {
                if (null != t) {
                    var n, i, r = et;
                    null != tt[e] && null != tt[e].parentLocale ? tt[e].set(E(tt[e]._config, t)) : (null != (i = ot(e)) && (r = i._config), t = E(r, t), null == i && (t.abbr = e), (n = new C(t)).parentLocale = tt[e], tt[e] = n), at(e)
                } else null != tt[e] && (null != tt[e].parentLocale ? (tt[e] = tt[e].parentLocale, e === at() && at(e)) : null != tt[e] && delete tt[e]);
                return tt[e]
            }, r.locales = function () {
                return k(tt)
            }, r.weekdaysShort = function (e, t, n) {
                return wn(e, t, n, "weekdaysShort")
            }, r.normalizeUnits = H, r.relativeTimeRounding = function (e) {
                return void 0 === e ? Gn : "function" == typeof e && (Gn = e, !0)
            }, r.relativeTimeThreshold = function (e, t) {
                return void 0 !== qn[e] && (void 0 === t ? qn[e] : (qn[e] = t, "s" === e && (qn.ss = t - 1), !0))
            }, r.calendarFormat = function (e, t) {
                var n = e.diff(t, "days", !0);
                return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
            }, r.prototype = gn, r.HTML5_FMT = {
                DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                DATE: "YYYY-MM-DD",
                TIME: "HH:mm",
                TIME_SECONDS: "HH:mm:ss",
                TIME_MS: "HH:mm:ss.SSS",
                WEEK: "GGGG-[W]WW",
                MONTH: "YYYY-MM"
            }, r
        }()
    }).call(this, n(150)(e))
}, function (e, t, n) {
    var i;
    /*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
    !function (t, n) {
        "use strict";
        "object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function (e) {
            if (!e.document) throw new Error("jQuery requires a window with a document");
            return n(e)
        } : n(t)
    }("undefined" != typeof window ? window : this, (function (n, r) {
        "use strict";
        var o = [], a = Object.getPrototypeOf, s = o.slice, l = o.flat ? function (e) {
                return o.flat.call(e)
            } : function (e) {
                return o.concat.apply([], e)
            }, c = o.push, u = o.indexOf, d = {}, h = d.toString, p = d.hasOwnProperty, f = p.toString, m = f.call(Object),
            _ = {}, g = function (e) {
                return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
            }, y = function (e) {
                return null != e && e === e.window
            }, v = n.document, x = {type: !0, src: !0, nonce: !0, noModule: !0};

        function b(e, t, n) {
            var i, r, o = (n = n || v).createElement("script");
            if (o.text = e, t) for (i in x) (r = t[i] || t.getAttribute && t.getAttribute(i)) && o.setAttribute(i, r);
            n.head.appendChild(o).parentNode.removeChild(o)
        }

        function w(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? d[h.call(e)] || "object" : typeof e
        }

        var M = function (e, t) {
            return new M.fn.init(e, t)
        };

        function T(e) {
            var t = !!e && "length" in e && e.length, n = w(e);
            return !g(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e)
        }

        M.fn = M.prototype = {
            jquery: "3.6.0", constructor: M, length: 0, toArray: function () {
                return s.call(this)
            }, get: function (e) {
                return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
            }, pushStack: function (e) {
                var t = M.merge(this.constructor(), e);
                return t.prevObject = this, t
            }, each: function (e) {
                return M.each(this, e)
            }, map: function (e) {
                return this.pushStack(M.map(this, (function (t, n) {
                    return e.call(t, n, t)
                })))
            }, slice: function () {
                return this.pushStack(s.apply(this, arguments))
            }, first: function () {
                return this.eq(0)
            }, last: function () {
                return this.eq(-1)
            }, even: function () {
                return this.pushStack(M.grep(this, (function (e, t) {
                    return (t + 1) % 2
                })))
            }, odd: function () {
                return this.pushStack(M.grep(this, (function (e, t) {
                    return t % 2
                })))
            }, eq: function (e) {
                var t = this.length, n = +e + (e < 0 ? t : 0);
                return this.pushStack(n >= 0 && n < t ? [this[n]] : [])
            }, end: function () {
                return this.prevObject || this.constructor()
            }, push: c, sort: o.sort, splice: o.splice
        }, M.extend = M.fn.extend = function () {
            var e, t, n, i, r, o, a = arguments[0] || {}, s = 1, l = arguments.length, c = !1;
            for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === l && (a = this, s--); s < l; s++) if (null != (e = arguments[s])) for (t in e) i = e[t], "__proto__" !== t && a !== i && (c && i && (M.isPlainObject(i) || (r = Array.isArray(i))) ? (n = a[t], o = r && !Array.isArray(n) ? [] : r || M.isPlainObject(n) ? n : {}, r = !1, a[t] = M.extend(c, o, i)) : void 0 !== i && (a[t] = i));
            return a
        }, M.extend({
            expando: "jQuery" + ("3.6.0" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) {
                throw new Error(e)
            }, noop: function () {
            }, isPlainObject: function (e) {
                var t, n;
                return !(!e || "[object Object]" !== h.call(e)) && (!(t = a(e)) || "function" == typeof (n = p.call(t, "constructor") && t.constructor) && f.call(n) === m)
            }, isEmptyObject: function (e) {
                var t;
                for (t in e) return !1;
                return !0
            }, globalEval: function (e, t, n) {
                b(e, {nonce: t && t.nonce}, n)
            }, each: function (e, t) {
                var n, i = 0;
                if (T(e)) for (n = e.length; i < n && !1 !== t.call(e[i], i, e[i]); i++) ; else for (i in e) if (!1 === t.call(e[i], i, e[i])) break;
                return e
            }, makeArray: function (e, t) {
                var n = t || [];
                return null != e && (T(Object(e)) ? M.merge(n, "string" == typeof e ? [e] : e) : c.call(n, e)), n
            }, inArray: function (e, t, n) {
                return null == t ? -1 : u.call(t, e, n)
            }, merge: function (e, t) {
                for (var n = +t.length, i = 0, r = e.length; i < n; i++) e[r++] = t[i];
                return e.length = r, e
            }, grep: function (e, t, n) {
                for (var i = [], r = 0, o = e.length, a = !n; r < o; r++) !t(e[r], r) !== a && i.push(e[r]);
                return i
            }, map: function (e, t, n) {
                var i, r, o = 0, a = [];
                if (T(e)) for (i = e.length; o < i; o++) null != (r = t(e[o], o, n)) && a.push(r); else for (o in e) null != (r = t(e[o], o, n)) && a.push(r);
                return l(a)
            }, guid: 1, support: _
        }), "function" == typeof Symbol && (M.fn[Symbol.iterator] = o[Symbol.iterator]), M.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) {
            d["[object " + t + "]"] = t.toLowerCase()
        }));
        var k =
            /*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
            function (e) {
                var t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x = "sizzle" + 1 * new Date,
                    b = e.document, w = 0, M = 0, T = le(), k = le(), S = le(), D = le(), L = function (e, t) {
                        return e === t && (d = !0), 0
                    }, E = {}.hasOwnProperty, C = [], A = C.pop, I = C.push, P = C.push, R = C.slice, Y = function (e, t) {
                        for (var n = 0, i = e.length; n < i; n++) if (e[n] === t) return n;
                        return -1
                    },
                    z = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    O = "[\\x20\\t\\r\\n\\f]",
                    F = "(?:\\\\[\\da-fA-F]{1,6}" + O + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                    B = "\\[" + O + "*(" + F + ")(?:" + O + "*([*^$|!~]?=)" + O + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + F + "))|)" + O + "*\\]",
                    j = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + B + ")*)|.*)\\)|)",
                    H = new RegExp(O + "+", "g"),
                    N = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"),
                    U = new RegExp("^" + O + "*," + O + "*"), W = new RegExp("^" + O + "*([>+~]|" + O + ")" + O + "*"),
                    V = new RegExp(O + "|>"), G = new RegExp(j), q = new RegExp("^" + F + "$"), Z = {
                        ID: new RegExp("^#(" + F + ")"),
                        CLASS: new RegExp("^\\.(" + F + ")"),
                        TAG: new RegExp("^(" + F + "|[*])"),
                        ATTR: new RegExp("^" + B),
                        PSEUDO: new RegExp("^" + j),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + z + ")$", "i"),
                        needsContext: new RegExp("^" + O + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", "i")
                    }, $ = /HTML$/i, X = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/,
                    Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/,
                    te = new RegExp("\\\\[\\da-fA-F]{1,6}" + O + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) {
                        var n = "0x" + e.slice(1) - 65536;
                        return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    }, ie = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, re = function (e, t) {
                        return t ? "\0" === e ? "" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
                    }, oe = function () {
                        h()
                    }, ae = xe((function (e) {
                        return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
                    }), {dir: "parentNode", next: "legend"});
                try {
                    P.apply(C = R.call(b.childNodes), b.childNodes), C[b.childNodes.length].nodeType
                } catch (e) {
                    P = {
                        apply: C.length ? function (e, t) {
                            I.apply(e, R.call(t))
                        } : function (e, t) {
                            for (var n = e.length, i = 0; e[n++] = t[i++];) ;
                            e.length = n - 1
                        }
                    }
                }

                function se(e, t, i, r) {
                    var o, s, c, u, d, f, g, y = t && t.ownerDocument, b = t ? t.nodeType : 9;
                    if (i = i || [], "string" != typeof e || !e || 1 !== b && 9 !== b && 11 !== b) return i;
                    if (!r && (h(t), t = t || p, m)) {
                        if (11 !== b && (d = Q.exec(e))) if (o = d[1]) {
                            if (9 === b) {
                                if (!(c = t.getElementById(o))) return i;
                                if (c.id === o) return i.push(c), i
                            } else if (y && (c = y.getElementById(o)) && v(t, c) && c.id === o) return i.push(c), i
                        } else {
                            if (d[2]) return P.apply(i, t.getElementsByTagName(e)), i;
                            if ((o = d[3]) && n.getElementsByClassName && t.getElementsByClassName) return P.apply(i, t.getElementsByClassName(o)), i
                        }
                        if (n.qsa && !D[e + " "] && (!_ || !_.test(e)) && (1 !== b || "object" !== t.nodeName.toLowerCase())) {
                            if (g = e, y = t, 1 === b && (V.test(e) || W.test(e))) {
                                for ((y = ee.test(e) && ge(t.parentNode) || t) === t && n.scope || ((u = t.getAttribute("id")) ? u = u.replace(ie, re) : t.setAttribute("id", u = x)), s = (f = a(e)).length; s--;) f[s] = (u ? "#" + u : ":scope") + " " + ve(f[s]);
                                g = f.join(",")
                            }
                            try {
                                return P.apply(i, y.querySelectorAll(g)), i
                            } catch (t) {
                                D(e, !0)
                            } finally {
                                u === x && t.removeAttribute("id")
                            }
                        }
                    }
                    return l(e.replace(N, "$1"), t, i, r)
                }

                function le() {
                    var e = [];
                    return function t(n, r) {
                        return e.push(n + " ") > i.cacheLength && delete t[e.shift()], t[n + " "] = r
                    }
                }

                function ce(e) {
                    return e[x] = !0, e
                }

                function ue(e) {
                    var t = p.createElement("fieldset");
                    try {
                        return !!e(t)
                    } catch (e) {
                        return !1
                    } finally {
                        t.parentNode && t.parentNode.removeChild(t), t = null
                    }
                }

                function de(e, t) {
                    for (var n = e.split("|"), r = n.length; r--;) i.attrHandle[n[r]] = t
                }

                function he(e, t) {
                    var n = t && e, i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                    if (i) return i;
                    if (n) for (; n = n.nextSibling;) if (n === t) return -1;
                    return e ? 1 : -1
                }

                function pe(e) {
                    return function (t) {
                        return "input" === t.nodeName.toLowerCase() && t.type === e
                    }
                }

                function fe(e) {
                    return function (t) {
                        var n = t.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && t.type === e
                    }
                }

                function me(e) {
                    return function (t) {
                        return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ae(t) === e : t.disabled === e : "label" in t && t.disabled === e
                    }
                }

                function _e(e) {
                    return ce((function (t) {
                        return t = +t, ce((function (n, i) {
                            for (var r, o = e([], n.length, t), a = o.length; a--;) n[r = o[a]] && (n[r] = !(i[r] = n[r]))
                        }))
                    }))
                }

                function ge(e) {
                    return e && void 0 !== e.getElementsByTagName && e
                }

                for (t in n = se.support = {}, o = se.isXML = function (e) {
                    var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement;
                    return !$.test(t || n && n.nodeName || "HTML")
                }, h = se.setDocument = function (e) {
                    var t, r, a = e ? e.ownerDocument || e : b;
                    return a != p && 9 === a.nodeType && a.documentElement ? (f = (p = a).documentElement, m = !o(p), b != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", oe, !1) : r.attachEvent && r.attachEvent("onunload", oe)), n.scope = ue((function (e) {
                        return f.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
                    })), n.attributes = ue((function (e) {
                        return e.className = "i", !e.getAttribute("className")
                    })), n.getElementsByTagName = ue((function (e) {
                        return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length
                    })), n.getElementsByClassName = K.test(p.getElementsByClassName), n.getById = ue((function (e) {
                        return f.appendChild(e).id = x, !p.getElementsByName || !p.getElementsByName(x).length
                    })), n.getById ? (i.filter.ID = function (e) {
                        var t = e.replace(te, ne);
                        return function (e) {
                            return e.getAttribute("id") === t
                        }
                    }, i.find.ID = function (e, t) {
                        if (void 0 !== t.getElementById && m) {
                            var n = t.getElementById(e);
                            return n ? [n] : []
                        }
                    }) : (i.filter.ID = function (e) {
                        var t = e.replace(te, ne);
                        return function (e) {
                            var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                            return n && n.value === t
                        }
                    }, i.find.ID = function (e, t) {
                        if (void 0 !== t.getElementById && m) {
                            var n, i, r, o = t.getElementById(e);
                            if (o) {
                                if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                                for (r = t.getElementsByName(e), i = 0; o = r[i++];) if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                            }
                            return []
                        }
                    }), i.find.TAG = n.getElementsByTagName ? function (e, t) {
                        return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
                    } : function (e, t) {
                        var n, i = [], r = 0, o = t.getElementsByTagName(e);
                        if ("*" === e) {
                            for (; n = o[r++];) 1 === n.nodeType && i.push(n);
                            return i
                        }
                        return o
                    }, i.find.CLASS = n.getElementsByClassName && function (e, t) {
                        if (void 0 !== t.getElementsByClassName && m) return t.getElementsByClassName(e)
                    }, g = [], _ = [], (n.qsa = K.test(p.querySelectorAll)) && (ue((function (e) {
                        var t;
                        f.appendChild(e).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && _.push("[*^$]=" + O + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || _.push("\\[" + O + "*(?:value|" + z + ")"), e.querySelectorAll("[id~=" + x + "-]").length || _.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || _.push("\\[" + O + "*name" + O + "*=" + O + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || _.push(":checked"), e.querySelectorAll("a#" + x + "+*").length || _.push(".#.+[+~]"), e.querySelectorAll("\\\f"), _.push("[\\r\\n\\f]")
                    })), ue((function (e) {
                        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var t = p.createElement("input");
                        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && _.push("name" + O + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && _.push(":enabled", ":disabled"), f.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && _.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), _.push(",.*:")
                    }))), (n.matchesSelector = K.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ue((function (e) {
                        n.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), g.push("!=", j)
                    })), _ = _.length && new RegExp(_.join("|")), g = g.length && new RegExp(g.join("|")), t = K.test(f.compareDocumentPosition), v = t || K.test(f.contains) ? function (e, t) {
                        var n = 9 === e.nodeType ? e.documentElement : e, i = t && t.parentNode;
                        return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
                    } : function (e, t) {
                        if (t) for (; t = t.parentNode;) if (t === e) return !0;
                        return !1
                    }, L = t ? function (e, t) {
                        if (e === t) return d = !0, 0;
                        var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        return i || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === i ? e == p || e.ownerDocument == b && v(b, e) ? -1 : t == p || t.ownerDocument == b && v(b, t) ? 1 : u ? Y(u, e) - Y(u, t) : 0 : 4 & i ? -1 : 1)
                    } : function (e, t) {
                        if (e === t) return d = !0, 0;
                        var n, i = 0, r = e.parentNode, o = t.parentNode, a = [e], s = [t];
                        if (!r || !o) return e == p ? -1 : t == p ? 1 : r ? -1 : o ? 1 : u ? Y(u, e) - Y(u, t) : 0;
                        if (r === o) return he(e, t);
                        for (n = e; n = n.parentNode;) a.unshift(n);
                        for (n = t; n = n.parentNode;) s.unshift(n);
                        for (; a[i] === s[i];) i++;
                        return i ? he(a[i], s[i]) : a[i] == b ? -1 : s[i] == b ? 1 : 0
                    }, p) : p
                }, se.matches = function (e, t) {
                    return se(e, null, null, t)
                }, se.matchesSelector = function (e, t) {
                    if (h(e), n.matchesSelector && m && !D[t + " "] && (!g || !g.test(t)) && (!_ || !_.test(t))) try {
                        var i = y.call(e, t);
                        if (i || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                    } catch (e) {
                        D(t, !0)
                    }
                    return se(t, p, null, [e]).length > 0
                }, se.contains = function (e, t) {
                    return (e.ownerDocument || e) != p && h(e), v(e, t)
                }, se.attr = function (e, t) {
                    (e.ownerDocument || e) != p && h(e);
                    var r = i.attrHandle[t.toLowerCase()],
                        o = r && E.call(i.attrHandle, t.toLowerCase()) ? r(e, t, !m) : void 0;
                    return void 0 !== o ? o : n.attributes || !m ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null
                }, se.escape = function (e) {
                    return (e + "").replace(ie, re)
                }, se.error = function (e) {
                    throw new Error("Syntax error, unrecognized expression: " + e)
                }, se.uniqueSort = function (e) {
                    var t, i = [], r = 0, o = 0;
                    if (d = !n.detectDuplicates, u = !n.sortStable && e.slice(0), e.sort(L), d) {
                        for (; t = e[o++];) t === e[o] && (r = i.push(o));
                        for (; r--;) e.splice(i[r], 1)
                    }
                    return u = null, e
                }, r = se.getText = function (e) {
                    var t, n = "", i = 0, o = e.nodeType;
                    if (o) {
                        if (1 === o || 9 === o || 11 === o) {
                            if ("string" == typeof e.textContent) return e.textContent;
                            for (e = e.firstChild; e; e = e.nextSibling) n += r(e)
                        } else if (3 === o || 4 === o) return e.nodeValue
                    } else for (; t = e[i++];) n += r(t);
                    return n
                }, (i = se.selectors = {
                    cacheLength: 50,
                    createPseudo: ce,
                    match: Z,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {dir: "parentNode", first: !0},
                        " ": {dir: "parentNode"},
                        "+": {dir: "previousSibling", first: !0},
                        "~": {dir: "previousSibling"}
                    },
                    preFilter: {
                        ATTR: function (e) {
                            return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                        }, CHILD: function (e) {
                            return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e
                        }, PSEUDO: function (e) {
                            var t, n = !e[6] && e[2];
                            return Z.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && G.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (e) {
                            var t = e.replace(te, ne).toLowerCase();
                            return "*" === e ? function () {
                                return !0
                            } : function (e) {
                                return e.nodeName && e.nodeName.toLowerCase() === t
                            }
                        }, CLASS: function (e) {
                            var t = T[e + " "];
                            return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && T(e, (function (e) {
                                return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                            }))
                        }, ATTR: function (e, t, n) {
                            return function (i) {
                                var r = se.attr(i, e);
                                return null == r ? "!=" === t : !t || (r += "", "=" === t ? r === n : "!=" === t ? r !== n : "^=" === t ? n && 0 === r.indexOf(n) : "*=" === t ? n && r.indexOf(n) > -1 : "$=" === t ? n && r.slice(-n.length) === n : "~=" === t ? (" " + r.replace(H, " ") + " ").indexOf(n) > -1 : "|=" === t && (r === n || r.slice(0, n.length + 1) === n + "-"))
                            }
                        }, CHILD: function (e, t, n, i, r) {
                            var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;
                            return 1 === i && 0 === r ? function (e) {
                                return !!e.parentNode
                            } : function (t, n, l) {
                                var c, u, d, h, p, f, m = o !== a ? "nextSibling" : "previousSibling", _ = t.parentNode,
                                    g = s && t.nodeName.toLowerCase(), y = !l && !s, v = !1;
                                if (_) {
                                    if (o) {
                                        for (; m;) {
                                            for (h = t; h = h[m];) if (s ? h.nodeName.toLowerCase() === g : 1 === h.nodeType) return !1;
                                            f = m = "only" === e && !f && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (f = [a ? _.firstChild : _.lastChild], a && y) {
                                        for (v = (p = (c = (u = (d = (h = _)[x] || (h[x] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[e] || [])[0] === w && c[1]) && c[2], h = p && _.childNodes[p]; h = ++p && h && h[m] || (v = p = 0) || f.pop();) if (1 === h.nodeType && ++v && h === t) {
                                            u[e] = [w, p, v];
                                            break
                                        }
                                    } else if (y && (v = p = (c = (u = (d = (h = t)[x] || (h[x] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[e] || [])[0] === w && c[1]), !1 === v) for (; (h = ++p && h && h[m] || (v = p = 0) || f.pop()) && ((s ? h.nodeName.toLowerCase() !== g : 1 !== h.nodeType) || !++v || (y && ((u = (d = h[x] || (h[x] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[e] = [w, v]), h !== t));) ;
                                    return (v -= r) === i || v % i == 0 && v / i >= 0
                                }
                            }
                        }, PSEUDO: function (e, t) {
                            var n,
                                r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                            return r[x] ? r(t) : r.length > 1 ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? ce((function (e, n) {
                                for (var i, o = r(e, t), a = o.length; a--;) e[i = Y(e, o[a])] = !(n[i] = o[a])
                            })) : function (e) {
                                return r(e, 0, n)
                            }) : r
                        }
                    },
                    pseudos: {
                        not: ce((function (e) {
                            var t = [], n = [], i = s(e.replace(N, "$1"));
                            return i[x] ? ce((function (e, t, n, r) {
                                for (var o, a = i(e, null, r, []), s = e.length; s--;) (o = a[s]) && (e[s] = !(t[s] = o))
                            })) : function (e, r, o) {
                                return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop()
                            }
                        })), has: ce((function (e) {
                            return function (t) {
                                return se(e, t).length > 0
                            }
                        })), contains: ce((function (e) {
                            return e = e.replace(te, ne), function (t) {
                                return (t.textContent || r(t)).indexOf(e) > -1
                            }
                        })), lang: ce((function (e) {
                            return q.test(e || "") || se.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(), function (t) {
                                var n;
                                do {
                                    if (n = m ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-")
                                } while ((t = t.parentNode) && 1 === t.nodeType);
                                return !1
                            }
                        })), target: function (t) {
                            var n = e.location && e.location.hash;
                            return n && n.slice(1) === t.id
                        }, root: function (e) {
                            return e === f
                        }, focus: function (e) {
                            return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                        }, enabled: me(!1), disabled: me(!0), checked: function (e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && !!e.checked || "option" === t && !!e.selected
                        }, selected: function (e) {
                            return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                        }, empty: function (e) {
                            for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                            return !0
                        }, parent: function (e) {
                            return !i.pseudos.empty(e)
                        }, header: function (e) {
                            return J.test(e.nodeName)
                        }, input: function (e) {
                            return X.test(e.nodeName)
                        }, button: function (e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && "button" === e.type || "button" === t
                        }, text: function (e) {
                            var t;
                            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                        }, first: _e((function () {
                            return [0]
                        })), last: _e((function (e, t) {
                            return [t - 1]
                        })), eq: _e((function (e, t, n) {
                            return [n < 0 ? n + t : n]
                        })), even: _e((function (e, t) {
                            for (var n = 0; n < t; n += 2) e.push(n);
                            return e
                        })), odd: _e((function (e, t) {
                            for (var n = 1; n < t; n += 2) e.push(n);
                            return e
                        })), lt: _e((function (e, t, n) {
                            for (var i = n < 0 ? n + t : n > t ? t : n; --i >= 0;) e.push(i);
                            return e
                        })), gt: _e((function (e, t, n) {
                            for (var i = n < 0 ? n + t : n; ++i < t;) e.push(i);
                            return e
                        }))
                    }
                }).pseudos.nth = i.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) i.pseudos[t] = pe(t);
                for (t in {submit: !0, reset: !0}) i.pseudos[t] = fe(t);

                function ye() {
                }

                function ve(e) {
                    for (var t = 0, n = e.length, i = ""; t < n; t++) i += e[t].value;
                    return i
                }

                function xe(e, t, n) {
                    var i = t.dir, r = t.next, o = r || i, a = n && "parentNode" === o, s = M++;
                    return t.first ? function (t, n, r) {
                        for (; t = t[i];) if (1 === t.nodeType || a) return e(t, n, r);
                        return !1
                    } : function (t, n, l) {
                        var c, u, d, h = [w, s];
                        if (l) {
                            for (; t = t[i];) if ((1 === t.nodeType || a) && e(t, n, l)) return !0
                        } else for (; t = t[i];) if (1 === t.nodeType || a) if (u = (d = t[x] || (t[x] = {}))[t.uniqueID] || (d[t.uniqueID] = {}), r && r === t.nodeName.toLowerCase()) t = t[i] || t; else {
                            if ((c = u[o]) && c[0] === w && c[1] === s) return h[2] = c[2];
                            if (u[o] = h, h[2] = e(t, n, l)) return !0
                        }
                        return !1
                    }
                }

                function be(e) {
                    return e.length > 1 ? function (t, n, i) {
                        for (var r = e.length; r--;) if (!e[r](t, n, i)) return !1;
                        return !0
                    } : e[0]
                }

                function we(e, t, n, i, r) {
                    for (var o, a = [], s = 0, l = e.length, c = null != t; s < l; s++) (o = e[s]) && (n && !n(o, i, r) || (a.push(o), c && t.push(s)));
                    return a
                }

                function Me(e, t, n, i, r, o) {
                    return i && !i[x] && (i = Me(i)), r && !r[x] && (r = Me(r, o)), ce((function (o, a, s, l) {
                        var c, u, d, h = [], p = [], f = a.length, m = o || function (e, t, n) {
                                for (var i = 0, r = t.length; i < r; i++) se(e, t[i], n);
                                return n
                            }(t || "*", s.nodeType ? [s] : s, []), _ = !e || !o && t ? m : we(m, h, e, s, l),
                            g = n ? r || (o ? e : f || i) ? [] : a : _;
                        if (n && n(_, g, s, l), i) for (c = we(g, p), i(c, [], s, l), u = c.length; u--;) (d = c[u]) && (g[p[u]] = !(_[p[u]] = d));
                        if (o) {
                            if (r || e) {
                                if (r) {
                                    for (c = [], u = g.length; u--;) (d = g[u]) && c.push(_[u] = d);
                                    r(null, g = [], c, l)
                                }
                                for (u = g.length; u--;) (d = g[u]) && (c = r ? Y(o, d) : h[u]) > -1 && (o[c] = !(a[c] = d))
                            }
                        } else g = we(g === a ? g.splice(f, g.length) : g), r ? r(null, a, g, l) : P.apply(a, g)
                    }))
                }

                function Te(e) {
                    for (var t, n, r, o = e.length, a = i.relative[e[0].type], s = a || i.relative[" "], l = a ? 1 : 0, u = xe((function (e) {
                        return e === t
                    }), s, !0), d = xe((function (e) {
                        return Y(t, e) > -1
                    }), s, !0), h = [function (e, n, i) {
                        var r = !a && (i || n !== c) || ((t = n).nodeType ? u(e, n, i) : d(e, n, i));
                        return t = null, r
                    }]; l < o; l++) if (n = i.relative[e[l].type]) h = [xe(be(h), n)]; else {
                        if ((n = i.filter[e[l].type].apply(null, e[l].matches))[x]) {
                            for (r = ++l; r < o && !i.relative[e[r].type]; r++) ;
                            return Me(l > 1 && be(h), l > 1 && ve(e.slice(0, l - 1).concat({value: " " === e[l - 2].type ? "*" : ""})).replace(N, "$1"), n, l < r && Te(e.slice(l, r)), r < o && Te(e = e.slice(r)), r < o && ve(e))
                        }
                        h.push(n)
                    }
                    return be(h)
                }

                return ye.prototype = i.filters = i.pseudos, i.setFilters = new ye, a = se.tokenize = function (e, t) {
                    var n, r, o, a, s, l, c, u = k[e + " "];
                    if (u) return t ? 0 : u.slice(0);
                    for (s = e, l = [], c = i.preFilter; s;) {
                        for (a in n && !(r = U.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), n = !1, (r = W.exec(s)) && (n = r.shift(), o.push({
                            value: n,
                            type: r[0].replace(N, " ")
                        }), s = s.slice(n.length)), i.filter) !(r = Z[a].exec(s)) || c[a] && !(r = c[a](r)) || (n = r.shift(), o.push({
                            value: n,
                            type: a,
                            matches: r
                        }), s = s.slice(n.length));
                        if (!n) break
                    }
                    return t ? s.length : s ? se.error(e) : k(e, l).slice(0)
                }, s = se.compile = function (e, t) {
                    var n, r = [], o = [], s = S[e + " "];
                    if (!s) {
                        for (t || (t = a(e)), n = t.length; n--;) (s = Te(t[n]))[x] ? r.push(s) : o.push(s);
                        (s = S(e, function (e, t) {
                            var n = t.length > 0, r = e.length > 0, o = function (o, a, s, l, u) {
                                var d, f, _, g = 0, y = "0", v = o && [], x = [], b = c,
                                    M = o || r && i.find.TAG("*", u), T = w += null == b ? 1 : Math.random() || .1,
                                    k = M.length;
                                for (u && (c = a == p || a || u); y !== k && null != (d = M[y]); y++) {
                                    if (r && d) {
                                        for (f = 0, a || d.ownerDocument == p || (h(d), s = !m); _ = e[f++];) if (_(d, a || p, s)) {
                                            l.push(d);
                                            break
                                        }
                                        u && (w = T)
                                    }
                                    n && ((d = !_ && d) && g--, o && v.push(d))
                                }
                                if (g += y, n && y !== g) {
                                    for (f = 0; _ = t[f++];) _(v, x, a, s);
                                    if (o) {
                                        if (g > 0) for (; y--;) v[y] || x[y] || (x[y] = A.call(l));
                                        x = we(x)
                                    }
                                    P.apply(l, x), u && !o && x.length > 0 && g + t.length > 1 && se.uniqueSort(l)
                                }
                                return u && (w = T, c = b), v
                            };
                            return n ? ce(o) : o
                        }(o, r))).selector = e
                    }
                    return s
                }, l = se.select = function (e, t, n, r) {
                    var o, l, c, u, d, h = "function" == typeof e && e, p = !r && a(e = h.selector || e);
                    if (n = n || [], 1 === p.length) {
                        if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === t.nodeType && m && i.relative[l[1].type]) {
                            if (!(t = (i.find.ID(c.matches[0].replace(te, ne), t) || [])[0])) return n;
                            h && (t = t.parentNode), e = e.slice(l.shift().value.length)
                        }
                        for (o = Z.needsContext.test(e) ? 0 : l.length; o-- && (c = l[o], !i.relative[u = c.type]);) if ((d = i.find[u]) && (r = d(c.matches[0].replace(te, ne), ee.test(l[0].type) && ge(t.parentNode) || t))) {
                            if (l.splice(o, 1), !(e = r.length && ve(l))) return P.apply(n, r), n;
                            break
                        }
                    }
                    return (h || s(e, p))(r, t, !m, n, !t || ee.test(e) && ge(t.parentNode) || t), n
                }, n.sortStable = x.split("").sort(L).join("") === x, n.detectDuplicates = !!d, h(), n.sortDetached = ue((function (e) {
                    return 1 & e.compareDocumentPosition(p.createElement("fieldset"))
                })), ue((function (e) {
                    return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                })) || de("type|href|height|width", (function (e, t, n) {
                    if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                })), n.attributes && ue((function (e) {
                    return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                })) || de("value", (function (e, t, n) {
                    if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
                })), ue((function (e) {
                    return null == e.getAttribute("disabled")
                })) || de(z, (function (e, t, n) {
                    var i;
                    if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
                })), se
            }(n);
        M.find = k, M.expr = k.selectors, M.expr[":"] = M.expr.pseudos, M.uniqueSort = M.unique = k.uniqueSort, M.text = k.getText, M.isXMLDoc = k.isXML, M.contains = k.contains, M.escapeSelector = k.escape;
        var S = function (e, t, n) {
            for (var i = [], r = void 0 !== n; (e = e[t]) && 9 !== e.nodeType;) if (1 === e.nodeType) {
                if (r && M(e).is(n)) break;
                i.push(e)
            }
            return i
        }, D = function (e, t) {
            for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
            return n
        }, L = M.expr.match.needsContext;

        function E(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        }

        var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

        function A(e, t, n) {
            return g(t) ? M.grep(e, (function (e, i) {
                return !!t.call(e, i, e) !== n
            })) : t.nodeType ? M.grep(e, (function (e) {
                return e === t !== n
            })) : "string" != typeof t ? M.grep(e, (function (e) {
                return u.call(t, e) > -1 !== n
            })) : M.filter(t, e, n)
        }

        M.filter = function (e, t, n) {
            var i = t[0];
            return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? M.find.matchesSelector(i, e) ? [i] : [] : M.find.matches(e, M.grep(t, (function (e) {
                return 1 === e.nodeType
            })))
        }, M.fn.extend({
            find: function (e) {
                var t, n, i = this.length, r = this;
                if ("string" != typeof e) return this.pushStack(M(e).filter((function () {
                    for (t = 0; t < i; t++) if (M.contains(r[t], this)) return !0
                })));
                for (n = this.pushStack([]), t = 0; t < i; t++) M.find(e, r[t], n);
                return i > 1 ? M.uniqueSort(n) : n
            }, filter: function (e) {
                return this.pushStack(A(this, e || [], !1))
            }, not: function (e) {
                return this.pushStack(A(this, e || [], !0))
            }, is: function (e) {
                return !!A(this, "string" == typeof e && L.test(e) ? M(e) : e || [], !1).length
            }
        });
        var I, P = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (M.fn.init = function (e, t, n) {
            var i, r;
            if (!e) return this;
            if (n = n || I, "string" == typeof e) {
                if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : P.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
                if (i[1]) {
                    if (t = t instanceof M ? t[0] : t, M.merge(this, M.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : v, !0)), C.test(i[1]) && M.isPlainObject(t)) for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
                    return this
                }
                return (r = v.getElementById(i[2])) && (this[0] = r, this.length = 1), this
            }
            return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(M) : M.makeArray(e, this)
        }).prototype = M.fn, I = M(v);
        var R = /^(?:parents|prev(?:Until|All))/, Y = {children: !0, contents: !0, next: !0, prev: !0};

        function z(e, t) {
            for (; (e = e[t]) && 1 !== e.nodeType;) ;
            return e
        }

        M.fn.extend({
            has: function (e) {
                var t = M(e, this), n = t.length;
                return this.filter((function () {
                    for (var e = 0; e < n; e++) if (M.contains(this, t[e])) return !0
                }))
            }, closest: function (e, t) {
                var n, i = 0, r = this.length, o = [], a = "string" != typeof e && M(e);
                if (!L.test(e)) for (; i < r; i++) for (n = this[i]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && M.find.matchesSelector(n, e))) {
                    o.push(n);
                    break
                }
                return this.pushStack(o.length > 1 ? M.uniqueSort(o) : o)
            }, index: function (e) {
                return e ? "string" == typeof e ? u.call(M(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }, add: function (e, t) {
                return this.pushStack(M.uniqueSort(M.merge(this.get(), M(e, t))))
            }, addBack: function (e) {
                return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
            }
        }), M.each({
            parent: function (e) {
                var t = e.parentNode;
                return t && 11 !== t.nodeType ? t : null
            }, parents: function (e) {
                return S(e, "parentNode")
            }, parentsUntil: function (e, t, n) {
                return S(e, "parentNode", n)
            }, next: function (e) {
                return z(e, "nextSibling")
            }, prev: function (e) {
                return z(e, "previousSibling")
            }, nextAll: function (e) {
                return S(e, "nextSibling")
            }, prevAll: function (e) {
                return S(e, "previousSibling")
            }, nextUntil: function (e, t, n) {
                return S(e, "nextSibling", n)
            }, prevUntil: function (e, t, n) {
                return S(e, "previousSibling", n)
            }, siblings: function (e) {
                return D((e.parentNode || {}).firstChild, e)
            }, children: function (e) {
                return D(e.firstChild)
            }, contents: function (e) {
                return null != e.contentDocument && a(e.contentDocument) ? e.contentDocument : (E(e, "template") && (e = e.content || e), M.merge([], e.childNodes))
            }
        }, (function (e, t) {
            M.fn[e] = function (n, i) {
                var r = M.map(this, t, n);
                return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = M.filter(i, r)), this.length > 1 && (Y[e] || M.uniqueSort(r), R.test(e) && r.reverse()), this.pushStack(r)
            }
        }));
        var O = /[^\x20\t\r\n\f]+/g;

        function F(e) {
            return e
        }

        function B(e) {
            throw e
        }

        function j(e, t, n, i) {
            var r;
            try {
                e && g(r = e.promise) ? r.call(e).done(t).fail(n) : e && g(r = e.then) ? r.call(e, t, n) : t.apply(void 0, [e].slice(i))
            } catch (e) {
                n.apply(void 0, [e])
            }
        }

        M.Callbacks = function (e) {
            e = "string" == typeof e ? function (e) {
                var t = {};
                return M.each(e.match(O) || [], (function (e, n) {
                    t[n] = !0
                })), t
            }(e) : M.extend({}, e);
            var t, n, i, r, o = [], a = [], s = -1, l = function () {
                for (r = r || e.once, i = t = !0; a.length; s = -1) for (n = a.shift(); ++s < o.length;) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1);
                e.memory || (n = !1), t = !1, r && (o = n ? [] : "")
            }, c = {
                add: function () {
                    return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) {
                        M.each(n, (function (n, i) {
                            g(i) ? e.unique && c.has(i) || o.push(i) : i && i.length && "string" !== w(i) && t(i)
                        }))
                    }(arguments), n && !t && l()), this
                }, remove: function () {
                    return M.each(arguments, (function (e, t) {
                        for (var n; (n = M.inArray(t, o, n)) > -1;) o.splice(n, 1), n <= s && s--
                    })), this
                }, has: function (e) {
                    return e ? M.inArray(e, o) > -1 : o.length > 0
                }, empty: function () {
                    return o && (o = []), this
                }, disable: function () {
                    return r = a = [], o = n = "", this
                }, disabled: function () {
                    return !o
                }, lock: function () {
                    return r = a = [], n || t || (o = n = ""), this
                }, locked: function () {
                    return !!r
                }, fireWith: function (e, n) {
                    return r || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || l()), this
                }, fire: function () {
                    return c.fireWith(this, arguments), this
                }, fired: function () {
                    return !!i
                }
            };
            return c
        }, M.extend({
            Deferred: function (e) {
                var t = [["notify", "progress", M.Callbacks("memory"), M.Callbacks("memory"), 2], ["resolve", "done", M.Callbacks("once memory"), M.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", M.Callbacks("once memory"), M.Callbacks("once memory"), 1, "rejected"]],
                    i = "pending", r = {
                        state: function () {
                            return i
                        }, always: function () {
                            return o.done(arguments).fail(arguments), this
                        }, catch: function (e) {
                            return r.then(null, e)
                        }, pipe: function () {
                            var e = arguments;
                            return M.Deferred((function (n) {
                                M.each(t, (function (t, i) {
                                    var r = g(e[i[4]]) && e[i[4]];
                                    o[i[1]]((function () {
                                        var e = r && r.apply(this, arguments);
                                        e && g(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [e] : arguments)
                                    }))
                                })), e = null
                            })).promise()
                        }, then: function (e, i, r) {
                            var o = 0;

                            function a(e, t, i, r) {
                                return function () {
                                    var s = this, l = arguments, c = function () {
                                        var n, c;
                                        if (!(e < o)) {
                                            if ((n = i.apply(s, l)) === t.promise()) throw new TypeError("Thenable self-resolution");
                                            c = n && ("object" == typeof n || "function" == typeof n) && n.then, g(c) ? r ? c.call(n, a(o, t, F, r), a(o, t, B, r)) : (o++, c.call(n, a(o, t, F, r), a(o, t, B, r), a(o, t, F, t.notifyWith))) : (i !== F && (s = void 0, l = [n]), (r || t.resolveWith)(s, l))
                                        }
                                    }, u = r ? c : function () {
                                        try {
                                            c()
                                        } catch (n) {
                                            M.Deferred.exceptionHook && M.Deferred.exceptionHook(n, u.stackTrace), e + 1 >= o && (i !== B && (s = void 0, l = [n]), t.rejectWith(s, l))
                                        }
                                    };
                                    e ? u() : (M.Deferred.getStackHook && (u.stackTrace = M.Deferred.getStackHook()), n.setTimeout(u))
                                }
                            }

                            return M.Deferred((function (n) {
                                t[0][3].add(a(0, n, g(r) ? r : F, n.notifyWith)), t[1][3].add(a(0, n, g(e) ? e : F)), t[2][3].add(a(0, n, g(i) ? i : B))
                            })).promise()
                        }, promise: function (e) {
                            return null != e ? M.extend(e, r) : r
                        }
                    }, o = {};
                return M.each(t, (function (e, n) {
                    var a = n[2], s = n[5];
                    r[n[1]] = a.add, s && a.add((function () {
                        i = s
                    }), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), a.add(n[3].fire), o[n[0]] = function () {
                        return o[n[0] + "With"](this === o ? void 0 : this, arguments), this
                    }, o[n[0] + "With"] = a.fireWith
                })), r.promise(o), e && e.call(o, o), o
            }, when: function (e) {
                var t = arguments.length, n = t, i = Array(n), r = s.call(arguments), o = M.Deferred(),
                    a = function (e) {
                        return function (n) {
                            i[e] = this, r[e] = arguments.length > 1 ? s.call(arguments) : n, --t || o.resolveWith(i, r)
                        }
                    };
                if (t <= 1 && (j(e, o.done(a(n)).resolve, o.reject, !t), "pending" === o.state() || g(r[n] && r[n].then))) return o.then();
                for (; n--;) j(r[n], a(n), o.reject);
                return o.promise()
            }
        });
        var H = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        M.Deferred.exceptionHook = function (e, t) {
            n.console && n.console.warn && e && H.test(e.name) && n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
        }, M.readyException = function (e) {
            n.setTimeout((function () {
                throw e
            }))
        };
        var N = M.Deferred();

        function U() {
            v.removeEventListener("DOMContentLoaded", U), n.removeEventListener("load", U), M.ready()
        }

        M.fn.ready = function (e) {
            return N.then(e).catch((function (e) {
                M.readyException(e)
            })), this
        }, M.extend({
            isReady: !1, readyWait: 1, ready: function (e) {
                (!0 === e ? --M.readyWait : M.isReady) || (M.isReady = !0, !0 !== e && --M.readyWait > 0 || N.resolveWith(v, [M]))
            }
        }), M.ready.then = N.then, "complete" === v.readyState || "loading" !== v.readyState && !v.documentElement.doScroll ? n.setTimeout(M.ready) : (v.addEventListener("DOMContentLoaded", U), n.addEventListener("load", U));
        var W = function (e, t, n, i, r, o, a) {
            var s = 0, l = e.length, c = null == n;
            if ("object" === w(n)) for (s in r = !0, n) W(e, t, s, n[s], !0, o, a); else if (void 0 !== i && (r = !0, g(i) || (a = !0), c && (a ? (t.call(e, i), t = null) : (c = t, t = function (e, t, n) {
                return c.call(M(e), n)
            })), t)) for (; s < l; s++) t(e[s], n, a ? i : i.call(e[s], s, t(e[s], n)));
            return r ? e : c ? t.call(e) : l ? t(e[0], n) : o
        }, V = /^-ms-/, G = /-([a-z])/g;

        function q(e, t) {
            return t.toUpperCase()
        }

        function Z(e) {
            return e.replace(V, "ms-").replace(G, q)
        }

        var $ = function (e) {
            return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
        };

        function X() {
            this.expando = M.expando + X.uid++
        }

        X.uid = 1, X.prototype = {
            cache: function (e) {
                var t = e[this.expando];
                return t || (t = {}, $(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                    value: t,
                    configurable: !0
                }))), t
            }, set: function (e, t, n) {
                var i, r = this.cache(e);
                if ("string" == typeof t) r[Z(t)] = n; else for (i in t) r[Z(i)] = t[i];
                return r
            }, get: function (e, t) {
                return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][Z(t)]
            }, access: function (e, t, n) {
                return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
            }, remove: function (e, t) {
                var n, i = e[this.expando];
                if (void 0 !== i) {
                    if (void 0 !== t) {
                        n = (t = Array.isArray(t) ? t.map(Z) : (t = Z(t)) in i ? [t] : t.match(O) || []).length;
                        for (; n--;) delete i[t[n]]
                    }
                    (void 0 === t || M.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                }
            }, hasData: function (e) {
                var t = e[this.expando];
                return void 0 !== t && !M.isEmptyObject(t)
            }
        };
        var J = new X, K = new X, Q = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, ee = /[A-Z]/g;

        function te(e, t, n) {
            var i;
            if (void 0 === n && 1 === e.nodeType) if (i = "data-" + t.replace(ee, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(i))) {
                try {
                    n = function (e) {
                        return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Q.test(e) ? JSON.parse(e) : e)
                    }(n)
                } catch (e) {
                }
                K.set(e, t, n)
            } else n = void 0;
            return n
        }

        M.extend({
            hasData: function (e) {
                return K.hasData(e) || J.hasData(e)
            }, data: function (e, t, n) {
                return K.access(e, t, n)
            }, removeData: function (e, t) {
                K.remove(e, t)
            }, _data: function (e, t, n) {
                return J.access(e, t, n)
            }, _removeData: function (e, t) {
                J.remove(e, t)
            }
        }), M.fn.extend({
            data: function (e, t) {
                var n, i, r, o = this[0], a = o && o.attributes;
                if (void 0 === e) {
                    if (this.length && (r = K.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) {
                        for (n = a.length; n--;) a[n] && 0 === (i = a[n].name).indexOf("data-") && (i = Z(i.slice(5)), te(o, i, r[i]));
                        J.set(o, "hasDataAttrs", !0)
                    }
                    return r
                }
                return "object" == typeof e ? this.each((function () {
                    K.set(this, e)
                })) : W(this, (function (t) {
                    var n;
                    if (o && void 0 === t) return void 0 !== (n = K.get(o, e)) || void 0 !== (n = te(o, e)) ? n : void 0;
                    this.each((function () {
                        K.set(this, e, t)
                    }))
                }), null, t, arguments.length > 1, null, !0)
            }, removeData: function (e) {
                return this.each((function () {
                    K.remove(this, e)
                }))
            }
        }), M.extend({
            queue: function (e, t, n) {
                var i;
                if (e) return t = (t || "fx") + "queue", i = J.get(e, t), n && (!i || Array.isArray(n) ? i = J.access(e, t, M.makeArray(n)) : i.push(n)), i || []
            }, dequeue: function (e, t) {
                t = t || "fx";
                var n = M.queue(e, t), i = n.length, r = n.shift(), o = M._queueHooks(e, t);
                "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete o.stop, r.call(e, (function () {
                    M.dequeue(e, t)
                }), o)), !i && o && o.empty.fire()
            }, _queueHooks: function (e, t) {
                var n = t + "queueHooks";
                return J.get(e, n) || J.access(e, n, {
                    empty: M.Callbacks("once memory").add((function () {
                        J.remove(e, [t + "queue", n])
                    }))
                })
            }
        }), M.fn.extend({
            queue: function (e, t) {
                var n = 2;
                return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? M.queue(this[0], e) : void 0 === t ? this : this.each((function () {
                    var n = M.queue(this, e, t);
                    M._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && M.dequeue(this, e)
                }))
            }, dequeue: function (e) {
                return this.each((function () {
                    M.dequeue(this, e)
                }))
            }, clearQueue: function (e) {
                return this.queue(e || "fx", [])
            }, promise: function (e, t) {
                var n, i = 1, r = M.Deferred(), o = this, a = this.length, s = function () {
                    --i || r.resolveWith(o, [o])
                };
                for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;) (n = J.get(o[a], e + "queueHooks")) && n.empty && (i++, n.empty.add(s));
                return s(), r.promise(t)
            }
        });
        var ne = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            ie = new RegExp("^(?:([+-])=|)(" + ne + ")([a-z%]*)$", "i"), re = ["Top", "Right", "Bottom", "Left"],
            oe = v.documentElement, ae = function (e) {
                return M.contains(e.ownerDocument, e)
            }, se = {composed: !0};
        oe.getRootNode && (ae = function (e) {
            return M.contains(e.ownerDocument, e) || e.getRootNode(se) === e.ownerDocument
        });
        var le = function (e, t) {
            return "none" === (e = t || e).style.display || "" === e.style.display && ae(e) && "none" === M.css(e, "display")
        };

        function ce(e, t, n, i) {
            var r, o, a = 20, s = i ? function () {
                    return i.cur()
                } : function () {
                    return M.css(e, t, "")
                }, l = s(), c = n && n[3] || (M.cssNumber[t] ? "" : "px"),
                u = e.nodeType && (M.cssNumber[t] || "px" !== c && +l) && ie.exec(M.css(e, t));
            if (u && u[3] !== c) {
                for (l /= 2, c = c || u[3], u = +l || 1; a--;) M.style(e, t, u + c), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), u /= o;
                u *= 2, M.style(e, t, u + c), n = n || []
            }
            return n && (u = +u || +l || 0, r = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = u, i.end = r)), r
        }

        var ue = {};

        function de(e) {
            var t, n = e.ownerDocument, i = e.nodeName, r = ue[i];
            return r || (t = n.body.appendChild(n.createElement(i)), r = M.css(t, "display"), t.parentNode.removeChild(t), "none" === r && (r = "block"), ue[i] = r, r)
        }

        function he(e, t) {
            for (var n, i, r = [], o = 0, a = e.length; o < a; o++) (i = e[o]).style && (n = i.style.display, t ? ("none" === n && (r[o] = J.get(i, "display") || null, r[o] || (i.style.display = "")), "" === i.style.display && le(i) && (r[o] = de(i))) : "none" !== n && (r[o] = "none", J.set(i, "display", n)));
            for (o = 0; o < a; o++) null != r[o] && (e[o].style.display = r[o]);
            return e
        }

        M.fn.extend({
            show: function () {
                return he(this, !0)
            }, hide: function () {
                return he(this)
            }, toggle: function (e) {
                return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () {
                    le(this) ? M(this).show() : M(this).hide()
                }))
            }
        });
        var pe, fe, me = /^(?:checkbox|radio)$/i, _e = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            ge = /^$|^module$|\/(?:java|ecma)script/i;
        pe = v.createDocumentFragment().appendChild(v.createElement("div")), (fe = v.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), pe.appendChild(fe), _.checkClone = pe.cloneNode(!0).cloneNode(!0).lastChild.checked, pe.innerHTML = "<textarea>x</textarea>", _.noCloneChecked = !!pe.cloneNode(!0).lastChild.defaultValue, pe.innerHTML = "<option></option>", _.option = !!pe.lastChild;
        var ye = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

        function ve(e, t) {
            var n;
            return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && E(e, t) ? M.merge([e], n) : n
        }

        function xe(e, t) {
            for (var n = 0, i = e.length; n < i; n++) J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval"))
        }

        ye.tbody = ye.tfoot = ye.colgroup = ye.caption = ye.thead, ye.th = ye.td, _.option || (ye.optgroup = ye.option = [1, "<select multiple='multiple'>", "</select>"]);
        var be = /<|&#?\w+;/;

        function we(e, t, n, i, r) {
            for (var o, a, s, l, c, u, d = t.createDocumentFragment(), h = [], p = 0, f = e.length; p < f; p++) if ((o = e[p]) || 0 === o) if ("object" === w(o)) M.merge(h, o.nodeType ? [o] : o); else if (be.test(o)) {
                for (a = a || d.appendChild(t.createElement("div")), s = (_e.exec(o) || ["", ""])[1].toLowerCase(), l = ye[s] || ye._default, a.innerHTML = l[1] + M.htmlPrefilter(o) + l[2], u = l[0]; u--;) a = a.lastChild;
                M.merge(h, a.childNodes), (a = d.firstChild).textContent = ""
            } else h.push(t.createTextNode(o));
            for (d.textContent = "", p = 0; o = h[p++];) if (i && M.inArray(o, i) > -1) r && r.push(o); else if (c = ae(o), a = ve(d.appendChild(o), "script"), c && xe(a), n) for (u = 0; o = a[u++];) ge.test(o.type || "") && n.push(o);
            return d
        }

        var Me = /^([^.]*)(?:\.(.+)|)/;

        function Te() {
            return !0
        }

        function ke() {
            return !1
        }

        function Se(e, t) {
            return e === function () {
                try {
                    return v.activeElement
                } catch (e) {
                }
            }() == ("focus" === t)
        }

        function De(e, t, n, i, r, o) {
            var a, s;
            if ("object" == typeof t) {
                for (s in "string" != typeof n && (i = i || n, n = void 0), t) De(e, s, n, i, t[s], o);
                return e
            }
            if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = ke; else if (!r) return e;
            return 1 === o && (a = r, (r = function (e) {
                return M().off(e), a.apply(this, arguments)
            }).guid = a.guid || (a.guid = M.guid++)), e.each((function () {
                M.event.add(this, t, r, i, n)
            }))
        }

        function Le(e, t, n) {
            n ? (J.set(e, t, !1), M.event.add(e, t, {
                namespace: !1, handler: function (e) {
                    var i, r, o = J.get(this, t);
                    if (1 & e.isTrigger && this[t]) {
                        if (o.length) (M.event.special[t] || {}).delegateType && e.stopPropagation(); else if (o = s.call(arguments), J.set(this, t, o), i = n(this, t), this[t](), o !== (r = J.get(this, t)) || i ? J.set(this, t, !1) : r = {}, o !== r) return e.stopImmediatePropagation(), e.preventDefault(), r && r.value
                    } else o.length && (J.set(this, t, {value: M.event.trigger(M.extend(o[0], M.Event.prototype), o.slice(1), this)}), e.stopImmediatePropagation())
                }
            })) : void 0 === J.get(e, t) && M.event.add(e, t, Te)
        }

        M.event = {
            global: {}, add: function (e, t, n, i, r) {
                var o, a, s, l, c, u, d, h, p, f, m, _ = J.get(e);
                if ($(e)) for (n.handler && (n = (o = n).handler, r = o.selector), r && M.find.matchesSelector(oe, r), n.guid || (n.guid = M.guid++), (l = _.events) || (l = _.events = Object.create(null)), (a = _.handle) || (a = _.handle = function (t) {
                    return void 0 !== M && M.event.triggered !== t.type ? M.event.dispatch.apply(e, arguments) : void 0
                }), c = (t = (t || "").match(O) || [""]).length; c--;) p = m = (s = Me.exec(t[c]) || [])[1], f = (s[2] || "").split(".").sort(), p && (d = M.event.special[p] || {}, p = (r ? d.delegateType : d.bindType) || p, d = M.event.special[p] || {}, u = M.extend({
                    type: p,
                    origType: m,
                    data: i,
                    handler: n,
                    guid: n.guid,
                    selector: r,
                    needsContext: r && M.expr.match.needsContext.test(r),
                    namespace: f.join(".")
                }, o), (h = l[p]) || ((h = l[p] = []).delegateCount = 0, d.setup && !1 !== d.setup.call(e, i, f, a) || e.addEventListener && e.addEventListener(p, a)), d.add && (d.add.call(e, u), u.handler.guid || (u.handler.guid = n.guid)), r ? h.splice(h.delegateCount++, 0, u) : h.push(u), M.event.global[p] = !0)
            }, remove: function (e, t, n, i, r) {
                var o, a, s, l, c, u, d, h, p, f, m, _ = J.hasData(e) && J.get(e);
                if (_ && (l = _.events)) {
                    for (c = (t = (t || "").match(O) || [""]).length; c--;) if (p = m = (s = Me.exec(t[c]) || [])[1], f = (s[2] || "").split(".").sort(), p) {
                        for (d = M.event.special[p] || {}, h = l[p = (i ? d.delegateType : d.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = h.length; o--;) u = h[o], !r && m !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (h.splice(o, 1), u.selector && h.delegateCount--, d.remove && d.remove.call(e, u));
                        a && !h.length && (d.teardown && !1 !== d.teardown.call(e, f, _.handle) || M.removeEvent(e, p, _.handle), delete l[p])
                    } else for (p in l) M.event.remove(e, p + t[c], n, i, !0);
                    M.isEmptyObject(l) && J.remove(e, "handle events")
                }
            }, dispatch: function (e) {
                var t, n, i, r, o, a, s = new Array(arguments.length), l = M.event.fix(e),
                    c = (J.get(this, "events") || Object.create(null))[l.type] || [], u = M.event.special[l.type] || {};
                for (s[0] = l, t = 1; t < arguments.length; t++) s[t] = arguments[t];
                if (l.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, l)) {
                    for (a = M.event.handlers.call(this, l, c), t = 0; (r = a[t++]) && !l.isPropagationStopped();) for (l.currentTarget = r.elem, n = 0; (o = r.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== o.namespace && !l.rnamespace.test(o.namespace) || (l.handleObj = o, l.data = o.data, void 0 !== (i = ((M.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, s)) && !1 === (l.result = i) && (l.preventDefault(), l.stopPropagation()));
                    return u.postDispatch && u.postDispatch.call(this, l), l.result
                }
            }, handlers: function (e, t) {
                var n, i, r, o, a, s = [], l = t.delegateCount, c = e.target;
                if (l && c.nodeType && !("click" === e.type && e.button >= 1)) for (; c !== this; c = c.parentNode || this) if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                    for (o = [], a = {}, n = 0; n < l; n++) void 0 === a[r = (i = t[n]).selector + " "] && (a[r] = i.needsContext ? M(r, this).index(c) > -1 : M.find(r, this, null, [c]).length), a[r] && o.push(i);
                    o.length && s.push({elem: c, handlers: o})
                }
                return c = this, l < t.length && s.push({elem: c, handlers: t.slice(l)}), s
            }, addProp: function (e, t) {
                Object.defineProperty(M.Event.prototype, e, {
                    enumerable: !0, configurable: !0, get: g(t) ? function () {
                        if (this.originalEvent) return t(this.originalEvent)
                    } : function () {
                        if (this.originalEvent) return this.originalEvent[e]
                    }, set: function (t) {
                        Object.defineProperty(this, e, {enumerable: !0, configurable: !0, writable: !0, value: t})
                    }
                })
            }, fix: function (e) {
                return e[M.expando] ? e : new M.Event(e)
            }, special: {
                load: {noBubble: !0}, click: {
                    setup: function (e) {
                        var t = this || e;
                        return me.test(t.type) && t.click && E(t, "input") && Le(t, "click", Te), !1
                    }, trigger: function (e) {
                        var t = this || e;
                        return me.test(t.type) && t.click && E(t, "input") && Le(t, "click"), !0
                    }, _default: function (e) {
                        var t = e.target;
                        return me.test(t.type) && t.click && E(t, "input") && J.get(t, "click") || E(t, "a")
                    }
                }, beforeunload: {
                    postDispatch: function (e) {
                        void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                    }
                }
            }
        }, M.removeEvent = function (e, t, n) {
            e.removeEventListener && e.removeEventListener(t, n)
        }, M.Event = function (e, t) {
            if (!(this instanceof M.Event)) return new M.Event(e, t);
            e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Te : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && M.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[M.expando] = !0
        }, M.Event.prototype = {
            constructor: M.Event,
            isDefaultPrevented: ke,
            isPropagationStopped: ke,
            isImmediatePropagationStopped: ke,
            isSimulated: !1,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = Te, e && !this.isSimulated && e.preventDefault()
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = Te, e && !this.isSimulated && e.stopPropagation()
            },
            stopImmediatePropagation: function () {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = Te, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, M.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: !0
        }, M.event.addProp), M.each({focus: "focusin", blur: "focusout"}, (function (e, t) {
            M.event.special[e] = {
                setup: function () {
                    return Le(this, e, Se), !1
                }, trigger: function () {
                    return Le(this, e), !0
                }, _default: function () {
                    return !0
                }, delegateType: t
            }
        })), M.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, (function (e, t) {
            M.event.special[e] = {
                delegateType: t, bindType: t, handle: function (e) {
                    var n, i = this, r = e.relatedTarget, o = e.handleObj;
                    return r && (r === i || M.contains(i, r)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
                }
            }
        })), M.fn.extend({
            on: function (e, t, n, i) {
                return De(this, e, t, n, i)
            }, one: function (e, t, n, i) {
                return De(this, e, t, n, i, 1)
            }, off: function (e, t, n) {
                var i, r;
                if (e && e.preventDefault && e.handleObj) return i = e.handleObj, M(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                if ("object" == typeof e) {
                    for (r in e) this.off(r, t, e[r]);
                    return this
                }
                return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each((function () {
                    M.event.remove(this, e, n, t)
                }))
            }
        });
        var Ee = /<script|<style|<link/i, Ce = /checked\s*(?:[^=]|=\s*.checked.)/i,
            Ae = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

        function Ie(e, t) {
            return E(e, "table") && E(11 !== t.nodeType ? t : t.firstChild, "tr") && M(e).children("tbody")[0] || e
        }

        function Pe(e) {
            return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
        }

        function Re(e) {
            return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
        }

        function Ye(e, t) {
            var n, i, r, o, a, s;
            if (1 === t.nodeType) {
                if (J.hasData(e) && (s = J.get(e).events)) for (r in J.remove(t, "handle events"), s) for (n = 0, i = s[r].length; n < i; n++) M.event.add(t, r, s[r][n]);
                K.hasData(e) && (o = K.access(e), a = M.extend({}, o), K.set(t, a))
            }
        }

        function ze(e, t) {
            var n = t.nodeName.toLowerCase();
            "input" === n && me.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue)
        }

        function Oe(e, t, n, i) {
            t = l(t);
            var r, o, a, s, c, u, d = 0, h = e.length, p = h - 1, f = t[0], m = g(f);
            if (m || h > 1 && "string" == typeof f && !_.checkClone && Ce.test(f)) return e.each((function (r) {
                var o = e.eq(r);
                m && (t[0] = f.call(this, r, o.html())), Oe(o, t, n, i)
            }));
            if (h && (o = (r = we(t, e[0].ownerDocument, !1, e, i)).firstChild, 1 === r.childNodes.length && (r = o), o || i)) {
                for (s = (a = M.map(ve(r, "script"), Pe)).length; d < h; d++) c = r, d !== p && (c = M.clone(c, !0, !0), s && M.merge(a, ve(c, "script"))), n.call(e[d], c, d);
                if (s) for (u = a[a.length - 1].ownerDocument, M.map(a, Re), d = 0; d < s; d++) c = a[d], ge.test(c.type || "") && !J.access(c, "globalEval") && M.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? M._evalUrl && !c.noModule && M._evalUrl(c.src, {nonce: c.nonce || c.getAttribute("nonce")}, u) : b(c.textContent.replace(Ae, ""), c, u))
            }
            return e
        }

        function Fe(e, t, n) {
            for (var i, r = t ? M.filter(t, e) : e, o = 0; null != (i = r[o]); o++) n || 1 !== i.nodeType || M.cleanData(ve(i)), i.parentNode && (n && ae(i) && xe(ve(i, "script")), i.parentNode.removeChild(i));
            return e
        }

        M.extend({
            htmlPrefilter: function (e) {
                return e
            }, clone: function (e, t, n) {
                var i, r, o, a, s = e.cloneNode(!0), l = ae(e);
                if (!(_.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || M.isXMLDoc(e))) for (a = ve(s), i = 0, r = (o = ve(e)).length; i < r; i++) ze(o[i], a[i]);
                if (t) if (n) for (o = o || ve(e), a = a || ve(s), i = 0, r = o.length; i < r; i++) Ye(o[i], a[i]); else Ye(e, s);
                return (a = ve(s, "script")).length > 0 && xe(a, !l && ve(e, "script")), s
            }, cleanData: function (e) {
                for (var t, n, i, r = M.event.special, o = 0; void 0 !== (n = e[o]); o++) if ($(n)) {
                    if (t = n[J.expando]) {
                        if (t.events) for (i in t.events) r[i] ? M.event.remove(n, i) : M.removeEvent(n, i, t.handle);
                        n[J.expando] = void 0
                    }
                    n[K.expando] && (n[K.expando] = void 0)
                }
            }
        }), M.fn.extend({
            detach: function (e) {
                return Fe(this, e, !0)
            }, remove: function (e) {
                return Fe(this, e)
            }, text: function (e) {
                return W(this, (function (e) {
                    return void 0 === e ? M.text(this) : this.empty().each((function () {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                    }))
                }), null, e, arguments.length)
            }, append: function () {
                return Oe(this, arguments, (function (e) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Ie(this, e).appendChild(e)
                }))
            }, prepend: function () {
                return Oe(this, arguments, (function (e) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var t = Ie(this, e);
                        t.insertBefore(e, t.firstChild)
                    }
                }))
            }, before: function () {
                return Oe(this, arguments, (function (e) {
                    this.parentNode && this.parentNode.insertBefore(e, this)
                }))
            }, after: function () {
                return Oe(this, arguments, (function (e) {
                    this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                }))
            }, empty: function () {
                for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (M.cleanData(ve(e, !1)), e.textContent = "");
                return this
            }, clone: function (e, t) {
                return e = null != e && e, t = null == t ? e : t, this.map((function () {
                    return M.clone(this, e, t)
                }))
            }, html: function (e) {
                return W(this, (function (e) {
                    var t = this[0] || {}, n = 0, i = this.length;
                    if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                    if ("string" == typeof e && !Ee.test(e) && !ye[(_e.exec(e) || ["", ""])[1].toLowerCase()]) {
                        e = M.htmlPrefilter(e);
                        try {
                            for (; n < i; n++) 1 === (t = this[n] || {}).nodeType && (M.cleanData(ve(t, !1)), t.innerHTML = e);
                            t = 0
                        } catch (e) {
                        }
                    }
                    t && this.empty().append(e)
                }), null, e, arguments.length)
            }, replaceWith: function () {
                var e = [];
                return Oe(this, arguments, (function (t) {
                    var n = this.parentNode;
                    M.inArray(this, e) < 0 && (M.cleanData(ve(this)), n && n.replaceChild(t, this))
                }), e)
            }
        }), M.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, (function (e, t) {
            M.fn[e] = function (e) {
                for (var n, i = [], r = M(e), o = r.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), M(r[a])[t](n), c.apply(i, n.get());
                return this.pushStack(i)
            }
        }));
        var Be = new RegExp("^(" + ne + ")(?!px)[a-z%]+$", "i"), je = function (e) {
            var t = e.ownerDocument.defaultView;
            return t && t.opener || (t = n), t.getComputedStyle(e)
        }, He = function (e, t, n) {
            var i, r, o = {};
            for (r in t) o[r] = e.style[r], e.style[r] = t[r];
            for (r in i = n.call(e), t) e.style[r] = o[r];
            return i
        }, Ne = new RegExp(re.join("|"), "i");

        function Ue(e, t, n) {
            var i, r, o, a, s = e.style;
            return (n = n || je(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ae(e) || (a = M.style(e, t)), !_.pixelBoxStyles() && Be.test(a) && Ne.test(t) && (i = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = i, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
        }

        function We(e, t) {
            return {
                get: function () {
                    if (!e()) return (this.get = t).apply(this, arguments);
                    delete this.get
                }
            }
        }

        !function () {
            function e() {
                if (u) {
                    c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", oe.appendChild(c).appendChild(u);
                    var e = n.getComputedStyle(u);
                    i = "1%" !== e.top, l = 12 === t(e.marginLeft), u.style.right = "60%", a = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", o = 12 === t(u.offsetWidth / 3), oe.removeChild(c), u = null
                }
            }

            function t(e) {
                return Math.round(parseFloat(e))
            }

            var i, r, o, a, s, l, c = v.createElement("div"), u = v.createElement("div");
            u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", _.clearCloneStyle = "content-box" === u.style.backgroundClip, M.extend(_, {
                boxSizingReliable: function () {
                    return e(), r
                }, pixelBoxStyles: function () {
                    return e(), a
                }, pixelPosition: function () {
                    return e(), i
                }, reliableMarginLeft: function () {
                    return e(), l
                }, scrollboxSize: function () {
                    return e(), o
                }, reliableTrDimensions: function () {
                    var e, t, i, r;
                    return null == s && (e = v.createElement("table"), t = v.createElement("tr"), i = v.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", i.style.height = "9px", i.style.display = "block", oe.appendChild(e).appendChild(t).appendChild(i), r = n.getComputedStyle(t), s = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, oe.removeChild(e)), s
                }
            }))
        }();
        var Ve = ["Webkit", "Moz", "ms"], Ge = v.createElement("div").style, qe = {};

        function Ze(e) {
            var t = M.cssProps[e] || qe[e];
            return t || (e in Ge ? e : qe[e] = function (e) {
                for (var t = e[0].toUpperCase() + e.slice(1), n = Ve.length; n--;) if ((e = Ve[n] + t) in Ge) return e
            }(e) || e)
        }

        var $e = /^(none|table(?!-c[ea]).+)/, Xe = /^--/,
            Je = {position: "absolute", visibility: "hidden", display: "block"},
            Ke = {letterSpacing: "0", fontWeight: "400"};

        function Qe(e, t, n) {
            var i = ie.exec(t);
            return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t
        }

        function et(e, t, n, i, r, o) {
            var a = "width" === t ? 1 : 0, s = 0, l = 0;
            if (n === (i ? "border" : "content")) return 0;
            for (; a < 4; a += 2) "margin" === n && (l += M.css(e, n + re[a], !0, r)), i ? ("content" === n && (l -= M.css(e, "padding" + re[a], !0, r)), "margin" !== n && (l -= M.css(e, "border" + re[a] + "Width", !0, r))) : (l += M.css(e, "padding" + re[a], !0, r), "padding" !== n ? l += M.css(e, "border" + re[a] + "Width", !0, r) : s += M.css(e, "border" + re[a] + "Width", !0, r));
            return !i && o >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - l - s - .5)) || 0), l
        }

        function tt(e, t, n) {
            var i = je(e), r = (!_.boxSizingReliable() || n) && "border-box" === M.css(e, "boxSizing", !1, i), o = r,
                a = Ue(e, t, i), s = "offset" + t[0].toUpperCase() + t.slice(1);
            if (Be.test(a)) {
                if (!n) return a;
                a = "auto"
            }
            return (!_.boxSizingReliable() && r || !_.reliableTrDimensions() && E(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === M.css(e, "display", !1, i)) && e.getClientRects().length && (r = "border-box" === M.css(e, "boxSizing", !1, i), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + et(e, t, n || (r ? "border" : "content"), o, i, a) + "px"
        }

        function nt(e, t, n, i, r) {
            return new nt.prototype.init(e, t, n, i, r)
        }

        M.extend({
            cssHooks: {
                opacity: {
                    get: function (e, t) {
                        if (t) {
                            var n = Ue(e, "opacity");
                            return "" === n ? "1" : n
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function (e, t, n, i) {
                if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                    var r, o, a, s = Z(t), l = Xe.test(t), c = e.style;
                    if (l || (t = Ze(s)), a = M.cssHooks[t] || M.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (r = a.get(e, !1, i)) ? r : c[t];
                    "string" === (o = typeof n) && (r = ie.exec(n)) && r[1] && (n = ce(e, t, r), o = "number"), null != n && n == n && ("number" !== o || l || (n += r && r[3] || (M.cssNumber[s] ? "" : "px")), _.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (c[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, i)) || (l ? c.setProperty(t, n) : c[t] = n))
                }
            },
            css: function (e, t, n, i) {
                var r, o, a, s = Z(t);
                return Xe.test(t) || (t = Ze(s)), (a = M.cssHooks[t] || M.cssHooks[s]) && "get" in a && (r = a.get(e, !0, n)), void 0 === r && (r = Ue(e, t, i)), "normal" === r && t in Ke && (r = Ke[t]), "" === n || n ? (o = parseFloat(r), !0 === n || isFinite(o) ? o || 0 : r) : r
            }
        }), M.each(["height", "width"], (function (e, t) {
            M.cssHooks[t] = {
                get: function (e, n, i) {
                    if (n) return !$e.test(M.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? tt(e, t, i) : He(e, Je, (function () {
                        return tt(e, t, i)
                    }))
                }, set: function (e, n, i) {
                    var r, o = je(e), a = !_.scrollboxSize() && "absolute" === o.position,
                        s = (a || i) && "border-box" === M.css(e, "boxSizing", !1, o), l = i ? et(e, t, i, s, o) : 0;
                    return s && a && (l -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - et(e, t, "border", !1, o) - .5)), l && (r = ie.exec(n)) && "px" !== (r[3] || "px") && (e.style[t] = n, n = M.css(e, t)), Qe(0, n, l)
                }
            }
        })), M.cssHooks.marginLeft = We(_.reliableMarginLeft, (function (e, t) {
            if (t) return (parseFloat(Ue(e, "marginLeft")) || e.getBoundingClientRect().left - He(e, {marginLeft: 0}, (function () {
                return e.getBoundingClientRect().left
            }))) + "px"
        })), M.each({margin: "", padding: "", border: "Width"}, (function (e, t) {
            M.cssHooks[e + t] = {
                expand: function (n) {
                    for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[e + re[i] + t] = o[i] || o[i - 2] || o[0];
                    return r
                }
            }, "margin" !== e && (M.cssHooks[e + t].set = Qe)
        })), M.fn.extend({
            css: function (e, t) {
                return W(this, (function (e, t, n) {
                    var i, r, o = {}, a = 0;
                    if (Array.isArray(t)) {
                        for (i = je(e), r = t.length; a < r; a++) o[t[a]] = M.css(e, t[a], !1, i);
                        return o
                    }
                    return void 0 !== n ? M.style(e, t, n) : M.css(e, t)
                }), e, t, arguments.length > 1)
            }
        }), M.Tween = nt, nt.prototype = {
            constructor: nt, init: function (e, t, n, i, r, o) {
                this.elem = e, this.prop = n, this.easing = r || M.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = i, this.unit = o || (M.cssNumber[n] ? "" : "px")
            }, cur: function () {
                var e = nt.propHooks[this.prop];
                return e && e.get ? e.get(this) : nt.propHooks._default.get(this)
            }, run: function (e) {
                var t, n = nt.propHooks[this.prop];
                return this.options.duration ? this.pos = t = M.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : nt.propHooks._default.set(this), this
            }
        }, nt.prototype.init.prototype = nt.prototype, nt.propHooks = {
            _default: {
                get: function (e) {
                    var t;
                    return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = M.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
                }, set: function (e) {
                    M.fx.step[e.prop] ? M.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !M.cssHooks[e.prop] && null == e.elem.style[Ze(e.prop)] ? e.elem[e.prop] = e.now : M.style(e.elem, e.prop, e.now + e.unit)
                }
            }
        }, nt.propHooks.scrollTop = nt.propHooks.scrollLeft = {
            set: function (e) {
                e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
            }
        }, M.easing = {
            linear: function (e) {
                return e
            }, swing: function (e) {
                return .5 - Math.cos(e * Math.PI) / 2
            }, _default: "swing"
        }, M.fx = nt.prototype.init, M.fx.step = {};
        var it, rt, ot = /^(?:toggle|show|hide)$/, at = /queueHooks$/;

        function st() {
            rt && (!1 === v.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(st) : n.setTimeout(st, M.fx.interval), M.fx.tick())
        }

        function lt() {
            return n.setTimeout((function () {
                it = void 0
            })), it = Date.now()
        }

        function ct(e, t) {
            var n, i = 0, r = {height: e};
            for (t = t ? 1 : 0; i < 4; i += 2 - t) r["margin" + (n = re[i])] = r["padding" + n] = e;
            return t && (r.opacity = r.width = e), r
        }

        function ut(e, t, n) {
            for (var i, r = (dt.tweeners[t] || []).concat(dt.tweeners["*"]), o = 0, a = r.length; o < a; o++) if (i = r[o].call(n, t, e)) return i
        }

        function dt(e, t, n) {
            var i, r, o = 0, a = dt.prefilters.length, s = M.Deferred().always((function () {
                delete l.elem
            })), l = function () {
                if (r) return !1;
                for (var t = it || lt(), n = Math.max(0, c.startTime + c.duration - t), i = 1 - (n / c.duration || 0), o = 0, a = c.tweens.length; o < a; o++) c.tweens[o].run(i);
                return s.notifyWith(e, [c, i, n]), i < 1 && a ? n : (a || s.notifyWith(e, [c, 1, 0]), s.resolveWith(e, [c]), !1)
            }, c = s.promise({
                elem: e,
                props: M.extend({}, t),
                opts: M.extend(!0, {specialEasing: {}, easing: M.easing._default}, n),
                originalProperties: t,
                originalOptions: n,
                startTime: it || lt(),
                duration: n.duration,
                tweens: [],
                createTween: function (t, n) {
                    var i = M.Tween(e, c.opts, t, n, c.opts.specialEasing[t] || c.opts.easing);
                    return c.tweens.push(i), i
                },
                stop: function (t) {
                    var n = 0, i = t ? c.tweens.length : 0;
                    if (r) return this;
                    for (r = !0; n < i; n++) c.tweens[n].run(1);
                    return t ? (s.notifyWith(e, [c, 1, 0]), s.resolveWith(e, [c, t])) : s.rejectWith(e, [c, t]), this
                }
            }), u = c.props;
            for (!function (e, t) {
                var n, i, r, o, a;
                for (n in e) if (r = t[i = Z(n)], o = e[n], Array.isArray(o) && (r = o[1], o = e[n] = o[0]), n !== i && (e[i] = o, delete e[n]), (a = M.cssHooks[i]) && "expand" in a) for (n in o = a.expand(o), delete e[i], o) n in e || (e[n] = o[n], t[n] = r); else t[i] = r
            }(u, c.opts.specialEasing); o < a; o++) if (i = dt.prefilters[o].call(c, e, u, c.opts)) return g(i.stop) && (M._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i;
            return M.map(u, ut, c), g(c.opts.start) && c.opts.start.call(e, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), M.fx.timer(M.extend(l, {
                elem: e,
                anim: c,
                queue: c.opts.queue
            })), c
        }

        M.Animation = M.extend(dt, {
            tweeners: {
                "*": [function (e, t) {
                    var n = this.createTween(e, t);
                    return ce(n.elem, e, ie.exec(t), n), n
                }]
            }, tweener: function (e, t) {
                g(e) ? (t = e, e = ["*"]) : e = e.match(O);
                for (var n, i = 0, r = e.length; i < r; i++) n = e[i], dt.tweeners[n] = dt.tweeners[n] || [], dt.tweeners[n].unshift(t)
            }, prefilters: [function (e, t, n) {
                var i, r, o, a, s, l, c, u, d = "width" in t || "height" in t, h = this, p = {}, f = e.style,
                    m = e.nodeType && le(e), _ = J.get(e, "fxshow");
                for (i in n.queue || (null == (a = M._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
                    a.unqueued || s()
                }), a.unqueued++, h.always((function () {
                    h.always((function () {
                        a.unqueued--, M.queue(e, "fx").length || a.empty.fire()
                    }))
                }))), t) if (r = t[i], ot.test(r)) {
                    if (delete t[i], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
                        if ("show" !== r || !_ || void 0 === _[i]) continue;
                        m = !0
                    }
                    p[i] = _ && _[i] || M.style(e, i)
                }
                if ((l = !M.isEmptyObject(t)) || !M.isEmptyObject(p)) for (i in d && 1 === e.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = _ && _.display) && (c = J.get(e, "display")), "none" === (u = M.css(e, "display")) && (c ? u = c : (he([e], !0), c = e.style.display || c, u = M.css(e, "display"), he([e]))), ("inline" === u || "inline-block" === u && null != c) && "none" === M.css(e, "float") && (l || (h.done((function () {
                    f.display = c
                })), null == c && (u = f.display, c = "none" === u ? "" : u)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", h.always((function () {
                    f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                }))), l = !1, p) l || (_ ? "hidden" in _ && (m = _.hidden) : _ = J.access(e, "fxshow", {display: c}), o && (_.hidden = !m), m && he([e], !0), h.done((function () {
                    for (i in m || he([e]), J.remove(e, "fxshow"), p) M.style(e, i, p[i])
                }))), l = ut(m ? _[i] : 0, i, h), i in _ || (_[i] = l.start, m && (l.end = l.start, l.start = 0))
            }], prefilter: function (e, t) {
                t ? dt.prefilters.unshift(e) : dt.prefilters.push(e)
            }
        }), M.speed = function (e, t, n) {
            var i = e && "object" == typeof e ? M.extend({}, e) : {
                complete: n || !n && t || g(e) && e,
                duration: e,
                easing: n && t || t && !g(t) && t
            };
            return M.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in M.fx.speeds ? i.duration = M.fx.speeds[i.duration] : i.duration = M.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function () {
                g(i.old) && i.old.call(this), i.queue && M.dequeue(this, i.queue)
            }, i
        }, M.fn.extend({
            fadeTo: function (e, t, n, i) {
                return this.filter(le).css("opacity", 0).show().end().animate({opacity: t}, e, n, i)
            }, animate: function (e, t, n, i) {
                var r = M.isEmptyObject(e), o = M.speed(t, n, i), a = function () {
                    var t = dt(this, M.extend({}, e), o);
                    (r || J.get(this, "finish")) && t.stop(!0)
                };
                return a.finish = a, r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
            }, stop: function (e, t, n) {
                var i = function (e) {
                    var t = e.stop;
                    delete e.stop, t(n)
                };
                return "string" != typeof e && (n = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each((function () {
                    var t = !0, r = null != e && e + "queueHooks", o = M.timers, a = J.get(this);
                    if (r) a[r] && a[r].stop && i(a[r]); else for (r in a) a[r] && a[r].stop && at.test(r) && i(a[r]);
                    for (r = o.length; r--;) o[r].elem !== this || null != e && o[r].queue !== e || (o[r].anim.stop(n), t = !1, o.splice(r, 1));
                    !t && n || M.dequeue(this, e)
                }))
            }, finish: function (e) {
                return !1 !== e && (e = e || "fx"), this.each((function () {
                    var t, n = J.get(this), i = n[e + "queue"], r = n[e + "queueHooks"], o = M.timers,
                        a = i ? i.length : 0;
                    for (n.finish = !0, M.queue(this, e, []), r && r.stop && r.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                    for (t = 0; t < a; t++) i[t] && i[t].finish && i[t].finish.call(this);
                    delete n.finish
                }))
            }
        }), M.each(["toggle", "show", "hide"], (function (e, t) {
            var n = M.fn[t];
            M.fn[t] = function (e, i, r) {
                return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ct(t, !0), e, i, r)
            }
        })), M.each({
            slideDown: ct("show"),
            slideUp: ct("hide"),
            slideToggle: ct("toggle"),
            fadeIn: {opacity: "show"},
            fadeOut: {opacity: "hide"},
            fadeToggle: {opacity: "toggle"}
        }, (function (e, t) {
            M.fn[e] = function (e, n, i) {
                return this.animate(t, e, n, i)
            }
        })), M.timers = [], M.fx.tick = function () {
            var e, t = 0, n = M.timers;
            for (it = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
            n.length || M.fx.stop(), it = void 0
        }, M.fx.timer = function (e) {
            M.timers.push(e), M.fx.start()
        }, M.fx.interval = 13, M.fx.start = function () {
            rt || (rt = !0, st())
        }, M.fx.stop = function () {
            rt = null
        }, M.fx.speeds = {slow: 600, fast: 200, _default: 400}, M.fn.delay = function (e, t) {
            return e = M.fx && M.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function (t, i) {
                var r = n.setTimeout(t, e);
                i.stop = function () {
                    n.clearTimeout(r)
                }
            }))
        }, function () {
            var e = v.createElement("input"), t = v.createElement("select").appendChild(v.createElement("option"));
            e.type = "checkbox", _.checkOn = "" !== e.value, _.optSelected = t.selected, (e = v.createElement("input")).value = "t", e.type = "radio", _.radioValue = "t" === e.value
        }();
        var ht, pt = M.expr.attrHandle;
        M.fn.extend({
            attr: function (e, t) {
                return W(this, M.attr, e, t, arguments.length > 1)
            }, removeAttr: function (e) {
                return this.each((function () {
                    M.removeAttr(this, e)
                }))
            }
        }), M.extend({
            attr: function (e, t, n) {
                var i, r, o = e.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? M.prop(e, t, n) : (1 === o && M.isXMLDoc(e) || (r = M.attrHooks[t.toLowerCase()] || (M.expr.match.bool.test(t) ? ht : void 0)), void 0 !== n ? null === n ? void M.removeAttr(e, t) : r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : r && "get" in r && null !== (i = r.get(e, t)) ? i : null == (i = M.find.attr(e, t)) ? void 0 : i)
            }, attrHooks: {
                type: {
                    set: function (e, t) {
                        if (!_.radioValue && "radio" === t && E(e, "input")) {
                            var n = e.value;
                            return e.setAttribute("type", t), n && (e.value = n), t
                        }
                    }
                }
            }, removeAttr: function (e, t) {
                var n, i = 0, r = t && t.match(O);
                if (r && 1 === e.nodeType) for (; n = r[i++];) e.removeAttribute(n)
            }
        }), ht = {
            set: function (e, t, n) {
                return !1 === t ? M.removeAttr(e, n) : e.setAttribute(n, n), n
            }
        }, M.each(M.expr.match.bool.source.match(/\w+/g), (function (e, t) {
            var n = pt[t] || M.find.attr;
            pt[t] = function (e, t, i) {
                var r, o, a = t.toLowerCase();
                return i || (o = pt[a], pt[a] = r, r = null != n(e, t, i) ? a : null, pt[a] = o), r
            }
        }));
        var ft = /^(?:input|select|textarea|button)$/i, mt = /^(?:a|area)$/i;

        function _t(e) {
            return (e.match(O) || []).join(" ")
        }

        function gt(e) {
            return e.getAttribute && e.getAttribute("class") || ""
        }

        function yt(e) {
            return Array.isArray(e) ? e : "string" == typeof e && e.match(O) || []
        }

        M.fn.extend({
            prop: function (e, t) {
                return W(this, M.prop, e, t, arguments.length > 1)
            }, removeProp: function (e) {
                return this.each((function () {
                    delete this[M.propFix[e] || e]
                }))
            }
        }), M.extend({
            prop: function (e, t, n) {
                var i, r, o = e.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return 1 === o && M.isXMLDoc(e) || (t = M.propFix[t] || t, r = M.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t]
            }, propHooks: {
                tabIndex: {
                    get: function (e) {
                        var t = M.find.attr(e, "tabindex");
                        return t ? parseInt(t, 10) : ft.test(e.nodeName) || mt.test(e.nodeName) && e.href ? 0 : -1
                    }
                }
            }, propFix: {for: "htmlFor", class: "className"}
        }), _.optSelected || (M.propHooks.selected = {
            get: function (e) {
                var t = e.parentNode;
                return t && t.parentNode && t.parentNode.selectedIndex, null
            }, set: function (e) {
                var t = e.parentNode;
                t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
            }
        }), M.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () {
            M.propFix[this.toLowerCase()] = this
        })), M.fn.extend({
            addClass: function (e) {
                var t, n, i, r, o, a, s, l = 0;
                if (g(e)) return this.each((function (t) {
                    M(this).addClass(e.call(this, t, gt(this)))
                }));
                if ((t = yt(e)).length) for (; n = this[l++];) if (r = gt(n), i = 1 === n.nodeType && " " + _t(r) + " ") {
                    for (a = 0; o = t[a++];) i.indexOf(" " + o + " ") < 0 && (i += o + " ");
                    r !== (s = _t(i)) && n.setAttribute("class", s)
                }
                return this
            }, removeClass: function (e) {
                var t, n, i, r, o, a, s, l = 0;
                if (g(e)) return this.each((function (t) {
                    M(this).removeClass(e.call(this, t, gt(this)))
                }));
                if (!arguments.length) return this.attr("class", "");
                if ((t = yt(e)).length) for (; n = this[l++];) if (r = gt(n), i = 1 === n.nodeType && " " + _t(r) + " ") {
                    for (a = 0; o = t[a++];) for (; i.indexOf(" " + o + " ") > -1;) i = i.replace(" " + o + " ", " ");
                    r !== (s = _t(i)) && n.setAttribute("class", s)
                }
                return this
            }, toggleClass: function (e, t) {
                var n = typeof e, i = "string" === n || Array.isArray(e);
                return "boolean" == typeof t && i ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each((function (n) {
                    M(this).toggleClass(e.call(this, n, gt(this), t), t)
                })) : this.each((function () {
                    var t, r, o, a;
                    if (i) for (r = 0, o = M(this), a = yt(e); t = a[r++];) o.hasClass(t) ? o.removeClass(t) : o.addClass(t); else void 0 !== e && "boolean" !== n || ((t = gt(this)) && J.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : J.get(this, "__className__") || ""))
                }))
            }, hasClass: function (e) {
                var t, n, i = 0;
                for (t = " " + e + " "; n = this[i++];) if (1 === n.nodeType && (" " + _t(gt(n)) + " ").indexOf(t) > -1) return !0;
                return !1
            }
        });
        var vt = /\r/g;
        M.fn.extend({
            val: function (e) {
                var t, n, i, r = this[0];
                return arguments.length ? (i = g(e), this.each((function (n) {
                    var r;
                    1 === this.nodeType && (null == (r = i ? e.call(this, n, M(this).val()) : e) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = M.map(r, (function (e) {
                        return null == e ? "" : e + ""
                    }))), (t = M.valHooks[this.type] || M.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r))
                }))) : r ? (t = M.valHooks[r.type] || M.valHooks[r.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(vt, "") : null == n ? "" : n : void 0
            }
        }), M.extend({
            valHooks: {
                option: {
                    get: function (e) {
                        var t = M.find.attr(e, "value");
                        return null != t ? t : _t(M.text(e))
                    }
                }, select: {
                    get: function (e) {
                        var t, n, i, r = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [],
                            l = a ? o + 1 : r.length;
                        for (i = o < 0 ? l : a ? o : 0; i < l; i++) if (((n = r[i]).selected || i === o) && !n.disabled && (!n.parentNode.disabled || !E(n.parentNode, "optgroup"))) {
                            if (t = M(n).val(), a) return t;
                            s.push(t)
                        }
                        return s
                    }, set: function (e, t) {
                        for (var n, i, r = e.options, o = M.makeArray(t), a = r.length; a--;) ((i = r[a]).selected = M.inArray(M.valHooks.option.get(i), o) > -1) && (n = !0);
                        return n || (e.selectedIndex = -1), o
                    }
                }
            }
        }), M.each(["radio", "checkbox"], (function () {
            M.valHooks[this] = {
                set: function (e, t) {
                    if (Array.isArray(t)) return e.checked = M.inArray(M(e).val(), t) > -1
                }
            }, _.checkOn || (M.valHooks[this].get = function (e) {
                return null === e.getAttribute("value") ? "on" : e.value
            })
        })), _.focusin = "onfocusin" in n;
        var xt = /^(?:focusinfocus|focusoutblur)$/, bt = function (e) {
            e.stopPropagation()
        };
        M.extend(M.event, {
            trigger: function (e, t, i, r) {
                var o, a, s, l, c, u, d, h, f = [i || v], m = p.call(e, "type") ? e.type : e,
                    _ = p.call(e, "namespace") ? e.namespace.split(".") : [];
                if (a = h = s = i = i || v, 3 !== i.nodeType && 8 !== i.nodeType && !xt.test(m + M.event.triggered) && (m.indexOf(".") > -1 && (_ = m.split("."), m = _.shift(), _.sort()), c = m.indexOf(":") < 0 && "on" + m, (e = e[M.expando] ? e : new M.Event(m, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = _.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + _.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : M.makeArray(t, [e]), d = M.event.special[m] || {}, r || !d.trigger || !1 !== d.trigger.apply(i, t))) {
                    if (!r && !d.noBubble && !y(i)) {
                        for (l = d.delegateType || m, xt.test(l + m) || (a = a.parentNode); a; a = a.parentNode) f.push(a), s = a;
                        s === (i.ownerDocument || v) && f.push(s.defaultView || s.parentWindow || n)
                    }
                    for (o = 0; (a = f[o++]) && !e.isPropagationStopped();) h = a, e.type = o > 1 ? l : d.bindType || m, (u = (J.get(a, "events") || Object.create(null))[e.type] && J.get(a, "handle")) && u.apply(a, t), (u = c && a[c]) && u.apply && $(a) && (e.result = u.apply(a, t), !1 === e.result && e.preventDefault());
                    return e.type = m, r || e.isDefaultPrevented() || d._default && !1 !== d._default.apply(f.pop(), t) || !$(i) || c && g(i[m]) && !y(i) && ((s = i[c]) && (i[c] = null), M.event.triggered = m, e.isPropagationStopped() && h.addEventListener(m, bt), i[m](), e.isPropagationStopped() && h.removeEventListener(m, bt), M.event.triggered = void 0, s && (i[c] = s)), e.result
                }
            }, simulate: function (e, t, n) {
                var i = M.extend(new M.Event, n, {type: e, isSimulated: !0});
                M.event.trigger(i, null, t)
            }
        }), M.fn.extend({
            trigger: function (e, t) {
                return this.each((function () {
                    M.event.trigger(e, t, this)
                }))
            }, triggerHandler: function (e, t) {
                var n = this[0];
                if (n) return M.event.trigger(e, t, n, !0)
            }
        }), _.focusin || M.each({focus: "focusin", blur: "focusout"}, (function (e, t) {
            var n = function (e) {
                M.event.simulate(t, e.target, M.event.fix(e))
            };
            M.event.special[t] = {
                setup: function () {
                    var i = this.ownerDocument || this.document || this, r = J.access(i, t);
                    r || i.addEventListener(e, n, !0), J.access(i, t, (r || 0) + 1)
                }, teardown: function () {
                    var i = this.ownerDocument || this.document || this, r = J.access(i, t) - 1;
                    r ? J.access(i, t, r) : (i.removeEventListener(e, n, !0), J.remove(i, t))
                }
            }
        }));
        var wt = n.location, Mt = {guid: Date.now()}, Tt = /\?/;
        M.parseXML = function (e) {
            var t, i;
            if (!e || "string" != typeof e) return null;
            try {
                t = (new n.DOMParser).parseFromString(e, "text/xml")
            } catch (e) {
            }
            return i = t && t.getElementsByTagName("parsererror")[0], t && !i || M.error("Invalid XML: " + (i ? M.map(i.childNodes, (function (e) {
                return e.textContent
            })).join("\n") : e)), t
        };
        var kt = /\[\]$/, St = /\r?\n/g, Dt = /^(?:submit|button|image|reset|file)$/i,
            Lt = /^(?:input|select|textarea|keygen)/i;

        function Et(e, t, n, i) {
            var r;
            if (Array.isArray(t)) M.each(t, (function (t, r) {
                n || kt.test(e) ? i(e, r) : Et(e + "[" + ("object" == typeof r && null != r ? t : "") + "]", r, n, i)
            })); else if (n || "object" !== w(t)) i(e, t); else for (r in t) Et(e + "[" + r + "]", t[r], n, i)
        }

        M.param = function (e, t) {
            var n, i = [], r = function (e, t) {
                var n = g(t) ? t() : t;
                i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
            };
            if (null == e) return "";
            if (Array.isArray(e) || e.jquery && !M.isPlainObject(e)) M.each(e, (function () {
                r(this.name, this.value)
            })); else for (n in e) Et(n, e[n], t, r);
            return i.join("&")
        }, M.fn.extend({
            serialize: function () {
                return M.param(this.serializeArray())
            }, serializeArray: function () {
                return this.map((function () {
                    var e = M.prop(this, "elements");
                    return e ? M.makeArray(e) : this
                })).filter((function () {
                    var e = this.type;
                    return this.name && !M(this).is(":disabled") && Lt.test(this.nodeName) && !Dt.test(e) && (this.checked || !me.test(e))
                })).map((function (e, t) {
                    var n = M(this).val();
                    return null == n ? null : Array.isArray(n) ? M.map(n, (function (e) {
                        return {name: t.name, value: e.replace(St, "\r\n")}
                    })) : {name: t.name, value: n.replace(St, "\r\n")}
                })).get()
            }
        });
        var Ct = /%20/g, At = /#.*$/, It = /([?&])_=[^&]*/, Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Rt = /^(?:GET|HEAD)$/,
            Yt = /^\/\//, zt = {}, Ot = {}, Ft = "*/".concat("*"), Bt = v.createElement("a");

        function jt(e) {
            return function (t, n) {
                "string" != typeof t && (n = t, t = "*");
                var i, r = 0, o = t.toLowerCase().match(O) || [];
                if (g(n)) for (; i = o[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(n)) : (e[i] = e[i] || []).push(n)
            }
        }

        function Ht(e, t, n, i) {
            var r = {}, o = e === Ot;

            function a(s) {
                var l;
                return r[s] = !0, M.each(e[s] || [], (function (e, s) {
                    var c = s(t, n, i);
                    return "string" != typeof c || o || r[c] ? o ? !(l = c) : void 0 : (t.dataTypes.unshift(c), a(c), !1)
                })), l
            }

            return a(t.dataTypes[0]) || !r["*"] && a("*")
        }

        function Nt(e, t) {
            var n, i, r = M.ajaxSettings.flatOptions || {};
            for (n in t) void 0 !== t[n] && ((r[n] ? e : i || (i = {}))[n] = t[n]);
            return i && M.extend(!0, e, i), e
        }

        Bt.href = wt.href, M.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: wt.href,
                type: "GET",
                isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(wt.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": Ft,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
                responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
                converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": M.parseXML},
                flatOptions: {url: !0, context: !0}
            },
            ajaxSetup: function (e, t) {
                return t ? Nt(Nt(e, M.ajaxSettings), t) : Nt(M.ajaxSettings, e)
            },
            ajaxPrefilter: jt(zt),
            ajaxTransport: jt(Ot),
            ajax: function (e, t) {
                "object" == typeof e && (t = e, e = void 0), t = t || {};
                var i, r, o, a, s, l, c, u, d, h, p = M.ajaxSetup({}, t), f = p.context || p,
                    m = p.context && (f.nodeType || f.jquery) ? M(f) : M.event, _ = M.Deferred(),
                    g = M.Callbacks("once memory"), y = p.statusCode || {}, x = {}, b = {}, w = "canceled", T = {
                        readyState: 0, getResponseHeader: function (e) {
                            var t;
                            if (c) {
                                if (!a) for (a = {}; t = Pt.exec(o);) a[t[1].toLowerCase() + " "] = (a[t[1].toLowerCase() + " "] || []).concat(t[2]);
                                t = a[e.toLowerCase() + " "]
                            }
                            return null == t ? null : t.join(", ")
                        }, getAllResponseHeaders: function () {
                            return c ? o : null
                        }, setRequestHeader: function (e, t) {
                            return null == c && (e = b[e.toLowerCase()] = b[e.toLowerCase()] || e, x[e] = t), this
                        }, overrideMimeType: function (e) {
                            return null == c && (p.mimeType = e), this
                        }, statusCode: function (e) {
                            var t;
                            if (e) if (c) T.always(e[T.status]); else for (t in e) y[t] = [y[t], e[t]];
                            return this
                        }, abort: function (e) {
                            var t = e || w;
                            return i && i.abort(t), k(0, t), this
                        }
                    };
                if (_.promise(T), p.url = ((e || p.url || wt.href) + "").replace(Yt, wt.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(O) || [""], null == p.crossDomain) {
                    l = v.createElement("a");
                    try {
                        l.href = p.url, l.href = l.href, p.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host
                    } catch (e) {
                        p.crossDomain = !0
                    }
                }
                if (p.data && p.processData && "string" != typeof p.data && (p.data = M.param(p.data, p.traditional)), Ht(zt, p, t, T), c) return T;
                for (d in (u = M.event && p.global) && 0 == M.active++ && M.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Rt.test(p.type), r = p.url.replace(At, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Ct, "+")) : (h = p.url.slice(r.length), p.data && (p.processData || "string" == typeof p.data) && (r += (Tt.test(r) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (r = r.replace(It, "$1"), h = (Tt.test(r) ? "&" : "?") + "_=" + Mt.guid++ + h), p.url = r + h), p.ifModified && (M.lastModified[r] && T.setRequestHeader("If-Modified-Since", M.lastModified[r]), M.etag[r] && T.setRequestHeader("If-None-Match", M.etag[r])), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && T.setRequestHeader("Content-Type", p.contentType), T.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Ft + "; q=0.01" : "") : p.accepts["*"]), p.headers) T.setRequestHeader(d, p.headers[d]);
                if (p.beforeSend && (!1 === p.beforeSend.call(f, T, p) || c)) return T.abort();
                if (w = "abort", g.add(p.complete), T.done(p.success), T.fail(p.error), i = Ht(Ot, p, t, T)) {
                    if (T.readyState = 1, u && m.trigger("ajaxSend", [T, p]), c) return T;
                    p.async && p.timeout > 0 && (s = n.setTimeout((function () {
                        T.abort("timeout")
                    }), p.timeout));
                    try {
                        c = !1, i.send(x, k)
                    } catch (e) {
                        if (c) throw e;
                        k(-1, e)
                    }
                } else k(-1, "No Transport");

                function k(e, t, a, l) {
                    var d, h, v, x, b, w = t;
                    c || (c = !0, s && n.clearTimeout(s), i = void 0, o = l || "", T.readyState = e > 0 ? 4 : 0, d = e >= 200 && e < 300 || 304 === e, a && (x = function (e, t, n) {
                        for (var i, r, o, a, s = e.contents, l = e.dataTypes; "*" === l[0];) l.shift(), void 0 === i && (i = e.mimeType || t.getResponseHeader("Content-Type"));
                        if (i) for (r in s) if (s[r] && s[r].test(i)) {
                            l.unshift(r);
                            break
                        }
                        if (l[0] in n) o = l[0]; else {
                            for (r in n) {
                                if (!l[0] || e.converters[r + " " + l[0]]) {
                                    o = r;
                                    break
                                }
                                a || (a = r)
                            }
                            o = o || a
                        }
                        if (o) return o !== l[0] && l.unshift(o), n[o]
                    }(p, T, a)), !d && M.inArray("script", p.dataTypes) > -1 && M.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () {
                    }), x = function (e, t, n, i) {
                        var r, o, a, s, l, c = {}, u = e.dataTypes.slice();
                        if (u[1]) for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
                        for (o = u.shift(); o;) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && i && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = u.shift()) if ("*" === o) o = l; else if ("*" !== l && l !== o) {
                            if (!(a = c[l + " " + o] || c["* " + o])) for (r in c) if ((s = r.split(" "))[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                                !0 === a ? a = c[r] : !0 !== c[r] && (o = s[0], u.unshift(s[1]));
                                break
                            }
                            if (!0 !== a) if (a && e.throws) t = a(t); else try {
                                t = a(t)
                            } catch (e) {
                                return {state: "parsererror", error: a ? e : "No conversion from " + l + " to " + o}
                            }
                        }
                        return {state: "success", data: t}
                    }(p, x, T, d), d ? (p.ifModified && ((b = T.getResponseHeader("Last-Modified")) && (M.lastModified[r] = b), (b = T.getResponseHeader("etag")) && (M.etag[r] = b)), 204 === e || "HEAD" === p.type ? w = "nocontent" : 304 === e ? w = "notmodified" : (w = x.state, h = x.data, d = !(v = x.error))) : (v = w, !e && w || (w = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || w) + "", d ? _.resolveWith(f, [h, w, T]) : _.rejectWith(f, [T, w, v]), T.statusCode(y), y = void 0, u && m.trigger(d ? "ajaxSuccess" : "ajaxError", [T, p, d ? h : v]), g.fireWith(f, [T, w]), u && (m.trigger("ajaxComplete", [T, p]), --M.active || M.event.trigger("ajaxStop")))
                }

                return T
            },
            getJSON: function (e, t, n) {
                return M.get(e, t, n, "json")
            },
            getScript: function (e, t) {
                return M.get(e, void 0, t, "script")
            }
        }), M.each(["get", "post"], (function (e, t) {
            M[t] = function (e, n, i, r) {
                return g(n) && (r = r || i, i = n, n = void 0), M.ajax(M.extend({
                    url: e,
                    type: t,
                    dataType: r,
                    data: n,
                    success: i
                }, M.isPlainObject(e) && e))
            }
        })), M.ajaxPrefilter((function (e) {
            var t;
            for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
        })), M._evalUrl = function (e, t, n) {
            return M.ajax({
                url: e,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function () {
                    }
                },
                dataFilter: function (e) {
                    M.globalEval(e, t, n)
                }
            })
        }, M.fn.extend({
            wrapAll: function (e) {
                var t;
                return this[0] && (g(e) && (e = e.call(this[0])), t = M(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () {
                    for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                    return e
                })).append(this)), this
            }, wrapInner: function (e) {
                return g(e) ? this.each((function (t) {
                    M(this).wrapInner(e.call(this, t))
                })) : this.each((function () {
                    var t = M(this), n = t.contents();
                    n.length ? n.wrapAll(e) : t.append(e)
                }))
            }, wrap: function (e) {
                var t = g(e);
                return this.each((function (n) {
                    M(this).wrapAll(t ? e.call(this, n) : e)
                }))
            }, unwrap: function (e) {
                return this.parent(e).not("body").each((function () {
                    M(this).replaceWith(this.childNodes)
                })), this
            }
        }), M.expr.pseudos.hidden = function (e) {
            return !M.expr.pseudos.visible(e)
        }, M.expr.pseudos.visible = function (e) {
            return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
        }, M.ajaxSettings.xhr = function () {
            try {
                return new n.XMLHttpRequest
            } catch (e) {
            }
        };
        var Ut = {0: 200, 1223: 204}, Wt = M.ajaxSettings.xhr();
        _.cors = !!Wt && "withCredentials" in Wt, _.ajax = Wt = !!Wt, M.ajaxTransport((function (e) {
            var t, i;
            if (_.cors || Wt && !e.crossDomain) return {
                send: function (r, o) {
                    var a, s = e.xhr();
                    if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (a in e.xhrFields) s[a] = e.xhrFields[a];
                    for (a in e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) s.setRequestHeader(a, r[a]);
                    t = function (e) {
                        return function () {
                            t && (t = i = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Ut[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {binary: s.response} : {text: s.responseText}, s.getAllResponseHeaders()))
                        }
                    }, s.onload = t(), i = s.onerror = s.ontimeout = t("error"), void 0 !== s.onabort ? s.onabort = i : s.onreadystatechange = function () {
                        4 === s.readyState && n.setTimeout((function () {
                            t && i()
                        }))
                    }, t = t("abort");
                    try {
                        s.send(e.hasContent && e.data || null)
                    } catch (e) {
                        if (t) throw e
                    }
                }, abort: function () {
                    t && t()
                }
            }
        })), M.ajaxPrefilter((function (e) {
            e.crossDomain && (e.contents.script = !1)
        })), M.ajaxSetup({
            accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
            contents: {script: /\b(?:java|ecma)script\b/},
            converters: {
                "text script": function (e) {
                    return M.globalEval(e), e
                }
            }
        }), M.ajaxPrefilter("script", (function (e) {
            void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
        })), M.ajaxTransport("script", (function (e) {
            var t, n;
            if (e.crossDomain || e.scriptAttrs) return {
                send: function (i, r) {
                    t = M("<script>").attr(e.scriptAttrs || {}).prop({
                        charset: e.scriptCharset,
                        src: e.url
                    }).on("load error", n = function (e) {
                        t.remove(), n = null, e && r("error" === e.type ? 404 : 200, e.type)
                    }), v.head.appendChild(t[0])
                }, abort: function () {
                    n && n()
                }
            }
        }));
        var Vt, Gt = [], qt = /(=)\?(?=&|$)|\?\?/;
        M.ajaxSetup({
            jsonp: "callback", jsonpCallback: function () {
                var e = Gt.pop() || M.expando + "_" + Mt.guid++;
                return this[e] = !0, e
            }
        }), M.ajaxPrefilter("json jsonp", (function (e, t, i) {
            var r, o, a,
                s = !1 !== e.jsonp && (qt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && qt.test(e.data) && "data");
            if (s || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = g(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(qt, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
                return a || M.error(r + " was not called"), a[0]
            }, e.dataTypes[0] = "json", o = n[r], n[r] = function () {
                a = arguments
            }, i.always((function () {
                void 0 === o ? M(n).removeProp(r) : n[r] = o, e[r] && (e.jsonpCallback = t.jsonpCallback, Gt.push(r)), a && g(o) && o(a[0]), a = o = void 0
            })), "script"
        })), _.createHTMLDocument = ((Vt = v.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Vt.childNodes.length), M.parseHTML = function (e, t, n) {
            return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (_.createHTMLDocument ? ((i = (t = v.implementation.createHTMLDocument("")).createElement("base")).href = v.location.href, t.head.appendChild(i)) : t = v), o = !n && [], (r = C.exec(e)) ? [t.createElement(r[1])] : (r = we([e], t, o), o && o.length && M(o).remove(), M.merge([], r.childNodes)));
            var i, r, o
        }, M.fn.load = function (e, t, n) {
            var i, r, o, a = this, s = e.indexOf(" ");
            return s > -1 && (i = _t(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && "object" == typeof t && (r = "POST"), a.length > 0 && M.ajax({
                url: e,
                type: r || "GET",
                dataType: "html",
                data: t
            }).done((function (e) {
                o = arguments, a.html(i ? M("<div>").append(M.parseHTML(e)).find(i) : e)
            })).always(n && function (e, t) {
                a.each((function () {
                    n.apply(this, o || [e.responseText, t, e])
                }))
            }), this
        }, M.expr.pseudos.animated = function (e) {
            return M.grep(M.timers, (function (t) {
                return e === t.elem
            })).length
        }, M.offset = {
            setOffset: function (e, t, n) {
                var i, r, o, a, s, l, c = M.css(e, "position"), u = M(e), d = {};
                "static" === c && (e.style.position = "relative"), s = u.offset(), o = M.css(e, "top"), l = M.css(e, "left"), ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1 ? (a = (i = u.position()).top, r = i.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), g(t) && (t = t.call(e, n, M.extend({}, s))), null != t.top && (d.top = t.top - s.top + a), null != t.left && (d.left = t.left - s.left + r), "using" in t ? t.using.call(e, d) : u.css(d)
            }
        }, M.fn.extend({
            offset: function (e) {
                if (arguments.length) return void 0 === e ? this : this.each((function (t) {
                    M.offset.setOffset(this, e, t)
                }));
                var t, n, i = this[0];
                return i ? i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
                    top: t.top + n.pageYOffset,
                    left: t.left + n.pageXOffset
                }) : {top: 0, left: 0} : void 0
            }, position: function () {
                if (this[0]) {
                    var e, t, n, i = this[0], r = {top: 0, left: 0};
                    if ("fixed" === M.css(i, "position")) t = i.getBoundingClientRect(); else {
                        for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === M.css(e, "position");) e = e.parentNode;
                        e && e !== i && 1 === e.nodeType && ((r = M(e).offset()).top += M.css(e, "borderTopWidth", !0), r.left += M.css(e, "borderLeftWidth", !0))
                    }
                    return {
                        top: t.top - r.top - M.css(i, "marginTop", !0),
                        left: t.left - r.left - M.css(i, "marginLeft", !0)
                    }
                }
            }, offsetParent: function () {
                return this.map((function () {
                    for (var e = this.offsetParent; e && "static" === M.css(e, "position");) e = e.offsetParent;
                    return e || oe
                }))
            }
        }), M.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, (function (e, t) {
            var n = "pageYOffset" === t;
            M.fn[e] = function (i) {
                return W(this, (function (e, i, r) {
                    var o;
                    if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === r) return o ? o[t] : e[i];
                    o ? o.scrollTo(n ? o.pageXOffset : r, n ? r : o.pageYOffset) : e[i] = r
                }), e, i, arguments.length)
            }
        })), M.each(["top", "left"], (function (e, t) {
            M.cssHooks[t] = We(_.pixelPosition, (function (e, n) {
                if (n) return n = Ue(e, t), Be.test(n) ? M(e).position()[t] + "px" : n
            }))
        })), M.each({Height: "height", Width: "width"}, (function (e, t) {
            M.each({padding: "inner" + e, content: t, "": "outer" + e}, (function (n, i) {
                M.fn[i] = function (r, o) {
                    var a = arguments.length && (n || "boolean" != typeof r),
                        s = n || (!0 === r || !0 === o ? "margin" : "border");
                    return W(this, (function (t, n, r) {
                        var o;
                        return y(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === r ? M.css(t, n, s) : M.style(t, n, r, s)
                    }), t, a ? r : void 0, a)
                }
            }))
        })), M.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (e, t) {
            M.fn[t] = function (e) {
                return this.on(t, e)
            }
        })), M.fn.extend({
            bind: function (e, t, n) {
                return this.on(e, null, t, n)
            }, unbind: function (e, t) {
                return this.off(e, null, t)
            }, delegate: function (e, t, n, i) {
                return this.on(t, e, n, i)
            }, undelegate: function (e, t, n) {
                return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
            }, hover: function (e, t) {
                return this.mouseenter(e).mouseleave(t || e)
            }
        }), M.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) {
            M.fn[t] = function (e, n) {
                return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
            }
        }));
        var Zt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        M.proxy = function (e, t) {
            var n, i, r;
            if ("string" == typeof t && (n = e[t], t = e, e = n), g(e)) return i = s.call(arguments, 2), (r = function () {
                return e.apply(t || this, i.concat(s.call(arguments)))
            }).guid = e.guid = e.guid || M.guid++, r
        }, M.holdReady = function (e) {
            e ? M.readyWait++ : M.ready(!0)
        }, M.isArray = Array.isArray, M.parseJSON = JSON.parse, M.nodeName = E, M.isFunction = g, M.isWindow = y, M.camelCase = Z, M.type = w, M.now = Date.now, M.isNumeric = function (e) {
            var t = M.type(e);
            return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
        }, M.trim = function (e) {
            return null == e ? "" : (e + "").replace(Zt, "")
        }, void 0 === (i = function () {
            return M
        }.apply(t, [])) || (e.exports = i);
        var $t = n.jQuery, Xt = n.$;
        return M.noConflict = function (e) {
            return n.$ === M && (n.$ = Xt), e && n.jQuery === M && (n.jQuery = $t), M
        }, void 0 === r && (n.jQuery = n.$ = M), M
    }))
}, function (e, t, n) {
    var i, r;
    n(146), i = [n(1)], void 0 === (r = function (e) {
        return function () {
            var t, n, i, r = 0, o = "error", a = "info", s = "success", l = "warning", c = {
                clear: function (n, i) {
                    var r = f();
                    t || u(r), d(n, r, i) || function (n) {
                        for (var i = t.children(), r = i.length - 1; r >= 0; r--) d(e(i[r]), n)
                    }(r)
                }, remove: function (n) {
                    var i = f();
                    t || u(i), n && 0 === e(":focus", n).length ? m(n) : t.children().length && t.remove()
                }, error: function (e, t, n) {
                    return p({type: o, iconClass: f().iconClasses.error, message: e, optionsOverride: n, title: t})
                }, getContainer: u, info: function (e, t, n) {
                    return p({type: a, iconClass: f().iconClasses.info, message: e, optionsOverride: n, title: t})
                }, options: {}, subscribe: function (e) {
                    n = e
                }, success: function (e, t, n) {
                    return p({type: s, iconClass: f().iconClasses.success, message: e, optionsOverride: n, title: t})
                }, version: "2.1.4", warning: function (e, t, n) {
                    return p({type: l, iconClass: f().iconClasses.warning, message: e, optionsOverride: n, title: t})
                }
            };
            return c;

            function u(n, i) {
                return n || (n = f()), (t = e("#" + n.containerId)).length || i && (t = function (n) {
                    return (t = e("<div/>").attr("id", n.containerId).addClass(n.positionClass)).appendTo(e(n.target)), t
                }(n)), t
            }

            function d(t, n, i) {
                var r = !(!i || !i.force) && i.force;
                return !(!t || !r && 0 !== e(":focus", t).length || (t[n.hideMethod]({
                    duration: n.hideDuration,
                    easing: n.hideEasing,
                    complete: function () {
                        m(t)
                    }
                }), 0))
            }

            function h(e) {
                n && n(e)
            }

            function p(n) {
                var o = f(), a = n.iconClass || o.iconClass;
                if (void 0 !== n.optionsOverride && (o = e.extend(o, n.optionsOverride), a = n.optionsOverride.iconClass || a), !function (e, t) {
                    if (e.preventDuplicates) {
                        if (t.message === i) return !0;
                        i = t.message
                    }
                    return !1
                }(o, n)) {
                    r++, t = u(o, !0);
                    var s = null, l = e("<div/>"), c = e("<div/>"), d = e("<div/>"), p = e("<div/>"),
                        _ = e(o.closeHtml), g = {intervalId: null, hideEta: null, maxHideTime: null},
                        y = {toastId: r, state: "visible", startTime: new Date, options: o, map: n};
                    return n.iconClass && l.addClass(o.toastClass).addClass(a), function () {
                        if (n.title) {
                            var e = n.title;
                            o.escapeHtml && (e = v(n.title)), c.append(e).addClass(o.titleClass), l.append(c)
                        }
                    }(), function () {
                        if (n.message) {
                            var e = n.message;
                            o.escapeHtml && (e = v(n.message)), d.append(e).addClass(o.messageClass), l.append(d)
                        }
                    }(), o.closeButton && (_.addClass(o.closeClass).attr("role", "button"), l.prepend(_)), o.progressBar && (p.addClass(o.progressClass), l.prepend(p)), o.rtl && l.addClass("rtl"), o.newestOnTop ? t.prepend(l) : t.append(l), function () {
                        var e = "";
                        switch (n.iconClass) {
                            case"toast-success":
                            case"toast-info":
                                e = "polite";
                                break;
                            default:
                                e = "assertive"
                        }
                        l.attr("aria-live", e)
                    }(), l.hide(), l[o.showMethod]({
                        duration: o.showDuration,
                        easing: o.showEasing,
                        complete: o.onShown
                    }), o.timeOut > 0 && (s = setTimeout(x, o.timeOut), g.maxHideTime = parseFloat(o.timeOut), g.hideEta = (new Date).getTime() + g.maxHideTime, o.progressBar && (g.intervalId = setInterval(M, 10))), o.closeOnHover && l.hover(w, b), !o.onclick && o.tapToDismiss && l.click(x), o.closeButton && _ && _.click((function (e) {
                        e.stopPropagation ? e.stopPropagation() : void 0 !== e.cancelBubble && !0 !== e.cancelBubble && (e.cancelBubble = !0), o.onCloseClick && o.onCloseClick(e), x(!0)
                    })), o.onclick && l.click((function (e) {
                        o.onclick(e), x()
                    })), h(y), o.debug && console && console.log(y), l
                }

                function v(e) {
                    return null == e && (e = ""), e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }

                function x(t) {
                    var n = t && !1 !== o.closeMethod ? o.closeMethod : o.hideMethod,
                        i = t && !1 !== o.closeDuration ? o.closeDuration : o.hideDuration,
                        r = t && !1 !== o.closeEasing ? o.closeEasing : o.hideEasing;
                    if (!e(":focus", l).length || t) return clearTimeout(g.intervalId), l[n]({
                        duration: i,
                        easing: r,
                        complete: function () {
                            m(l), clearTimeout(s), o.onHidden && "hidden" !== y.state && o.onHidden(), y.state = "hidden", y.endTime = new Date, h(y)
                        }
                    })
                }

                function b() {
                    (o.timeOut > 0 || o.extendedTimeOut > 0) && (s = setTimeout(x, o.extendedTimeOut), g.maxHideTime = parseFloat(o.extendedTimeOut), g.hideEta = (new Date).getTime() + g.maxHideTime)
                }

                function w() {
                    clearTimeout(s), g.hideEta = 0, l.stop(!0, !0)[o.showMethod]({
                        duration: o.showDuration,
                        easing: o.showEasing
                    })
                }

                function M() {
                    var e = (g.hideEta - (new Date).getTime()) / g.maxHideTime * 100;
                    p.width(e + "%")
                }
            }

            function f() {
                return e.extend({}, {
                    tapToDismiss: !0,
                    toastClass: "toast",
                    containerId: "toast-container",
                    debug: !1,
                    showMethod: "fadeIn",
                    showDuration: 300,
                    showEasing: "swing",
                    onShown: void 0,
                    hideMethod: "fadeOut",
                    hideDuration: 1e3,
                    hideEasing: "swing",
                    onHidden: void 0,
                    closeMethod: !1,
                    closeDuration: !1,
                    closeEasing: !1,
                    closeOnHover: !0,
                    extendedTimeOut: 1e3,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    iconClass: "toast-info",
                    positionClass: "toast-top-right",
                    timeOut: 5e3,
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    escapeHtml: !1,
                    target: "body",
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: "toast-close-button",
                    newestOnTop: !0,
                    preventDuplicates: !1,
                    progressBar: !1,
                    progressClass: "toast-progress",
                    rtl: !1
                }, c.options)
            }

            function m(e) {
                t || (t = u()), e.is(":visible") || (e.remove(), e = null, 0 === t.children().length && (t.remove(), i = void 0))
            }
        }()
    }.apply(t, i)) || (e.exports = r)
}, function (e, t, n) {
    /*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
    e.exports = function (e) {
        "use strict";
        e = e && e.hasOwnProperty("default") ? e.default : e;
        var t = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }, n = function (e, t) {
            return e(t = {exports: {}}, t.exports), t.exports
        }((function (e) {
            var n = {};
            for (var i in t) t.hasOwnProperty(i) && (n[t[i]] = i);
            var r = e.exports = {
                rgb: {channels: 3, labels: "rgb"},
                hsl: {channels: 3, labels: "hsl"},
                hsv: {channels: 3, labels: "hsv"},
                hwb: {channels: 3, labels: "hwb"},
                cmyk: {channels: 4, labels: "cmyk"},
                xyz: {channels: 3, labels: "xyz"},
                lab: {channels: 3, labels: "lab"},
                lch: {channels: 3, labels: "lch"},
                hex: {channels: 1, labels: ["hex"]},
                keyword: {channels: 1, labels: ["keyword"]},
                ansi16: {channels: 1, labels: ["ansi16"]},
                ansi256: {channels: 1, labels: ["ansi256"]},
                hcg: {channels: 3, labels: ["h", "c", "g"]},
                apple: {channels: 3, labels: ["r16", "g16", "b16"]},
                gray: {channels: 1, labels: ["gray"]}
            };
            for (var o in r) if (r.hasOwnProperty(o)) {
                if (!("channels" in r[o])) throw new Error("missing channels property: " + o);
                if (!("labels" in r[o])) throw new Error("missing channel labels property: " + o);
                if (r[o].labels.length !== r[o].channels) throw new Error("channel and label counts mismatch: " + o);
                var a = r[o].channels, s = r[o].labels;
                delete r[o].channels, delete r[o].labels, Object.defineProperty(r[o], "channels", {value: a}), Object.defineProperty(r[o], "labels", {value: s})
            }
            r.rgb.hsl = function (e) {
                var t, n, i = e[0] / 255, r = e[1] / 255, o = e[2] / 255, a = Math.min(i, r, o), s = Math.max(i, r, o),
                    l = s - a;
                return s === a ? t = 0 : i === s ? t = (r - o) / l : r === s ? t = 2 + (o - i) / l : o === s && (t = 4 + (i - r) / l), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (a + s) / 2, [t, 100 * (s === a ? 0 : n <= .5 ? l / (s + a) : l / (2 - s - a)), 100 * n]
            }, r.rgb.hsv = function (e) {
                var t, n, i, r, o, a = e[0] / 255, s = e[1] / 255, l = e[2] / 255, c = Math.max(a, s, l),
                    u = c - Math.min(a, s, l), d = function (e) {
                        return (c - e) / 6 / u + .5
                    };
                return 0 === u ? r = o = 0 : (o = u / c, t = d(a), n = d(s), i = d(l), a === c ? r = i - n : s === c ? r = 1 / 3 + t - i : l === c && (r = 2 / 3 + n - t), r < 0 ? r += 1 : r > 1 && (r -= 1)), [360 * r, 100 * o, 100 * c]
            }, r.rgb.hwb = function (e) {
                var t = e[0], n = e[1], i = e[2];
                return [r.rgb.hsl(e)[0], 1 / 255 * Math.min(t, Math.min(n, i)) * 100, 100 * (i = 1 - 1 / 255 * Math.max(t, Math.max(n, i)))]
            }, r.rgb.cmyk = function (e) {
                var t, n = e[0] / 255, i = e[1] / 255, r = e[2] / 255;
                return [100 * ((1 - n - (t = Math.min(1 - n, 1 - i, 1 - r))) / (1 - t) || 0), 100 * ((1 - i - t) / (1 - t) || 0), 100 * ((1 - r - t) / (1 - t) || 0), 100 * t]
            }, r.rgb.keyword = function (e) {
                var i = n[e];
                if (i) return i;
                var r, o, a, s = 1 / 0;
                for (var l in t) if (t.hasOwnProperty(l)) {
                    var c = t[l],
                        u = (o = e, a = c, Math.pow(o[0] - a[0], 2) + Math.pow(o[1] - a[1], 2) + Math.pow(o[2] - a[2], 2));
                    u < s && (s = u, r = l)
                }
                return r
            }, r.keyword.rgb = function (e) {
                return t[e]
            }, r.rgb.xyz = function (e) {
                var t = e[0] / 255, n = e[1] / 255, i = e[2] / 255;
                return [100 * (.4124 * (t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92) + .3576 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92)), 100 * (.2126 * t + .7152 * n + .0722 * i), 100 * (.0193 * t + .1192 * n + .9505 * i)]
            }, r.rgb.lab = function (e) {
                var t = r.rgb.xyz(e), n = t[0], i = t[1], o = t[2];
                return i /= 100, o /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (n - i), 200 * (i - (o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116))]
            }, r.hsl.rgb = function (e) {
                var t, n, i, r, o, a = e[0] / 360, s = e[1] / 100, l = e[2] / 100;
                if (0 === s) return [o = 255 * l, o, o];
                t = 2 * l - (n = l < .5 ? l * (1 + s) : l + s - l * s), r = [0, 0, 0];
                for (var c = 0; c < 3; c++) (i = a + 1 / 3 * -(c - 1)) < 0 && i++, i > 1 && i--, o = 6 * i < 1 ? t + 6 * (n - t) * i : 2 * i < 1 ? n : 3 * i < 2 ? t + (n - t) * (2 / 3 - i) * 6 : t, r[c] = 255 * o;
                return r
            }, r.hsl.hsv = function (e) {
                var t = e[0], n = e[1] / 100, i = e[2] / 100, r = n, o = Math.max(i, .01);
                return n *= (i *= 2) <= 1 ? i : 2 - i, r *= o <= 1 ? o : 2 - o, [t, 100 * (0 === i ? 2 * r / (o + r) : 2 * n / (i + n)), (i + n) / 2 * 100]
            }, r.hsv.rgb = function (e) {
                var t = e[0] / 60, n = e[1] / 100, i = e[2] / 100, r = Math.floor(t) % 6, o = t - Math.floor(t),
                    a = 255 * i * (1 - n), s = 255 * i * (1 - n * o), l = 255 * i * (1 - n * (1 - o));
                switch (i *= 255, r) {
                    case 0:
                        return [i, l, a];
                    case 1:
                        return [s, i, a];
                    case 2:
                        return [a, i, l];
                    case 3:
                        return [a, s, i];
                    case 4:
                        return [l, a, i];
                    case 5:
                        return [i, a, s]
                }
            }, r.hsv.hsl = function (e) {
                var t, n, i, r = e[0], o = e[1] / 100, a = e[2] / 100, s = Math.max(a, .01);
                return i = (2 - o) * a, n = o * s, [r, 100 * (n = (n /= (t = (2 - o) * s) <= 1 ? t : 2 - t) || 0), 100 * (i /= 2)]
            }, r.hwb.rgb = function (e) {
                var t, n, i, r, o, a, s, l = e[0] / 360, c = e[1] / 100, u = e[2] / 100, d = c + u;
                switch (d > 1 && (c /= d, u /= d), i = 6 * l - (t = Math.floor(6 * l)), 0 != (1 & t) && (i = 1 - i), r = c + i * ((n = 1 - u) - c), t) {
                    default:
                    case 6:
                    case 0:
                        o = n, a = r, s = c;
                        break;
                    case 1:
                        o = r, a = n, s = c;
                        break;
                    case 2:
                        o = c, a = n, s = r;
                        break;
                    case 3:
                        o = c, a = r, s = n;
                        break;
                    case 4:
                        o = r, a = c, s = n;
                        break;
                    case 5:
                        o = n, a = c, s = r
                }
                return [255 * o, 255 * a, 255 * s]
            }, r.cmyk.rgb = function (e) {
                var t = e[0] / 100, n = e[1] / 100, i = e[2] / 100, r = e[3] / 100;
                return [255 * (1 - Math.min(1, t * (1 - r) + r)), 255 * (1 - Math.min(1, n * (1 - r) + r)), 255 * (1 - Math.min(1, i * (1 - r) + r))]
            }, r.xyz.rgb = function (e) {
                var t, n, i, r = e[0] / 100, o = e[1] / 100, a = e[2] / 100;
                return n = -.9689 * r + 1.8758 * o + .0415 * a, i = .0557 * r + -.204 * o + 1.057 * a, t = (t = 3.2406 * r + -1.5372 * o + -.4986 * a) > .0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : 12.92 * i, [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (i = Math.min(Math.max(0, i), 1))]
            }, r.xyz.lab = function (e) {
                var t = e[0], n = e[1], i = e[2];
                return n /= 100, i /= 108.883, t = (t /= 95.047) > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (t - n), 200 * (n - (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116))]
            }, r.lab.xyz = function (e) {
                var t, n, i, r = e[0];
                t = e[1] / 500 + (n = (r + 16) / 116), i = n - e[2] / 200;
                var o = Math.pow(n, 3), a = Math.pow(t, 3), s = Math.pow(i, 3);
                return n = o > .008856 ? o : (n - 16 / 116) / 7.787, t = a > .008856 ? a : (t - 16 / 116) / 7.787, i = s > .008856 ? s : (i - 16 / 116) / 7.787, [t *= 95.047, n *= 100, i *= 108.883]
            }, r.lab.lch = function (e) {
                var t, n = e[0], i = e[1], r = e[2];
                return (t = 360 * Math.atan2(r, i) / 2 / Math.PI) < 0 && (t += 360), [n, Math.sqrt(i * i + r * r), t]
            }, r.lch.lab = function (e) {
                var t, n = e[0], i = e[1];
                return t = e[2] / 360 * 2 * Math.PI, [n, i * Math.cos(t), i * Math.sin(t)]
            }, r.rgb.ansi16 = function (e) {
                var t = e[0], n = e[1], i = e[2], o = 1 in arguments ? arguments[1] : r.rgb.hsv(e)[2];
                if (0 === (o = Math.round(o / 50))) return 30;
                var a = 30 + (Math.round(i / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255));
                return 2 === o && (a += 60), a
            }, r.hsv.ansi16 = function (e) {
                return r.rgb.ansi16(r.hsv.rgb(e), e[2])
            }, r.rgb.ansi256 = function (e) {
                var t = e[0], n = e[1], i = e[2];
                return t === n && n === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(i / 255 * 5)
            }, r.ansi16.rgb = function (e) {
                var t = e % 10;
                if (0 === t || 7 === t) return e > 50 && (t += 3.5), [t = t / 10.5 * 255, t, t];
                var n = .5 * (1 + ~~(e > 50));
                return [(1 & t) * n * 255, (t >> 1 & 1) * n * 255, (t >> 2 & 1) * n * 255]
            }, r.ansi256.rgb = function (e) {
                if (e >= 232) {
                    var t = 10 * (e - 232) + 8;
                    return [t, t, t]
                }
                var n;
                return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((n = e % 36) / 6) / 5 * 255, n % 6 / 5 * 255]
            }, r.rgb.hex = function (e) {
                var t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase();
                return "000000".substring(t.length) + t
            }, r.hex.rgb = function (e) {
                var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!t) return [0, 0, 0];
                var n = t[0];
                3 === t[0].length && (n = n.split("").map((function (e) {
                    return e + e
                })).join(""));
                var i = parseInt(n, 16);
                return [i >> 16 & 255, i >> 8 & 255, 255 & i]
            }, r.rgb.hcg = function (e) {
                var t, n = e[0] / 255, i = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(n, i), r),
                    a = Math.min(Math.min(n, i), r), s = o - a;
                return t = s <= 0 ? 0 : o === n ? (i - r) / s % 6 : o === i ? 2 + (r - n) / s : 4 + (n - i) / s + 4, t /= 6, [360 * (t %= 1), 100 * s, 100 * (s < 1 ? a / (1 - s) : 0)]
            }, r.hsl.hcg = function (e) {
                var t = e[1] / 100, n = e[2] / 100, i = 1, r = 0;
                return (i = n < .5 ? 2 * t * n : 2 * t * (1 - n)) < 1 && (r = (n - .5 * i) / (1 - i)), [e[0], 100 * i, 100 * r]
            }, r.hsv.hcg = function (e) {
                var t = e[1] / 100, n = e[2] / 100, i = t * n, r = 0;
                return i < 1 && (r = (n - i) / (1 - i)), [e[0], 100 * i, 100 * r]
            }, r.hcg.rgb = function (e) {
                var t = e[0] / 360, n = e[1] / 100, i = e[2] / 100;
                if (0 === n) return [255 * i, 255 * i, 255 * i];
                var r, o = [0, 0, 0], a = t % 1 * 6, s = a % 1, l = 1 - s;
                switch (Math.floor(a)) {
                    case 0:
                        o[0] = 1, o[1] = s, o[2] = 0;
                        break;
                    case 1:
                        o[0] = l, o[1] = 1, o[2] = 0;
                        break;
                    case 2:
                        o[0] = 0, o[1] = 1, o[2] = s;
                        break;
                    case 3:
                        o[0] = 0, o[1] = l, o[2] = 1;
                        break;
                    case 4:
                        o[0] = s, o[1] = 0, o[2] = 1;
                        break;
                    default:
                        o[0] = 1, o[1] = 0, o[2] = l
                }
                return r = (1 - n) * i, [255 * (n * o[0] + r), 255 * (n * o[1] + r), 255 * (n * o[2] + r)]
            }, r.hcg.hsv = function (e) {
                var t = e[1] / 100, n = t + e[2] / 100 * (1 - t), i = 0;
                return n > 0 && (i = t / n), [e[0], 100 * i, 100 * n]
            }, r.hcg.hsl = function (e) {
                var t = e[1] / 100, n = e[2] / 100 * (1 - t) + .5 * t, i = 0;
                return n > 0 && n < .5 ? i = t / (2 * n) : n >= .5 && n < 1 && (i = t / (2 * (1 - n))), [e[0], 100 * i, 100 * n]
            }, r.hcg.hwb = function (e) {
                var t = e[1] / 100, n = t + e[2] / 100 * (1 - t);
                return [e[0], 100 * (n - t), 100 * (1 - n)]
            }, r.hwb.hcg = function (e) {
                var t = e[1] / 100, n = 1 - e[2] / 100, i = n - t, r = 0;
                return i < 1 && (r = (n - i) / (1 - i)), [e[0], 100 * i, 100 * r]
            }, r.apple.rgb = function (e) {
                return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]
            }, r.rgb.apple = function (e) {
                return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]
            }, r.gray.rgb = function (e) {
                return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]
            }, r.gray.hsl = r.gray.hsv = function (e) {
                return [0, 0, e[0]]
            }, r.gray.hwb = function (e) {
                return [0, 100, e[0]]
            }, r.gray.cmyk = function (e) {
                return [0, 0, 0, e[0]]
            }, r.gray.lab = function (e) {
                return [e[0], 0, 0]
            }, r.gray.hex = function (e) {
                var t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
                return "000000".substring(n.length) + n
            }, r.rgb.gray = function (e) {
                return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]
            }
        }));

        function i(e) {
            var t = function () {
                for (var e = {}, t = Object.keys(n), i = t.length, r = 0; r < i; r++) e[t[r]] = {
                    distance: -1,
                    parent: null
                };
                return e
            }(), i = [e];
            for (t[e].distance = 0; i.length;) for (var r = i.pop(), o = Object.keys(n[r]), a = o.length, s = 0; s < a; s++) {
                var l = o[s], c = t[l];
                -1 === c.distance && (c.distance = t[r].distance + 1, c.parent = r, i.unshift(l))
            }
            return t
        }

        function r(e, t) {
            return function (n) {
                return t(e(n))
            }
        }

        function o(e, t) {
            for (var i = [t[e].parent, e], o = n[t[e].parent][e], a = t[e].parent; t[a].parent;) i.unshift(t[a].parent), o = r(n[t[a].parent][a], o), a = t[a].parent;
            return o.conversion = i, o
        }

        n.rgb, n.hsl, n.hsv, n.hwb, n.cmyk, n.xyz, n.lab, n.lch, n.hex, n.keyword, n.ansi16, n.ansi256, n.hcg, n.apple, n.gray;
        var a = {};
        Object.keys(n).forEach((function (e) {
            a[e] = {}, Object.defineProperty(a[e], "channels", {value: n[e].channels}), Object.defineProperty(a[e], "labels", {value: n[e].labels});
            var t = function (e) {
                for (var t = i(e), n = {}, r = Object.keys(t), a = r.length, s = 0; s < a; s++) {
                    var l = r[s];
                    null !== t[l].parent && (n[l] = o(l, t))
                }
                return n
            }(e);
            Object.keys(t).forEach((function (n) {
                var i = t[n];
                a[e][n] = function (e) {
                    var t = function (t) {
                        if (null == t) return t;
                        arguments.length > 1 && (t = Array.prototype.slice.call(arguments));
                        var n = e(t);
                        if ("object" == typeof n) for (var i = n.length, r = 0; r < i; r++) n[r] = Math.round(n[r]);
                        return n
                    };
                    return "conversion" in e && (t.conversion = e.conversion), t
                }(i), a[e][n].raw = function (e) {
                    var t = function (t) {
                        return null == t ? t : (arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), e(t))
                    };
                    return "conversion" in e && (t.conversion = e.conversion), t
                }(i)
            }))
        }));
        var s = a, l = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }, c = {
            getRgba: u, getHsla: d, getRgb: function (e) {
                var t = u(e);
                return t && t.slice(0, 3)
            }, getHsl: function (e) {
                var t = d(e);
                return t && t.slice(0, 3)
            }, getHwb: h, getAlpha: function (e) {
                var t = u(e);
                return t || (t = d(e)) || (t = h(e)) ? t[3] : void 0
            }, hexString: function (e, t) {
                return t = void 0 !== t && 3 === e.length ? t : e[3], "#" + g(e[0]) + g(e[1]) + g(e[2]) + (t >= 0 && t < 1 ? g(Math.round(255 * t)) : "")
            }, rgbString: function (e, t) {
                return t < 1 || e[3] && e[3] < 1 ? p(e, t) : "rgb(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
            }, rgbaString: p, percentString: function (e, t) {
                if (t < 1 || e[3] && e[3] < 1) return f(e, t);
                var n = Math.round(e[0] / 255 * 100), i = Math.round(e[1] / 255 * 100),
                    r = Math.round(e[2] / 255 * 100);
                return "rgb(" + n + "%, " + i + "%, " + r + "%)"
            }, percentaString: f, hslString: function (e, t) {
                return t < 1 || e[3] && e[3] < 1 ? m(e, t) : "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)"
            }, hslaString: m, hwbString: function (e, t) {
                return void 0 === t && (t = void 0 !== e[3] ? e[3] : 1), "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + (void 0 !== t && 1 !== t ? ", " + t : "") + ")"
            }, keyword: function (e) {
                return y[e.slice(0, 3)]
            }
        };

        function u(e) {
            if (e) {
                var t = [0, 0, 0], n = 1, i = e.match(/^#([a-fA-F0-9]{3,4})$/i), r = "";
                if (i) {
                    r = (i = i[1])[3];
                    for (var o = 0; o < t.length; o++) t[o] = parseInt(i[o] + i[o], 16);
                    r && (n = Math.round(parseInt(r + r, 16) / 255 * 100) / 100)
                } else if (i = e.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) {
                    for (r = i[2], i = i[1], o = 0; o < t.length; o++) t[o] = parseInt(i.slice(2 * o, 2 * o + 2), 16);
                    r && (n = Math.round(parseInt(r, 16) / 255 * 100) / 100)
                } else if (i = e.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
                    for (o = 0; o < t.length; o++) t[o] = parseInt(i[o + 1]);
                    n = parseFloat(i[4])
                } else if (i = e.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
                    for (o = 0; o < t.length; o++) t[o] = Math.round(2.55 * parseFloat(i[o + 1]));
                    n = parseFloat(i[4])
                } else if (i = e.match(/(\w+)/)) {
                    if ("transparent" == i[1]) return [0, 0, 0, 0];
                    if (!(t = l[i[1]])) return
                }
                for (o = 0; o < t.length; o++) t[o] = _(t[o], 0, 255);
                return n = n || 0 == n ? _(n, 0, 1) : 1, t[3] = n, t
            }
        }

        function d(e) {
            if (e) {
                var t = e.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                if (t) {
                    var n = parseFloat(t[4]);
                    return [_(parseInt(t[1]), 0, 360), _(parseFloat(t[2]), 0, 100), _(parseFloat(t[3]), 0, 100), _(isNaN(n) ? 1 : n, 0, 1)]
                }
            }
        }

        function h(e) {
            if (e) {
                var t = e.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                if (t) {
                    var n = parseFloat(t[4]);
                    return [_(parseInt(t[1]), 0, 360), _(parseFloat(t[2]), 0, 100), _(parseFloat(t[3]), 0, 100), _(isNaN(n) ? 1 : n, 0, 1)]
                }
            }
        }

        function p(e, t) {
            return void 0 === t && (t = void 0 !== e[3] ? e[3] : 1), "rgba(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + t + ")"
        }

        function f(e, t) {
            return "rgba(" + Math.round(e[0] / 255 * 100) + "%, " + Math.round(e[1] / 255 * 100) + "%, " + Math.round(e[2] / 255 * 100) + "%, " + (t || e[3] || 1) + ")"
        }

        function m(e, t) {
            return void 0 === t && (t = void 0 !== e[3] ? e[3] : 1), "hsla(" + e[0] + ", " + e[1] + "%, " + e[2] + "%, " + t + ")"
        }

        function _(e, t, n) {
            return Math.min(Math.max(t, e), n)
        }

        function g(e) {
            var t = e.toString(16).toUpperCase();
            return t.length < 2 ? "0" + t : t
        }

        var y = {};
        for (var v in l) y[l[v]] = v;
        var x = function (e) {
            return e instanceof x ? e : this instanceof x ? (this.valid = !1, this.values = {
                rgb: [0, 0, 0],
                hsl: [0, 0, 0],
                hsv: [0, 0, 0],
                hwb: [0, 0, 0],
                cmyk: [0, 0, 0, 0],
                alpha: 1
            }, void ("string" == typeof e ? (t = c.getRgba(e)) ? this.setValues("rgb", t) : (t = c.getHsla(e)) ? this.setValues("hsl", t) : (t = c.getHwb(e)) && this.setValues("hwb", t) : "object" == typeof e && (void 0 !== (t = e).r || void 0 !== t.red ? this.setValues("rgb", t) : void 0 !== t.l || void 0 !== t.lightness ? this.setValues("hsl", t) : void 0 !== t.v || void 0 !== t.value ? this.setValues("hsv", t) : void 0 !== t.w || void 0 !== t.whiteness ? this.setValues("hwb", t) : void 0 === t.c && void 0 === t.cyan || this.setValues("cmyk", t)))) : new x(e);
            var t
        };
        x.prototype = {
            isValid: function () {
                return this.valid
            }, rgb: function () {
                return this.setSpace("rgb", arguments)
            }, hsl: function () {
                return this.setSpace("hsl", arguments)
            }, hsv: function () {
                return this.setSpace("hsv", arguments)
            }, hwb: function () {
                return this.setSpace("hwb", arguments)
            }, cmyk: function () {
                return this.setSpace("cmyk", arguments)
            }, rgbArray: function () {
                return this.values.rgb
            }, hslArray: function () {
                return this.values.hsl
            }, hsvArray: function () {
                return this.values.hsv
            }, hwbArray: function () {
                var e = this.values;
                return 1 !== e.alpha ? e.hwb.concat([e.alpha]) : e.hwb
            }, cmykArray: function () {
                return this.values.cmyk
            }, rgbaArray: function () {
                var e = this.values;
                return e.rgb.concat([e.alpha])
            }, hslaArray: function () {
                var e = this.values;
                return e.hsl.concat([e.alpha])
            }, alpha: function (e) {
                return void 0 === e ? this.values.alpha : (this.setValues("alpha", e), this)
            }, red: function (e) {
                return this.setChannel("rgb", 0, e)
            }, green: function (e) {
                return this.setChannel("rgb", 1, e)
            }, blue: function (e) {
                return this.setChannel("rgb", 2, e)
            }, hue: function (e) {
                return e && (e = (e %= 360) < 0 ? 360 + e : e), this.setChannel("hsl", 0, e)
            }, saturation: function (e) {
                return this.setChannel("hsl", 1, e)
            }, lightness: function (e) {
                return this.setChannel("hsl", 2, e)
            }, saturationv: function (e) {
                return this.setChannel("hsv", 1, e)
            }, whiteness: function (e) {
                return this.setChannel("hwb", 1, e)
            }, blackness: function (e) {
                return this.setChannel("hwb", 2, e)
            }, value: function (e) {
                return this.setChannel("hsv", 2, e)
            }, cyan: function (e) {
                return this.setChannel("cmyk", 0, e)
            }, magenta: function (e) {
                return this.setChannel("cmyk", 1, e)
            }, yellow: function (e) {
                return this.setChannel("cmyk", 2, e)
            }, black: function (e) {
                return this.setChannel("cmyk", 3, e)
            }, hexString: function () {
                return c.hexString(this.values.rgb)
            }, rgbString: function () {
                return c.rgbString(this.values.rgb, this.values.alpha)
            }, rgbaString: function () {
                return c.rgbaString(this.values.rgb, this.values.alpha)
            }, percentString: function () {
                return c.percentString(this.values.rgb, this.values.alpha)
            }, hslString: function () {
                return c.hslString(this.values.hsl, this.values.alpha)
            }, hslaString: function () {
                return c.hslaString(this.values.hsl, this.values.alpha)
            }, hwbString: function () {
                return c.hwbString(this.values.hwb, this.values.alpha)
            }, keyword: function () {
                return c.keyword(this.values.rgb, this.values.alpha)
            }, rgbNumber: function () {
                var e = this.values.rgb;
                return e[0] << 16 | e[1] << 8 | e[2]
            }, luminosity: function () {
                for (var e = this.values.rgb, t = [], n = 0; n < e.length; n++) {
                    var i = e[n] / 255;
                    t[n] = i <= .03928 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
                }
                return .2126 * t[0] + .7152 * t[1] + .0722 * t[2]
            }, contrast: function (e) {
                var t = this.luminosity(), n = e.luminosity();
                return t > n ? (t + .05) / (n + .05) : (n + .05) / (t + .05)
            }, level: function (e) {
                var t = this.contrast(e);
                return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : ""
            }, dark: function () {
                var e = this.values.rgb;
                return (299 * e[0] + 587 * e[1] + 114 * e[2]) / 1e3 < 128
            }, light: function () {
                return !this.dark()
            }, negate: function () {
                for (var e = [], t = 0; t < 3; t++) e[t] = 255 - this.values.rgb[t];
                return this.setValues("rgb", e), this
            }, lighten: function (e) {
                var t = this.values.hsl;
                return t[2] += t[2] * e, this.setValues("hsl", t), this
            }, darken: function (e) {
                var t = this.values.hsl;
                return t[2] -= t[2] * e, this.setValues("hsl", t), this
            }, saturate: function (e) {
                var t = this.values.hsl;
                return t[1] += t[1] * e, this.setValues("hsl", t), this
            }, desaturate: function (e) {
                var t = this.values.hsl;
                return t[1] -= t[1] * e, this.setValues("hsl", t), this
            }, whiten: function (e) {
                var t = this.values.hwb;
                return t[1] += t[1] * e, this.setValues("hwb", t), this
            }, blacken: function (e) {
                var t = this.values.hwb;
                return t[2] += t[2] * e, this.setValues("hwb", t), this
            }, greyscale: function () {
                var e = this.values.rgb, t = .3 * e[0] + .59 * e[1] + .11 * e[2];
                return this.setValues("rgb", [t, t, t]), this
            }, clearer: function (e) {
                var t = this.values.alpha;
                return this.setValues("alpha", t - t * e), this
            }, opaquer: function (e) {
                var t = this.values.alpha;
                return this.setValues("alpha", t + t * e), this
            }, rotate: function (e) {
                var t = this.values.hsl, n = (t[0] + e) % 360;
                return t[0] = n < 0 ? 360 + n : n, this.setValues("hsl", t), this
            }, mix: function (e, t) {
                var n = e, i = void 0 === t ? .5 : t, r = 2 * i - 1, o = this.alpha() - n.alpha(),
                    a = ((r * o == -1 ? r : (r + o) / (1 + r * o)) + 1) / 2, s = 1 - a;
                return this.rgb(a * this.red() + s * n.red(), a * this.green() + s * n.green(), a * this.blue() + s * n.blue()).alpha(this.alpha() * i + n.alpha() * (1 - i))
            }, toJSON: function () {
                return this.rgb()
            }, clone: function () {
                var e, t, n = new x, i = this.values, r = n.values;
                for (var o in i) i.hasOwnProperty(o) && (e = i[o], "[object Array]" === (t = {}.toString.call(e)) ? r[o] = e.slice(0) : "[object Number]" === t ? r[o] = e : console.error("unexpected color value:", e));
                return n
            }
        }, x.prototype.spaces = {
            rgb: ["red", "green", "blue"],
            hsl: ["hue", "saturation", "lightness"],
            hsv: ["hue", "saturation", "value"],
            hwb: ["hue", "whiteness", "blackness"],
            cmyk: ["cyan", "magenta", "yellow", "black"]
        }, x.prototype.maxes = {
            rgb: [255, 255, 255],
            hsl: [360, 100, 100],
            hsv: [360, 100, 100],
            hwb: [360, 100, 100],
            cmyk: [100, 100, 100, 100]
        }, x.prototype.getValues = function (e) {
            for (var t = this.values, n = {}, i = 0; i < e.length; i++) n[e.charAt(i)] = t[e][i];
            return 1 !== t.alpha && (n.a = t.alpha), n
        }, x.prototype.setValues = function (e, t) {
            var n, i, r = this.values, o = this.spaces, a = this.maxes, l = 1;
            if (this.valid = !0, "alpha" === e) l = t; else if (t.length) r[e] = t.slice(0, e.length), l = t[e.length]; else if (void 0 !== t[e.charAt(0)]) {
                for (n = 0; n < e.length; n++) r[e][n] = t[e.charAt(n)];
                l = t.a
            } else if (void 0 !== t[o[e][0]]) {
                var c = o[e];
                for (n = 0; n < e.length; n++) r[e][n] = t[c[n]];
                l = t.alpha
            }
            if (r.alpha = Math.max(0, Math.min(1, void 0 === l ? r.alpha : l)), "alpha" === e) return !1;
            for (n = 0; n < e.length; n++) i = Math.max(0, Math.min(a[e][n], r[e][n])), r[e][n] = Math.round(i);
            for (var u in o) u !== e && (r[u] = s[e][u](r[e]));
            return !0
        }, x.prototype.setSpace = function (e, t) {
            var n = t[0];
            return void 0 === n ? this.getValues(e) : ("number" == typeof n && (n = Array.prototype.slice.call(t)), this.setValues(e, n), this)
        }, x.prototype.setChannel = function (e, t, n) {
            var i = this.values[e];
            return void 0 === n ? i[t] : (n === i[t] || (i[t] = n, this.setValues(e, i)), this)
        }, "undefined" != typeof window && (window.Color = x);
        var b = x;

        function w(e) {
            return -1 === ["__proto__", "prototype", "constructor"].indexOf(e)
        }

        var M, T = {
            noop: function () {
            }, uid: (M = 0, function () {
                return M++
            }), isNullOrUndef: function (e) {
                return null == e
            }, isArray: function (e) {
                if (Array.isArray && Array.isArray(e)) return !0;
                var t = Object.prototype.toString.call(e);
                return "[object" === t.substr(0, 7) && "Array]" === t.substr(-6)
            }, isObject: function (e) {
                return null !== e && "[object Object]" === Object.prototype.toString.call(e)
            }, isFinite: function (e) {
                return ("number" == typeof e || e instanceof Number) && isFinite(e)
            }, valueOrDefault: function (e, t) {
                return void 0 === e ? t : e
            }, valueAtIndexOrDefault: function (e, t, n) {
                return T.valueOrDefault(T.isArray(e) ? e[t] : e, n)
            }, callback: function (e, t, n) {
                if (e && "function" == typeof e.call) return e.apply(n, t)
            }, each: function (e, t, n, i) {
                var r, o, a;
                if (T.isArray(e)) if (o = e.length, i) for (r = o - 1; r >= 0; r--) t.call(n, e[r], r); else for (r = 0; r < o; r++) t.call(n, e[r], r); else if (T.isObject(e)) for (o = (a = Object.keys(e)).length, r = 0; r < o; r++) t.call(n, e[a[r]], a[r])
            }, arrayEquals: function (e, t) {
                var n, i, r, o;
                if (!e || !t || e.length !== t.length) return !1;
                for (n = 0, i = e.length; n < i; ++n) if (r = e[n], o = t[n], r instanceof Array && o instanceof Array) {
                    if (!T.arrayEquals(r, o)) return !1
                } else if (r !== o) return !1;
                return !0
            }, clone: function (e) {
                if (T.isArray(e)) return e.map(T.clone);
                if (T.isObject(e)) {
                    for (var t = Object.create(e), n = Object.keys(e), i = n.length, r = 0; r < i; ++r) t[n[r]] = T.clone(e[n[r]]);
                    return t
                }
                return e
            }, _merger: function (e, t, n, i) {
                if (w(e)) {
                    var r = t[e], o = n[e];
                    T.isObject(r) && T.isObject(o) ? T.merge(r, o, i) : t[e] = T.clone(o)
                }
            }, _mergerIf: function (e, t, n) {
                if (w(e)) {
                    var i = t[e], r = n[e];
                    T.isObject(i) && T.isObject(r) ? T.mergeIf(i, r) : t.hasOwnProperty(e) || (t[e] = T.clone(r))
                }
            }, merge: function (e, t, n) {
                var i, r, o, a, s, l = T.isArray(t) ? t : [t], c = l.length;
                if (!T.isObject(e)) return e;
                for (i = (n = n || {}).merger || T._merger, r = 0; r < c; ++r) if (t = l[r], T.isObject(t)) for (s = 0, a = (o = Object.keys(t)).length; s < a; ++s) i(o[s], e, t, n);
                return e
            }, mergeIf: function (e, t) {
                return T.merge(e, t, {merger: T._mergerIf})
            }, extend: Object.assign || function (e) {
                return T.merge(e, [].slice.call(arguments, 1), {
                    merger: function (e, t, n) {
                        t[e] = n[e]
                    }
                })
            }, inherits: function (e) {
                var t = this, n = e && e.hasOwnProperty("constructor") ? e.constructor : function () {
                    return t.apply(this, arguments)
                }, i = function () {
                    this.constructor = n
                };
                return i.prototype = t.prototype, n.prototype = new i, n.extend = T.inherits, e && T.extend(n.prototype, e), n.__super__ = t.prototype, n
            }, _deprecated: function (e, t, n, i) {
                void 0 !== t && console.warn(e + ': "' + n + '" is deprecated. Please use "' + i + '" instead')
            }
        }, k = T;
        T.callCallback = T.callback, T.indexOf = function (e, t, n) {
            return Array.prototype.indexOf.call(e, t, n)
        }, T.getValueOrDefault = T.valueOrDefault, T.getValueAtIndexOrDefault = T.valueAtIndexOrDefault;
        var S = {
            linear: function (e) {
                return e
            }, easeInQuad: function (e) {
                return e * e
            }, easeOutQuad: function (e) {
                return -e * (e - 2)
            }, easeInOutQuad: function (e) {
                return (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
            }, easeInCubic: function (e) {
                return e * e * e
            }, easeOutCubic: function (e) {
                return (e -= 1) * e * e + 1
            }, easeInOutCubic: function (e) {
                return (e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
            }, easeInQuart: function (e) {
                return e * e * e * e
            }, easeOutQuart: function (e) {
                return -((e -= 1) * e * e * e - 1)
            }, easeInOutQuart: function (e) {
                return (e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
            }, easeInQuint: function (e) {
                return e * e * e * e * e
            }, easeOutQuint: function (e) {
                return (e -= 1) * e * e * e * e + 1
            }, easeInOutQuint: function (e) {
                return (e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
            }, easeInSine: function (e) {
                return 1 - Math.cos(e * (Math.PI / 2))
            }, easeOutSine: function (e) {
                return Math.sin(e * (Math.PI / 2))
            }, easeInOutSine: function (e) {
                return -.5 * (Math.cos(Math.PI * e) - 1)
            }, easeInExpo: function (e) {
                return 0 === e ? 0 : Math.pow(2, 10 * (e - 1))
            }, easeOutExpo: function (e) {
                return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
            }, easeInOutExpo: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : (e /= .5) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * --e))
            }, easeInCirc: function (e) {
                return e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1)
            }, easeOutCirc: function (e) {
                return Math.sqrt(1 - (e -= 1) * e)
            }, easeInOutCirc: function (e) {
                return (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
            }, easeInElastic: function (e) {
                var t = 1.70158, n = 0, i = 1;
                return 0 === e ? 0 : 1 === e ? 1 : (n || (n = .3), i < 1 ? (i = 1, t = n / 4) : t = n / (2 * Math.PI) * Math.asin(1 / i), -i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n))
            }, easeOutElastic: function (e) {
                var t = 1.70158, n = 0, i = 1;
                return 0 === e ? 0 : 1 === e ? 1 : (n || (n = .3), i < 1 ? (i = 1, t = n / 4) : t = n / (2 * Math.PI) * Math.asin(1 / i), i * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1)
            }, easeInOutElastic: function (e) {
                var t = 1.70158, n = 0, i = 1;
                return 0 === e ? 0 : 2 == (e /= .5) ? 1 : (n || (n = .45), i < 1 ? (i = 1, t = n / 4) : t = n / (2 * Math.PI) * Math.asin(1 / i), e < 1 ? i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * -.5 : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * .5 + 1)
            }, easeInBack: function (e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t)
            }, easeOutBack: function (e) {
                var t = 1.70158;
                return (e -= 1) * e * ((t + 1) * e + t) + 1
            }, easeInOutBack: function (e) {
                var t = 1.70158;
                return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2)
            }, easeInBounce: function (e) {
                return 1 - S.easeOutBounce(1 - e)
            }, easeOutBounce: function (e) {
                return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
            }, easeInOutBounce: function (e) {
                return e < .5 ? .5 * S.easeInBounce(2 * e) : .5 * S.easeOutBounce(2 * e - 1) + .5
            }
        }, D = {effects: S};
        k.easingEffects = S;
        var L = Math.PI, E = L / 180, C = 2 * L, A = L / 2, I = L / 4, P = 2 * L / 3, R = {
            clear: function (e) {
                e.ctx.clearRect(0, 0, e.width, e.height)
            }, roundedRect: function (e, t, n, i, r, o) {
                if (o) {
                    var a = Math.min(o, r / 2, i / 2), s = t + a, l = n + a, c = t + i - a, u = n + r - a;
                    e.moveTo(t, l), s < c && l < u ? (e.arc(s, l, a, -L, -A), e.arc(c, l, a, -A, 0), e.arc(c, u, a, 0, A), e.arc(s, u, a, A, L)) : s < c ? (e.moveTo(s, n), e.arc(c, l, a, -A, A), e.arc(s, l, a, A, L + A)) : l < u ? (e.arc(s, l, a, -L, 0), e.arc(s, u, a, 0, L)) : e.arc(s, l, a, -L, L), e.closePath(), e.moveTo(t, n)
                } else e.rect(t, n, i, r)
            }, drawPoint: function (e, t, n, i, r, o) {
                var a, s, l, c, u, d = (o || 0) * E;
                if (t && "object" == typeof t && ("[object HTMLImageElement]" === (a = t.toString()) || "[object HTMLCanvasElement]" === a)) return e.save(), e.translate(i, r), e.rotate(d), e.drawImage(t, -t.width / 2, -t.height / 2, t.width, t.height), void e.restore();
                if (!(isNaN(n) || n <= 0)) {
                    switch (e.beginPath(), t) {
                        default:
                            e.arc(i, r, n, 0, C), e.closePath();
                            break;
                        case"triangle":
                            e.moveTo(i + Math.sin(d) * n, r - Math.cos(d) * n), d += P, e.lineTo(i + Math.sin(d) * n, r - Math.cos(d) * n), d += P, e.lineTo(i + Math.sin(d) * n, r - Math.cos(d) * n), e.closePath();
                            break;
                        case"rectRounded":
                            c = n - (u = .516 * n), s = Math.cos(d + I) * c, l = Math.sin(d + I) * c, e.arc(i - s, r - l, u, d - L, d - A), e.arc(i + l, r - s, u, d - A, d), e.arc(i + s, r + l, u, d, d + A), e.arc(i - l, r + s, u, d + A, d + L), e.closePath();
                            break;
                        case"rect":
                            if (!o) {
                                c = Math.SQRT1_2 * n, e.rect(i - c, r - c, 2 * c, 2 * c);
                                break
                            }
                            d += I;
                        case"rectRot":
                            s = Math.cos(d) * n, l = Math.sin(d) * n, e.moveTo(i - s, r - l), e.lineTo(i + l, r - s), e.lineTo(i + s, r + l), e.lineTo(i - l, r + s), e.closePath();
                            break;
                        case"crossRot":
                            d += I;
                        case"cross":
                            s = Math.cos(d) * n, l = Math.sin(d) * n, e.moveTo(i - s, r - l), e.lineTo(i + s, r + l), e.moveTo(i + l, r - s), e.lineTo(i - l, r + s);
                            break;
                        case"star":
                            s = Math.cos(d) * n, l = Math.sin(d) * n, e.moveTo(i - s, r - l), e.lineTo(i + s, r + l), e.moveTo(i + l, r - s), e.lineTo(i - l, r + s), d += I, s = Math.cos(d) * n, l = Math.sin(d) * n, e.moveTo(i - s, r - l), e.lineTo(i + s, r + l), e.moveTo(i + l, r - s), e.lineTo(i - l, r + s);
                            break;
                        case"line":
                            s = Math.cos(d) * n, l = Math.sin(d) * n, e.moveTo(i - s, r - l), e.lineTo(i + s, r + l);
                            break;
                        case"dash":
                            e.moveTo(i, r), e.lineTo(i + Math.cos(d) * n, r + Math.sin(d) * n)
                    }
                    e.fill(), e.stroke()
                }
            }, _isPointInArea: function (e, t) {
                return e.x > t.left - 1e-6 && e.x < t.right + 1e-6 && e.y > t.top - 1e-6 && e.y < t.bottom + 1e-6
            }, clipArea: function (e, t) {
                e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip()
            }, unclipArea: function (e) {
                e.restore()
            }, lineTo: function (e, t, n, i) {
                var r = n.steppedLine;
                if (r) {
                    if ("middle" === r) {
                        var o = (t.x + n.x) / 2;
                        e.lineTo(o, i ? n.y : t.y), e.lineTo(o, i ? t.y : n.y)
                    } else "after" === r && !i || "after" !== r && i ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
                    e.lineTo(n.x, n.y)
                } else n.tension ? e.bezierCurveTo(i ? t.controlPointPreviousX : t.controlPointNextX, i ? t.controlPointPreviousY : t.controlPointNextY, i ? n.controlPointNextX : n.controlPointPreviousX, i ? n.controlPointNextY : n.controlPointPreviousY, n.x, n.y) : e.lineTo(n.x, n.y)
            }
        }, Y = R;
        k.clear = R.clear, k.drawRoundedRectangle = function (e) {
            e.beginPath(), R.roundedRect.apply(R, arguments)
        };
        var z = {
            _set: function (e, t) {
                return k.merge(this[e] || (this[e] = {}), t)
            }
        };
        z._set("global", {
            defaultColor: "rgba(0,0,0,0.1)",
            defaultFontColor: "#666",
            defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            defaultFontSize: 12,
            defaultFontStyle: "normal",
            defaultLineHeight: 1.2,
            showLines: !0
        });
        var O = z, F = k.valueOrDefault, B = {
            toLineHeight: function (e, t) {
                var n = ("" + e).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                if (!n || "normal" === n[1]) return 1.2 * t;
                switch (e = +n[2], n[3]) {
                    case"px":
                        return e;
                    case"%":
                        e /= 100
                }
                return t * e
            }, toPadding: function (e) {
                var t, n, i, r;
                return k.isObject(e) ? (t = +e.top || 0, n = +e.right || 0, i = +e.bottom || 0, r = +e.left || 0) : t = n = i = r = +e || 0, {
                    top: t,
                    right: n,
                    bottom: i,
                    left: r,
                    height: t + i,
                    width: r + n
                }
            }, _parseFont: function (e) {
                var t = O.global, n = F(e.fontSize, t.defaultFontSize), i = {
                    family: F(e.fontFamily, t.defaultFontFamily),
                    lineHeight: k.options.toLineHeight(F(e.lineHeight, t.defaultLineHeight), n),
                    size: n,
                    style: F(e.fontStyle, t.defaultFontStyle),
                    weight: null,
                    string: ""
                };
                return i.string = function (e) {
                    return !e || k.isNullOrUndef(e.size) || k.isNullOrUndef(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family
                }(i), i
            }, resolve: function (e, t, n, i) {
                var r, o, a, s = !0;
                for (r = 0, o = e.length; r < o; ++r) if (void 0 !== (a = e[r]) && (void 0 !== t && "function" == typeof a && (a = a(t), s = !1), void 0 !== n && k.isArray(a) && (a = a[n], s = !1), void 0 !== a)) return i && !s && (i.cacheable = !1), a
            }
        }, j = {
            _factorize: function (e) {
                var t, n = [], i = Math.sqrt(e);
                for (t = 1; t < i; t++) e % t == 0 && (n.push(t), n.push(e / t));
                return i === (0 | i) && n.push(i), n.sort((function (e, t) {
                    return e - t
                })).pop(), n
            }, log10: Math.log10 || function (e) {
                var t = Math.log(e) * Math.LOG10E, n = Math.round(t);
                return e === Math.pow(10, n) ? n : t
            }
        }, H = j;
        k.log10 = j.log10;
        var N = k, U = D, W = Y, V = B, G = H, q = {
            getRtlAdapter: function (e, t, n) {
                return e ? function (e, t) {
                    return {
                        x: function (n) {
                            return e + e + t - n
                        }, setWidth: function (e) {
                            t = e
                        }, textAlign: function (e) {
                            return "center" === e ? e : "right" === e ? "left" : "right"
                        }, xPlus: function (e, t) {
                            return e - t
                        }, leftForLtr: function (e, t) {
                            return e - t
                        }
                    }
                }(t, n) : {
                    x: function (e) {
                        return e
                    }, setWidth: function (e) {
                    }, textAlign: function (e) {
                        return e
                    }, xPlus: function (e, t) {
                        return e + t
                    }, leftForLtr: function (e, t) {
                        return e
                    }
                }
            }, overrideTextDirection: function (e, t) {
                var n, i;
                "ltr" !== t && "rtl" !== t || (i = [(n = e.canvas.style).getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", t, "important"), e.prevTextDirection = i)
            }, restoreTextDirection: function (e) {
                var t = e.prevTextDirection;
                void 0 !== t && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]))
            }
        };
        N.easing = U, N.canvas = W, N.options = V, N.math = G, N.rtl = q;
        var Z = function (e) {
            N.extend(this, e), this.initialize.apply(this, arguments)
        };
        N.extend(Z.prototype, {
            _type: void 0, initialize: function () {
                this.hidden = !1
            }, pivot: function () {
                var e = this;
                return e._view || (e._view = N.extend({}, e._model)), e._start = {}, e
            }, transition: function (e) {
                var t = this, n = t._model, i = t._start, r = t._view;
                return n && 1 !== e ? (r || (r = t._view = {}), i || (i = t._start = {}), function (e, t, n, i) {
                    var r, o, a, s, l, c, u, d, h, p = Object.keys(n);
                    for (r = 0, o = p.length; r < o; ++r) if (c = n[a = p[r]], t.hasOwnProperty(a) || (t[a] = c), (s = t[a]) !== c && "_" !== a[0]) {
                        if (e.hasOwnProperty(a) || (e[a] = s), (u = typeof c) == typeof (l = e[a])) if ("string" === u) {
                            if ((d = b(l)).valid && (h = b(c)).valid) {
                                t[a] = h.mix(d, i).rgbString();
                                continue
                            }
                        } else if (N.isFinite(l) && N.isFinite(c)) {
                            t[a] = l + (c - l) * i;
                            continue
                        }
                        t[a] = c
                    }
                }(i, r, n, e), t) : (t._view = N.extend({}, n), t._start = null, t)
            }, tooltipPosition: function () {
                return {x: this._model.x, y: this._model.y}
            }, hasValue: function () {
                return N.isNumber(this._model.x) && N.isNumber(this._model.y)
            }
        }), Z.extend = N.inherits;
        var $ = Z, X = $.extend({
            chart: null,
            currentStep: 0,
            numSteps: 60,
            easing: "",
            render: null,
            onAnimationProgress: null,
            onAnimationComplete: null
        }), J = X;
        Object.defineProperty(X.prototype, "animationObject", {
            get: function () {
                return this
            }
        }), Object.defineProperty(X.prototype, "chartInstance", {
            get: function () {
                return this.chart
            }, set: function (e) {
                this.chart = e
            }
        }), O._set("global", {
            animation: {
                duration: 1e3,
                easing: "easeOutQuart",
                onProgress: N.noop,
                onComplete: N.noop
            }
        });
        var K = {
            animations: [], request: null, addAnimation: function (e, t, n, i) {
                var r, o, a = this.animations;
                for (t.chart = e, t.startTime = Date.now(), t.duration = n, i || (e.animating = !0), r = 0, o = a.length; r < o; ++r) if (a[r].chart === e) return void (a[r] = t);
                a.push(t), 1 === a.length && this.requestAnimationFrame()
            }, cancelAnimation: function (e) {
                var t = N.findIndex(this.animations, (function (t) {
                    return t.chart === e
                }));
                -1 !== t && (this.animations.splice(t, 1), e.animating = !1)
            }, requestAnimationFrame: function () {
                var e = this;
                null === e.request && (e.request = N.requestAnimFrame.call(window, (function () {
                    e.request = null, e.startDigest()
                })))
            }, startDigest: function () {
                this.advance(), this.animations.length > 0 && this.requestAnimationFrame()
            }, advance: function () {
                for (var e, t, n, i, r = this.animations, o = 0; o < r.length;) t = (e = r[o]).chart, n = e.numSteps, i = Math.floor((Date.now() - e.startTime) / e.duration * n) + 1, e.currentStep = Math.min(i, n), N.callback(e.render, [t, e], t), N.callback(e.onAnimationProgress, [e], t), e.currentStep >= n ? (N.callback(e.onAnimationComplete, [e], t), t.animating = !1, r.splice(o, 1)) : ++o
            }
        }, Q = N.options.resolve, ee = ["push", "pop", "shift", "splice", "unshift"];

        function te(e, t) {
            var n = e._chartjs;
            if (n) {
                var i = n.listeners, r = i.indexOf(t);
                -1 !== r && i.splice(r, 1), i.length > 0 || (ee.forEach((function (t) {
                    delete e[t]
                })), delete e._chartjs)
            }
        }

        var ne = function (e, t) {
            this.initialize(e, t)
        };
        N.extend(ne.prototype, {
            datasetElementType: null,
            dataElementType: null,
            _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth"],
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "pointStyle"],
            initialize: function (e, t) {
                var n = this;
                n.chart = e, n.index = t, n.linkScales(), n.addElements(), n._type = n.getMeta().type
            },
            updateIndex: function (e) {
                this.index = e
            },
            linkScales: function () {
                var e = this.getMeta(), t = this.chart, n = t.scales, i = this.getDataset(), r = t.options.scales;
                null !== e.xAxisID && e.xAxisID in n && !i.xAxisID || (e.xAxisID = i.xAxisID || r.xAxes[0].id), null !== e.yAxisID && e.yAxisID in n && !i.yAxisID || (e.yAxisID = i.yAxisID || r.yAxes[0].id)
            },
            getDataset: function () {
                return this.chart.data.datasets[this.index]
            },
            getMeta: function () {
                return this.chart.getDatasetMeta(this.index)
            },
            getScaleForId: function (e) {
                return this.chart.scales[e]
            },
            _getValueScaleId: function () {
                return this.getMeta().yAxisID
            },
            _getIndexScaleId: function () {
                return this.getMeta().xAxisID
            },
            _getValueScale: function () {
                return this.getScaleForId(this._getValueScaleId())
            },
            _getIndexScale: function () {
                return this.getScaleForId(this._getIndexScaleId())
            },
            reset: function () {
                this._update(!0)
            },
            destroy: function () {
                this._data && te(this._data, this)
            },
            createMetaDataset: function () {
                var e = this.datasetElementType;
                return e && new e({_chart: this.chart, _datasetIndex: this.index})
            },
            createMetaData: function (e) {
                var t = this.dataElementType;
                return t && new t({_chart: this.chart, _datasetIndex: this.index, _index: e})
            },
            addElements: function () {
                var e, t, n = this.getMeta(), i = this.getDataset().data || [], r = n.data;
                for (e = 0, t = i.length; e < t; ++e) r[e] = r[e] || this.createMetaData(e);
                n.dataset = n.dataset || this.createMetaDataset()
            },
            addElementAndReset: function (e) {
                var t = this.createMetaData(e);
                this.getMeta().data.splice(e, 0, t), this.updateElement(t, e, !0)
            },
            buildOrUpdateElements: function () {
                var e, t, n = this, i = n.getDataset(), r = i.data || (i.data = []);
                n._data !== r && (n._data && te(n._data, n), r && Object.isExtensible(r) && (t = n, (e = r)._chartjs ? e._chartjs.listeners.push(t) : (Object.defineProperty(e, "_chartjs", {
                    configurable: !0,
                    enumerable: !1,
                    value: {listeners: [t]}
                }), ee.forEach((function (t) {
                    var n = "onData" + t.charAt(0).toUpperCase() + t.slice(1), i = e[t];
                    Object.defineProperty(e, t, {
                        configurable: !0, enumerable: !1, value: function () {
                            var t = Array.prototype.slice.call(arguments), r = i.apply(this, t);
                            return N.each(e._chartjs.listeners, (function (e) {
                                "function" == typeof e[n] && e[n].apply(e, t)
                            })), r
                        }
                    })
                })))), n._data = r), n.resyncElements()
            },
            _configure: function () {
                this._config = N.merge(Object.create(null), [this.chart.options.datasets[this._type], this.getDataset()], {
                    merger: function (e, t, n) {
                        "_meta" !== e && "data" !== e && N._merger(e, t, n)
                    }
                })
            },
            _update: function (e) {
                this._configure(), this._cachedDataOpts = null, this.update(e)
            },
            update: N.noop,
            transition: function (e) {
                for (var t = this.getMeta(), n = t.data || [], i = n.length, r = 0; r < i; ++r) n[r].transition(e);
                t.dataset && t.dataset.transition(e)
            },
            draw: function () {
                var e = this.getMeta(), t = e.data || [], n = t.length, i = 0;
                for (e.dataset && e.dataset.draw(); i < n; ++i) t[i].draw()
            },
            getStyle: function (e) {
                var t, n = this.getMeta(), i = n.dataset;
                return this._configure(), i && void 0 === e ? t = this._resolveDatasetElementOptions(i || {}) : (e = e || 0, t = this._resolveDataElementOptions(n.data[e] || {}, e)), !1 !== t.fill && null !== t.fill || (t.backgroundColor = t.borderColor), t
            },
            _resolveDatasetElementOptions: function (e, t) {
                var n, i, r, o, a = this, s = a.chart, l = a._config, c = e.custom || {},
                    u = s.options.elements[a.datasetElementType.prototype._type] || {}, d = a._datasetElementOptions,
                    h = {}, p = {chart: s, dataset: a.getDataset(), datasetIndex: a.index, hover: t};
                for (n = 0, i = d.length; n < i; ++n) r = d[n], o = t ? "hover" + r.charAt(0).toUpperCase() + r.slice(1) : r, h[r] = Q([c[o], l[o], u[o]], p);
                return h
            },
            _resolveDataElementOptions: function (e, t) {
                var n = this, i = e && e.custom, r = n._cachedDataOpts;
                if (r && !i) return r;
                var o, a, s, l, c = n.chart, u = n._config,
                    d = c.options.elements[n.dataElementType.prototype._type] || {}, h = n._dataElementOptions, p = {},
                    f = {chart: c, dataIndex: t, dataset: n.getDataset(), datasetIndex: n.index}, m = {cacheable: !i};
                if (i = i || {}, N.isArray(h)) for (a = 0, s = h.length; a < s; ++a) p[l = h[a]] = Q([i[l], u[l], d[l]], f, t, m); else for (a = 0, s = (o = Object.keys(h)).length; a < s; ++a) p[l = o[a]] = Q([i[l], u[h[l]], u[l], d[l]], f, t, m);
                return m.cacheable && (n._cachedDataOpts = Object.freeze(p)), p
            },
            removeHoverStyle: function (e) {
                N.merge(e._model, e.$previousStyle || {}), delete e.$previousStyle
            },
            setHoverStyle: function (e) {
                var t = this.chart.data.datasets[e._datasetIndex], n = e._index, i = e.custom || {}, r = e._model,
                    o = N.getHoverColor;
                e.$previousStyle = {
                    backgroundColor: r.backgroundColor,
                    borderColor: r.borderColor,
                    borderWidth: r.borderWidth
                }, r.backgroundColor = Q([i.hoverBackgroundColor, t.hoverBackgroundColor, o(r.backgroundColor)], void 0, n), r.borderColor = Q([i.hoverBorderColor, t.hoverBorderColor, o(r.borderColor)], void 0, n), r.borderWidth = Q([i.hoverBorderWidth, t.hoverBorderWidth, r.borderWidth], void 0, n)
            },
            _removeDatasetHoverStyle: function () {
                var e = this.getMeta().dataset;
                e && this.removeHoverStyle(e)
            },
            _setDatasetHoverStyle: function () {
                var e, t, n, i, r, o, a = this.getMeta().dataset, s = {};
                if (a) {
                    for (o = a._model, r = this._resolveDatasetElementOptions(a, !0), e = 0, t = (i = Object.keys(r)).length; e < t; ++e) s[n = i[e]] = o[n], o[n] = r[n];
                    a.$previousStyle = s
                }
            },
            resyncElements: function () {
                var e = this.getMeta(), t = this.getDataset().data, n = e.data.length, i = t.length;
                i < n ? e.data.splice(i, n - i) : i > n && this.insertElements(n, i - n)
            },
            insertElements: function (e, t) {
                for (var n = 0; n < t; ++n) this.addElementAndReset(e + n)
            },
            onDataPush: function () {
                var e = arguments.length;
                this.insertElements(this.getDataset().data.length - e, e)
            },
            onDataPop: function () {
                this.getMeta().data.pop()
            },
            onDataShift: function () {
                this.getMeta().data.shift()
            },
            onDataSplice: function (e, t) {
                this.getMeta().data.splice(e, t), this.insertElements(e, arguments.length - 2)
            },
            onDataUnshift: function () {
                this.insertElements(0, arguments.length)
            }
        }), ne.extend = N.inherits;
        var ie = ne, re = 2 * Math.PI;

        function oe(e, t) {
            var n = t.startAngle, i = t.endAngle, r = t.pixelMargin, o = r / t.outerRadius, a = t.x, s = t.y;
            e.beginPath(), e.arc(a, s, t.outerRadius, n - o, i + o), t.innerRadius > r ? (o = r / t.innerRadius, e.arc(a, s, t.innerRadius - r, i + o, n - o, !0)) : e.arc(a, s, r, i + Math.PI / 2, n - Math.PI / 2), e.closePath(), e.clip()
        }

        function ae(e, t, n) {
            var i = "inner" === t.borderAlign;
            i ? (e.lineWidth = 2 * t.borderWidth, e.lineJoin = "round") : (e.lineWidth = t.borderWidth, e.lineJoin = "bevel"), n.fullCircles && function (e, t, n, i) {
                var r, o = n.endAngle;
                for (i && (n.endAngle = n.startAngle + re, oe(e, n), n.endAngle = o, n.endAngle === n.startAngle && n.fullCircles && (n.endAngle += re, n.fullCircles--)), e.beginPath(), e.arc(n.x, n.y, n.innerRadius, n.startAngle + re, n.startAngle, !0), r = 0; r < n.fullCircles; ++r) e.stroke();
                for (e.beginPath(), e.arc(n.x, n.y, t.outerRadius, n.startAngle, n.startAngle + re), r = 0; r < n.fullCircles; ++r) e.stroke()
            }(e, t, n, i), i && oe(e, n), e.beginPath(), e.arc(n.x, n.y, t.outerRadius, n.startAngle, n.endAngle), e.arc(n.x, n.y, n.innerRadius, n.endAngle, n.startAngle, !0), e.closePath(), e.stroke()
        }

        O._set("global", {
            elements: {
                arc: {
                    backgroundColor: O.global.defaultColor,
                    borderColor: "#fff",
                    borderWidth: 2,
                    borderAlign: "center"
                }
            }
        });
        var se = $.extend({
            _type: "arc", inLabelRange: function (e) {
                var t = this._view;
                return !!t && Math.pow(e - t.x, 2) < Math.pow(t.radius + t.hoverRadius, 2)
            }, inRange: function (e, t) {
                var n = this._view;
                if (n) {
                    for (var i = N.getAngleFromPoint(n, {
                        x: e,
                        y: t
                    }), r = i.angle, o = i.distance, a = n.startAngle, s = n.endAngle; s < a;) s += re;
                    for (; r > s;) r -= re;
                    for (; r < a;) r += re;
                    var l = r >= a && r <= s, c = o >= n.innerRadius && o <= n.outerRadius;
                    return l && c
                }
                return !1
            }, getCenterPoint: function () {
                var e = this._view, t = (e.startAngle + e.endAngle) / 2, n = (e.innerRadius + e.outerRadius) / 2;
                return {x: e.x + Math.cos(t) * n, y: e.y + Math.sin(t) * n}
            }, getArea: function () {
                var e = this._view;
                return Math.PI * ((e.endAngle - e.startAngle) / (2 * Math.PI)) * (Math.pow(e.outerRadius, 2) - Math.pow(e.innerRadius, 2))
            }, tooltipPosition: function () {
                var e = this._view, t = e.startAngle + (e.endAngle - e.startAngle) / 2,
                    n = (e.outerRadius - e.innerRadius) / 2 + e.innerRadius;
                return {x: e.x + Math.cos(t) * n, y: e.y + Math.sin(t) * n}
            }, draw: function () {
                var e, t = this._chart.ctx, n = this._view, i = "inner" === n.borderAlign ? .33 : 0, r = {
                    x: n.x,
                    y: n.y,
                    innerRadius: n.innerRadius,
                    outerRadius: Math.max(n.outerRadius - i, 0),
                    pixelMargin: i,
                    startAngle: n.startAngle,
                    endAngle: n.endAngle,
                    fullCircles: Math.floor(n.circumference / re)
                };
                if (t.save(), t.fillStyle = n.backgroundColor, t.strokeStyle = n.borderColor, r.fullCircles) {
                    for (r.endAngle = r.startAngle + re, t.beginPath(), t.arc(r.x, r.y, r.outerRadius, r.startAngle, r.endAngle), t.arc(r.x, r.y, r.innerRadius, r.endAngle, r.startAngle, !0), t.closePath(), e = 0; e < r.fullCircles; ++e) t.fill();
                    r.endAngle = r.startAngle + n.circumference % re
                }
                t.beginPath(), t.arc(r.x, r.y, r.outerRadius, r.startAngle, r.endAngle), t.arc(r.x, r.y, r.innerRadius, r.endAngle, r.startAngle, !0), t.closePath(), t.fill(), n.borderWidth && ae(t, n, r), t.restore()
            }
        }), le = N.valueOrDefault, ce = O.global.defaultColor;
        O._set("global", {
            elements: {
                line: {
                    tension: .4,
                    backgroundColor: ce,
                    borderWidth: 3,
                    borderColor: ce,
                    borderCapStyle: "butt",
                    borderDash: [],
                    borderDashOffset: 0,
                    borderJoinStyle: "miter",
                    capBezierPoints: !0,
                    fill: !0
                }
            }
        });
        var ue = $.extend({
            _type: "line", draw: function () {
                var e, t, n, i = this, r = i._view, o = i._chart.ctx, a = r.spanGaps, s = i._children.slice(),
                    l = O.global, c = l.elements.line, u = -1, d = i._loop;
                if (s.length) {
                    if (i._loop) {
                        for (e = 0; e < s.length; ++e) if (t = N.previousItem(s, e), !s[e]._view.skip && t._view.skip) {
                            s = s.slice(e).concat(s.slice(0, e)), d = a;
                            break
                        }
                        d && s.push(s[0])
                    }
                    for (o.save(), o.lineCap = r.borderCapStyle || c.borderCapStyle, o.setLineDash && o.setLineDash(r.borderDash || c.borderDash), o.lineDashOffset = le(r.borderDashOffset, c.borderDashOffset), o.lineJoin = r.borderJoinStyle || c.borderJoinStyle, o.lineWidth = le(r.borderWidth, c.borderWidth), o.strokeStyle = r.borderColor || l.defaultColor, o.beginPath(), (n = s[0]._view).skip || (o.moveTo(n.x, n.y), u = 0), e = 1; e < s.length; ++e) n = s[e]._view, t = -1 === u ? N.previousItem(s, e) : s[u], n.skip || (u !== e - 1 && !a || -1 === u ? o.moveTo(n.x, n.y) : N.canvas.lineTo(o, t._view, n), u = e);
                    d && o.closePath(), o.stroke(), o.restore()
                }
            }
        }), de = N.valueOrDefault, he = O.global.defaultColor;

        function pe(e) {
            var t = this._view;
            return !!t && Math.abs(e - t.x) < t.radius + t.hitRadius
        }

        O._set("global", {
            elements: {
                point: {
                    radius: 3,
                    pointStyle: "circle",
                    backgroundColor: he,
                    borderColor: he,
                    borderWidth: 1,
                    hitRadius: 1,
                    hoverRadius: 4,
                    hoverBorderWidth: 1
                }
            }
        });
        var fe = $.extend({
            _type: "point", inRange: function (e, t) {
                var n = this._view;
                return !!n && Math.pow(e - n.x, 2) + Math.pow(t - n.y, 2) < Math.pow(n.hitRadius + n.radius, 2)
            }, inLabelRange: pe, inXRange: pe, inYRange: function (e) {
                var t = this._view;
                return !!t && Math.abs(e - t.y) < t.radius + t.hitRadius
            }, getCenterPoint: function () {
                var e = this._view;
                return {x: e.x, y: e.y}
            }, getArea: function () {
                return Math.PI * Math.pow(this._view.radius, 2)
            }, tooltipPosition: function () {
                var e = this._view;
                return {x: e.x, y: e.y, padding: e.radius + e.borderWidth}
            }, draw: function (e) {
                var t = this._view, n = this._chart.ctx, i = t.pointStyle, r = t.rotation, o = t.radius, a = t.x,
                    s = t.y, l = O.global, c = l.defaultColor;
                t.skip || (void 0 === e || N.canvas._isPointInArea(t, e)) && (n.strokeStyle = t.borderColor || c, n.lineWidth = de(t.borderWidth, l.elements.point.borderWidth), n.fillStyle = t.backgroundColor || c, N.canvas.drawPoint(n, i, o, a, s, r))
            }
        }), me = O.global.defaultColor;

        function _e(e) {
            return e && void 0 !== e.width
        }

        function ge(e) {
            var t, n, i, r, o;
            return _e(e) ? (o = e.width / 2, t = e.x - o, n = e.x + o, i = Math.min(e.y, e.base), r = Math.max(e.y, e.base)) : (o = e.height / 2, t = Math.min(e.x, e.base), n = Math.max(e.x, e.base), i = e.y - o, r = e.y + o), {
                left: t,
                top: i,
                right: n,
                bottom: r
            }
        }

        function ye(e, t, n) {
            return e === t ? n : e === n ? t : e
        }

        function ve(e, t, n) {
            var i, r, o, a, s = e.borderWidth, l = function (e) {
                var t = e.borderSkipped, n = {};
                return t ? (e.horizontal ? e.base > e.x && (t = ye(t, "left", "right")) : e.base < e.y && (t = ye(t, "bottom", "top")), n[t] = !0, n) : n
            }(e);
            return N.isObject(s) ? (i = +s.top || 0, r = +s.right || 0, o = +s.bottom || 0, a = +s.left || 0) : i = r = o = a = +s || 0, {
                t: l.top || i < 0 ? 0 : i > n ? n : i,
                r: l.right || r < 0 ? 0 : r > t ? t : r,
                b: l.bottom || o < 0 ? 0 : o > n ? n : o,
                l: l.left || a < 0 ? 0 : a > t ? t : a
            }
        }

        function xe(e, t, n) {
            var i = null === t, r = null === n, o = !(!e || i && r) && ge(e);
            return o && (i || t >= o.left && t <= o.right) && (r || n >= o.top && n <= o.bottom)
        }

        O._set("global", {
            elements: {
                rectangle: {
                    backgroundColor: me,
                    borderColor: me,
                    borderSkipped: "bottom",
                    borderWidth: 0
                }
            }
        });
        var be = $.extend({
            _type: "rectangle", draw: function () {
                var e = this._chart.ctx, t = this._view, n = function (e) {
                    var t = ge(e), n = t.right - t.left, i = t.bottom - t.top, r = ve(e, n / 2, i / 2);
                    return {
                        outer: {x: t.left, y: t.top, w: n, h: i},
                        inner: {x: t.left + r.l, y: t.top + r.t, w: n - r.l - r.r, h: i - r.t - r.b}
                    }
                }(t), i = n.outer, r = n.inner;
                e.fillStyle = t.backgroundColor, e.fillRect(i.x, i.y, i.w, i.h), i.w === r.w && i.h === r.h || (e.save(), e.beginPath(), e.rect(i.x, i.y, i.w, i.h), e.clip(), e.fillStyle = t.borderColor, e.rect(r.x, r.y, r.w, r.h), e.fill("evenodd"), e.restore())
            }, height: function () {
                var e = this._view;
                return e.base - e.y
            }, inRange: function (e, t) {
                return xe(this._view, e, t)
            }, inLabelRange: function (e, t) {
                var n = this._view;
                return _e(n) ? xe(n, e, null) : xe(n, null, t)
            }, inXRange: function (e) {
                return xe(this._view, e, null)
            }, inYRange: function (e) {
                return xe(this._view, null, e)
            }, getCenterPoint: function () {
                var e, t, n = this._view;
                return _e(n) ? (e = n.x, t = (n.y + n.base) / 2) : (e = (n.x + n.base) / 2, t = n.y), {x: e, y: t}
            }, getArea: function () {
                var e = this._view;
                return _e(e) ? e.width * Math.abs(e.y - e.base) : e.height * Math.abs(e.x - e.base)
            }, tooltipPosition: function () {
                var e = this._view;
                return {x: e.x, y: e.y}
            }
        }), we = {}, Me = se, Te = ue, ke = fe, Se = be;
        we.Arc = Me, we.Line = Te, we.Point = ke, we.Rectangle = Se;
        var De = N._deprecated, Le = N.valueOrDefault;

        function Ee(e, t, n) {
            var i, r, o = n.barThickness, a = t.stackCount, s = t.pixels[e], l = N.isNullOrUndef(o) ? function (e, t) {
                var n, i, r, o, a = e._length;
                for (r = 1, o = t.length; r < o; ++r) a = Math.min(a, Math.abs(t[r] - t[r - 1]));
                for (r = 0, o = e.getTicks().length; r < o; ++r) i = e.getPixelForTick(r), a = r > 0 ? Math.min(a, Math.abs(i - n)) : a, n = i;
                return a
            }(t.scale, t.pixels) : -1;
            return N.isNullOrUndef(o) ? (i = l * n.categoryPercentage, r = n.barPercentage) : (i = o * a, r = 1), {
                chunk: i / a,
                ratio: r,
                start: s - i / 2
            }
        }

        O._set("bar", {
            hover: {mode: "label"},
            scales: {
                xAxes: [{type: "category", offset: !0, gridLines: {offsetGridLines: !0}}],
                yAxes: [{type: "linear"}]
            }
        }), O._set("global", {datasets: {bar: {categoryPercentage: .8, barPercentage: .9}}});
        var Ce = ie.extend({
            dataElementType: we.Rectangle,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength"],
            initialize: function () {
                var e, t, n = this;
                ie.prototype.initialize.apply(n, arguments), (e = n.getMeta()).stack = n.getDataset().stack, e.bar = !0, t = n._getIndexScale().options, De("bar chart", t.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage"), De("bar chart", t.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness"), De("bar chart", t.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage"), De("bar chart", n._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength"), De("bar chart", t.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness")
            },
            update: function (e) {
                var t, n, i = this.getMeta().data;
                for (this._ruler = this.getRuler(), t = 0, n = i.length; t < n; ++t) this.updateElement(i[t], t, e)
            },
            updateElement: function (e, t, n) {
                var i = this, r = i.getMeta(), o = i.getDataset(), a = i._resolveDataElementOptions(e, t);
                e._xScale = i.getScaleForId(r.xAxisID), e._yScale = i.getScaleForId(r.yAxisID), e._datasetIndex = i.index, e._index = t, e._model = {
                    backgroundColor: a.backgroundColor,
                    borderColor: a.borderColor,
                    borderSkipped: a.borderSkipped,
                    borderWidth: a.borderWidth,
                    datasetLabel: o.label,
                    label: i.chart.data.labels[t]
                }, N.isArray(o.data[t]) && (e._model.borderSkipped = null), i._updateElementGeometry(e, t, n, a), e.pivot()
            },
            _updateElementGeometry: function (e, t, n, i) {
                var r = this, o = e._model, a = r._getValueScale(), s = a.getBasePixel(), l = a.isHorizontal(),
                    c = r._ruler || r.getRuler(), u = r.calculateBarValuePixels(r.index, t, i),
                    d = r.calculateBarIndexPixels(r.index, t, c, i);
                o.horizontal = l, o.base = n ? s : u.base, o.x = l ? n ? s : u.head : d.center, o.y = l ? d.center : n ? s : u.head, o.height = l ? d.size : void 0, o.width = l ? void 0 : d.size
            },
            _getStacks: function (e) {
                var t, n, i = this._getIndexScale(), r = i._getMatchingVisibleMetas(this._type), o = i.options.stacked,
                    a = r.length, s = [];
                for (t = 0; t < a && (n = r[t], (!1 === o || -1 === s.indexOf(n.stack) || void 0 === o && void 0 === n.stack) && s.push(n.stack), n.index !== e); ++t) ;
                return s
            },
            getStackCount: function () {
                return this._getStacks().length
            },
            getStackIndex: function (e, t) {
                var n = this._getStacks(e), i = void 0 !== t ? n.indexOf(t) : -1;
                return -1 === i ? n.length - 1 : i
            },
            getRuler: function () {
                var e, t, n = this._getIndexScale(), i = [];
                for (e = 0, t = this.getMeta().data.length; e < t; ++e) i.push(n.getPixelForValue(null, e, this.index));
                return {pixels: i, start: n._startPixel, end: n._endPixel, stackCount: this.getStackCount(), scale: n}
            },
            calculateBarValuePixels: function (e, t, n) {
                var i, r, o, a, s, l, c, u = this.chart, d = this._getValueScale(), h = d.isHorizontal(),
                    p = u.data.datasets, f = d._getMatchingVisibleMetas(this._type), m = d._parseValue(p[e].data[t]),
                    _ = n.minBarLength, g = d.options.stacked, y = this.getMeta().stack,
                    v = void 0 === m.start ? 0 : m.max >= 0 && m.min >= 0 ? m.min : m.max,
                    x = void 0 === m.start ? m.end : m.max >= 0 && m.min >= 0 ? m.max - m.min : m.min - m.max,
                    b = f.length;
                if (g || void 0 === g && void 0 !== y) for (i = 0; i < b && (r = f[i]).index !== e; ++i) r.stack === y && (o = void 0 === (c = d._parseValue(p[r.index].data[t])).start ? c.end : c.min >= 0 && c.max >= 0 ? c.max : c.min, (m.min < 0 && o < 0 || m.max >= 0 && o > 0) && (v += o));
                return a = d.getPixelForValue(v), l = (s = d.getPixelForValue(v + x)) - a, void 0 !== _ && Math.abs(l) < _ && (l = _, s = x >= 0 && !h || x < 0 && h ? a - _ : a + _), {
                    size: l,
                    base: a,
                    head: s,
                    center: s + l / 2
                }
            },
            calculateBarIndexPixels: function (e, t, n, i) {
                var r = "flex" === i.barThickness ? function (e, t, n) {
                        var i, r = t.pixels, o = r[e], a = e > 0 ? r[e - 1] : null, s = e < r.length - 1 ? r[e + 1] : null,
                            l = n.categoryPercentage;
                        return null === a && (a = o - (null === s ? t.end - t.start : s - o)), null === s && (s = o + o - a), i = o - (o - Math.min(a, s)) / 2 * l, {
                            chunk: Math.abs(s - a) / 2 * l / t.stackCount,
                            ratio: n.barPercentage,
                            start: i
                        }
                    }(t, n, i) : Ee(t, n, i), o = this.getStackIndex(e, this.getMeta().stack),
                    a = r.start + r.chunk * o + r.chunk / 2,
                    s = Math.min(Le(i.maxBarThickness, 1 / 0), r.chunk * r.ratio);
                return {base: a - s / 2, head: a + s / 2, center: a, size: s}
            },
            draw: function () {
                var e = this.chart, t = this._getValueScale(), n = this.getMeta().data, i = this.getDataset(),
                    r = n.length, o = 0;
                for (N.canvas.clipArea(e.ctx, e.chartArea); o < r; ++o) {
                    var a = t._parseValue(i.data[o]);
                    isNaN(a.min) || isNaN(a.max) || n[o].draw()
                }
                N.canvas.unclipArea(e.ctx)
            },
            _resolveDataElementOptions: function () {
                var e = this, t = N.extend({}, ie.prototype._resolveDataElementOptions.apply(e, arguments)),
                    n = e._getIndexScale().options, i = e._getValueScale().options;
                return t.barPercentage = Le(n.barPercentage, t.barPercentage), t.barThickness = Le(n.barThickness, t.barThickness), t.categoryPercentage = Le(n.categoryPercentage, t.categoryPercentage), t.maxBarThickness = Le(n.maxBarThickness, t.maxBarThickness), t.minBarLength = Le(i.minBarLength, t.minBarLength), t
            }
        }), Ae = N.valueOrDefault, Ie = N.options.resolve;
        O._set("bubble", {
            hover: {mode: "single"},
            scales: {
                xAxes: [{type: "linear", position: "bottom", id: "x-axis-0"}],
                yAxes: [{type: "linear", position: "left", id: "y-axis-0"}]
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (e, t) {
                        var n = t.datasets[e.datasetIndex].label || "", i = t.datasets[e.datasetIndex].data[e.index];
                        return n + ": (" + e.xLabel + ", " + e.yLabel + ", " + i.r + ")"
                    }
                }
            }
        });
        var Pe = ie.extend({
            dataElementType: we.Point,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"],
            update: function (e) {
                var t = this, n = t.getMeta().data;
                N.each(n, (function (n, i) {
                    t.updateElement(n, i, e)
                }))
            },
            updateElement: function (e, t, n) {
                var i = this, r = i.getMeta(), o = e.custom || {}, a = i.getScaleForId(r.xAxisID),
                    s = i.getScaleForId(r.yAxisID), l = i._resolveDataElementOptions(e, t), c = i.getDataset().data[t],
                    u = i.index,
                    d = n ? a.getPixelForDecimal(.5) : a.getPixelForValue("object" == typeof c ? c : NaN, t, u),
                    h = n ? s.getBasePixel() : s.getPixelForValue(c, t, u);
                e._xScale = a, e._yScale = s, e._options = l, e._datasetIndex = u, e._index = t, e._model = {
                    backgroundColor: l.backgroundColor,
                    borderColor: l.borderColor,
                    borderWidth: l.borderWidth,
                    hitRadius: l.hitRadius,
                    pointStyle: l.pointStyle,
                    rotation: l.rotation,
                    radius: n ? 0 : l.radius,
                    skip: o.skip || isNaN(d) || isNaN(h),
                    x: d,
                    y: h
                }, e.pivot()
            },
            setHoverStyle: function (e) {
                var t = e._model, n = e._options, i = N.getHoverColor;
                e.$previousStyle = {
                    backgroundColor: t.backgroundColor,
                    borderColor: t.borderColor,
                    borderWidth: t.borderWidth,
                    radius: t.radius
                }, t.backgroundColor = Ae(n.hoverBackgroundColor, i(n.backgroundColor)), t.borderColor = Ae(n.hoverBorderColor, i(n.borderColor)), t.borderWidth = Ae(n.hoverBorderWidth, n.borderWidth), t.radius = n.radius + n.hoverRadius
            },
            _resolveDataElementOptions: function (e, t) {
                var n = this, i = n.chart, r = n.getDataset(), o = e.custom || {}, a = r.data[t] || {},
                    s = ie.prototype._resolveDataElementOptions.apply(n, arguments),
                    l = {chart: i, dataIndex: t, dataset: r, datasetIndex: n.index};
                return n._cachedDataOpts === s && (s = N.extend({}, s)), s.radius = Ie([o.radius, a.r, n._config.radius, i.options.elements.point.radius], l, t), s
            }
        }), Re = N.valueOrDefault, Ye = Math.PI, ze = 2 * Ye, Oe = Ye / 2;
        O._set("doughnut", {
            animation: {animateRotate: !0, animateScale: !1}, hover: {mode: "single"}, legendCallback: function (e) {
                var t, n, i, r = document.createElement("ul"), o = e.data, a = o.datasets, s = o.labels;
                if (r.setAttribute("class", e.id + "-legend"), a.length) for (t = 0, n = a[0].data.length; t < n; ++t) (i = r.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = a[0].backgroundColor[t], s[t] && i.appendChild(document.createTextNode(s[t]));
                return r.outerHTML
            }, legend: {
                labels: {
                    generateLabels: function (e) {
                        var t = e.data;
                        return t.labels.length && t.datasets.length ? t.labels.map((function (n, i) {
                            var r = e.getDatasetMeta(0), o = r.controller.getStyle(i);
                            return {
                                text: n,
                                fillStyle: o.backgroundColor,
                                strokeStyle: o.borderColor,
                                lineWidth: o.borderWidth,
                                hidden: isNaN(t.datasets[0].data[i]) || r.data[i].hidden,
                                index: i
                            }
                        })) : []
                    }
                }, onClick: function (e, t) {
                    var n, i, r, o = t.index, a = this.chart;
                    for (n = 0, i = (a.data.datasets || []).length; n < i; ++n) (r = a.getDatasetMeta(n)).data[o] && (r.data[o].hidden = !r.data[o].hidden);
                    a.update()
                }
            }, cutoutPercentage: 50, rotation: -Oe, circumference: ze, tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (e, t) {
                        var n = t.labels[e.index], i = ": " + t.datasets[e.datasetIndex].data[e.index];
                        return N.isArray(n) ? (n = n.slice())[0] += i : n += i, n
                    }
                }
            }
        });
        var Fe = ie.extend({
            dataElementType: we.Arc,
            linkScales: N.noop,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
            getRingIndex: function (e) {
                for (var t = 0, n = 0; n < e; ++n) this.chart.isDatasetVisible(n) && ++t;
                return t
            },
            update: function (e) {
                var t, n, i, r, o = this, a = o.chart, s = a.chartArea, l = a.options, c = 1, u = 1, d = 0, h = 0,
                    p = o.getMeta(), f = p.data, m = l.cutoutPercentage / 100 || 0, _ = l.circumference,
                    g = o._getRingWeight(o.index);
                if (_ < ze) {
                    var y = l.rotation % ze, v = (y += y >= Ye ? -ze : y < -Ye ? ze : 0) + _, x = Math.cos(y),
                        b = Math.sin(y), w = Math.cos(v), M = Math.sin(v), T = y <= 0 && v >= 0 || v >= ze,
                        k = y <= Oe && v >= Oe || v >= ze + Oe, S = y <= -Oe && v >= -Oe || v >= Ye + Oe,
                        D = y === -Ye || v >= Ye ? -1 : Math.min(x, x * m, w, w * m),
                        L = S ? -1 : Math.min(b, b * m, M, M * m), E = T ? 1 : Math.max(x, x * m, w, w * m),
                        C = k ? 1 : Math.max(b, b * m, M, M * m);
                    c = (E - D) / 2, u = (C - L) / 2, d = -(E + D) / 2, h = -(C + L) / 2
                }
                for (i = 0, r = f.length; i < r; ++i) f[i]._options = o._resolveDataElementOptions(f[i], i);
                for (a.borderWidth = o.getMaxBorderWidth(), t = (s.right - s.left - a.borderWidth) / c, n = (s.bottom - s.top - a.borderWidth) / u, a.outerRadius = Math.max(Math.min(t, n) / 2, 0), a.innerRadius = Math.max(a.outerRadius * m, 0), a.radiusLength = (a.outerRadius - a.innerRadius) / (o._getVisibleDatasetWeightTotal() || 1), a.offsetX = d * a.outerRadius, a.offsetY = h * a.outerRadius, p.total = o.calculateTotal(), o.outerRadius = a.outerRadius - a.radiusLength * o._getRingWeightOffset(o.index), o.innerRadius = Math.max(o.outerRadius - a.radiusLength * g, 0), i = 0, r = f.length; i < r; ++i) o.updateElement(f[i], i, e)
            },
            updateElement: function (e, t, n) {
                var i = this, r = i.chart, o = r.chartArea, a = r.options, s = a.animation, l = (o.left + o.right) / 2,
                    c = (o.top + o.bottom) / 2, u = a.rotation, d = a.rotation, h = i.getDataset(),
                    p = n && s.animateRotate || e.hidden ? 0 : i.calculateCircumference(h.data[t]) * (a.circumference / ze),
                    f = n && s.animateScale ? 0 : i.innerRadius, m = n && s.animateScale ? 0 : i.outerRadius,
                    _ = e._options || {};
                N.extend(e, {
                    _datasetIndex: i.index,
                    _index: t,
                    _model: {
                        backgroundColor: _.backgroundColor,
                        borderColor: _.borderColor,
                        borderWidth: _.borderWidth,
                        borderAlign: _.borderAlign,
                        x: l + r.offsetX,
                        y: c + r.offsetY,
                        startAngle: u,
                        endAngle: d,
                        circumference: p,
                        outerRadius: m,
                        innerRadius: f,
                        label: N.valueAtIndexOrDefault(h.label, t, r.data.labels[t])
                    }
                });
                var g = e._model;
                n && s.animateRotate || (g.startAngle = 0 === t ? a.rotation : i.getMeta().data[t - 1]._model.endAngle, g.endAngle = g.startAngle + g.circumference), e.pivot()
            },
            calculateTotal: function () {
                var e, t = this.getDataset(), n = this.getMeta(), i = 0;
                return N.each(n.data, (function (n, r) {
                    e = t.data[r], isNaN(e) || n.hidden || (i += Math.abs(e))
                })), i
            },
            calculateCircumference: function (e) {
                var t = this.getMeta().total;
                return t > 0 && !isNaN(e) ? ze * (Math.abs(e) / t) : 0
            },
            getMaxBorderWidth: function (e) {
                var t, n, i, r, o, a, s, l, c = 0, u = this.chart;
                if (!e) for (t = 0, n = u.data.datasets.length; t < n; ++t) if (u.isDatasetVisible(t)) {
                    e = (i = u.getDatasetMeta(t)).data, t !== this.index && (o = i.controller);
                    break
                }
                if (!e) return 0;
                for (t = 0, n = e.length; t < n; ++t) r = e[t], o ? (o._configure(), a = o._resolveDataElementOptions(r, t)) : a = r._options, "inner" !== a.borderAlign && (s = a.borderWidth, c = (l = a.hoverBorderWidth) > (c = s > c ? s : c) ? l : c);
                return c
            },
            setHoverStyle: function (e) {
                var t = e._model, n = e._options, i = N.getHoverColor;
                e.$previousStyle = {
                    backgroundColor: t.backgroundColor,
                    borderColor: t.borderColor,
                    borderWidth: t.borderWidth
                }, t.backgroundColor = Re(n.hoverBackgroundColor, i(n.backgroundColor)), t.borderColor = Re(n.hoverBorderColor, i(n.borderColor)), t.borderWidth = Re(n.hoverBorderWidth, n.borderWidth)
            },
            _getRingWeightOffset: function (e) {
                for (var t = 0, n = 0; n < e; ++n) this.chart.isDatasetVisible(n) && (t += this._getRingWeight(n));
                return t
            },
            _getRingWeight: function (e) {
                return Math.max(Re(this.chart.data.datasets[e].weight, 1), 0)
            },
            _getVisibleDatasetWeightTotal: function () {
                return this._getRingWeightOffset(this.chart.data.datasets.length)
            }
        });
        O._set("horizontalBar", {
            hover: {mode: "index", axis: "y"},
            scales: {
                xAxes: [{type: "linear", position: "bottom"}],
                yAxes: [{type: "category", position: "left", offset: !0, gridLines: {offsetGridLines: !0}}]
            },
            elements: {rectangle: {borderSkipped: "left"}},
            tooltips: {mode: "index", axis: "y"}
        }), O._set("global", {datasets: {horizontalBar: {categoryPercentage: .8, barPercentage: .9}}});
        var Be = Ce.extend({
            _getValueScaleId: function () {
                return this.getMeta().xAxisID
            }, _getIndexScaleId: function () {
                return this.getMeta().yAxisID
            }
        }), je = N.valueOrDefault, He = N.options.resolve, Ne = N.canvas._isPointInArea;

        function Ue(e, t) {
            var n = e && e.options.ticks || {}, i = n.reverse, r = void 0 === n.min ? t : 0,
                o = void 0 === n.max ? t : 0;
            return {start: i ? o : r, end: i ? r : o}
        }

        function We(e, t, n) {
            var i = n / 2, r = Ue(e, i), o = Ue(t, i);
            return {top: o.end, right: r.end, bottom: o.start, left: r.start}
        }

        function Ve(e) {
            var t, n, i, r;
            return N.isObject(e) ? (t = e.top, n = e.right, i = e.bottom, r = e.left) : t = n = i = r = e, {
                top: t,
                right: n,
                bottom: i,
                left: r
            }
        }

        O._set("line", {
            showLines: !0,
            spanGaps: !1,
            hover: {mode: "label"},
            scales: {xAxes: [{type: "category", id: "x-axis-0"}], yAxes: [{type: "linear", id: "y-axis-0"}]}
        });
        var Ge = ie.extend({
            datasetElementType: we.Line,
            dataElementType: we.Point,
            _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill"],
            _dataElementOptions: {
                backgroundColor: "pointBackgroundColor",
                borderColor: "pointBorderColor",
                borderWidth: "pointBorderWidth",
                hitRadius: "pointHitRadius",
                hoverBackgroundColor: "pointHoverBackgroundColor",
                hoverBorderColor: "pointHoverBorderColor",
                hoverBorderWidth: "pointHoverBorderWidth",
                hoverRadius: "pointHoverRadius",
                pointStyle: "pointStyle",
                radius: "pointRadius",
                rotation: "pointRotation"
            },
            update: function (e) {
                var t, n, i = this, r = i.getMeta(), o = r.dataset, a = r.data || [], s = i.chart.options,
                    l = i._config, c = i._showLine = je(l.showLine, s.showLines);
                for (i._xScale = i.getScaleForId(r.xAxisID), i._yScale = i.getScaleForId(r.yAxisID), c && (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = i._yScale, o._datasetIndex = i.index, o._children = a, o._model = i._resolveDatasetElementOptions(o), o.pivot()), t = 0, n = a.length; t < n; ++t) i.updateElement(a[t], t, e);
                for (c && 0 !== o._model.tension && i.updateBezierControlPoints(), t = 0, n = a.length; t < n; ++t) a[t].pivot()
            },
            updateElement: function (e, t, n) {
                var i, r, o = this, a = o.getMeta(), s = e.custom || {}, l = o.getDataset(), c = o.index, u = l.data[t],
                    d = o._xScale, h = o._yScale, p = a.dataset._model, f = o._resolveDataElementOptions(e, t);
                i = d.getPixelForValue("object" == typeof u ? u : NaN, t, c), r = n ? h.getBasePixel() : o.calculatePointY(u, t, c), e._xScale = d, e._yScale = h, e._options = f, e._datasetIndex = c, e._index = t, e._model = {
                    x: i,
                    y: r,
                    skip: s.skip || isNaN(i) || isNaN(r),
                    radius: f.radius,
                    pointStyle: f.pointStyle,
                    rotation: f.rotation,
                    backgroundColor: f.backgroundColor,
                    borderColor: f.borderColor,
                    borderWidth: f.borderWidth,
                    tension: je(s.tension, p ? p.tension : 0),
                    steppedLine: !!p && p.steppedLine,
                    hitRadius: f.hitRadius
                }
            },
            _resolveDatasetElementOptions: function (e) {
                var t = this, n = t._config, i = e.custom || {}, r = t.chart.options, o = r.elements.line,
                    a = ie.prototype._resolveDatasetElementOptions.apply(t, arguments);
                return a.spanGaps = je(n.spanGaps, r.spanGaps), a.tension = je(n.lineTension, o.tension), a.steppedLine = He([i.steppedLine, n.steppedLine, o.stepped]), a.clip = Ve(je(n.clip, We(t._xScale, t._yScale, a.borderWidth))), a
            },
            calculatePointY: function (e, t, n) {
                var i, r, o, a, s, l, c, u = this.chart, d = this._yScale, h = 0, p = 0;
                if (d.options.stacked) {
                    for (s = +d.getRightValue(e), c = (l = u._getSortedVisibleDatasetMetas()).length, i = 0; i < c && (o = l[i]).index !== n; ++i) r = u.data.datasets[o.index], "line" === o.type && o.yAxisID === d.id && ((a = +d.getRightValue(r.data[t])) < 0 ? p += a || 0 : h += a || 0);
                    return s < 0 ? d.getPixelForValue(p + s) : d.getPixelForValue(h + s)
                }
                return d.getPixelForValue(e)
            },
            updateBezierControlPoints: function () {
                var e, t, n, i, r = this.chart, o = this.getMeta(), a = o.dataset._model, s = r.chartArea,
                    l = o.data || [];

                function c(e, t, n) {
                    return Math.max(Math.min(e, n), t)
                }

                if (a.spanGaps && (l = l.filter((function (e) {
                    return !e._model.skip
                }))), "monotone" === a.cubicInterpolationMode) N.splineCurveMonotone(l); else for (e = 0, t = l.length; e < t; ++e) n = l[e]._model, i = N.splineCurve(N.previousItem(l, e)._model, n, N.nextItem(l, e)._model, a.tension), n.controlPointPreviousX = i.previous.x, n.controlPointPreviousY = i.previous.y, n.controlPointNextX = i.next.x, n.controlPointNextY = i.next.y;
                if (r.options.elements.line.capBezierPoints) for (e = 0, t = l.length; e < t; ++e) n = l[e]._model, Ne(n, s) && (e > 0 && Ne(l[e - 1]._model, s) && (n.controlPointPreviousX = c(n.controlPointPreviousX, s.left, s.right), n.controlPointPreviousY = c(n.controlPointPreviousY, s.top, s.bottom)), e < l.length - 1 && Ne(l[e + 1]._model, s) && (n.controlPointNextX = c(n.controlPointNextX, s.left, s.right), n.controlPointNextY = c(n.controlPointNextY, s.top, s.bottom)))
            },
            draw: function () {
                var e, t = this.chart, n = this.getMeta(), i = n.data || [], r = t.chartArea, o = t.canvas, a = 0,
                    s = i.length;
                for (this._showLine && (e = n.dataset._model.clip, N.canvas.clipArea(t.ctx, {
                    left: !1 === e.left ? 0 : r.left - e.left,
                    right: !1 === e.right ? o.width : r.right + e.right,
                    top: !1 === e.top ? 0 : r.top - e.top,
                    bottom: !1 === e.bottom ? o.height : r.bottom + e.bottom
                }), n.dataset.draw(), N.canvas.unclipArea(t.ctx)); a < s; ++a) i[a].draw(r)
            },
            setHoverStyle: function (e) {
                var t = e._model, n = e._options, i = N.getHoverColor;
                e.$previousStyle = {
                    backgroundColor: t.backgroundColor,
                    borderColor: t.borderColor,
                    borderWidth: t.borderWidth,
                    radius: t.radius
                }, t.backgroundColor = je(n.hoverBackgroundColor, i(n.backgroundColor)), t.borderColor = je(n.hoverBorderColor, i(n.borderColor)), t.borderWidth = je(n.hoverBorderWidth, n.borderWidth), t.radius = je(n.hoverRadius, n.radius)
            }
        }), qe = N.options.resolve;
        O._set("polarArea", {
            scale: {
                type: "radialLinear",
                angleLines: {display: !1},
                gridLines: {circular: !0},
                pointLabels: {display: !1},
                ticks: {beginAtZero: !0}
            },
            animation: {animateRotate: !0, animateScale: !0},
            startAngle: -.5 * Math.PI,
            legendCallback: function (e) {
                var t, n, i, r = document.createElement("ul"), o = e.data, a = o.datasets, s = o.labels;
                if (r.setAttribute("class", e.id + "-legend"), a.length) for (t = 0, n = a[0].data.length; t < n; ++t) (i = r.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = a[0].backgroundColor[t], s[t] && i.appendChild(document.createTextNode(s[t]));
                return r.outerHTML
            },
            legend: {
                labels: {
                    generateLabels: function (e) {
                        var t = e.data;
                        return t.labels.length && t.datasets.length ? t.labels.map((function (n, i) {
                            var r = e.getDatasetMeta(0), o = r.controller.getStyle(i);
                            return {
                                text: n,
                                fillStyle: o.backgroundColor,
                                strokeStyle: o.borderColor,
                                lineWidth: o.borderWidth,
                                hidden: isNaN(t.datasets[0].data[i]) || r.data[i].hidden,
                                index: i
                            }
                        })) : []
                    }
                }, onClick: function (e, t) {
                    var n, i, r, o = t.index, a = this.chart;
                    for (n = 0, i = (a.data.datasets || []).length; n < i; ++n) (r = a.getDatasetMeta(n)).data[o].hidden = !r.data[o].hidden;
                    a.update()
                }
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (e, t) {
                        return t.labels[e.index] + ": " + e.yLabel
                    }
                }
            }
        });
        var Ze = ie.extend({
            dataElementType: we.Arc,
            linkScales: N.noop,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
            _getIndexScaleId: function () {
                return this.chart.scale.id
            },
            _getValueScaleId: function () {
                return this.chart.scale.id
            },
            update: function (e) {
                var t, n, i, r = this, o = r.getDataset(), a = r.getMeta(), s = r.chart.options.startAngle || 0,
                    l = r._starts = [], c = r._angles = [], u = a.data;
                for (r._updateRadius(), a.count = r.countVisibleElements(), t = 0, n = o.data.length; t < n; t++) l[t] = s, i = r._computeAngle(t), c[t] = i, s += i;
                for (t = 0, n = u.length; t < n; ++t) u[t]._options = r._resolveDataElementOptions(u[t], t), r.updateElement(u[t], t, e)
            },
            _updateRadius: function () {
                var e = this, t = e.chart, n = t.chartArea, i = t.options,
                    r = Math.min(n.right - n.left, n.bottom - n.top);
                t.outerRadius = Math.max(r / 2, 0), t.innerRadius = Math.max(i.cutoutPercentage ? t.outerRadius / 100 * i.cutoutPercentage : 1, 0), t.radiusLength = (t.outerRadius - t.innerRadius) / t.getVisibleDatasetCount(), e.outerRadius = t.outerRadius - t.radiusLength * e.index, e.innerRadius = e.outerRadius - t.radiusLength
            },
            updateElement: function (e, t, n) {
                var i = this, r = i.chart, o = i.getDataset(), a = r.options, s = a.animation, l = r.scale,
                    c = r.data.labels, u = l.xCenter, d = l.yCenter, h = a.startAngle,
                    p = e.hidden ? 0 : l.getDistanceFromCenterForValue(o.data[t]), f = i._starts[t],
                    m = f + (e.hidden ? 0 : i._angles[t]),
                    _ = s.animateScale ? 0 : l.getDistanceFromCenterForValue(o.data[t]), g = e._options || {};
                N.extend(e, {
                    _datasetIndex: i.index,
                    _index: t,
                    _scale: l,
                    _model: {
                        backgroundColor: g.backgroundColor,
                        borderColor: g.borderColor,
                        borderWidth: g.borderWidth,
                        borderAlign: g.borderAlign,
                        x: u,
                        y: d,
                        innerRadius: 0,
                        outerRadius: n ? _ : p,
                        startAngle: n && s.animateRotate ? h : f,
                        endAngle: n && s.animateRotate ? h : m,
                        label: N.valueAtIndexOrDefault(c, t, c[t])
                    }
                }), e.pivot()
            },
            countVisibleElements: function () {
                var e = this.getDataset(), t = this.getMeta(), n = 0;
                return N.each(t.data, (function (t, i) {
                    isNaN(e.data[i]) || t.hidden || n++
                })), n
            },
            setHoverStyle: function (e) {
                var t = e._model, n = e._options, i = N.getHoverColor, r = N.valueOrDefault;
                e.$previousStyle = {
                    backgroundColor: t.backgroundColor,
                    borderColor: t.borderColor,
                    borderWidth: t.borderWidth
                }, t.backgroundColor = r(n.hoverBackgroundColor, i(n.backgroundColor)), t.borderColor = r(n.hoverBorderColor, i(n.borderColor)), t.borderWidth = r(n.hoverBorderWidth, n.borderWidth)
            },
            _computeAngle: function (e) {
                var t = this, n = this.getMeta().count, i = t.getDataset(), r = t.getMeta();
                if (isNaN(i.data[e]) || r.data[e].hidden) return 0;
                var o = {chart: t.chart, dataIndex: e, dataset: i, datasetIndex: t.index};
                return qe([t.chart.options.elements.arc.angle, 2 * Math.PI / n], o, e)
            }
        });
        O._set("pie", N.clone(O.doughnut)), O._set("pie", {cutoutPercentage: 0});
        var $e = Fe, Xe = N.valueOrDefault;
        O._set("radar", {spanGaps: !1, scale: {type: "radialLinear"}, elements: {line: {fill: "start", tension: 0}}});
        var Je = ie.extend({
            datasetElementType: we.Line,
            dataElementType: we.Point,
            linkScales: N.noop,
            _datasetElementOptions: ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"],
            _dataElementOptions: {
                backgroundColor: "pointBackgroundColor",
                borderColor: "pointBorderColor",
                borderWidth: "pointBorderWidth",
                hitRadius: "pointHitRadius",
                hoverBackgroundColor: "pointHoverBackgroundColor",
                hoverBorderColor: "pointHoverBorderColor",
                hoverBorderWidth: "pointHoverBorderWidth",
                hoverRadius: "pointHoverRadius",
                pointStyle: "pointStyle",
                radius: "pointRadius",
                rotation: "pointRotation"
            },
            _getIndexScaleId: function () {
                return this.chart.scale.id
            },
            _getValueScaleId: function () {
                return this.chart.scale.id
            },
            update: function (e) {
                var t, n, i = this, r = i.getMeta(), o = r.dataset, a = r.data || [], s = i.chart.scale, l = i._config;
                for (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = s, o._datasetIndex = i.index, o._children = a, o._loop = !0, o._model = i._resolveDatasetElementOptions(o), o.pivot(), t = 0, n = a.length; t < n; ++t) i.updateElement(a[t], t, e);
                for (i.updateBezierControlPoints(), t = 0, n = a.length; t < n; ++t) a[t].pivot()
            },
            updateElement: function (e, t, n) {
                var i = this, r = e.custom || {}, o = i.getDataset(), a = i.chart.scale,
                    s = a.getPointPositionForValue(t, o.data[t]), l = i._resolveDataElementOptions(e, t),
                    c = i.getMeta().dataset._model, u = n ? a.xCenter : s.x, d = n ? a.yCenter : s.y;
                e._scale = a, e._options = l, e._datasetIndex = i.index, e._index = t, e._model = {
                    x: u,
                    y: d,
                    skip: r.skip || isNaN(u) || isNaN(d),
                    radius: l.radius,
                    pointStyle: l.pointStyle,
                    rotation: l.rotation,
                    backgroundColor: l.backgroundColor,
                    borderColor: l.borderColor,
                    borderWidth: l.borderWidth,
                    tension: Xe(r.tension, c ? c.tension : 0),
                    hitRadius: l.hitRadius
                }
            },
            _resolveDatasetElementOptions: function () {
                var e = this, t = e._config, n = e.chart.options,
                    i = ie.prototype._resolveDatasetElementOptions.apply(e, arguments);
                return i.spanGaps = Xe(t.spanGaps, n.spanGaps), i.tension = Xe(t.lineTension, n.elements.line.tension), i
            },
            updateBezierControlPoints: function () {
                var e, t, n, i, r = this.getMeta(), o = this.chart.chartArea, a = r.data || [];

                function s(e, t, n) {
                    return Math.max(Math.min(e, n), t)
                }

                for (r.dataset._model.spanGaps && (a = a.filter((function (e) {
                    return !e._model.skip
                }))), e = 0, t = a.length; e < t; ++e) n = a[e]._model, i = N.splineCurve(N.previousItem(a, e, !0)._model, n, N.nextItem(a, e, !0)._model, n.tension), n.controlPointPreviousX = s(i.previous.x, o.left, o.right), n.controlPointPreviousY = s(i.previous.y, o.top, o.bottom), n.controlPointNextX = s(i.next.x, o.left, o.right), n.controlPointNextY = s(i.next.y, o.top, o.bottom)
            },
            setHoverStyle: function (e) {
                var t = e._model, n = e._options, i = N.getHoverColor;
                e.$previousStyle = {
                    backgroundColor: t.backgroundColor,
                    borderColor: t.borderColor,
                    borderWidth: t.borderWidth,
                    radius: t.radius
                }, t.backgroundColor = Xe(n.hoverBackgroundColor, i(n.backgroundColor)), t.borderColor = Xe(n.hoverBorderColor, i(n.borderColor)), t.borderWidth = Xe(n.hoverBorderWidth, n.borderWidth), t.radius = Xe(n.hoverRadius, n.radius)
            }
        });
        O._set("scatter", {
            hover: {mode: "single"},
            scales: {
                xAxes: [{id: "x-axis-1", type: "linear", position: "bottom"}],
                yAxes: [{id: "y-axis-1", type: "linear", position: "left"}]
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (e) {
                        return "(" + e.xLabel + ", " + e.yLabel + ")"
                    }
                }
            }
        }), O._set("global", {datasets: {scatter: {showLine: !1}}});
        var Ke = {
            bar: Ce,
            bubble: Pe,
            doughnut: Fe,
            horizontalBar: Be,
            line: Ge,
            polarArea: Ze,
            pie: $e,
            radar: Je,
            scatter: Ge
        };

        function Qe(e, t) {
            return e.native ? {x: e.x, y: e.y} : N.getRelativePosition(e, t)
        }

        function et(e, t) {
            var n, i, r, o, a, s, l = e._getSortedVisibleDatasetMetas();
            for (i = 0, o = l.length; i < o; ++i) for (r = 0, a = (n = l[i].data).length; r < a; ++r) (s = n[r])._view.skip || t(s)
        }

        function tt(e, t) {
            var n = [];
            return et(e, (function (e) {
                e.inRange(t.x, t.y) && n.push(e)
            })), n
        }

        function nt(e, t, n, i) {
            var r = Number.POSITIVE_INFINITY, o = [];
            return et(e, (function (e) {
                if (!n || e.inRange(t.x, t.y)) {
                    var a = e.getCenterPoint(), s = i(t, a);
                    s < r ? (o = [e], r = s) : s === r && o.push(e)
                }
            })), o
        }

        function it(e) {
            var t = -1 !== e.indexOf("x"), n = -1 !== e.indexOf("y");
            return function (e, i) {
                var r = t ? Math.abs(e.x - i.x) : 0, o = n ? Math.abs(e.y - i.y) : 0;
                return Math.sqrt(Math.pow(r, 2) + Math.pow(o, 2))
            }
        }

        function rt(e, t, n) {
            var i = Qe(t, e);
            n.axis = n.axis || "x";
            var r = it(n.axis), o = n.intersect ? tt(e, i) : nt(e, i, !1, r), a = [];
            return o.length ? (e._getSortedVisibleDatasetMetas().forEach((function (e) {
                var t = e.data[o[0]._index];
                t && !t._view.skip && a.push(t)
            })), a) : []
        }

        var ot = {
            modes: {
                single: function (e, t) {
                    var n = Qe(t, e), i = [];
                    return et(e, (function (e) {
                        if (e.inRange(n.x, n.y)) return i.push(e), i
                    })), i.slice(0, 1)
                }, label: rt, index: rt, dataset: function (e, t, n) {
                    var i = Qe(t, e);
                    n.axis = n.axis || "xy";
                    var r = it(n.axis), o = n.intersect ? tt(e, i) : nt(e, i, !1, r);
                    return o.length > 0 && (o = e.getDatasetMeta(o[0]._datasetIndex).data), o
                }, "x-axis": function (e, t) {
                    return rt(e, t, {intersect: !1})
                }, point: function (e, t) {
                    return tt(e, Qe(t, e))
                }, nearest: function (e, t, n) {
                    var i = Qe(t, e);
                    n.axis = n.axis || "xy";
                    var r = it(n.axis);
                    return nt(e, i, n.intersect, r)
                }, x: function (e, t, n) {
                    var i = Qe(t, e), r = [], o = !1;
                    return et(e, (function (e) {
                        e.inXRange(i.x) && r.push(e), e.inRange(i.x, i.y) && (o = !0)
                    })), n.intersect && !o && (r = []), r
                }, y: function (e, t, n) {
                    var i = Qe(t, e), r = [], o = !1;
                    return et(e, (function (e) {
                        e.inYRange(i.y) && r.push(e), e.inRange(i.x, i.y) && (o = !0)
                    })), n.intersect && !o && (r = []), r
                }
            }
        }, at = N.extend;

        function st(e, t) {
            return N.where(e, (function (e) {
                return e.pos === t
            }))
        }

        function lt(e, t) {
            return e.sort((function (e, n) {
                var i = t ? n : e, r = t ? e : n;
                return i.weight === r.weight ? i.index - r.index : i.weight - r.weight
            }))
        }

        function ct(e, t, n, i) {
            return Math.max(e[n], t[n]) + Math.max(e[i], t[i])
        }

        function ut(e, t, n) {
            var i, r, o = n.box, a = e.maxPadding;
            if (n.size && (e[n.pos] -= n.size), n.size = n.horizontal ? o.height : o.width, e[n.pos] += n.size, o.getPadding) {
                var s = o.getPadding();
                a.top = Math.max(a.top, s.top), a.left = Math.max(a.left, s.left), a.bottom = Math.max(a.bottom, s.bottom), a.right = Math.max(a.right, s.right)
            }
            if (i = t.outerWidth - ct(a, e, "left", "right"), r = t.outerHeight - ct(a, e, "top", "bottom"), i !== e.w || r !== e.h) {
                e.w = i, e.h = r;
                var l = n.horizontal ? [i, e.w] : [r, e.h];
                return !(l[0] === l[1] || isNaN(l[0]) && isNaN(l[1]))
            }
        }

        function dt(e, t) {
            var n = t.maxPadding;

            function i(e) {
                var i = {left: 0, top: 0, right: 0, bottom: 0};
                return e.forEach((function (e) {
                    i[e] = Math.max(t[e], n[e])
                })), i
            }

            return i(e ? ["left", "right"] : ["top", "bottom"])
        }

        function ht(e, t, n) {
            var i, r, o, a, s, l, c = [];
            for (i = 0, r = e.length; i < r; ++i) (a = (o = e[i]).box).update(o.width || t.w, o.height || t.h, dt(o.horizontal, t)), ut(t, n, o) && (l = !0, c.length && (s = !0)), a.fullWidth || c.push(o);
            return s && ht(c, t, n) || l
        }

        function pt(e, t, n) {
            var i, r, o, a, s = n.padding, l = t.x, c = t.y;
            for (i = 0, r = e.length; i < r; ++i) a = (o = e[i]).box, o.horizontal ? (a.left = a.fullWidth ? s.left : t.left, a.right = a.fullWidth ? n.outerWidth - s.right : t.left + t.w, a.top = c, a.bottom = c + a.height, a.width = a.right - a.left, c = a.bottom) : (a.left = l, a.right = l + a.width, a.top = t.top, a.bottom = t.top + t.h, a.height = a.bottom - a.top, l = a.right);
            t.x = l, t.y = c
        }

        O._set("global", {layout: {padding: {top: 0, right: 0, bottom: 0, left: 0}}});
        var ft, mt = {
            defaults: {}, addBox: function (e, t) {
                e.boxes || (e.boxes = []), t.fullWidth = t.fullWidth || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () {
                    return [{
                        z: 0, draw: function () {
                            t.draw.apply(t, arguments)
                        }
                    }]
                }, e.boxes.push(t)
            }, removeBox: function (e, t) {
                var n = e.boxes ? e.boxes.indexOf(t) : -1;
                -1 !== n && e.boxes.splice(n, 1)
            }, configure: function (e, t, n) {
                for (var i, r = ["fullWidth", "position", "weight"], o = r.length, a = 0; a < o; ++a) i = r[a], n.hasOwnProperty(i) && (t[i] = n[i])
            }, update: function (e, t, n) {
                if (e) {
                    var i = e.options.layout || {}, r = N.options.toPadding(i.padding), o = t - r.width,
                        a = n - r.height, s = function (e) {
                            var t = function (e) {
                                    var t, n, i, r = [];
                                    for (t = 0, n = (e || []).length; t < n; ++t) i = e[t], r.push({
                                        index: t,
                                        box: i,
                                        pos: i.position,
                                        horizontal: i.isHorizontal(),
                                        weight: i.weight
                                    });
                                    return r
                                }(e), n = lt(st(t, "left"), !0), i = lt(st(t, "right")), r = lt(st(t, "top"), !0),
                                o = lt(st(t, "bottom"));
                            return {
                                leftAndTop: n.concat(r),
                                rightAndBottom: i.concat(o),
                                chartArea: st(t, "chartArea"),
                                vertical: n.concat(i),
                                horizontal: r.concat(o)
                            }
                        }(e.boxes), l = s.vertical, c = s.horizontal, u = Object.freeze({
                            outerWidth: t,
                            outerHeight: n,
                            padding: r,
                            availableWidth: o,
                            vBoxMaxWidth: o / 2 / l.length,
                            hBoxMaxHeight: a / 2
                        }), d = at({maxPadding: at({}, r), w: o, h: a, x: r.left, y: r.top}, r);
                    !function (e, t) {
                        var n, i, r;
                        for (n = 0, i = e.length; n < i; ++n) (r = e[n]).width = r.horizontal ? r.box.fullWidth && t.availableWidth : t.vBoxMaxWidth, r.height = r.horizontal && t.hBoxMaxHeight
                    }(l.concat(c), u), ht(l, d, u), ht(c, d, u) && ht(l, d, u), function (e) {
                        var t = e.maxPadding;

                        function n(n) {
                            var i = Math.max(t[n] - e[n], 0);
                            return e[n] += i, i
                        }

                        e.y += n("top"), e.x += n("left"), n("right"), n("bottom")
                    }(d), pt(s.leftAndTop, d, u), d.x += d.w, d.y += d.h, pt(s.rightAndBottom, d, u), e.chartArea = {
                        left: d.left,
                        top: d.top,
                        right: d.left + d.w,
                        bottom: d.top + d.h
                    }, N.each(s.chartArea, (function (t) {
                        var n = t.box;
                        at(n, e.chartArea), n.update(d.w, d.h)
                    }))
                }
            }
        }, _t = (ft = Object.freeze({
            __proto__: null,
            default: "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n\tfrom { opacity: 0.99; }\r\n\tto { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n\tanimation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n\tposition: absolute;\r\n\tdirection: ltr;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\tvisibility: hidden;\r\n\tz-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n\tposition: absolute;\r\n\twidth: 1000000px;\r\n\theight: 1000000px;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n\tposition: absolute;\r\n\twidth: 200%;\r\n\theight: 200%;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n"
        })) && ft.default || ft, gt = ["animationstart", "webkitAnimationStart"], yt = {
            touchstart: "mousedown",
            touchmove: "mousemove",
            touchend: "mouseup",
            pointerenter: "mouseenter",
            pointerdown: "mousedown",
            pointermove: "mousemove",
            pointerup: "mouseup",
            pointerleave: "mouseout",
            pointerout: "mouseout"
        };

        function vt(e, t) {
            var n = N.getStyle(e, t), i = n && n.match(/^(\d+)(\.\d+)?px$/);
            return i ? Number(i[1]) : void 0
        }

        var xt = !!function () {
            var e = !1;
            try {
                var t = Object.defineProperty({}, "passive", {
                    get: function () {
                        e = !0
                    }
                });
                window.addEventListener("e", null, t)
            } catch (e) {
            }
            return e
        }() && {passive: !0};

        function bt(e, t, n) {
            e.addEventListener(t, n, xt)
        }

        function wt(e, t, n) {
            e.removeEventListener(t, n, xt)
        }

        function Mt(e, t, n, i, r) {
            return {type: e, chart: t, native: r || null, x: void 0 !== n ? n : null, y: void 0 !== i ? i : null}
        }

        function Tt(e) {
            var t = document.createElement("div");
            return t.className = e || "", t
        }

        function kt(e, t, n) {
            var i, r, o, a, s = e.$chartjs || (e.$chartjs = {}), l = s.resizer = function (e) {
                var t = Tt("chartjs-size-monitor"), n = Tt("chartjs-size-monitor-expand"),
                    i = Tt("chartjs-size-monitor-shrink");
                n.appendChild(Tt()), i.appendChild(Tt()), t.appendChild(n), t.appendChild(i), t._reset = function () {
                    n.scrollLeft = 1e6, n.scrollTop = 1e6, i.scrollLeft = 1e6, i.scrollTop = 1e6
                };
                var r = function () {
                    t._reset(), e()
                };
                return bt(n, "scroll", r.bind(n, "expand")), bt(i, "scroll", r.bind(i, "shrink")), t
            }((i = function () {
                if (s.resizer) {
                    var i = n.options.maintainAspectRatio && e.parentNode, r = i ? i.clientWidth : 0;
                    t(Mt("resize", n)), i && i.clientWidth < r && n.canvas && t(Mt("resize", n))
                }
            }, o = !1, a = [], function () {
                a = Array.prototype.slice.call(arguments), r = r || this, o || (o = !0, N.requestAnimFrame.call(window, (function () {
                    o = !1, i.apply(r, a)
                })))
            }));
            !function (e, t) {
                var n = e.$chartjs || (e.$chartjs = {}), i = n.renderProxy = function (e) {
                    "chartjs-render-animation" === e.animationName && t()
                };
                N.each(gt, (function (t) {
                    bt(e, t, i)
                })), n.reflow = !!e.offsetParent, e.classList.add("chartjs-render-monitor")
            }(e, (function () {
                if (s.resizer) {
                    var t = e.parentNode;
                    t && t !== l.parentNode && t.insertBefore(l, t.firstChild), l._reset()
                }
            }))
        }

        function St(e) {
            var t = e.$chartjs || {}, n = t.resizer;
            delete t.resizer, function (e) {
                var t = e.$chartjs || {}, n = t.renderProxy;
                n && (N.each(gt, (function (t) {
                    wt(e, t, n)
                })), delete t.renderProxy), e.classList.remove("chartjs-render-monitor")
            }(e), n && n.parentNode && n.parentNode.removeChild(n)
        }

        var Dt = {
            disableCSSInjection: !1,
            _enabled: "undefined" != typeof window && "undefined" != typeof document,
            _ensureLoaded: function (e) {
                if (!this.disableCSSInjection) {
                    var t = e.getRootNode ? e.getRootNode() : document;
                    !function (e, t) {
                        var n = e.$chartjs || (e.$chartjs = {});
                        if (!n.containsStyles) {
                            n.containsStyles = !0, t = "/* Chart.js */\n" + t;
                            var i = document.createElement("style");
                            i.setAttribute("type", "text/css"), i.appendChild(document.createTextNode(t)), e.appendChild(i)
                        }
                    }(t.host ? t : document.head, _t)
                }
            },
            acquireContext: function (e, t) {
                "string" == typeof e ? e = document.getElementById(e) : e.length && (e = e[0]), e && e.canvas && (e = e.canvas);
                var n = e && e.getContext && e.getContext("2d");
                return n && n.canvas === e ? (this._ensureLoaded(e), function (e, t) {
                    var n = e.style, i = e.getAttribute("height"), r = e.getAttribute("width");
                    if (e.$chartjs = {
                        initial: {
                            height: i,
                            width: r,
                            style: {display: n.display, height: n.height, width: n.width}
                        }
                    }, n.display = n.display || "block", null === r || "" === r) {
                        var o = vt(e, "width");
                        void 0 !== o && (e.width = o)
                    }
                    if (null === i || "" === i) if ("" === e.style.height) e.height = e.width / (t.options.aspectRatio || 2); else {
                        var a = vt(e, "height");
                        void 0 !== o && (e.height = a)
                    }
                }(e, t), n) : null
            },
            releaseContext: function (e) {
                var t = e.canvas;
                if (t.$chartjs) {
                    var n = t.$chartjs.initial;
                    ["height", "width"].forEach((function (e) {
                        var i = n[e];
                        N.isNullOrUndef(i) ? t.removeAttribute(e) : t.setAttribute(e, i)
                    })), N.each(n.style || {}, (function (e, n) {
                        t.style[n] = e
                    })), t.width = t.width, delete t.$chartjs
                }
            },
            addEventListener: function (e, t, n) {
                var i = e.canvas;
                if ("resize" !== t) {
                    var r = n.$chartjs || (n.$chartjs = {});
                    bt(i, t, (r.proxies || (r.proxies = {}))[e.id + "_" + t] = function (t) {
                        n(function (e, t) {
                            var n = yt[e.type] || e.type, i = N.getRelativePosition(e, t);
                            return Mt(n, t, i.x, i.y, e)
                        }(t, e))
                    })
                } else kt(i, n, e)
            },
            removeEventListener: function (e, t, n) {
                var i = e.canvas;
                if ("resize" !== t) {
                    var r = ((n.$chartjs || {}).proxies || {})[e.id + "_" + t];
                    r && wt(i, t, r)
                } else St(i)
            }
        };
        N.addEvent = bt, N.removeEvent = wt;
        var Lt = Dt._enabled ? Dt : {
            acquireContext: function (e) {
                return e && e.canvas && (e = e.canvas), e && e.getContext("2d") || null
            }
        }, Et = N.extend({
            initialize: function () {
            }, acquireContext: function () {
            }, releaseContext: function () {
            }, addEventListener: function () {
            }, removeEventListener: function () {
            }
        }, Lt);
        O._set("global", {plugins: {}});
        var Ct = {
            _plugins: [], _cacheId: 0, register: function (e) {
                var t = this._plugins;
                [].concat(e).forEach((function (e) {
                    -1 === t.indexOf(e) && t.push(e)
                })), this._cacheId++
            }, unregister: function (e) {
                var t = this._plugins;
                [].concat(e).forEach((function (e) {
                    var n = t.indexOf(e);
                    -1 !== n && t.splice(n, 1)
                })), this._cacheId++
            }, clear: function () {
                this._plugins = [], this._cacheId++
            }, count: function () {
                return this._plugins.length
            }, getAll: function () {
                return this._plugins
            }, notify: function (e, t, n) {
                var i, r, o, a, s, l = this.descriptors(e), c = l.length;
                for (i = 0; i < c; ++i) if ("function" == typeof (s = (o = (r = l[i]).plugin)[t]) && ((a = [e].concat(n || [])).push(r.options), !1 === s.apply(o, a))) return !1;
                return !0
            }, descriptors: function (e) {
                var t = e.$plugins || (e.$plugins = {});
                if (t.id === this._cacheId) return t.descriptors;
                var n = [], i = [], r = e && e.config || {}, o = r.options && r.options.plugins || {};
                return this._plugins.concat(r.plugins || []).forEach((function (e) {
                    if (-1 === n.indexOf(e)) {
                        var t = e.id, r = o[t];
                        !1 !== r && (!0 === r && (r = N.clone(O.global.plugins[t])), n.push(e), i.push({
                            plugin: e,
                            options: r || {}
                        }))
                    }
                })), t.descriptors = i, t.id = this._cacheId, i
            }, _invalidate: function (e) {
                delete e.$plugins
            }
        }, At = {
            constructors: {}, defaults: {}, registerScaleType: function (e, t, n) {
                this.constructors[e] = t, this.defaults[e] = N.clone(n)
            }, getScaleConstructor: function (e) {
                return this.constructors.hasOwnProperty(e) ? this.constructors[e] : void 0
            }, getScaleDefaults: function (e) {
                return this.defaults.hasOwnProperty(e) ? N.merge(Object.create(null), [O.scale, this.defaults[e]]) : {}
            }, updateScaleDefaults: function (e, t) {
                this.defaults.hasOwnProperty(e) && (this.defaults[e] = N.extend(this.defaults[e], t))
            }, addScalesToLayout: function (e) {
                N.each(e.scales, (function (t) {
                    t.fullWidth = t.options.fullWidth, t.position = t.options.position, t.weight = t.options.weight, mt.addBox(e, t)
                }))
            }
        }, It = N.valueOrDefault, Pt = N.rtl.getRtlAdapter;
        O._set("global", {
            tooltips: {
                enabled: !0,
                custom: null,
                mode: "nearest",
                position: "average",
                intersect: !0,
                backgroundColor: "rgba(0,0,0,0.8)",
                titleFontStyle: "bold",
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleFontColor: "#fff",
                titleAlign: "left",
                bodySpacing: 2,
                bodyFontColor: "#fff",
                bodyAlign: "left",
                footerFontStyle: "bold",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFontColor: "#fff",
                footerAlign: "left",
                yPadding: 6,
                xPadding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                multiKeyBackground: "#fff",
                displayColors: !0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                callbacks: {
                    beforeTitle: N.noop, title: function (e, t) {
                        var n = "", i = t.labels, r = i ? i.length : 0;
                        if (e.length > 0) {
                            var o = e[0];
                            o.label ? n = o.label : o.xLabel ? n = o.xLabel : r > 0 && o.index < r && (n = i[o.index])
                        }
                        return n
                    }, afterTitle: N.noop, beforeBody: N.noop, beforeLabel: N.noop, label: function (e, t) {
                        var n = t.datasets[e.datasetIndex].label || "";
                        return n && (n += ": "), N.isNullOrUndef(e.value) ? n += e.yLabel : n += e.value, n
                    }, labelColor: function (e, t) {
                        var n = t.getDatasetMeta(e.datasetIndex).data[e.index]._view;
                        return {borderColor: n.borderColor, backgroundColor: n.backgroundColor}
                    }, labelTextColor: function () {
                        return this._options.bodyFontColor
                    }, afterLabel: N.noop, afterBody: N.noop, beforeFooter: N.noop, footer: N.noop, afterFooter: N.noop
                }
            }
        });
        var Rt = {
            average: function (e) {
                if (!e.length) return !1;
                var t, n, i = 0, r = 0, o = 0;
                for (t = 0, n = e.length; t < n; ++t) {
                    var a = e[t];
                    if (a && a.hasValue()) {
                        var s = a.tooltipPosition();
                        i += s.x, r += s.y, ++o
                    }
                }
                return {x: i / o, y: r / o}
            }, nearest: function (e, t) {
                var n, i, r, o = t.x, a = t.y, s = Number.POSITIVE_INFINITY;
                for (n = 0, i = e.length; n < i; ++n) {
                    var l = e[n];
                    if (l && l.hasValue()) {
                        var c = l.getCenterPoint(), u = N.distanceBetweenPoints(t, c);
                        u < s && (s = u, r = l)
                    }
                }
                if (r) {
                    var d = r.tooltipPosition();
                    o = d.x, a = d.y
                }
                return {x: o, y: a}
            }
        };

        function Yt(e, t) {
            return t && (N.isArray(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e
        }

        function zt(e) {
            return ("string" == typeof e || e instanceof String) && e.indexOf("\n") > -1 ? e.split("\n") : e
        }

        function Ot(e) {
            var t = O.global;
            return {
                xPadding: e.xPadding,
                yPadding: e.yPadding,
                xAlign: e.xAlign,
                yAlign: e.yAlign,
                rtl: e.rtl,
                textDirection: e.textDirection,
                bodyFontColor: e.bodyFontColor,
                _bodyFontFamily: It(e.bodyFontFamily, t.defaultFontFamily),
                _bodyFontStyle: It(e.bodyFontStyle, t.defaultFontStyle),
                _bodyAlign: e.bodyAlign,
                bodyFontSize: It(e.bodyFontSize, t.defaultFontSize),
                bodySpacing: e.bodySpacing,
                titleFontColor: e.titleFontColor,
                _titleFontFamily: It(e.titleFontFamily, t.defaultFontFamily),
                _titleFontStyle: It(e.titleFontStyle, t.defaultFontStyle),
                titleFontSize: It(e.titleFontSize, t.defaultFontSize),
                _titleAlign: e.titleAlign,
                titleSpacing: e.titleSpacing,
                titleMarginBottom: e.titleMarginBottom,
                footerFontColor: e.footerFontColor,
                _footerFontFamily: It(e.footerFontFamily, t.defaultFontFamily),
                _footerFontStyle: It(e.footerFontStyle, t.defaultFontStyle),
                footerFontSize: It(e.footerFontSize, t.defaultFontSize),
                _footerAlign: e.footerAlign,
                footerSpacing: e.footerSpacing,
                footerMarginTop: e.footerMarginTop,
                caretSize: e.caretSize,
                cornerRadius: e.cornerRadius,
                backgroundColor: e.backgroundColor,
                opacity: 0,
                legendColorBackground: e.multiKeyBackground,
                displayColors: e.displayColors,
                borderColor: e.borderColor,
                borderWidth: e.borderWidth
            }
        }

        function Ft(e, t) {
            return "center" === t ? e.x + e.width / 2 : "right" === t ? e.x + e.width - e.xPadding : e.x + e.xPadding
        }

        function Bt(e) {
            return Yt([], zt(e))
        }

        var jt = $.extend({
            initialize: function () {
                this._model = Ot(this._options), this._lastActive = []
            }, getTitle: function () {
                var e = this, t = e._options, n = t.callbacks, i = n.beforeTitle.apply(e, arguments),
                    r = n.title.apply(e, arguments), o = n.afterTitle.apply(e, arguments), a = [];
                return a = Yt(a, zt(i)), a = Yt(a, zt(r)), a = Yt(a, zt(o))
            }, getBeforeBody: function () {
                return Bt(this._options.callbacks.beforeBody.apply(this, arguments))
            }, getBody: function (e, t) {
                var n = this, i = n._options.callbacks, r = [];
                return N.each(e, (function (e) {
                    var o = {before: [], lines: [], after: []};
                    Yt(o.before, zt(i.beforeLabel.call(n, e, t))), Yt(o.lines, i.label.call(n, e, t)), Yt(o.after, zt(i.afterLabel.call(n, e, t))), r.push(o)
                })), r
            }, getAfterBody: function () {
                return Bt(this._options.callbacks.afterBody.apply(this, arguments))
            }, getFooter: function () {
                var e = this, t = e._options.callbacks, n = t.beforeFooter.apply(e, arguments),
                    i = t.footer.apply(e, arguments), r = t.afterFooter.apply(e, arguments), o = [];
                return o = Yt(o, zt(n)), o = Yt(o, zt(i)), o = Yt(o, zt(r))
            }, update: function (e) {
                var t, n, i, r, o, a, s, l, c, u, d = this, h = d._options, p = d._model, f = d._model = Ot(h),
                    m = d._active, _ = d._data, g = {xAlign: p.xAlign, yAlign: p.yAlign}, y = {x: p.x, y: p.y},
                    v = {width: p.width, height: p.height}, x = {x: p.caretX, y: p.caretY};
                if (m.length) {
                    f.opacity = 1;
                    var b = [], w = [];
                    x = Rt[h.position].call(d, m, d._eventPosition);
                    var M = [];
                    for (t = 0, n = m.length; t < n; ++t) M.push((i = m[t], r = void 0, o = void 0, a = void 0, s = void 0, l = void 0, c = void 0, u = void 0, r = i._xScale, o = i._yScale || i._scale, a = i._index, s = i._datasetIndex, l = i._chart.getDatasetMeta(s).controller, c = l._getIndexScale(), u = l._getValueScale(), {
                        xLabel: r ? r.getLabelForIndex(a, s) : "",
                        yLabel: o ? o.getLabelForIndex(a, s) : "",
                        label: c ? "" + c.getLabelForIndex(a, s) : "",
                        value: u ? "" + u.getLabelForIndex(a, s) : "",
                        index: a,
                        datasetIndex: s,
                        x: i._model.x,
                        y: i._model.y
                    }));
                    h.filter && (M = M.filter((function (e) {
                        return h.filter(e, _)
                    }))), h.itemSort && (M = M.sort((function (e, t) {
                        return h.itemSort(e, t, _)
                    }))), N.each(M, (function (e) {
                        b.push(h.callbacks.labelColor.call(d, e, d._chart)), w.push(h.callbacks.labelTextColor.call(d, e, d._chart))
                    })), f.title = d.getTitle(M, _), f.beforeBody = d.getBeforeBody(M, _), f.body = d.getBody(M, _), f.afterBody = d.getAfterBody(M, _), f.footer = d.getFooter(M, _), f.x = x.x, f.y = x.y, f.caretPadding = h.caretPadding, f.labelColors = b, f.labelTextColors = w, f.dataPoints = M, v = function (e, t) {
                        var n = e._chart.ctx, i = 2 * t.yPadding, r = 0, o = t.body, a = o.reduce((function (e, t) {
                            return e + t.before.length + t.lines.length + t.after.length
                        }), 0);
                        a += t.beforeBody.length + t.afterBody.length;
                        var s = t.title.length, l = t.footer.length, c = t.titleFontSize, u = t.bodyFontSize,
                            d = t.footerFontSize;
                        i += s * c, i += s ? (s - 1) * t.titleSpacing : 0, i += s ? t.titleMarginBottom : 0, i += a * u, i += a ? (a - 1) * t.bodySpacing : 0, i += l ? t.footerMarginTop : 0, i += l * d, i += l ? (l - 1) * t.footerSpacing : 0;
                        var h = 0, p = function (e) {
                            r = Math.max(r, n.measureText(e).width + h)
                        };
                        return n.font = N.fontString(c, t._titleFontStyle, t._titleFontFamily), N.each(t.title, p), n.font = N.fontString(u, t._bodyFontStyle, t._bodyFontFamily), N.each(t.beforeBody.concat(t.afterBody), p), h = t.displayColors ? u + 2 : 0, N.each(o, (function (e) {
                            N.each(e.before, p), N.each(e.lines, p), N.each(e.after, p)
                        })), h = 0, n.font = N.fontString(d, t._footerFontStyle, t._footerFontFamily), N.each(t.footer, p), {
                            width: r += 2 * t.xPadding,
                            height: i
                        }
                    }(this, f), y = function (e, t, n, i) {
                        var r = e.x, o = e.y, a = e.caretSize, s = e.caretPadding, l = e.cornerRadius, c = n.xAlign,
                            u = n.yAlign, d = a + s, h = l + s;
                        return "right" === c ? r -= t.width : "center" === c && ((r -= t.width / 2) + t.width > i.width && (r = i.width - t.width), r < 0 && (r = 0)), "top" === u ? o += d : o -= "bottom" === u ? t.height + d : t.height / 2, "center" === u ? "left" === c ? r += d : "right" === c && (r -= d) : "left" === c ? r -= h : "right" === c && (r += h), {
                            x: r,
                            y: o
                        }
                    }(f, v, g = function (e, t) {
                        var n, i, r, o, a, s = e._model, l = e._chart, c = e._chart.chartArea, u = "center",
                            d = "center";
                        s.y < t.height ? d = "top" : s.y > l.height - t.height && (d = "bottom");
                        var h = (c.left + c.right) / 2, p = (c.top + c.bottom) / 2;
                        "center" === d ? (n = function (e) {
                            return e <= h
                        }, i = function (e) {
                            return e > h
                        }) : (n = function (e) {
                            return e <= t.width / 2
                        }, i = function (e) {
                            return e >= l.width - t.width / 2
                        }), r = function (e) {
                            return e + t.width + s.caretSize + s.caretPadding > l.width
                        }, o = function (e) {
                            return e - t.width - s.caretSize - s.caretPadding < 0
                        }, a = function (e) {
                            return e <= p ? "top" : "bottom"
                        }, n(s.x) ? (u = "left", r(s.x) && (u = "center", d = a(s.y))) : i(s.x) && (u = "right", o(s.x) && (u = "center", d = a(s.y)));
                        var f = e._options;
                        return {xAlign: f.xAlign ? f.xAlign : u, yAlign: f.yAlign ? f.yAlign : d}
                    }(this, v), d._chart)
                } else f.opacity = 0;
                return f.xAlign = g.xAlign, f.yAlign = g.yAlign, f.x = y.x, f.y = y.y, f.width = v.width, f.height = v.height, f.caretX = x.x, f.caretY = x.y, d._model = f, e && h.custom && h.custom.call(d, f), d
            }, drawCaret: function (e, t) {
                var n = this._chart.ctx, i = this._view, r = this.getCaretPosition(e, t, i);
                n.lineTo(r.x1, r.y1), n.lineTo(r.x2, r.y2), n.lineTo(r.x3, r.y3)
            }, getCaretPosition: function (e, t, n) {
                var i, r, o, a, s, l, c = n.caretSize, u = n.cornerRadius, d = n.xAlign, h = n.yAlign, p = e.x, f = e.y,
                    m = t.width, _ = t.height;
                if ("center" === h) s = f + _ / 2, "left" === d ? (r = (i = p) - c, o = i, a = s + c, l = s - c) : (r = (i = p + m) + c, o = i, a = s - c, l = s + c); else if ("left" === d ? (i = (r = p + u + c) - c, o = r + c) : "right" === d ? (i = (r = p + m - u - c) - c, o = r + c) : (i = (r = n.caretX) - c, o = r + c), "top" === h) s = (a = f) - c, l = a; else {
                    s = (a = f + _) + c, l = a;
                    var g = o;
                    o = i, i = g
                }
                return {x1: i, x2: r, x3: o, y1: a, y2: s, y3: l}
            }, drawTitle: function (e, t, n) {
                var i, r, o, a = t.title, s = a.length;
                if (s) {
                    var l = Pt(t.rtl, t.x, t.width);
                    for (e.x = Ft(t, t._titleAlign), n.textAlign = l.textAlign(t._titleAlign), n.textBaseline = "middle", i = t.titleFontSize, r = t.titleSpacing, n.fillStyle = t.titleFontColor, n.font = N.fontString(i, t._titleFontStyle, t._titleFontFamily), o = 0; o < s; ++o) n.fillText(a[o], l.x(e.x), e.y + i / 2), e.y += i + r, o + 1 === s && (e.y += t.titleMarginBottom - r)
                }
            }, drawBody: function (e, t, n) {
                var i, r, o, a, s, l, c, u, d = t.bodyFontSize, h = t.bodySpacing, p = t._bodyAlign, f = t.body,
                    m = t.displayColors, _ = 0, g = m ? Ft(t, "left") : 0, y = Pt(t.rtl, t.x, t.width),
                    v = function (t) {
                        n.fillText(t, y.x(e.x + _), e.y + d / 2), e.y += d + h
                    }, x = y.textAlign(p);
                for (n.textAlign = p, n.textBaseline = "middle", n.font = N.fontString(d, t._bodyFontStyle, t._bodyFontFamily), e.x = Ft(t, x), n.fillStyle = t.bodyFontColor, N.each(t.beforeBody, v), _ = m && "right" !== x ? "center" === p ? d / 2 + 1 : d + 2 : 0, s = 0, c = f.length; s < c; ++s) {
                    for (i = f[s], r = t.labelTextColors[s], o = t.labelColors[s], n.fillStyle = r, N.each(i.before, v), l = 0, u = (a = i.lines).length; l < u; ++l) {
                        if (m) {
                            var b = y.x(g);
                            n.fillStyle = t.legendColorBackground, n.fillRect(y.leftForLtr(b, d), e.y, d, d), n.lineWidth = 1, n.strokeStyle = o.borderColor, n.strokeRect(y.leftForLtr(b, d), e.y, d, d), n.fillStyle = o.backgroundColor, n.fillRect(y.leftForLtr(y.xPlus(b, 1), d - 2), e.y + 1, d - 2, d - 2), n.fillStyle = r
                        }
                        v(a[l])
                    }
                    N.each(i.after, v)
                }
                _ = 0, N.each(t.afterBody, v), e.y -= h
            }, drawFooter: function (e, t, n) {
                var i, r, o = t.footer, a = o.length;
                if (a) {
                    var s = Pt(t.rtl, t.x, t.width);
                    for (e.x = Ft(t, t._footerAlign), e.y += t.footerMarginTop, n.textAlign = s.textAlign(t._footerAlign), n.textBaseline = "middle", i = t.footerFontSize, n.fillStyle = t.footerFontColor, n.font = N.fontString(i, t._footerFontStyle, t._footerFontFamily), r = 0; r < a; ++r) n.fillText(o[r], s.x(e.x), e.y + i / 2), e.y += i + t.footerSpacing
                }
            }, drawBackground: function (e, t, n, i) {
                n.fillStyle = t.backgroundColor, n.strokeStyle = t.borderColor, n.lineWidth = t.borderWidth;
                var r = t.xAlign, o = t.yAlign, a = e.x, s = e.y, l = i.width, c = i.height, u = t.cornerRadius;
                n.beginPath(), n.moveTo(a + u, s), "top" === o && this.drawCaret(e, i), n.lineTo(a + l - u, s), n.quadraticCurveTo(a + l, s, a + l, s + u), "center" === o && "right" === r && this.drawCaret(e, i), n.lineTo(a + l, s + c - u), n.quadraticCurveTo(a + l, s + c, a + l - u, s + c), "bottom" === o && this.drawCaret(e, i), n.lineTo(a + u, s + c), n.quadraticCurveTo(a, s + c, a, s + c - u), "center" === o && "left" === r && this.drawCaret(e, i), n.lineTo(a, s + u), n.quadraticCurveTo(a, s, a + u, s), n.closePath(), n.fill(), t.borderWidth > 0 && n.stroke()
            }, draw: function () {
                var e = this._chart.ctx, t = this._view;
                if (0 !== t.opacity) {
                    var n = {width: t.width, height: t.height}, i = {x: t.x, y: t.y},
                        r = Math.abs(t.opacity < .001) ? 0 : t.opacity,
                        o = t.title.length || t.beforeBody.length || t.body.length || t.afterBody.length || t.footer.length;
                    this._options.enabled && o && (e.save(), e.globalAlpha = r, this.drawBackground(i, t, e, n), i.y += t.yPadding, N.rtl.overrideTextDirection(e, t.textDirection), this.drawTitle(i, t, e), this.drawBody(i, t, e), this.drawFooter(i, t, e), N.rtl.restoreTextDirection(e, t.textDirection), e.restore())
                }
            }, handleEvent: function (e) {
                var t, n = this, i = n._options;
                return n._lastActive = n._lastActive || [], "mouseout" === e.type ? n._active = [] : (n._active = n._chart.getElementsAtEventForMode(e, i.mode, i), i.reverse && n._active.reverse()), (t = !N.arrayEquals(n._active, n._lastActive)) && (n._lastActive = n._active, (i.enabled || i.custom) && (n._eventPosition = {
                    x: e.x,
                    y: e.y
                }, n.update(!0), n.pivot())), t
            }
        }), Ht = Rt, Nt = jt;
        Nt.positioners = Ht;
        var Ut = N.valueOrDefault;

        function Wt() {
            return N.merge(Object.create(null), [].slice.call(arguments), {
                merger: function (e, t, n, i) {
                    if ("xAxes" === e || "yAxes" === e) {
                        var r, o, a, s = n[e].length;
                        for (t[e] || (t[e] = []), r = 0; r < s; ++r) a = n[e][r], o = Ut(a.type, "xAxes" === e ? "category" : "linear"), r >= t[e].length && t[e].push({}), !t[e][r].type || a.type && a.type !== t[e][r].type ? N.merge(t[e][r], [At.getScaleDefaults(o), a]) : N.merge(t[e][r], a)
                    } else N._merger(e, t, n, i)
                }
            })
        }

        function Vt() {
            return N.merge(Object.create(null), [].slice.call(arguments), {
                merger: function (e, t, n, i) {
                    var r = t[e] || Object.create(null), o = n[e];
                    "scales" === e ? t[e] = Wt(r, o) : "scale" === e ? t[e] = N.merge(r, [At.getScaleDefaults(o.type), o]) : N._merger(e, t, n, i)
                }
            })
        }

        function Gt(e) {
            var t = e.options;
            N.each(e.scales, (function (t) {
                mt.removeBox(e, t)
            })), t = Vt(O.global, O[e.config.type], t), e.options = e.config.options = t, e.ensureScalesHaveIDs(), e.buildOrUpdateScales(), e.tooltip._options = t.tooltips, e.tooltip.initialize()
        }

        function qt(e, t, n) {
            var i, r = function (e) {
                return e.id === i
            };
            do {
                i = t + n++
            } while (N.findIndex(e, r) >= 0);
            return i
        }

        function Zt(e) {
            return "top" === e || "bottom" === e
        }

        function $t(e, t) {
            return function (n, i) {
                return n[e] === i[e] ? n[t] - i[t] : n[e] - i[e]
            }
        }

        O._set("global", {
            elements: {},
            events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
            hover: {onHover: null, mode: "nearest", intersect: !0, animationDuration: 400},
            onClick: null,
            maintainAspectRatio: !0,
            responsive: !0,
            responsiveAnimationDuration: 0
        });
        var Xt = function (e, t) {
            return this.construct(e, t), this
        };
        N.extend(Xt.prototype, {
            construct: function (e, t) {
                var n = this;
                t = function (e) {
                    var t = (e = e || Object.create(null)).data = e.data || {};
                    return t.datasets = t.datasets || [], t.labels = t.labels || [], e.options = Vt(O.global, O[e.type], e.options || {}), e
                }(t);
                var i = Et.acquireContext(e, t), r = i && i.canvas, o = r && r.height, a = r && r.width;
                n.id = N.uid(), n.ctx = i, n.canvas = r, n.config = t, n.width = a, n.height = o, n.aspectRatio = o ? a / o : null, n.options = t.options, n._bufferedRender = !1, n._layers = [], n.chart = n, n.controller = n, Xt.instances[n.id] = n, Object.defineProperty(n, "data", {
                    get: function () {
                        return n.config.data
                    }, set: function (e) {
                        n.config.data = e
                    }
                }), i && r ? (n.initialize(), n.update()) : console.error("Failed to create chart: can't acquire context from the given item")
            }, initialize: function () {
                var e = this;
                return Ct.notify(e, "beforeInit"), N.retinaScale(e, e.options.devicePixelRatio), e.bindEvents(), e.options.responsive && e.resize(!0), e.initToolTip(), Ct.notify(e, "afterInit"), e
            }, clear: function () {
                return N.canvas.clear(this), this
            }, stop: function () {
                return K.cancelAnimation(this), this
            }, resize: function (e) {
                var t = this, n = t.options, i = t.canvas, r = n.maintainAspectRatio && t.aspectRatio || null,
                    o = Math.max(0, Math.floor(N.getMaximumWidth(i))),
                    a = Math.max(0, Math.floor(r ? o / r : N.getMaximumHeight(i)));
                if ((t.width !== o || t.height !== a) && (i.width = t.width = o, i.height = t.height = a, i.style.width = o + "px", i.style.height = a + "px", N.retinaScale(t, n.devicePixelRatio), !e)) {
                    var s = {width: o, height: a};
                    Ct.notify(t, "resize", [s]), n.onResize && n.onResize(t, s), t.stop(), t.update({duration: n.responsiveAnimationDuration})
                }
            }, ensureScalesHaveIDs: function () {
                var e = this.options, t = e.scales || {}, n = e.scale;
                N.each(t.xAxes, (function (e, n) {
                    e.id || (e.id = qt(t.xAxes, "x-axis-", n))
                })), N.each(t.yAxes, (function (e, n) {
                    e.id || (e.id = qt(t.yAxes, "y-axis-", n))
                })), n && (n.id = n.id || "scale")
            }, buildOrUpdateScales: function () {
                var e = this, t = e.options, n = e.scales || {}, i = [], r = Object.keys(n).reduce((function (e, t) {
                    return e[t] = !1, e
                }), {});
                t.scales && (i = i.concat((t.scales.xAxes || []).map((function (e) {
                    return {options: e, dtype: "category", dposition: "bottom"}
                })), (t.scales.yAxes || []).map((function (e) {
                    return {options: e, dtype: "linear", dposition: "left"}
                })))), t.scale && i.push({
                    options: t.scale,
                    dtype: "radialLinear",
                    isDefault: !0,
                    dposition: "chartArea"
                }), N.each(i, (function (t) {
                    var i = t.options, o = i.id, a = Ut(i.type, t.dtype);
                    Zt(i.position) !== Zt(t.dposition) && (i.position = t.dposition), r[o] = !0;
                    var s = null;
                    if (o in n && n[o].type === a) (s = n[o]).options = i, s.ctx = e.ctx, s.chart = e; else {
                        var l = At.getScaleConstructor(a);
                        if (!l) return;
                        s = new l({id: o, type: a, options: i, ctx: e.ctx, chart: e}), n[s.id] = s
                    }
                    s.mergeTicksOptions(), t.isDefault && (e.scale = s)
                })), N.each(r, (function (e, t) {
                    e || delete n[t]
                })), e.scales = n, At.addScalesToLayout(this)
            }, buildOrUpdateControllers: function () {
                var e, t, n = this, i = [], r = n.data.datasets;
                for (e = 0, t = r.length; e < t; e++) {
                    var o = r[e], a = n.getDatasetMeta(e), s = o.type || n.config.type;
                    if (a.type && a.type !== s && (n.destroyDatasetMeta(e), a = n.getDatasetMeta(e)), a.type = s, a.order = o.order || 0, a.index = e, a.controller) a.controller.updateIndex(e), a.controller.linkScales(); else {
                        var l = Ke[a.type];
                        if (void 0 === l) throw new Error('"' + a.type + '" is not a chart type.');
                        a.controller = new l(n, e), i.push(a.controller)
                    }
                }
                return i
            }, resetElements: function () {
                var e = this;
                N.each(e.data.datasets, (function (t, n) {
                    e.getDatasetMeta(n).controller.reset()
                }), e)
            }, reset: function () {
                this.resetElements(), this.tooltip.initialize()
            }, update: function (e) {
                var t, n, i = this;
                if (e && "object" == typeof e || (e = {
                    duration: e,
                    lazy: arguments[1]
                }), Gt(i), Ct._invalidate(i), !1 !== Ct.notify(i, "beforeUpdate")) {
                    i.tooltip._data = i.data;
                    var r = i.buildOrUpdateControllers();
                    for (t = 0, n = i.data.datasets.length; t < n; t++) i.getDatasetMeta(t).controller.buildOrUpdateElements();
                    i.updateLayout(), i.options.animation && i.options.animation.duration && N.each(r, (function (e) {
                        e.reset()
                    })), i.updateDatasets(), i.tooltip.initialize(), i.lastActive = [], Ct.notify(i, "afterUpdate"), i._layers.sort($t("z", "_idx")), i._bufferedRender ? i._bufferedRequest = {
                        duration: e.duration,
                        easing: e.easing,
                        lazy: e.lazy
                    } : i.render(e)
                }
            }, updateLayout: function () {
                var e = this;
                !1 !== Ct.notify(e, "beforeLayout") && (mt.update(this, this.width, this.height), e._layers = [], N.each(e.boxes, (function (t) {
                    t._configure && t._configure(), e._layers.push.apply(e._layers, t._layers())
                }), e), e._layers.forEach((function (e, t) {
                    e._idx = t
                })), Ct.notify(e, "afterScaleUpdate"), Ct.notify(e, "afterLayout"))
            }, updateDatasets: function () {
                if (!1 !== Ct.notify(this, "beforeDatasetsUpdate")) {
                    for (var e = 0, t = this.data.datasets.length; e < t; ++e) this.updateDataset(e);
                    Ct.notify(this, "afterDatasetsUpdate")
                }
            }, updateDataset: function (e) {
                var t = this.getDatasetMeta(e), n = {meta: t, index: e};
                !1 !== Ct.notify(this, "beforeDatasetUpdate", [n]) && (t.controller._update(), Ct.notify(this, "afterDatasetUpdate", [n]))
            }, render: function (e) {
                var t = this;
                e && "object" == typeof e || (e = {duration: e, lazy: arguments[1]});
                var n = t.options.animation, i = Ut(e.duration, n && n.duration), r = e.lazy;
                if (!1 !== Ct.notify(t, "beforeRender")) {
                    var o = function (e) {
                        Ct.notify(t, "afterRender"), N.callback(n && n.onComplete, [e], t)
                    };
                    if (n && i) {
                        var a = new J({
                            numSteps: i / 16.66, easing: e.easing || n.easing, render: function (e, t) {
                                var n = N.easing.effects[t.easing], i = t.currentStep, r = i / t.numSteps;
                                e.draw(n(r), r, i)
                            }, onAnimationProgress: n.onProgress, onAnimationComplete: o
                        });
                        K.addAnimation(t, a, i, r)
                    } else t.draw(), o(new J({numSteps: 0, chart: t}));
                    return t
                }
            }, draw: function (e) {
                var t, n, i = this;
                if (i.clear(), N.isNullOrUndef(e) && (e = 1), i.transition(e), !(i.width <= 0 || i.height <= 0) && !1 !== Ct.notify(i, "beforeDraw", [e])) {
                    for (n = i._layers, t = 0; t < n.length && n[t].z <= 0; ++t) n[t].draw(i.chartArea);
                    for (i.drawDatasets(e); t < n.length; ++t) n[t].draw(i.chartArea);
                    i._drawTooltip(e), Ct.notify(i, "afterDraw", [e])
                }
            }, transition: function (e) {
                for (var t = 0, n = (this.data.datasets || []).length; t < n; ++t) this.isDatasetVisible(t) && this.getDatasetMeta(t).controller.transition(e);
                this.tooltip.transition(e)
            }, _getSortedDatasetMetas: function (e) {
                var t, n, i = [];
                for (t = 0, n = (this.data.datasets || []).length; t < n; ++t) e && !this.isDatasetVisible(t) || i.push(this.getDatasetMeta(t));
                return i.sort($t("order", "index")), i
            }, _getSortedVisibleDatasetMetas: function () {
                return this._getSortedDatasetMetas(!0)
            }, drawDatasets: function (e) {
                var t, n;
                if (!1 !== Ct.notify(this, "beforeDatasetsDraw", [e])) {
                    for (n = (t = this._getSortedVisibleDatasetMetas()).length - 1; n >= 0; --n) this.drawDataset(t[n], e);
                    Ct.notify(this, "afterDatasetsDraw", [e])
                }
            }, drawDataset: function (e, t) {
                var n = {meta: e, index: e.index, easingValue: t};
                !1 !== Ct.notify(this, "beforeDatasetDraw", [n]) && (e.controller.draw(t), Ct.notify(this, "afterDatasetDraw", [n]))
            }, _drawTooltip: function (e) {
                var t = this.tooltip, n = {tooltip: t, easingValue: e};
                !1 !== Ct.notify(this, "beforeTooltipDraw", [n]) && (t.draw(), Ct.notify(this, "afterTooltipDraw", [n]))
            }, getElementAtEvent: function (e) {
                return ot.modes.single(this, e)
            }, getElementsAtEvent: function (e) {
                return ot.modes.label(this, e, {intersect: !0})
            }, getElementsAtXAxis: function (e) {
                return ot.modes["x-axis"](this, e, {intersect: !0})
            }, getElementsAtEventForMode: function (e, t, n) {
                var i = ot.modes[t];
                return "function" == typeof i ? i(this, e, n) : []
            }, getDatasetAtEvent: function (e) {
                return ot.modes.dataset(this, e, {intersect: !0})
            }, getDatasetMeta: function (e) {
                var t = this.data.datasets[e];
                t._meta || (t._meta = {});
                var n = t._meta[this.id];
                return n || (n = t._meta[this.id] = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: t.order || 0,
                    index: e
                }), n
            }, getVisibleDatasetCount: function () {
                for (var e = 0, t = 0, n = this.data.datasets.length; t < n; ++t) this.isDatasetVisible(t) && e++;
                return e
            }, isDatasetVisible: function (e) {
                var t = this.getDatasetMeta(e);
                return "boolean" == typeof t.hidden ? !t.hidden : !this.data.datasets[e].hidden
            }, generateLegend: function () {
                return this.options.legendCallback(this)
            }, destroyDatasetMeta: function (e) {
                var t = this.id, n = this.data.datasets[e], i = n._meta && n._meta[t];
                i && (i.controller.destroy(), delete n._meta[t])
            }, destroy: function () {
                var e, t, n = this, i = n.canvas;
                for (n.stop(), e = 0, t = n.data.datasets.length; e < t; ++e) n.destroyDatasetMeta(e);
                i && (n.unbindEvents(), N.canvas.clear(n), Et.releaseContext(n.ctx), n.canvas = null, n.ctx = null), Ct.notify(n, "destroy"), delete Xt.instances[n.id]
            }, toBase64Image: function () {
                return this.canvas.toDataURL.apply(this.canvas, arguments)
            }, initToolTip: function () {
                var e = this;
                e.tooltip = new Nt({_chart: e, _chartInstance: e, _data: e.data, _options: e.options.tooltips}, e)
            }, bindEvents: function () {
                var e = this, t = e._listeners = {}, n = function () {
                    e.eventHandler.apply(e, arguments)
                };
                N.each(e.options.events, (function (i) {
                    Et.addEventListener(e, i, n), t[i] = n
                })), e.options.responsive && (n = function () {
                    e.resize()
                }, Et.addEventListener(e, "resize", n), t.resize = n)
            }, unbindEvents: function () {
                var e = this, t = e._listeners;
                t && (delete e._listeners, N.each(t, (function (t, n) {
                    Et.removeEventListener(e, n, t)
                })))
            }, updateHoverStyle: function (e, t, n) {
                var i, r, o, a = n ? "set" : "remove";
                for (r = 0, o = e.length; r < o; ++r) (i = e[r]) && this.getDatasetMeta(i._datasetIndex).controller[a + "HoverStyle"](i);
                "dataset" === t && this.getDatasetMeta(e[0]._datasetIndex).controller["_" + a + "DatasetHoverStyle"]()
            }, eventHandler: function (e) {
                var t = this, n = t.tooltip;
                if (!1 !== Ct.notify(t, "beforeEvent", [e])) {
                    t._bufferedRender = !0, t._bufferedRequest = null;
                    var i = t.handleEvent(e);
                    n && (i = n._start ? n.handleEvent(e) : i | n.handleEvent(e)), Ct.notify(t, "afterEvent", [e]);
                    var r = t._bufferedRequest;
                    return r ? t.render(r) : i && !t.animating && (t.stop(), t.render({
                        duration: t.options.hover.animationDuration,
                        lazy: !0
                    })), t._bufferedRender = !1, t._bufferedRequest = null, t
                }
            }, handleEvent: function (e) {
                var t, n = this, i = n.options || {}, r = i.hover;
                return n.lastActive = n.lastActive || [], "mouseout" === e.type ? n.active = [] : n.active = n.getElementsAtEventForMode(e, r.mode, r), N.callback(i.onHover || i.hover.onHover, [e.native, n.active], n), "mouseup" !== e.type && "click" !== e.type || i.onClick && i.onClick.call(n, e.native, n.active), n.lastActive.length && n.updateHoverStyle(n.lastActive, r.mode, !1), n.active.length && r.mode && n.updateHoverStyle(n.active, r.mode, !0), t = !N.arrayEquals(n.active, n.lastActive), n.lastActive = n.active, t
            }
        }), Xt.instances = {};
        var Jt = Xt;

        function Kt() {
            throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")
        }

        function Qt(e) {
            this.options = e || {}
        }

        Xt.Controller = Xt, Xt.types = {}, N.configMerge = Vt, N.scaleMerge = Wt, N.extend(Qt.prototype, {
            formats: Kt,
            parse: Kt,
            format: Kt,
            add: Kt,
            diff: Kt,
            startOf: Kt,
            endOf: Kt,
            _create: function (e) {
                return e
            }
        }), Qt.override = function (e) {
            N.extend(Qt.prototype, e)
        };
        var en = {_date: Qt}, tn = {
            formatters: {
                values: function (e) {
                    return N.isArray(e) ? e : "" + e
                }, linear: function (e, t, n) {
                    var i = n.length > 3 ? n[2] - n[1] : n[1] - n[0];
                    Math.abs(i) > 1 && e !== Math.floor(e) && (i = e - Math.floor(e));
                    var r = N.log10(Math.abs(i)), o = "";
                    if (0 !== e) if (Math.max(Math.abs(n[0]), Math.abs(n[n.length - 1])) < 1e-4) {
                        var a = N.log10(Math.abs(e)), s = Math.floor(a) - Math.floor(r);
                        s = Math.max(Math.min(s, 20), 0), o = e.toExponential(s)
                    } else {
                        var l = -1 * Math.floor(r);
                        l = Math.max(Math.min(l, 20), 0), o = e.toFixed(l)
                    } else o = "0";
                    return o
                }, logarithmic: function (e, t, n) {
                    var i = e / Math.pow(10, Math.floor(N.log10(e)));
                    return 0 === e ? "0" : 1 === i || 2 === i || 5 === i || 0 === t || t === n.length - 1 ? e.toExponential() : ""
                }
            }
        }, nn = N.isArray, rn = N.isNullOrUndef, on = N.valueOrDefault, an = N.valueAtIndexOrDefault;

        function sn(e, t, n) {
            var i, r = e.getTicks().length, o = Math.min(t, r - 1), a = e.getPixelForTick(o), s = e._startPixel,
                l = e._endPixel;
            if (!(n && (i = 1 === r ? Math.max(a - s, l - a) : 0 === t ? (e.getPixelForTick(1) - a) / 2 : (a - e.getPixelForTick(o - 1)) / 2, (a += o < t ? i : -i) < s - 1e-6 || a > l + 1e-6))) return a
        }

        function ln(e, t, n, i) {
            var r, o, a, s, l, c, u, d, h, p, f, m, _, g = n.length, y = [], v = [], x = [], b = 0, w = 0;
            for (r = 0; r < g; ++r) {
                if (s = n[r].label, l = n[r].major ? t.major : t.minor, e.font = c = l.string, u = i[c] = i[c] || {
                    data: {},
                    gc: []
                }, d = l.lineHeight, h = p = 0, rn(s) || nn(s)) {
                    if (nn(s)) for (o = 0, a = s.length; o < a; ++o) f = s[o], rn(f) || nn(f) || (h = N.measureText(e, u.data, u.gc, h, f), p += d)
                } else h = N.measureText(e, u.data, u.gc, h, s), p = d;
                y.push(h), v.push(p), x.push(d / 2), b = Math.max(h, b), w = Math.max(p, w)
            }

            function M(e) {
                return {width: y[e] || 0, height: v[e] || 0, offset: x[e] || 0}
            }

            return function (e, t) {
                N.each(e, (function (e) {
                    var n, i = e.gc, r = i.length / 2;
                    if (r > t) {
                        for (n = 0; n < r; ++n) delete e.data[i[n]];
                        i.splice(0, r)
                    }
                }))
            }(i, g), m = y.indexOf(b), _ = v.indexOf(w), {first: M(0), last: M(g - 1), widest: M(m), highest: M(_)}
        }

        function cn(e) {
            return e.drawTicks ? e.tickMarkLength : 0
        }

        function un(e) {
            var t, n;
            return e.display ? (t = N.options._parseFont(e), n = N.options.toPadding(e.padding), t.lineHeight + n.height) : 0
        }

        function dn(e, t) {
            return N.extend(N.options._parseFont({
                fontFamily: on(t.fontFamily, e.fontFamily),
                fontSize: on(t.fontSize, e.fontSize),
                fontStyle: on(t.fontStyle, e.fontStyle),
                lineHeight: on(t.lineHeight, e.lineHeight)
            }), {color: N.options.resolve([t.fontColor, e.fontColor, O.global.defaultFontColor])})
        }

        function hn(e) {
            var t = dn(e, e.minor);
            return {minor: t, major: e.major.enabled ? dn(e, e.major) : t}
        }

        function pn(e) {
            var t, n, i, r = [];
            for (n = 0, i = e.length; n < i; ++n) void 0 !== (t = e[n])._index && r.push(t);
            return r
        }

        function fn(e, t, n, i) {
            var r, o, a, s, l = on(n, 0), c = Math.min(on(i, e.length), e.length), u = 0;
            for (t = Math.ceil(t), i && (t = (r = i - n) / Math.floor(r / t)), s = l; s < 0;) u++, s = Math.round(l + u * t);
            for (o = Math.max(l, 0); o < c; o++) a = e[o], o === s ? (a._index = o, u++, s = Math.round(l + u * t)) : delete a.label
        }

        O._set("scale", {
            display: !0,
            position: "left",
            offset: !1,
            gridLines: {
                display: !0,
                color: "rgba(0,0,0,0.1)",
                lineWidth: 1,
                drawBorder: !0,
                drawOnChartArea: !0,
                drawTicks: !0,
                tickMarkLength: 10,
                zeroLineWidth: 1,
                zeroLineColor: "rgba(0,0,0,0.25)",
                zeroLineBorderDash: [],
                zeroLineBorderDashOffset: 0,
                offsetGridLines: !1,
                borderDash: [],
                borderDashOffset: 0
            },
            scaleLabel: {display: !1, labelString: "", padding: {top: 4, bottom: 4}},
            ticks: {
                beginAtZero: !1,
                minRotation: 0,
                maxRotation: 50,
                mirror: !1,
                padding: 0,
                reverse: !1,
                display: !0,
                autoSkip: !0,
                autoSkipPadding: 0,
                labelOffset: 0,
                callback: tn.formatters.values,
                minor: {},
                major: {}
            }
        });
        var mn = $.extend({
            zeroLineIndex: 0,
            getPadding: function () {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                }
            },
            getTicks: function () {
                return this._ticks
            },
            _getLabels: function () {
                var e = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || []
            },
            mergeTicksOptions: function () {
            },
            beforeUpdate: function () {
                N.callback(this.options.beforeUpdate, [this])
            },
            update: function (e, t, n) {
                var i, r, o, a, s, l = this, c = l.options.ticks, u = c.sampleSize;
                if (l.beforeUpdate(), l.maxWidth = e, l.maxHeight = t, l.margins = N.extend({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, n), l._ticks = null, l.ticks = null, l._labelSizes = null, l._maxLabelLines = 0, l.longestLabelWidth = 0, l.longestTextCache = l.longestTextCache || {}, l._gridLineItems = null, l._labelItems = null, l.beforeSetDimensions(), l.setDimensions(), l.afterSetDimensions(), l.beforeDataLimits(), l.determineDataLimits(), l.afterDataLimits(), l.beforeBuildTicks(), a = l.buildTicks() || [], (!(a = l.afterBuildTicks(a) || a) || !a.length) && l.ticks) for (a = [], i = 0, r = l.ticks.length; i < r; ++i) a.push({
                    value: l.ticks[i],
                    major: !1
                });
                return l._ticks = a, s = u < a.length, o = l._convertTicksToLabels(s ? function (e, t) {
                    for (var n = [], i = e.length / t, r = 0, o = e.length; r < o; r += i) n.push(e[Math.floor(r)]);
                    return n
                }(a, u) : a), l._configure(), l.beforeCalculateTickRotation(), l.calculateTickRotation(), l.afterCalculateTickRotation(), l.beforeFit(), l.fit(), l.afterFit(), l._ticksToDraw = c.display && (c.autoSkip || "auto" === c.source) ? l._autoSkip(a) : a, s && (o = l._convertTicksToLabels(l._ticksToDraw)), l.ticks = o, l.afterUpdate(), l.minSize
            },
            _configure: function () {
                var e, t, n = this, i = n.options.ticks.reverse;
                n.isHorizontal() ? (e = n.left, t = n.right) : (e = n.top, t = n.bottom, i = !i), n._startPixel = e, n._endPixel = t, n._reversePixels = i, n._length = t - e
            },
            afterUpdate: function () {
                N.callback(this.options.afterUpdate, [this])
            },
            beforeSetDimensions: function () {
                N.callback(this.options.beforeSetDimensions, [this])
            },
            setDimensions: function () {
                var e = this;
                e.isHorizontal() ? (e.width = e.maxWidth, e.left = 0, e.right = e.width) : (e.height = e.maxHeight, e.top = 0, e.bottom = e.height), e.paddingLeft = 0, e.paddingTop = 0, e.paddingRight = 0, e.paddingBottom = 0
            },
            afterSetDimensions: function () {
                N.callback(this.options.afterSetDimensions, [this])
            },
            beforeDataLimits: function () {
                N.callback(this.options.beforeDataLimits, [this])
            },
            determineDataLimits: N.noop,
            afterDataLimits: function () {
                N.callback(this.options.afterDataLimits, [this])
            },
            beforeBuildTicks: function () {
                N.callback(this.options.beforeBuildTicks, [this])
            },
            buildTicks: N.noop,
            afterBuildTicks: function (e) {
                var t = this;
                return nn(e) && e.length ? N.callback(t.options.afterBuildTicks, [t, e]) : (t.ticks = N.callback(t.options.afterBuildTicks, [t, t.ticks]) || t.ticks, e)
            },
            beforeTickToLabelConversion: function () {
                N.callback(this.options.beforeTickToLabelConversion, [this])
            },
            convertTicksToLabels: function () {
                var e = this.options.ticks;
                this.ticks = this.ticks.map(e.userCallback || e.callback, this)
            },
            afterTickToLabelConversion: function () {
                N.callback(this.options.afterTickToLabelConversion, [this])
            },
            beforeCalculateTickRotation: function () {
                N.callback(this.options.beforeCalculateTickRotation, [this])
            },
            calculateTickRotation: function () {
                var e, t, n, i, r, o, a, s = this, l = s.options, c = l.ticks, u = s.getTicks().length,
                    d = c.minRotation || 0, h = c.maxRotation, p = d;
                !s._isVisible() || !c.display || d >= h || u <= 1 || !s.isHorizontal() ? s.labelRotation = d : (t = (e = s._getLabelSizes()).widest.width, n = e.highest.height - e.highest.offset, i = Math.min(s.maxWidth, s.chart.width - t), t + 6 > (r = l.offset ? s.maxWidth / u : i / (u - 1)) && (r = i / (u - (l.offset ? .5 : 1)), o = s.maxHeight - cn(l.gridLines) - c.padding - un(l.scaleLabel), a = Math.sqrt(t * t + n * n), p = N.toDegrees(Math.min(Math.asin(Math.min((e.highest.height + 6) / r, 1)), Math.asin(Math.min(o / a, 1)) - Math.asin(n / a))), p = Math.max(d, Math.min(h, p))), s.labelRotation = p)
            },
            afterCalculateTickRotation: function () {
                N.callback(this.options.afterCalculateTickRotation, [this])
            },
            beforeFit: function () {
                N.callback(this.options.beforeFit, [this])
            },
            fit: function () {
                var e = this, t = e.minSize = {width: 0, height: 0}, n = e.chart, i = e.options, r = i.ticks,
                    o = i.scaleLabel, a = i.gridLines, s = e._isVisible(), l = "bottom" === i.position,
                    c = e.isHorizontal();
                if (c ? t.width = e.maxWidth : s && (t.width = cn(a) + un(o)), c ? s && (t.height = cn(a) + un(o)) : t.height = e.maxHeight, r.display && s) {
                    var u = hn(r), d = e._getLabelSizes(), h = d.first, p = d.last, f = d.widest, m = d.highest,
                        _ = .4 * u.minor.lineHeight, g = r.padding;
                    if (c) {
                        var y = 0 !== e.labelRotation, v = N.toRadians(e.labelRotation), x = Math.cos(v),
                            b = Math.sin(v), w = b * f.width + x * (m.height - (y ? m.offset : 0)) + (y ? 0 : _);
                        t.height = Math.min(e.maxHeight, t.height + w + g);
                        var M, T, k = e.getPixelForTick(0) - e.left,
                            S = e.right - e.getPixelForTick(e.getTicks().length - 1);
                        y ? (M = l ? x * h.width + b * h.offset : b * (h.height - h.offset), T = l ? b * (p.height - p.offset) : x * p.width + b * p.offset) : (M = h.width / 2, T = p.width / 2), e.paddingLeft = Math.max((M - k) * e.width / (e.width - k), 0) + 3, e.paddingRight = Math.max((T - S) * e.width / (e.width - S), 0) + 3
                    } else {
                        var D = r.mirror ? 0 : f.width + g + _;
                        t.width = Math.min(e.maxWidth, t.width + D), e.paddingTop = h.height / 2, e.paddingBottom = p.height / 2
                    }
                }
                e.handleMargins(), c ? (e.width = e._length = n.width - e.margins.left - e.margins.right, e.height = t.height) : (e.width = t.width, e.height = e._length = n.height - e.margins.top - e.margins.bottom)
            },
            handleMargins: function () {
                var e = this;
                e.margins && (e.margins.left = Math.max(e.paddingLeft, e.margins.left), e.margins.top = Math.max(e.paddingTop, e.margins.top), e.margins.right = Math.max(e.paddingRight, e.margins.right), e.margins.bottom = Math.max(e.paddingBottom, e.margins.bottom))
            },
            afterFit: function () {
                N.callback(this.options.afterFit, [this])
            },
            isHorizontal: function () {
                var e = this.options.position;
                return "top" === e || "bottom" === e
            },
            isFullWidth: function () {
                return this.options.fullWidth
            },
            getRightValue: function (e) {
                if (rn(e)) return NaN;
                if (("number" == typeof e || e instanceof Number) && !isFinite(e)) return NaN;
                if (e) if (this.isHorizontal()) {
                    if (void 0 !== e.x) return this.getRightValue(e.x)
                } else if (void 0 !== e.y) return this.getRightValue(e.y);
                return e
            },
            _convertTicksToLabels: function (e) {
                var t, n, i, r = this;
                for (r.ticks = e.map((function (e) {
                    return e.value
                })), r.beforeTickToLabelConversion(), t = r.convertTicksToLabels(e) || r.ticks, r.afterTickToLabelConversion(), n = 0, i = e.length; n < i; ++n) e[n].label = t[n];
                return t
            },
            _getLabelSizes: function () {
                var e = this, t = e._labelSizes;
                return t || (e._labelSizes = t = ln(e.ctx, hn(e.options.ticks), e.getTicks(), e.longestTextCache), e.longestLabelWidth = t.widest.width), t
            },
            _parseValue: function (e) {
                var t, n, i, r;
                return nn(e) ? (t = +this.getRightValue(e[0]), n = +this.getRightValue(e[1]), i = Math.min(t, n), r = Math.max(t, n)) : (t = void 0, n = e = +this.getRightValue(e), i = e, r = e), {
                    min: i,
                    max: r,
                    start: t,
                    end: n
                }
            },
            _getScaleLabel: function (e) {
                var t = this._parseValue(e);
                return void 0 !== t.start ? "[" + t.start + ", " + t.end + "]" : +this.getRightValue(e)
            },
            getLabelForIndex: N.noop,
            getPixelForValue: N.noop,
            getValueForPixel: N.noop,
            getPixelForTick: function (e) {
                var t = this.options.offset, n = this._ticks.length, i = 1 / Math.max(n - (t ? 0 : 1), 1);
                return e < 0 || e > n - 1 ? null : this.getPixelForDecimal(e * i + (t ? i / 2 : 0))
            },
            getPixelForDecimal: function (e) {
                return this._reversePixels && (e = 1 - e), this._startPixel + e * this._length
            },
            getDecimalForPixel: function (e) {
                var t = (e - this._startPixel) / this._length;
                return this._reversePixels ? 1 - t : t
            },
            getBasePixel: function () {
                return this.getPixelForValue(this.getBaseValue())
            },
            getBaseValue: function () {
                var e = this.min, t = this.max;
                return this.beginAtZero ? 0 : e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0
            },
            _autoSkip: function (e) {
                var t, n, i, r, o = this.options.ticks, a = this._length,
                    s = o.maxTicksLimit || a / this._tickSize() + 1, l = o.major.enabled ? function (e) {
                        var t, n, i = [];
                        for (t = 0, n = e.length; t < n; t++) e[t].major && i.push(t);
                        return i
                    }(e) : [], c = l.length, u = l[0], d = l[c - 1];
                if (c > s) return function (e, t, n) {
                    var i, r, o = 0, a = t[0];
                    for (n = Math.ceil(n), i = 0; i < e.length; i++) r = e[i], i === a ? (r._index = i, a = t[++o * n]) : delete r.label
                }(e, l, c / s), pn(e);
                if (i = function (e, t, n, i) {
                    var r, o, a, s, l = function (e) {
                        var t, n, i = e.length;
                        if (i < 2) return !1;
                        for (n = e[0], t = 1; t < i; ++t) if (e[t] - e[t - 1] !== n) return !1;
                        return n
                    }(e), c = (t.length - 1) / i;
                    if (!l) return Math.max(c, 1);
                    for (a = 0, s = (r = N.math._factorize(l)).length - 1; a < s; a++) if ((o = r[a]) > c) return o;
                    return Math.max(c, 1)
                }(l, e, 0, s), c > 0) {
                    for (t = 0, n = c - 1; t < n; t++) fn(e, i, l[t], l[t + 1]);
                    return r = c > 1 ? (d - u) / (c - 1) : null, fn(e, i, N.isNullOrUndef(r) ? 0 : u - r, u), fn(e, i, d, N.isNullOrUndef(r) ? e.length : d + r), pn(e)
                }
                return fn(e, i), pn(e)
            },
            _tickSize: function () {
                var e = this.options.ticks, t = N.toRadians(this.labelRotation), n = Math.abs(Math.cos(t)),
                    i = Math.abs(Math.sin(t)), r = this._getLabelSizes(), o = e.autoSkipPadding || 0,
                    a = r ? r.widest.width + o : 0, s = r ? r.highest.height + o : 0;
                return this.isHorizontal() ? s * n > a * i ? a / n : s / i : s * i < a * n ? s / n : a / i
            },
            _isVisible: function () {
                var e, t, n, i = this.chart, r = this.options.display;
                if ("auto" !== r) return !!r;
                for (e = 0, t = i.data.datasets.length; e < t; ++e) if (i.isDatasetVisible(e) && ((n = i.getDatasetMeta(e)).xAxisID === this.id || n.yAxisID === this.id)) return !0;
                return !1
            },
            _computeGridLineItems: function (e) {
                var t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y = this, v = y.chart, x = y.options,
                    b = x.gridLines, w = x.position, M = b.offsetGridLines, T = y.isHorizontal(), k = y._ticksToDraw,
                    S = k.length + (M ? 1 : 0), D = cn(b), L = [], E = b.drawBorder ? an(b.lineWidth, 0, 0) : 0,
                    C = E / 2, A = N._alignPixel, I = function (e) {
                        return A(v, e, E)
                    };
                for ("top" === w ? (t = I(y.bottom), s = y.bottom - D, c = t - C, d = I(e.top) + C, p = e.bottom) : "bottom" === w ? (t = I(y.top), d = e.top, p = I(e.bottom) - C, s = t + C, c = y.top + D) : "left" === w ? (t = I(y.right), a = y.right - D, l = t - C, u = I(e.left) + C, h = e.right) : (t = I(y.left), u = e.left, h = I(e.right) - C, a = t + C, l = y.left + D), n = 0; n < S; ++n) i = k[n] || {}, rn(i.label) && n < k.length || (n === y.zeroLineIndex && x.offset === M ? (f = b.zeroLineWidth, m = b.zeroLineColor, _ = b.zeroLineBorderDash || [], g = b.zeroLineBorderDashOffset || 0) : (f = an(b.lineWidth, n, 1), m = an(b.color, n, "rgba(0,0,0,0.1)"), _ = b.borderDash || [], g = b.borderDashOffset || 0), void 0 !== (r = sn(y, i._index || n, M)) && (o = A(v, r, f), T ? a = l = u = h = o : s = c = d = p = o, L.push({
                    tx1: a,
                    ty1: s,
                    tx2: l,
                    ty2: c,
                    x1: u,
                    y1: d,
                    x2: h,
                    y2: p,
                    width: f,
                    color: m,
                    borderDash: _,
                    borderDashOffset: g
                })));
                return L.ticksLength = S, L.borderValue = t, L
            },
            _computeLabelItems: function () {
                var e, t, n, i, r, o, a, s, l, c, u, d, h = this, p = h.options, f = p.ticks, m = p.position,
                    _ = f.mirror, g = h.isHorizontal(), y = h._ticksToDraw, v = hn(f), x = f.padding,
                    b = cn(p.gridLines), w = -N.toRadians(h.labelRotation), M = [];
                for ("top" === m ? (o = h.bottom - b - x, a = w ? "left" : "center") : "bottom" === m ? (o = h.top + b + x, a = w ? "right" : "center") : "left" === m ? (r = h.right - (_ ? 0 : b) - x, a = _ ? "left" : "right") : (r = h.left + (_ ? 0 : b) + x, a = _ ? "right" : "left"), e = 0, t = y.length; e < t; ++e) i = (n = y[e]).label, rn(i) || (s = h.getPixelForTick(n._index || e) + f.labelOffset, c = (l = n.major ? v.major : v.minor).lineHeight, u = nn(i) ? i.length : 1, g ? (r = s, d = "top" === m ? ((w ? 1 : .5) - u) * c : (w ? 0 : .5) * c) : (o = s, d = (1 - u) * c / 2), M.push({
                    x: r,
                    y: o,
                    rotation: w,
                    label: i,
                    font: l,
                    textOffset: d,
                    textAlign: a
                }));
                return M
            },
            _drawGrid: function (e) {
                var t = this, n = t.options.gridLines;
                if (n.display) {
                    var i, r, o, a, s, l = t.ctx, c = t.chart, u = N._alignPixel,
                        d = n.drawBorder ? an(n.lineWidth, 0, 0) : 0,
                        h = t._gridLineItems || (t._gridLineItems = t._computeGridLineItems(e));
                    for (o = 0, a = h.length; o < a; ++o) i = (s = h[o]).width, r = s.color, i && r && (l.save(), l.lineWidth = i, l.strokeStyle = r, l.setLineDash && (l.setLineDash(s.borderDash), l.lineDashOffset = s.borderDashOffset), l.beginPath(), n.drawTicks && (l.moveTo(s.tx1, s.ty1), l.lineTo(s.tx2, s.ty2)), n.drawOnChartArea && (l.moveTo(s.x1, s.y1), l.lineTo(s.x2, s.y2)), l.stroke(), l.restore());
                    if (d) {
                        var p, f, m, _, g = d, y = an(n.lineWidth, h.ticksLength - 1, 1), v = h.borderValue;
                        t.isHorizontal() ? (p = u(c, t.left, g) - g / 2, f = u(c, t.right, y) + y / 2, m = _ = v) : (m = u(c, t.top, g) - g / 2, _ = u(c, t.bottom, y) + y / 2, p = f = v), l.lineWidth = d, l.strokeStyle = an(n.color, 0), l.beginPath(), l.moveTo(p, m), l.lineTo(f, _), l.stroke()
                    }
                }
            },
            _drawLabels: function () {
                var e = this;
                if (e.options.ticks.display) {
                    var t, n, i, r, o, a, s, l, c = e.ctx,
                        u = e._labelItems || (e._labelItems = e._computeLabelItems());
                    for (t = 0, i = u.length; t < i; ++t) {
                        if (a = (o = u[t]).font, c.save(), c.translate(o.x, o.y), c.rotate(o.rotation), c.font = a.string, c.fillStyle = a.color, c.textBaseline = "middle", c.textAlign = o.textAlign, s = o.label, l = o.textOffset, nn(s)) for (n = 0, r = s.length; n < r; ++n) c.fillText("" + s[n], 0, l), l += a.lineHeight; else c.fillText(s, 0, l);
                        c.restore()
                    }
                }
            },
            _drawTitle: function () {
                var e = this, t = e.ctx, n = e.options, i = n.scaleLabel;
                if (i.display) {
                    var r, o, a = on(i.fontColor, O.global.defaultFontColor), s = N.options._parseFont(i),
                        l = N.options.toPadding(i.padding), c = s.lineHeight / 2, u = n.position, d = 0;
                    if (e.isHorizontal()) r = e.left + e.width / 2, o = "bottom" === u ? e.bottom - c - l.bottom : e.top + c + l.top; else {
                        var h = "left" === u;
                        r = h ? e.left + c + l.top : e.right - c - l.top, o = e.top + e.height / 2, d = h ? -.5 * Math.PI : .5 * Math.PI
                    }
                    t.save(), t.translate(r, o), t.rotate(d), t.textAlign = "center", t.textBaseline = "middle", t.fillStyle = a, t.font = s.string, t.fillText(i.labelString, 0, 0), t.restore()
                }
            },
            draw: function (e) {
                this._isVisible() && (this._drawGrid(e), this._drawTitle(), this._drawLabels())
            },
            _layers: function () {
                var e = this, t = e.options, n = t.ticks && t.ticks.z || 0, i = t.gridLines && t.gridLines.z || 0;
                return e._isVisible() && n !== i && e.draw === e._draw ? [{
                    z: i, draw: function () {
                        e._drawGrid.apply(e, arguments), e._drawTitle.apply(e, arguments)
                    }
                }, {
                    z: n, draw: function () {
                        e._drawLabels.apply(e, arguments)
                    }
                }] : [{
                    z: n, draw: function () {
                        e.draw.apply(e, arguments)
                    }
                }]
            },
            _getMatchingVisibleMetas: function (e) {
                var t = this, n = t.isHorizontal();
                return t.chart._getSortedVisibleDatasetMetas().filter((function (i) {
                    return (!e || i.type === e) && (n ? i.xAxisID === t.id : i.yAxisID === t.id)
                }))
            }
        });
        mn.prototype._draw = mn.prototype.draw;
        var _n = mn, gn = N.isNullOrUndef, yn = _n.extend({
            determineDataLimits: function () {
                var e, t = this, n = t._getLabels(), i = t.options.ticks, r = i.min, o = i.max, a = 0, s = n.length - 1;
                void 0 !== r && (e = n.indexOf(r)) >= 0 && (a = e), void 0 !== o && (e = n.indexOf(o)) >= 0 && (s = e), t.minIndex = a, t.maxIndex = s, t.min = n[a], t.max = n[s]
            }, buildTicks: function () {
                var e = this._getLabels(), t = this.minIndex, n = this.maxIndex;
                this.ticks = 0 === t && n === e.length - 1 ? e : e.slice(t, n + 1)
            }, getLabelForIndex: function (e, t) {
                var n = this.chart;
                return n.getDatasetMeta(t).controller._getValueScaleId() === this.id ? this.getRightValue(n.data.datasets[t].data[e]) : this._getLabels()[e]
            }, _configure: function () {
                var e = this, t = e.options.offset, n = e.ticks;
                _n.prototype._configure.call(e), e.isHorizontal() || (e._reversePixels = !e._reversePixels), n && (e._startValue = e.minIndex - (t ? .5 : 0), e._valueRange = Math.max(n.length - (t ? 0 : 1), 1))
            }, getPixelForValue: function (e, t, n) {
                var i, r, o, a = this;
                return gn(t) || gn(n) || (e = a.chart.data.datasets[n].data[t]), gn(e) || (i = a.isHorizontal() ? e.x : e.y), (void 0 !== i || void 0 !== e && isNaN(t)) && (r = a._getLabels(), e = N.valueOrDefault(i, e), t = -1 !== (o = r.indexOf(e)) ? o : t, isNaN(t) && (t = e)), a.getPixelForDecimal((t - a._startValue) / a._valueRange)
            }, getPixelForTick: function (e) {
                var t = this.ticks;
                return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e], e + this.minIndex)
            }, getValueForPixel: function (e) {
                var t = Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
                return Math.min(Math.max(t, 0), this.ticks.length - 1)
            }, getBasePixel: function () {
                return this.bottom
            }
        }), vn = {position: "bottom"};
        yn._defaults = vn;
        var xn = N.noop, bn = N.isNullOrUndef, wn = _n.extend({
            getRightValue: function (e) {
                return "string" == typeof e ? +e : _n.prototype.getRightValue.call(this, e)
            }, handleTickRangeOptions: function () {
                var e = this, t = e.options.ticks;
                if (t.beginAtZero) {
                    var n = N.sign(e.min), i = N.sign(e.max);
                    n < 0 && i < 0 ? e.max = 0 : n > 0 && i > 0 && (e.min = 0)
                }
                var r = void 0 !== t.min || void 0 !== t.suggestedMin,
                    o = void 0 !== t.max || void 0 !== t.suggestedMax;
                void 0 !== t.min ? e.min = t.min : void 0 !== t.suggestedMin && (null === e.min ? e.min = t.suggestedMin : e.min = Math.min(e.min, t.suggestedMin)), void 0 !== t.max ? e.max = t.max : void 0 !== t.suggestedMax && (null === e.max ? e.max = t.suggestedMax : e.max = Math.max(e.max, t.suggestedMax)), r !== o && e.min >= e.max && (r ? e.max = e.min + 1 : e.min = e.max - 1), e.min === e.max && (e.max++, t.beginAtZero || e.min--)
            }, getTickLimit: function () {
                var e, t = this.options.ticks, n = t.stepSize, i = t.maxTicksLimit;
                return n ? e = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1 : (e = this._computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e
            }, _computeTickLimit: function () {
                return Number.POSITIVE_INFINITY
            }, handleDirectionalChanges: xn, buildTicks: function () {
                var e = this, t = e.options.ticks, n = e.getTickLimit(), i = {
                    maxTicks: n = Math.max(2, n),
                    min: t.min,
                    max: t.max,
                    precision: t.precision,
                    stepSize: N.valueOrDefault(t.fixedStepSize, t.stepSize)
                }, r = e.ticks = function (e, t) {
                    var n, i, r, o, a = [], s = e.stepSize, l = s || 1, c = e.maxTicks - 1, u = e.min, d = e.max,
                        h = e.precision, p = t.min, f = t.max, m = N.niceNum((f - p) / c / l) * l;
                    if (m < 1e-14 && bn(u) && bn(d)) return [p, f];
                    (o = Math.ceil(f / m) - Math.floor(p / m)) > c && (m = N.niceNum(o * m / c / l) * l), s || bn(h) ? n = Math.pow(10, N._decimalPlaces(m)) : (n = Math.pow(10, h), m = Math.ceil(m * n) / n), i = Math.floor(p / m) * m, r = Math.ceil(f / m) * m, s && (!bn(u) && N.almostWhole(u / m, m / 1e3) && (i = u), !bn(d) && N.almostWhole(d / m, m / 1e3) && (r = d)), o = (r - i) / m, o = N.almostEquals(o, Math.round(o), m / 1e3) ? Math.round(o) : Math.ceil(o), i = Math.round(i * n) / n, r = Math.round(r * n) / n, a.push(bn(u) ? i : u);
                    for (var _ = 1; _ < o; ++_) a.push(Math.round((i + _ * m) * n) / n);
                    return a.push(bn(d) ? r : d), a
                }(i, e);
                e.handleDirectionalChanges(), e.max = N.max(r), e.min = N.min(r), t.reverse ? (r.reverse(), e.start = e.max, e.end = e.min) : (e.start = e.min, e.end = e.max)
            }, convertTicksToLabels: function () {
                var e = this;
                e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), _n.prototype.convertTicksToLabels.call(e)
            }, _configure: function () {
                var e, t = this, n = t.getTicks(), i = t.min, r = t.max;
                _n.prototype._configure.call(t), t.options.offset && n.length && (i -= e = (r - i) / Math.max(n.length - 1, 1) / 2, r += e), t._startValue = i, t._endValue = r, t._valueRange = r - i
            }
        }), Mn = {position: "left", ticks: {callback: tn.formatters.linear}};

        function Tn(e, t, n, i) {
            var r, o, a = e.options, s = function (e, t, n) {
                var i = [n.type, void 0 === t && void 0 === n.stack ? n.index : "", n.stack].join(".");
                return void 0 === e[i] && (e[i] = {pos: [], neg: []}), e[i]
            }(t, a.stacked, n), l = s.pos, c = s.neg, u = i.length;
            for (r = 0; r < u; ++r) o = e._parseValue(i[r]), isNaN(o.min) || isNaN(o.max) || n.data[r].hidden || (l[r] = l[r] || 0, c[r] = c[r] || 0, a.relativePoints ? l[r] = 100 : o.min < 0 || o.max < 0 ? c[r] += o.min : l[r] += o.max)
        }

        function kn(e, t, n) {
            var i, r, o = n.length;
            for (i = 0; i < o; ++i) r = e._parseValue(n[i]), isNaN(r.min) || isNaN(r.max) || t.data[i].hidden || (e.min = Math.min(e.min, r.min), e.max = Math.max(e.max, r.max))
        }

        var Sn = wn.extend({
            determineDataLimits: function () {
                var e, t, n, i, r = this, o = r.options, a = r.chart.data.datasets, s = r._getMatchingVisibleMetas(),
                    l = o.stacked, c = {}, u = s.length;
                if (r.min = Number.POSITIVE_INFINITY, r.max = Number.NEGATIVE_INFINITY, void 0 === l) for (e = 0; !l && e < u; ++e) l = void 0 !== (t = s[e]).stack;
                for (e = 0; e < u; ++e) n = a[(t = s[e]).index].data, l ? Tn(r, c, t, n) : kn(r, t, n);
                N.each(c, (function (e) {
                    i = e.pos.concat(e.neg), r.min = Math.min(r.min, N.min(i)), r.max = Math.max(r.max, N.max(i))
                })), r.min = N.isFinite(r.min) && !isNaN(r.min) ? r.min : 0, r.max = N.isFinite(r.max) && !isNaN(r.max) ? r.max : 1, r.handleTickRangeOptions()
            }, _computeTickLimit: function () {
                var e;
                return this.isHorizontal() ? Math.ceil(this.width / 40) : (e = N.options._parseFont(this.options.ticks), Math.ceil(this.height / e.lineHeight))
            }, handleDirectionalChanges: function () {
                this.isHorizontal() || this.ticks.reverse()
            }, getLabelForIndex: function (e, t) {
                return this._getScaleLabel(this.chart.data.datasets[t].data[e])
            }, getPixelForValue: function (e) {
                return this.getPixelForDecimal((+this.getRightValue(e) - this._startValue) / this._valueRange)
            }, getValueForPixel: function (e) {
                return this._startValue + this.getDecimalForPixel(e) * this._valueRange
            }, getPixelForTick: function (e) {
                var t = this.ticksAsNumbers;
                return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e])
            }
        }), Dn = Mn;
        Sn._defaults = Dn;
        var Ln = N.valueOrDefault, En = N.math.log10,
            Cn = {position: "left", ticks: {callback: tn.formatters.logarithmic}};

        function An(e, t) {
            return N.isFinite(e) && e >= 0 ? e : t
        }

        var In = _n.extend({
            determineDataLimits: function () {
                var e, t, n, i, r, o, a = this, s = a.options, l = a.chart, c = l.data.datasets, u = a.isHorizontal();

                function d(e) {
                    return u ? e.xAxisID === a.id : e.yAxisID === a.id
                }

                a.min = Number.POSITIVE_INFINITY, a.max = Number.NEGATIVE_INFINITY, a.minNotZero = Number.POSITIVE_INFINITY;
                var h = s.stacked;
                if (void 0 === h) for (e = 0; e < c.length; e++) if (t = l.getDatasetMeta(e), l.isDatasetVisible(e) && d(t) && void 0 !== t.stack) {
                    h = !0;
                    break
                }
                if (s.stacked || h) {
                    var p = {};
                    for (e = 0; e < c.length; e++) {
                        var f = [(t = l.getDatasetMeta(e)).type, void 0 === s.stacked && void 0 === t.stack ? e : "", t.stack].join(".");
                        if (l.isDatasetVisible(e) && d(t)) for (void 0 === p[f] && (p[f] = []), r = 0, o = (i = c[e].data).length; r < o; r++) {
                            var m = p[f];
                            n = a._parseValue(i[r]), isNaN(n.min) || isNaN(n.max) || t.data[r].hidden || n.min < 0 || n.max < 0 || (m[r] = m[r] || 0, m[r] += n.max)
                        }
                    }
                    N.each(p, (function (e) {
                        if (e.length > 0) {
                            var t = N.min(e), n = N.max(e);
                            a.min = Math.min(a.min, t), a.max = Math.max(a.max, n)
                        }
                    }))
                } else for (e = 0; e < c.length; e++) if (t = l.getDatasetMeta(e), l.isDatasetVisible(e) && d(t)) for (r = 0, o = (i = c[e].data).length; r < o; r++) n = a._parseValue(i[r]), isNaN(n.min) || isNaN(n.max) || t.data[r].hidden || n.min < 0 || n.max < 0 || (a.min = Math.min(n.min, a.min), a.max = Math.max(n.max, a.max), 0 !== n.min && (a.minNotZero = Math.min(n.min, a.minNotZero)));
                a.min = N.isFinite(a.min) ? a.min : null, a.max = N.isFinite(a.max) ? a.max : null, a.minNotZero = N.isFinite(a.minNotZero) ? a.minNotZero : null, this.handleTickRangeOptions()
            }, handleTickRangeOptions: function () {
                var e = this, t = e.options.ticks;
                e.min = An(t.min, e.min), e.max = An(t.max, e.max), e.min === e.max && (0 !== e.min && null !== e.min ? (e.min = Math.pow(10, Math.floor(En(e.min)) - 1), e.max = Math.pow(10, Math.floor(En(e.max)) + 1)) : (e.min = 1, e.max = 10)), null === e.min && (e.min = Math.pow(10, Math.floor(En(e.max)) - 1)), null === e.max && (e.max = 0 !== e.min ? Math.pow(10, Math.floor(En(e.min)) + 1) : 10), null === e.minNotZero && (e.min > 0 ? e.minNotZero = e.min : e.max < 1 ? e.minNotZero = Math.pow(10, Math.floor(En(e.max))) : e.minNotZero = 1)
            }, buildTicks: function () {
                var e = this, t = e.options.ticks, n = !e.isHorizontal(), i = {min: An(t.min), max: An(t.max)},
                    r = e.ticks = function (e, t) {
                        var n, i, r = [], o = Ln(e.min, Math.pow(10, Math.floor(En(t.min)))), a = Math.floor(En(t.max)),
                            s = Math.ceil(t.max / Math.pow(10, a));
                        0 === o ? (n = Math.floor(En(t.minNotZero)), i = Math.floor(t.minNotZero / Math.pow(10, n)), r.push(o), o = i * Math.pow(10, n)) : (n = Math.floor(En(o)), i = Math.floor(o / Math.pow(10, n)));
                        var l = n < 0 ? Math.pow(10, Math.abs(n)) : 1;
                        do {
                            r.push(o), 10 == ++i && (i = 1, l = ++n >= 0 ? 1 : l), o = Math.round(i * Math.pow(10, n) * l) / l
                        } while (n < a || n === a && i < s);
                        var c = Ln(e.max, o);
                        return r.push(c), r
                    }(i, e);
                e.max = N.max(r), e.min = N.min(r), t.reverse ? (n = !n, e.start = e.max, e.end = e.min) : (e.start = e.min, e.end = e.max), n && r.reverse()
            }, convertTicksToLabels: function () {
                this.tickValues = this.ticks.slice(), _n.prototype.convertTicksToLabels.call(this)
            }, getLabelForIndex: function (e, t) {
                return this._getScaleLabel(this.chart.data.datasets[t].data[e])
            }, getPixelForTick: function (e) {
                var t = this.tickValues;
                return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e])
            }, _getFirstTickValue: function (e) {
                var t = Math.floor(En(e));
                return Math.floor(e / Math.pow(10, t)) * Math.pow(10, t)
            }, _configure: function () {
                var e = this, t = e.min, n = 0;
                _n.prototype._configure.call(e), 0 === t && (t = e._getFirstTickValue(e.minNotZero), n = Ln(e.options.ticks.fontSize, O.global.defaultFontSize) / e._length), e._startValue = En(t), e._valueOffset = n, e._valueRange = (En(e.max) - En(t)) / (1 - n)
            }, getPixelForValue: function (e) {
                var t = this, n = 0;
                return (e = +t.getRightValue(e)) > t.min && e > 0 && (n = (En(e) - t._startValue) / t._valueRange + t._valueOffset), t.getPixelForDecimal(n)
            }, getValueForPixel: function (e) {
                var t = this, n = t.getDecimalForPixel(e);
                return 0 === n && 0 === t.min ? 0 : Math.pow(10, t._startValue + (n - t._valueOffset) * t._valueRange)
            }
        }), Pn = Cn;
        In._defaults = Pn;
        var Rn = N.valueOrDefault, Yn = N.valueAtIndexOrDefault, zn = N.options.resolve, On = {
            display: !0,
            animate: !0,
            position: "chartArea",
            angleLines: {display: !0, color: "rgba(0,0,0,0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0},
            gridLines: {circular: !1},
            ticks: {
                showLabelBackdrop: !0,
                backdropColor: "rgba(255,255,255,0.75)",
                backdropPaddingY: 2,
                backdropPaddingX: 2,
                callback: tn.formatters.linear
            },
            pointLabels: {
                display: !0, fontSize: 10, callback: function (e) {
                    return e
                }
            }
        };

        function Fn(e) {
            var t = e.ticks;
            return t.display && e.display ? Rn(t.fontSize, O.global.defaultFontSize) + 2 * t.backdropPaddingY : 0
        }

        function Bn(e, t, n, i, r) {
            return e === i || e === r ? {start: t - n / 2, end: t + n / 2} : e < i || e > r ? {
                start: t - n,
                end: t
            } : {start: t, end: t + n}
        }

        function jn(e) {
            return 0 === e || 180 === e ? "center" : e < 180 ? "left" : "right"
        }

        function Hn(e, t, n, i) {
            var r, o, a = n.y + i / 2;
            if (N.isArray(t)) for (r = 0, o = t.length; r < o; ++r) e.fillText(t[r], n.x, a), a += i; else e.fillText(t, n.x, a)
        }

        function Nn(e, t, n) {
            90 === e || 270 === e ? n.y -= t.h / 2 : (e > 270 || e < 90) && (n.y -= t.h)
        }

        function Un(e) {
            return N.isNumber(e) ? e : 0
        }

        var Wn = wn.extend({
            setDimensions: function () {
                var e = this;
                e.width = e.maxWidth, e.height = e.maxHeight, e.paddingTop = Fn(e.options) / 2, e.xCenter = Math.floor(e.width / 2), e.yCenter = Math.floor((e.height - e.paddingTop) / 2), e.drawingArea = Math.min(e.height - e.paddingTop, e.width) / 2
            }, determineDataLimits: function () {
                var e = this, t = e.chart, n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
                N.each(t.data.datasets, (function (r, o) {
                    if (t.isDatasetVisible(o)) {
                        var a = t.getDatasetMeta(o);
                        N.each(r.data, (function (t, r) {
                            var o = +e.getRightValue(t);
                            isNaN(o) || a.data[r].hidden || (n = Math.min(o, n), i = Math.max(o, i))
                        }))
                    }
                })), e.min = n === Number.POSITIVE_INFINITY ? 0 : n, e.max = i === Number.NEGATIVE_INFINITY ? 0 : i, e.handleTickRangeOptions()
            }, _computeTickLimit: function () {
                return Math.ceil(this.drawingArea / Fn(this.options))
            }, convertTicksToLabels: function () {
                var e = this;
                wn.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map((function () {
                    var t = N.callback(e.options.pointLabels.callback, arguments, e);
                    return t || 0 === t ? t : ""
                }))
            }, getLabelForIndex: function (e, t) {
                return +this.getRightValue(this.chart.data.datasets[t].data[e])
            }, fit: function () {
                var e = this.options;
                e.display && e.pointLabels.display ? function (e) {
                    var t, n, i, r = N.options._parseFont(e.options.pointLabels),
                        o = {l: 0, r: e.width, t: 0, b: e.height - e.paddingTop}, a = {};
                    e.ctx.font = r.string, e._pointLabelSizes = [];
                    var s, l, c, u = e.chart.data.labels.length;
                    for (t = 0; t < u; t++) {
                        i = e.getPointPosition(t, e.drawingArea + 5), s = e.ctx, l = r.lineHeight, c = e.pointLabels[t], n = N.isArray(c) ? {
                            w: N.longestText(s, s.font, c),
                            h: c.length * l
                        } : {w: s.measureText(c).width, h: l}, e._pointLabelSizes[t] = n;
                        var d = e.getIndexAngle(t), h = N.toDegrees(d) % 360, p = Bn(h, i.x, n.w, 0, 180),
                            f = Bn(h, i.y, n.h, 90, 270);
                        p.start < o.l && (o.l = p.start, a.l = d), p.end > o.r && (o.r = p.end, a.r = d), f.start < o.t && (o.t = f.start, a.t = d), f.end > o.b && (o.b = f.end, a.b = d)
                    }
                    e.setReductions(e.drawingArea, o, a)
                }(this) : this.setCenterPoint(0, 0, 0, 0)
            }, setReductions: function (e, t, n) {
                var i = this, r = t.l / Math.sin(n.l), o = Math.max(t.r - i.width, 0) / Math.sin(n.r),
                    a = -t.t / Math.cos(n.t), s = -Math.max(t.b - (i.height - i.paddingTop), 0) / Math.cos(n.b);
                r = Un(r), o = Un(o), a = Un(a), s = Un(s), i.drawingArea = Math.min(Math.floor(e - (r + o) / 2), Math.floor(e - (a + s) / 2)), i.setCenterPoint(r, o, a, s)
            }, setCenterPoint: function (e, t, n, i) {
                var r = this, o = r.width - t - r.drawingArea, a = e + r.drawingArea, s = n + r.drawingArea,
                    l = r.height - r.paddingTop - i - r.drawingArea;
                r.xCenter = Math.floor((a + o) / 2 + r.left), r.yCenter = Math.floor((s + l) / 2 + r.top + r.paddingTop)
            }, getIndexAngle: function (e) {
                var t = this.chart, n = (e * (360 / t.data.labels.length) + ((t.options || {}).startAngle || 0)) % 360;
                return (n < 0 ? n + 360 : n) * Math.PI * 2 / 360
            }, getDistanceFromCenterForValue: function (e) {
                var t = this;
                if (N.isNullOrUndef(e)) return NaN;
                var n = t.drawingArea / (t.max - t.min);
                return t.options.ticks.reverse ? (t.max - e) * n : (e - t.min) * n
            }, getPointPosition: function (e, t) {
                var n = this.getIndexAngle(e) - Math.PI / 2;
                return {x: Math.cos(n) * t + this.xCenter, y: Math.sin(n) * t + this.yCenter}
            }, getPointPositionForValue: function (e, t) {
                return this.getPointPosition(e, this.getDistanceFromCenterForValue(t))
            }, getBasePosition: function (e) {
                var t = this.min, n = this.max;
                return this.getPointPositionForValue(e || 0, this.beginAtZero ? 0 : t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0)
            }, _drawGrid: function () {
                var e, t, n, i = this, r = i.ctx, o = i.options, a = o.gridLines, s = o.angleLines,
                    l = Rn(s.lineWidth, a.lineWidth), c = Rn(s.color, a.color);
                if (o.pointLabels.display && function (e) {
                    var t = e.ctx, n = e.options, i = n.pointLabels, r = Fn(n),
                        o = e.getDistanceFromCenterForValue(n.ticks.reverse ? e.min : e.max),
                        a = N.options._parseFont(i);
                    t.save(), t.font = a.string, t.textBaseline = "middle";
                    for (var s = e.chart.data.labels.length - 1; s >= 0; s--) {
                        var l = 0 === s ? r / 2 : 0, c = e.getPointPosition(s, o + l + 5),
                            u = Yn(i.fontColor, s, O.global.defaultFontColor);
                        t.fillStyle = u;
                        var d = e.getIndexAngle(s), h = N.toDegrees(d);
                        t.textAlign = jn(h), Nn(h, e._pointLabelSizes[s], c), Hn(t, e.pointLabels[s], c, a.lineHeight)
                    }
                    t.restore()
                }(i), a.display && N.each(i.ticks, (function (e, n) {
                    0 !== n && (t = i.getDistanceFromCenterForValue(i.ticksAsNumbers[n]), function (e, t, n, i) {
                        var r, o = e.ctx, a = t.circular, s = e.chart.data.labels.length, l = Yn(t.color, i - 1),
                            c = Yn(t.lineWidth, i - 1);
                        if ((a || s) && l && c) {
                            if (o.save(), o.strokeStyle = l, o.lineWidth = c, o.setLineDash && (o.setLineDash(t.borderDash || []), o.lineDashOffset = t.borderDashOffset || 0), o.beginPath(), a) o.arc(e.xCenter, e.yCenter, n, 0, 2 * Math.PI); else {
                                r = e.getPointPosition(0, n), o.moveTo(r.x, r.y);
                                for (var u = 1; u < s; u++) r = e.getPointPosition(u, n), o.lineTo(r.x, r.y)
                            }
                            o.closePath(), o.stroke(), o.restore()
                        }
                    }(i, a, t, n))
                })), s.display && l && c) {
                    for (r.save(), r.lineWidth = l, r.strokeStyle = c, r.setLineDash && (r.setLineDash(zn([s.borderDash, a.borderDash, []])), r.lineDashOffset = zn([s.borderDashOffset, a.borderDashOffset, 0])), e = i.chart.data.labels.length - 1; e >= 0; e--) t = i.getDistanceFromCenterForValue(o.ticks.reverse ? i.min : i.max), n = i.getPointPosition(e, t), r.beginPath(), r.moveTo(i.xCenter, i.yCenter), r.lineTo(n.x, n.y), r.stroke();
                    r.restore()
                }
            }, _drawLabels: function () {
                var e = this, t = e.ctx, n = e.options.ticks;
                if (n.display) {
                    var i, r, o = e.getIndexAngle(0), a = N.options._parseFont(n),
                        s = Rn(n.fontColor, O.global.defaultFontColor);
                    t.save(), t.font = a.string, t.translate(e.xCenter, e.yCenter), t.rotate(o), t.textAlign = "center", t.textBaseline = "middle", N.each(e.ticks, (function (o, l) {
                        (0 !== l || n.reverse) && (i = e.getDistanceFromCenterForValue(e.ticksAsNumbers[l]), n.showLabelBackdrop && (r = t.measureText(o).width, t.fillStyle = n.backdropColor, t.fillRect(-r / 2 - n.backdropPaddingX, -i - a.size / 2 - n.backdropPaddingY, r + 2 * n.backdropPaddingX, a.size + 2 * n.backdropPaddingY)), t.fillStyle = s, t.fillText(o, 0, -i))
                    })), t.restore()
                }
            }, _drawTitle: N.noop
        }), Vn = On;
        Wn._defaults = Vn;
        var Gn = N._deprecated, qn = N.options.resolve, Zn = N.valueOrDefault,
            $n = Number.MIN_SAFE_INTEGER || -9007199254740991, Xn = Number.MAX_SAFE_INTEGER || 9007199254740991, Jn = {
                millisecond: {common: !0, size: 1, steps: 1e3},
                second: {common: !0, size: 1e3, steps: 60},
                minute: {common: !0, size: 6e4, steps: 60},
                hour: {common: !0, size: 36e5, steps: 24},
                day: {common: !0, size: 864e5, steps: 30},
                week: {common: !1, size: 6048e5, steps: 4},
                month: {common: !0, size: 2628e6, steps: 12},
                quarter: {common: !1, size: 7884e6, steps: 4},
                year: {common: !0, size: 3154e7}
            }, Kn = Object.keys(Jn);

        function Qn(e, t) {
            return e - t
        }

        function ei(e) {
            return N.valueOrDefault(e.time.min, e.ticks.min)
        }

        function ti(e) {
            return N.valueOrDefault(e.time.max, e.ticks.max)
        }

        function ni(e, t, n, i) {
            var r = function (e, t, n) {
                    for (var i, r, o, a = 0, s = e.length - 1; a >= 0 && a <= s;) {
                        if (r = e[(i = a + s >> 1) - 1] || null, o = e[i], !r) return {lo: null, hi: o};
                        if (o[t] < n) a = i + 1; else {
                            if (!(r[t] > n)) return {lo: r, hi: o};
                            s = i - 1
                        }
                    }
                    return {lo: o, hi: null}
                }(e, t, n), o = r.lo ? r.hi ? r.lo : e[e.length - 2] : e[0],
                a = r.lo ? r.hi ? r.hi : e[e.length - 1] : e[1], s = a[t] - o[t], l = s ? (n - o[t]) / s : 0,
                c = (a[i] - o[i]) * l;
            return o[i] + c
        }

        function ii(e, t) {
            var n = e._adapter, i = e.options.time, r = i.parser, o = r || i.format, a = t;
            return "function" == typeof r && (a = r(a)), N.isFinite(a) || (a = "string" == typeof o ? n.parse(a, o) : n.parse(a)), null !== a ? +a : (r || "function" != typeof o || (a = o(t), N.isFinite(a) || (a = n.parse(a))), a)
        }

        function ri(e, t) {
            if (N.isNullOrUndef(t)) return null;
            var n = e.options.time, i = ii(e, e.getRightValue(t));
            return null === i || n.round && (i = +e._adapter.startOf(i, n.round)), i
        }

        function oi(e, t, n, i) {
            var r, o, a, s = Kn.length;
            for (r = Kn.indexOf(e); r < s - 1; ++r) if (a = (o = Jn[Kn[r]]).steps ? o.steps : Xn, o.common && Math.ceil((n - t) / (a * o.size)) <= i) return Kn[r];
            return Kn[s - 1]
        }

        function ai(e, t, n) {
            var i, r, o = [], a = {}, s = t.length;
            for (i = 0; i < s; ++i) a[r = t[i]] = i, o.push({value: r, major: !1});
            return 0 !== s && n ? function (e, t, n, i) {
                var r, o, a = e._adapter, s = +a.startOf(t[0].value, i), l = t[t.length - 1].value;
                for (r = s; r <= l; r = +a.add(r, 1, i)) (o = n[r]) >= 0 && (t[o].major = !0);
                return t
            }(e, o, a, n) : o
        }

        var si = _n.extend({
            initialize: function () {
                this.mergeTicksOptions(), _n.prototype.initialize.call(this)
            }, update: function () {
                var e = this, t = e.options, n = t.time || (t.time = {}),
                    i = e._adapter = new en._date(t.adapters.date);
                return Gn("time scale", n.format, "time.format", "time.parser"), Gn("time scale", n.min, "time.min", "ticks.min"), Gn("time scale", n.max, "time.max", "ticks.max"), N.mergeIf(n.displayFormats, i.formats()), _n.prototype.update.apply(e, arguments)
            }, getRightValue: function (e) {
                return e && void 0 !== e.t && (e = e.t), _n.prototype.getRightValue.call(this, e)
            }, determineDataLimits: function () {
                var e, t, n, i, r, o, a, s = this, l = s.chart, c = s._adapter, u = s.options, d = u.time.unit || "day",
                    h = Xn, p = $n, f = [], m = [], _ = [], g = s._getLabels();
                for (e = 0, n = g.length; e < n; ++e) _.push(ri(s, g[e]));
                for (e = 0, n = (l.data.datasets || []).length; e < n; ++e) if (l.isDatasetVisible(e)) if (r = l.data.datasets[e].data, N.isObject(r[0])) for (m[e] = [], t = 0, i = r.length; t < i; ++t) o = ri(s, r[t]), f.push(o), m[e][t] = o; else m[e] = _.slice(0), a || (f = f.concat(_), a = !0); else m[e] = [];
                _.length && (h = Math.min(h, _[0]), p = Math.max(p, _[_.length - 1])), f.length && (f = n > 1 ? function (e) {
                    var t, n, i, r = {}, o = [];
                    for (t = 0, n = e.length; t < n; ++t) r[i = e[t]] || (r[i] = !0, o.push(i));
                    return o
                }(f).sort(Qn) : f.sort(Qn), h = Math.min(h, f[0]), p = Math.max(p, f[f.length - 1])), h = ri(s, ei(u)) || h, p = ri(s, ti(u)) || p, h = h === Xn ? +c.startOf(Date.now(), d) : h, p = p === $n ? +c.endOf(Date.now(), d) + 1 : p, s.min = Math.min(h, p), s.max = Math.max(h + 1, p), s._table = [], s._timestamps = {
                    data: f,
                    datasets: m,
                    labels: _
                }
            }, buildTicks: function () {
                var e, t, n, i = this, r = i.min, o = i.max, a = i.options, s = a.ticks, l = a.time, c = i._timestamps,
                    u = [], d = i.getLabelCapacity(r), h = s.source, p = a.distribution;
                for (c = "data" === h || "auto" === h && "series" === p ? c.data : "labels" === h ? c.labels : function (e, t, n, i) {
                    var r, o = e._adapter, a = e.options, s = a.time, l = s.unit || oi(s.minUnit, t, n, i),
                        c = qn([s.stepSize, s.unitStepSize, 1]), u = "week" === l && s.isoWeekday, d = t, h = [];
                    if (u && (d = +o.startOf(d, "isoWeek", u)), d = +o.startOf(d, u ? "day" : l), o.diff(n, t, l) > 1e5 * c) throw t + " and " + n + " are too far apart with stepSize of " + c + " " + l;
                    for (r = d; r < n; r = +o.add(r, c, l)) h.push(r);
                    return r !== n && "ticks" !== a.bounds || h.push(r), h
                }(i, r, o, d), "ticks" === a.bounds && c.length && (r = c[0], o = c[c.length - 1]), r = ri(i, ei(a)) || r, o = ri(i, ti(a)) || o, e = 0, t = c.length; e < t; ++e) (n = c[e]) >= r && n <= o && u.push(n);
                return i.min = r, i.max = o, i._unit = l.unit || (s.autoSkip ? oi(l.minUnit, i.min, i.max, d) : function (e, t, n, i, r) {
                    var o, a;
                    for (o = Kn.length - 1; o >= Kn.indexOf(n); o--) if (a = Kn[o], Jn[a].common && e._adapter.diff(r, i, a) >= t - 1) return a;
                    return Kn[n ? Kn.indexOf(n) : 0]
                }(i, u.length, l.minUnit, i.min, i.max)), i._majorUnit = s.major.enabled && "year" !== i._unit ? function (e) {
                    for (var t = Kn.indexOf(e) + 1, n = Kn.length; t < n; ++t) if (Jn[Kn[t]].common) return Kn[t]
                }(i._unit) : void 0, i._table = function (e, t, n, i) {
                    if ("linear" === i || !e.length) return [{time: t, pos: 0}, {time: n, pos: 1}];
                    var r, o, a, s, l, c = [], u = [t];
                    for (r = 0, o = e.length; r < o; ++r) (s = e[r]) > t && s < n && u.push(s);
                    for (u.push(n), r = 0, o = u.length; r < o; ++r) l = u[r + 1], a = u[r - 1], s = u[r], void 0 !== a && void 0 !== l && Math.round((l + a) / 2) === s || c.push({
                        time: s,
                        pos: r / (o - 1)
                    });
                    return c
                }(i._timestamps.data, r, o, p), i._offsets = function (e, t, n, i, r) {
                    var o, a, s = 0, l = 0;
                    return r.offset && t.length && (o = ni(e, "time", t[0], "pos"), s = 1 === t.length ? 1 - o : (ni(e, "time", t[1], "pos") - o) / 2, a = ni(e, "time", t[t.length - 1], "pos"), l = 1 === t.length ? a : (a - ni(e, "time", t[t.length - 2], "pos")) / 2), {
                        start: s,
                        end: l,
                        factor: 1 / (s + 1 + l)
                    }
                }(i._table, u, 0, 0, a), s.reverse && u.reverse(), ai(i, u, i._majorUnit)
            }, getLabelForIndex: function (e, t) {
                var n = this, i = n._adapter, r = n.chart.data, o = n.options.time,
                    a = r.labels && e < r.labels.length ? r.labels[e] : "", s = r.datasets[t].data[e];
                return N.isObject(s) && (a = n.getRightValue(s)), o.tooltipFormat ? i.format(ii(n, a), o.tooltipFormat) : "string" == typeof a ? a : i.format(ii(n, a), o.displayFormats.datetime)
            }, tickFormatFunction: function (e, t, n, i) {
                var r = this._adapter, o = this.options, a = o.time.displayFormats, s = a[this._unit],
                    l = this._majorUnit, c = a[l], u = n[t], d = o.ticks, h = l && c && u && u.major,
                    p = r.format(e, i || (h ? c : s)), f = h ? d.major : d.minor,
                    m = qn([f.callback, f.userCallback, d.callback, d.userCallback]);
                return m ? m(p, t, n) : p
            }, convertTicksToLabels: function (e) {
                var t, n, i = [];
                for (t = 0, n = e.length; t < n; ++t) i.push(this.tickFormatFunction(e[t].value, t, e));
                return i
            }, getPixelForOffset: function (e) {
                var t = this._offsets, n = ni(this._table, "time", e, "pos");
                return this.getPixelForDecimal((t.start + n) * t.factor)
            }, getPixelForValue: function (e, t, n) {
                var i = null;
                if (void 0 !== t && void 0 !== n && (i = this._timestamps.datasets[n][t]), null === i && (i = ri(this, e)), null !== i) return this.getPixelForOffset(i)
            }, getPixelForTick: function (e) {
                var t = this.getTicks();
                return e >= 0 && e < t.length ? this.getPixelForOffset(t[e].value) : null
            }, getValueForPixel: function (e) {
                var t = this._offsets, n = this.getDecimalForPixel(e) / t.factor - t.end,
                    i = ni(this._table, "pos", n, "time");
                return this._adapter._create(i)
            }, _getLabelSize: function (e) {
                var t = this.options.ticks, n = this.ctx.measureText(e).width,
                    i = N.toRadians(this.isHorizontal() ? t.maxRotation : t.minRotation), r = Math.cos(i),
                    o = Math.sin(i), a = Zn(t.fontSize, O.global.defaultFontSize);
                return {w: n * r + a * o, h: n * o + a * r}
            }, getLabelWidth: function (e) {
                return this._getLabelSize(e).w
            }, getLabelCapacity: function (e) {
                var t = this, n = t.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond,
                    o = t.tickFormatFunction(e, 0, ai(t, [e], t._majorUnit), r), a = t._getLabelSize(o),
                    s = Math.floor(t.isHorizontal() ? t.width / a.w : t.height / a.h);
                return t.options.offset && s--, s > 0 ? s : 1
            }
        }), li = {
            position: "bottom",
            distribution: "linear",
            bounds: "data",
            adapters: {},
            time: {
                parser: !1,
                unit: !1,
                round: !1,
                displayFormat: !1,
                isoWeekday: !1,
                minUnit: "millisecond",
                displayFormats: {}
            },
            ticks: {autoSkip: !1, source: "auto", major: {enabled: !1}}
        };
        si._defaults = li;
        var ci = {category: yn, linear: Sn, logarithmic: In, radialLinear: Wn, time: si}, ui = {
            datetime: "MMM D, YYYY, h:mm:ss a",
            millisecond: "h:mm:ss.SSS a",
            second: "h:mm:ss a",
            minute: "h:mm a",
            hour: "hA",
            day: "MMM D",
            week: "ll",
            month: "MMM YYYY",
            quarter: "[Q]Q - YYYY",
            year: "YYYY"
        };
        en._date.override("function" == typeof e ? {
            _id: "moment", formats: function () {
                return ui
            }, parse: function (t, n) {
                return "string" == typeof t && "string" == typeof n ? t = e(t, n) : t instanceof e || (t = e(t)), t.isValid() ? t.valueOf() : null
            }, format: function (t, n) {
                return e(t).format(n)
            }, add: function (t, n, i) {
                return e(t).add(n, i).valueOf()
            }, diff: function (t, n, i) {
                return e(t).diff(e(n), i)
            }, startOf: function (t, n, i) {
                return t = e(t), "isoWeek" === n ? t.isoWeekday(i).valueOf() : t.startOf(n).valueOf()
            }, endOf: function (t, n) {
                return e(t).endOf(n).valueOf()
            }, _create: function (t) {
                return e(t)
            }
        } : {}), O._set("global", {plugins: {filler: {propagate: !0}}});
        var di = {
            dataset: function (e) {
                var t = e.fill, n = e.chart, i = n.getDatasetMeta(t),
                    r = i && n.isDatasetVisible(t) && i.dataset._children || [], o = r.length || 0;
                return o ? function (e, t) {
                    return t < o && r[t]._view || null
                } : null
            }, boundary: function (e) {
                var t = e.boundary, n = t ? t.x : null, i = t ? t.y : null;
                return N.isArray(t) ? function (e, n) {
                    return t[n]
                } : function (e) {
                    return {x: null === n ? e.x : n, y: null === i ? e.y : i}
                }
            }
        };

        function hi(e, t, n) {
            var i, r = e._model || {}, o = r.fill;
            if (void 0 === o && (o = !!r.backgroundColor), !1 === o || null === o) return !1;
            if (!0 === o) return "origin";
            if (i = parseFloat(o, 10), isFinite(i) && Math.floor(i) === i) return "-" !== o[0] && "+" !== o[0] || (i = t + i), !(i === t || i < 0 || i >= n) && i;
            switch (o) {
                case"bottom":
                    return "start";
                case"top":
                    return "end";
                case"zero":
                    return "origin";
                case"origin":
                case"start":
                case"end":
                    return o;
                default:
                    return !1
            }
        }

        function pi(e) {
            return (e.el._scale || {}).getPointPositionForValue ? function (e) {
                var t, n, i, r, o, a = e.el._scale, s = a.options, l = a.chart.data.labels.length, c = e.fill, u = [];
                if (!l) return null;
                for (t = s.ticks.reverse ? a.max : a.min, n = s.ticks.reverse ? a.min : a.max, i = a.getPointPositionForValue(0, t), r = 0; r < l; ++r) o = "start" === c || "end" === c ? a.getPointPositionForValue(r, "start" === c ? t : n) : a.getBasePosition(r), s.gridLines.circular && (o.cx = i.x, o.cy = i.y, o.angle = a.getIndexAngle(r) - Math.PI / 2), u.push(o);
                return u
            }(e) : function (e) {
                var t, n = e.el._model || {}, i = e.el._scale || {}, r = e.fill, o = null;
                if (isFinite(r)) return null;
                if ("start" === r ? o = void 0 === n.scaleBottom ? i.bottom : n.scaleBottom : "end" === r ? o = void 0 === n.scaleTop ? i.top : n.scaleTop : void 0 !== n.scaleZero ? o = n.scaleZero : i.getBasePixel && (o = i.getBasePixel()), null != o) {
                    if (void 0 !== o.x && void 0 !== o.y) return o;
                    if (N.isFinite(o)) return {x: (t = i.isHorizontal()) ? o : null, y: t ? null : o}
                }
                return null
            }(e)
        }

        function fi(e, t, n) {
            var i, r = e[t].fill, o = [t];
            if (!n) return r;
            for (; !1 !== r && -1 === o.indexOf(r);) {
                if (!isFinite(r)) return r;
                if (!(i = e[r])) return !1;
                if (i.visible) return r;
                o.push(r), r = i.fill
            }
            return !1
        }

        function mi(e) {
            var t = e.fill, n = "dataset";
            return !1 === t ? null : (isFinite(t) || (n = "boundary"), di[n](e))
        }

        function _i(e) {
            return e && !e.skip
        }

        function gi(e, t, n, i, r) {
            var o, a, s, l;
            if (i && r) {
                for (e.moveTo(t[0].x, t[0].y), o = 1; o < i; ++o) N.canvas.lineTo(e, t[o - 1], t[o]);
                if (void 0 === n[0].angle) for (e.lineTo(n[r - 1].x, n[r - 1].y), o = r - 1; o > 0; --o) N.canvas.lineTo(e, n[o], n[o - 1], !0); else for (a = n[0].cx, s = n[0].cy, l = Math.sqrt(Math.pow(n[0].x - a, 2) + Math.pow(n[0].y - s, 2)), o = r - 1; o > 0; --o) e.arc(a, s, l, n[o].angle, n[o - 1].angle, !0)
            }
        }

        function yi(e, t, n, i, r, o) {
            var a, s, l, c, u, d, h, p, f = t.length, m = i.spanGaps, _ = [], g = [], y = 0, v = 0;
            for (e.beginPath(), a = 0, s = f; a < s; ++a) u = n(c = t[l = a % f]._view, l, i), d = _i(c), h = _i(u), o && void 0 === p && d && (s = f + (p = a + 1)), d && h ? (y = _.push(c), v = g.push(u)) : y && v && (m ? (d && _.push(c), h && g.push(u)) : (gi(e, _, g, y, v), y = v = 0, _ = [], g = []));
            gi(e, _, g, y, v), e.closePath(), e.fillStyle = r, e.fill()
        }

        var vi = {
            id: "filler", afterDatasetsUpdate: function (e, t) {
                var n, i, r, o, a = (e.data.datasets || []).length, s = t.propagate, l = [];
                for (i = 0; i < a; ++i) o = null, (r = (n = e.getDatasetMeta(i)).dataset) && r._model && r instanceof we.Line && (o = {
                    visible: e.isDatasetVisible(i),
                    fill: hi(r, i, a),
                    chart: e,
                    el: r
                }), n.$filler = o, l.push(o);
                for (i = 0; i < a; ++i) (o = l[i]) && (o.fill = fi(l, i, s), o.boundary = pi(o), o.mapper = mi(o))
            }, beforeDatasetsDraw: function (e) {
                var t, n, i, r, o, a, s, l = e._getSortedVisibleDatasetMetas(), c = e.ctx;
                for (n = l.length - 1; n >= 0; --n) (t = l[n].$filler) && t.visible && (r = (i = t.el)._view, o = i._children || [], a = t.mapper, s = r.backgroundColor || O.global.defaultColor, a && s && o.length && (N.canvas.clipArea(c, e.chartArea), yi(c, o, a, r, s, i._loop), N.canvas.unclipArea(c)))
            }
        }, xi = N.rtl.getRtlAdapter, bi = N.noop, wi = N.valueOrDefault;

        function Mi(e, t) {
            return e.usePointStyle && e.boxWidth > t ? t : e.boxWidth
        }

        O._set("global", {
            legend: {
                display: !0,
                position: "top",
                align: "center",
                fullWidth: !0,
                reverse: !1,
                weight: 1e3,
                onClick: function (e, t) {
                    var n = t.datasetIndex, i = this.chart, r = i.getDatasetMeta(n);
                    r.hidden = null === r.hidden ? !i.data.datasets[n].hidden : null, i.update()
                },
                onHover: null,
                onLeave: null,
                labels: {
                    boxWidth: 40, padding: 10, generateLabels: function (e) {
                        var t = e.data.datasets, n = e.options.legend || {}, i = n.labels && n.labels.usePointStyle;
                        return e._getSortedDatasetMetas().map((function (n) {
                            var r = n.controller.getStyle(i ? 0 : void 0);
                            return {
                                text: t[n.index].label,
                                fillStyle: r.backgroundColor,
                                hidden: !e.isDatasetVisible(n.index),
                                lineCap: r.borderCapStyle,
                                lineDash: r.borderDash,
                                lineDashOffset: r.borderDashOffset,
                                lineJoin: r.borderJoinStyle,
                                lineWidth: r.borderWidth,
                                strokeStyle: r.borderColor,
                                pointStyle: r.pointStyle,
                                rotation: r.rotation,
                                datasetIndex: n.index
                            }
                        }), this)
                    }
                }
            }, legendCallback: function (e) {
                var t, n, i, r = document.createElement("ul"), o = e.data.datasets;
                for (r.setAttribute("class", e.id + "-legend"), t = 0, n = o.length; t < n; t++) (i = r.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o[t].backgroundColor, o[t].label && i.appendChild(document.createTextNode(o[t].label));
                return r.outerHTML
            }
        });
        var Ti = $.extend({
            initialize: function (e) {
                N.extend(this, e), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1
            }, beforeUpdate: bi, update: function (e, t, n) {
                var i = this;
                return i.beforeUpdate(), i.maxWidth = e, i.maxHeight = t, i.margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize
            }, afterUpdate: bi, beforeSetDimensions: bi, setDimensions: function () {
                var e = this;
                e.isHorizontal() ? (e.width = e.maxWidth, e.left = 0, e.right = e.width) : (e.height = e.maxHeight, e.top = 0, e.bottom = e.height), e.paddingLeft = 0, e.paddingTop = 0, e.paddingRight = 0, e.paddingBottom = 0, e.minSize = {
                    width: 0,
                    height: 0
                }
            }, afterSetDimensions: bi, beforeBuildLabels: bi, buildLabels: function () {
                var e = this, t = e.options.labels || {}, n = N.callback(t.generateLabels, [e.chart], e) || [];
                t.filter && (n = n.filter((function (n) {
                    return t.filter(n, e.chart.data)
                }))), e.options.reverse && n.reverse(), e.legendItems = n
            }, afterBuildLabels: bi, beforeFit: bi, fit: function () {
                var e = this, t = e.options, n = t.labels, i = t.display, r = e.ctx, o = N.options._parseFont(n),
                    a = o.size, s = e.legendHitBoxes = [], l = e.minSize, c = e.isHorizontal();
                if (c ? (l.width = e.maxWidth, l.height = i ? 10 : 0) : (l.width = i ? 10 : 0, l.height = e.maxHeight), i) {
                    if (r.font = o.string, c) {
                        var u = e.lineWidths = [0], d = 0;
                        r.textAlign = "left", r.textBaseline = "middle", N.each(e.legendItems, (function (e, t) {
                            var i = Mi(n, a) + a / 2 + r.measureText(e.text).width;
                            (0 === t || u[u.length - 1] + i + 2 * n.padding > l.width) && (d += a + n.padding, u[u.length - (t > 0 ? 0 : 1)] = 0), s[t] = {
                                left: 0,
                                top: 0,
                                width: i,
                                height: a
                            }, u[u.length - 1] += i + n.padding
                        })), l.height += d
                    } else {
                        var h = n.padding, p = e.columnWidths = [], f = e.columnHeights = [], m = n.padding, _ = 0,
                            g = 0;
                        N.each(e.legendItems, (function (e, t) {
                            var i = Mi(n, a) + a / 2 + r.measureText(e.text).width;
                            t > 0 && g + a + 2 * h > l.height && (m += _ + n.padding, p.push(_), f.push(g), _ = 0, g = 0), _ = Math.max(_, i), g += a + h, s[t] = {
                                left: 0,
                                top: 0,
                                width: i,
                                height: a
                            }
                        })), m += _, p.push(_), f.push(g), l.width += m
                    }
                    e.width = l.width, e.height = l.height
                } else e.width = l.width = e.height = l.height = 0
            }, afterFit: bi, isHorizontal: function () {
                return "top" === this.options.position || "bottom" === this.options.position
            }, draw: function () {
                var e = this, t = e.options, n = t.labels, i = O.global, r = i.defaultColor, o = i.elements.line,
                    a = e.height, s = e.columnHeights, l = e.width, c = e.lineWidths;
                if (t.display) {
                    var u, d = xi(t.rtl, e.left, e.minSize.width), h = e.ctx, p = wi(n.fontColor, i.defaultFontColor),
                        f = N.options._parseFont(n), m = f.size;
                    h.textAlign = d.textAlign("left"), h.textBaseline = "middle", h.lineWidth = .5, h.strokeStyle = p, h.fillStyle = p, h.font = f.string;
                    var _ = Mi(n, m), g = e.legendHitBoxes, y = function (e, i) {
                        switch (t.align) {
                            case"start":
                                return n.padding;
                            case"end":
                                return e - i;
                            default:
                                return (e - i + n.padding) / 2
                        }
                    }, v = e.isHorizontal();
                    u = v ? {x: e.left + y(l, c[0]), y: e.top + n.padding, line: 0} : {
                        x: e.left + n.padding,
                        y: e.top + y(a, s[0]),
                        line: 0
                    }, N.rtl.overrideTextDirection(e.ctx, t.textDirection);
                    var x = m + n.padding;
                    N.each(e.legendItems, (function (t, i) {
                        var p = h.measureText(t.text).width, f = _ + m / 2 + p, b = u.x, w = u.y;
                        d.setWidth(e.minSize.width), v ? i > 0 && b + f + n.padding > e.left + e.minSize.width && (w = u.y += x, u.line++, b = u.x = e.left + y(l, c[u.line])) : i > 0 && w + x > e.top + e.minSize.height && (b = u.x = b + e.columnWidths[u.line] + n.padding, u.line++, w = u.y = e.top + y(a, s[u.line]));
                        var M = d.x(b);
                        !function (e, t, i) {
                            if (!(isNaN(_) || _ <= 0)) {
                                h.save();
                                var a = wi(i.lineWidth, o.borderWidth);
                                if (h.fillStyle = wi(i.fillStyle, r), h.lineCap = wi(i.lineCap, o.borderCapStyle), h.lineDashOffset = wi(i.lineDashOffset, o.borderDashOffset), h.lineJoin = wi(i.lineJoin, o.borderJoinStyle), h.lineWidth = a, h.strokeStyle = wi(i.strokeStyle, r), h.setLineDash && h.setLineDash(wi(i.lineDash, o.borderDash)), n && n.usePointStyle) {
                                    var s = _ * Math.SQRT2 / 2, l = d.xPlus(e, _ / 2), c = t + m / 2;
                                    N.canvas.drawPoint(h, i.pointStyle, s, l, c, i.rotation)
                                } else h.fillRect(d.leftForLtr(e, _), t, _, m), 0 !== a && h.strokeRect(d.leftForLtr(e, _), t, _, m);
                                h.restore()
                            }
                        }(M, w, t), g[i].left = d.leftForLtr(M, g[i].width), g[i].top = w, function (e, t, n, i) {
                            var r = m / 2, o = d.xPlus(e, _ + r), a = t + r;
                            h.fillText(n.text, o, a), n.hidden && (h.beginPath(), h.lineWidth = 2, h.moveTo(o, a), h.lineTo(d.xPlus(o, i), a), h.stroke())
                        }(M, w, t, p), v ? u.x += f + n.padding : u.y += x
                    })), N.rtl.restoreTextDirection(e.ctx, t.textDirection)
                }
            }, _getLegendItemAt: function (e, t) {
                var n, i, r, o = this;
                if (e >= o.left && e <= o.right && t >= o.top && t <= o.bottom) for (r = o.legendHitBoxes, n = 0; n < r.length; ++n) if (e >= (i = r[n]).left && e <= i.left + i.width && t >= i.top && t <= i.top + i.height) return o.legendItems[n];
                return null
            }, handleEvent: function (e) {
                var t, n = this, i = n.options, r = "mouseup" === e.type ? "click" : e.type;
                if ("mousemove" === r) {
                    if (!i.onHover && !i.onLeave) return
                } else {
                    if ("click" !== r) return;
                    if (!i.onClick) return
                }
                t = n._getLegendItemAt(e.x, e.y), "click" === r ? t && i.onClick && i.onClick.call(n, e.native, t) : (i.onLeave && t !== n._hoveredItem && (n._hoveredItem && i.onLeave.call(n, e.native, n._hoveredItem), n._hoveredItem = t), i.onHover && t && i.onHover.call(n, e.native, t))
            }
        });

        function ki(e, t) {
            var n = new Ti({ctx: e.ctx, options: t, chart: e});
            mt.configure(e, n, t), mt.addBox(e, n), e.legend = n
        }

        var Si = {
            id: "legend", _element: Ti, beforeInit: function (e) {
                var t = e.options.legend;
                t && ki(e, t)
            }, beforeUpdate: function (e) {
                var t = e.options.legend, n = e.legend;
                t ? (N.mergeIf(t, O.global.legend), n ? (mt.configure(e, n, t), n.options = t) : ki(e, t)) : n && (mt.removeBox(e, n), delete e.legend)
            }, afterEvent: function (e, t) {
                var n = e.legend;
                n && n.handleEvent(t)
            }
        }, Di = N.noop;
        O._set("global", {
            title: {
                display: !1,
                fontStyle: "bold",
                fullWidth: !0,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            }
        });
        var Li = $.extend({
            initialize: function (e) {
                N.extend(this, e), this.legendHitBoxes = []
            },
            beforeUpdate: Di,
            update: function (e, t, n) {
                var i = this;
                return i.beforeUpdate(), i.maxWidth = e, i.maxHeight = t, i.margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize
            },
            afterUpdate: Di,
            beforeSetDimensions: Di,
            setDimensions: function () {
                var e = this;
                e.isHorizontal() ? (e.width = e.maxWidth, e.left = 0, e.right = e.width) : (e.height = e.maxHeight, e.top = 0, e.bottom = e.height), e.paddingLeft = 0, e.paddingTop = 0, e.paddingRight = 0, e.paddingBottom = 0, e.minSize = {
                    width: 0,
                    height: 0
                }
            },
            afterSetDimensions: Di,
            beforeBuildLabels: Di,
            buildLabels: Di,
            afterBuildLabels: Di,
            beforeFit: Di,
            fit: function () {
                var e, t = this, n = t.options, i = t.minSize = {}, r = t.isHorizontal();
                n.display ? (e = (N.isArray(n.text) ? n.text.length : 1) * N.options._parseFont(n).lineHeight + 2 * n.padding, t.width = i.width = r ? t.maxWidth : e, t.height = i.height = r ? e : t.maxHeight) : t.width = i.width = t.height = i.height = 0
            },
            afterFit: Di,
            isHorizontal: function () {
                var e = this.options.position;
                return "top" === e || "bottom" === e
            },
            draw: function () {
                var e = this, t = e.ctx, n = e.options;
                if (n.display) {
                    var i, r, o, a = N.options._parseFont(n), s = a.lineHeight, l = s / 2 + n.padding, c = 0, u = e.top,
                        d = e.left, h = e.bottom, p = e.right;
                    t.fillStyle = N.valueOrDefault(n.fontColor, O.global.defaultFontColor), t.font = a.string, e.isHorizontal() ? (r = d + (p - d) / 2, o = u + l, i = p - d) : (r = "left" === n.position ? d + l : p - l, o = u + (h - u) / 2, i = h - u, c = Math.PI * ("left" === n.position ? -.5 : .5)), t.save(), t.translate(r, o), t.rotate(c), t.textAlign = "center", t.textBaseline = "middle";
                    var f = n.text;
                    if (N.isArray(f)) for (var m = 0, _ = 0; _ < f.length; ++_) t.fillText(f[_], 0, m, i), m += s; else t.fillText(f, 0, 0, i);
                    t.restore()
                }
            }
        });

        function Ei(e, t) {
            var n = new Li({ctx: e.ctx, options: t, chart: e});
            mt.configure(e, n, t), mt.addBox(e, n), e.titleBlock = n
        }

        var Ci = {}, Ai = vi, Ii = Si, Pi = {
            id: "title", _element: Li, beforeInit: function (e) {
                var t = e.options.title;
                t && Ei(e, t)
            }, beforeUpdate: function (e) {
                var t = e.options.title, n = e.titleBlock;
                t ? (N.mergeIf(t, O.global.title), n ? (mt.configure(e, n, t), n.options = t) : Ei(e, t)) : n && (mt.removeBox(e, n), delete e.titleBlock)
            }
        };
        for (var Ri in Ci.filler = Ai, Ci.legend = Ii, Ci.title = Pi, Jt.helpers = N, function () {
            function e(e, t, n) {
                var i;
                return "string" == typeof e ? (i = parseInt(e, 10), -1 !== e.indexOf("%") && (i = i / 100 * t.parentNode[n])) : i = e, i
            }

            function t(e) {
                return null != e && "none" !== e
            }

            function n(n, i, r) {
                var o = document.defaultView, a = N._getParentNode(n), s = o.getComputedStyle(n)[i],
                    l = o.getComputedStyle(a)[i], c = t(s), u = t(l), d = Number.POSITIVE_INFINITY;
                return c || u ? Math.min(c ? e(s, n, r) : d, u ? e(l, a, r) : d) : "none"
            }

            N.where = function (e, t) {
                if (N.isArray(e) && Array.prototype.filter) return e.filter(t);
                var n = [];
                return N.each(e, (function (e) {
                    t(e) && n.push(e)
                })), n
            }, N.findIndex = Array.prototype.findIndex ? function (e, t, n) {
                return e.findIndex(t, n)
            } : function (e, t, n) {
                n = void 0 === n ? e : n;
                for (var i = 0, r = e.length; i < r; ++i) if (t.call(n, e[i], i, e)) return i;
                return -1
            }, N.findNextWhere = function (e, t, n) {
                N.isNullOrUndef(n) && (n = -1);
                for (var i = n + 1; i < e.length; i++) {
                    var r = e[i];
                    if (t(r)) return r
                }
            }, N.findPreviousWhere = function (e, t, n) {
                N.isNullOrUndef(n) && (n = e.length);
                for (var i = n - 1; i >= 0; i--) {
                    var r = e[i];
                    if (t(r)) return r
                }
            }, N.isNumber = function (e) {
                return !isNaN(parseFloat(e)) && isFinite(e)
            }, N.almostEquals = function (e, t, n) {
                return Math.abs(e - t) < n
            }, N.almostWhole = function (e, t) {
                var n = Math.round(e);
                return n - t <= e && n + t >= e
            }, N.max = function (e) {
                return e.reduce((function (e, t) {
                    return isNaN(t) ? e : Math.max(e, t)
                }), Number.NEGATIVE_INFINITY)
            }, N.min = function (e) {
                return e.reduce((function (e, t) {
                    return isNaN(t) ? e : Math.min(e, t)
                }), Number.POSITIVE_INFINITY)
            }, N.sign = Math.sign ? function (e) {
                return Math.sign(e)
            } : function (e) {
                return 0 == (e = +e) || isNaN(e) ? e : e > 0 ? 1 : -1
            }, N.toRadians = function (e) {
                return e * (Math.PI / 180)
            }, N.toDegrees = function (e) {
                return e * (180 / Math.PI)
            }, N._decimalPlaces = function (e) {
                if (N.isFinite(e)) {
                    for (var t = 1, n = 0; Math.round(e * t) / t !== e;) t *= 10, n++;
                    return n
                }
            }, N.getAngleFromPoint = function (e, t) {
                var n = t.x - e.x, i = t.y - e.y, r = Math.sqrt(n * n + i * i), o = Math.atan2(i, n);
                return o < -.5 * Math.PI && (o += 2 * Math.PI), {angle: o, distance: r}
            }, N.distanceBetweenPoints = function (e, t) {
                return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
            }, N.aliasPixel = function (e) {
                return e % 2 == 0 ? 0 : .5
            }, N._alignPixel = function (e, t, n) {
                var i = e.currentDevicePixelRatio, r = n / 2;
                return Math.round((t - r) * i) / i + r
            }, N.splineCurve = function (e, t, n, i) {
                var r = e.skip ? t : e, o = t, a = n.skip ? t : n,
                    s = Math.sqrt(Math.pow(o.x - r.x, 2) + Math.pow(o.y - r.y, 2)),
                    l = Math.sqrt(Math.pow(a.x - o.x, 2) + Math.pow(a.y - o.y, 2)), c = s / (s + l), u = l / (s + l),
                    d = i * (c = isNaN(c) ? 0 : c), h = i * (u = isNaN(u) ? 0 : u);
                return {
                    previous: {x: o.x - d * (a.x - r.x), y: o.y - d * (a.y - r.y)},
                    next: {x: o.x + h * (a.x - r.x), y: o.y + h * (a.y - r.y)}
                }
            }, N.EPSILON = Number.EPSILON || 1e-14, N.splineCurveMonotone = function (e) {
                var t, n, i, r, o, a, s, l, c, u = (e || []).map((function (e) {
                    return {model: e._model, deltaK: 0, mK: 0}
                })), d = u.length;
                for (t = 0; t < d; ++t) if (!(i = u[t]).model.skip) {
                    if (n = t > 0 ? u[t - 1] : null, (r = t < d - 1 ? u[t + 1] : null) && !r.model.skip) {
                        var h = r.model.x - i.model.x;
                        i.deltaK = 0 !== h ? (r.model.y - i.model.y) / h : 0
                    }
                    !n || n.model.skip ? i.mK = i.deltaK : !r || r.model.skip ? i.mK = n.deltaK : this.sign(n.deltaK) !== this.sign(i.deltaK) ? i.mK = 0 : i.mK = (n.deltaK + i.deltaK) / 2
                }
                for (t = 0; t < d - 1; ++t) i = u[t], r = u[t + 1], i.model.skip || r.model.skip || (N.almostEquals(i.deltaK, 0, this.EPSILON) ? i.mK = r.mK = 0 : (o = i.mK / i.deltaK, a = r.mK / i.deltaK, (l = Math.pow(o, 2) + Math.pow(a, 2)) <= 9 || (s = 3 / Math.sqrt(l), i.mK = o * s * i.deltaK, r.mK = a * s * i.deltaK)));
                for (t = 0; t < d; ++t) (i = u[t]).model.skip || (n = t > 0 ? u[t - 1] : null, r = t < d - 1 ? u[t + 1] : null, n && !n.model.skip && (c = (i.model.x - n.model.x) / 3, i.model.controlPointPreviousX = i.model.x - c, i.model.controlPointPreviousY = i.model.y - c * i.mK), r && !r.model.skip && (c = (r.model.x - i.model.x) / 3, i.model.controlPointNextX = i.model.x + c, i.model.controlPointNextY = i.model.y + c * i.mK))
            }, N.nextItem = function (e, t, n) {
                return n ? t >= e.length - 1 ? e[0] : e[t + 1] : t >= e.length - 1 ? e[e.length - 1] : e[t + 1]
            }, N.previousItem = function (e, t, n) {
                return n ? t <= 0 ? e[e.length - 1] : e[t - 1] : t <= 0 ? e[0] : e[t - 1]
            }, N.niceNum = function (e, t) {
                var n = Math.floor(N.log10(e)), i = e / Math.pow(10, n);
                return (t ? i < 1.5 ? 1 : i < 3 ? 2 : i < 7 ? 5 : 10 : i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * Math.pow(10, n)
            }, N.requestAnimFrame = "undefined" == typeof window ? function (e) {
                e()
            } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
                return window.setTimeout(e, 1e3 / 60)
            }, N.getRelativePosition = function (e, t) {
                var n, i, r = e.originalEvent || e, o = e.target || e.srcElement, a = o.getBoundingClientRect(),
                    s = r.touches;
                s && s.length > 0 ? (n = s[0].clientX, i = s[0].clientY) : (n = r.clientX, i = r.clientY);
                var l = parseFloat(N.getStyle(o, "padding-left")), c = parseFloat(N.getStyle(o, "padding-top")),
                    u = parseFloat(N.getStyle(o, "padding-right")), d = parseFloat(N.getStyle(o, "padding-bottom")),
                    h = a.right - a.left - l - u, p = a.bottom - a.top - c - d;
                return {
                    x: n = Math.round((n - a.left - l) / h * o.width / t.currentDevicePixelRatio),
                    y: i = Math.round((i - a.top - c) / p * o.height / t.currentDevicePixelRatio)
                }
            }, N.getConstraintWidth = function (e) {
                return n(e, "max-width", "clientWidth")
            }, N.getConstraintHeight = function (e) {
                return n(e, "max-height", "clientHeight")
            }, N._calculatePadding = function (e, t, n) {
                return (t = N.getStyle(e, t)).indexOf("%") > -1 ? n * parseInt(t, 10) / 100 : parseInt(t, 10)
            }, N._getParentNode = function (e) {
                var t = e.parentNode;
                return t && "[object ShadowRoot]" === t.toString() && (t = t.host), t
            }, N.getMaximumWidth = function (e) {
                var t = N._getParentNode(e);
                if (!t) return e.clientWidth;
                var n = t.clientWidth,
                    i = n - N._calculatePadding(t, "padding-left", n) - N._calculatePadding(t, "padding-right", n),
                    r = N.getConstraintWidth(e);
                return isNaN(r) ? i : Math.min(i, r)
            }, N.getMaximumHeight = function (e) {
                var t = N._getParentNode(e);
                if (!t) return e.clientHeight;
                var n = t.clientHeight,
                    i = n - N._calculatePadding(t, "padding-top", n) - N._calculatePadding(t, "padding-bottom", n),
                    r = N.getConstraintHeight(e);
                return isNaN(r) ? i : Math.min(i, r)
            }, N.getStyle = function (e, t) {
                return e.currentStyle ? e.currentStyle[t] : document.defaultView.getComputedStyle(e, null).getPropertyValue(t)
            }, N.retinaScale = function (e, t) {
                var n = e.currentDevicePixelRatio = t || "undefined" != typeof window && window.devicePixelRatio || 1;
                if (1 !== n) {
                    var i = e.canvas, r = e.height, o = e.width;
                    i.height = r * n, i.width = o * n, e.ctx.scale(n, n), i.style.height || i.style.width || (i.style.height = r + "px", i.style.width = o + "px")
                }
            }, N.fontString = function (e, t, n) {
                return t + " " + e + "px " + n
            }, N.longestText = function (e, t, n, i) {
                var r = (i = i || {}).data = i.data || {}, o = i.garbageCollect = i.garbageCollect || [];
                i.font !== t && (r = i.data = {}, o = i.garbageCollect = [], i.font = t), e.font = t;
                var a, s, l, c, u, d = 0, h = n.length;
                for (a = 0; a < h; a++) if (null != (c = n[a]) && !0 !== N.isArray(c)) d = N.measureText(e, r, o, d, c); else if (N.isArray(c)) for (s = 0, l = c.length; s < l; s++) null == (u = c[s]) || N.isArray(u) || (d = N.measureText(e, r, o, d, u));
                var p = o.length / 2;
                if (p > n.length) {
                    for (a = 0; a < p; a++) delete r[o[a]];
                    o.splice(0, p)
                }
                return d
            }, N.measureText = function (e, t, n, i, r) {
                var o = t[r];
                return o || (o = t[r] = e.measureText(r).width, n.push(r)), o > i && (i = o), i
            }, N.numberOfLabelLines = function (e) {
                var t = 1;
                return N.each(e, (function (e) {
                    N.isArray(e) && e.length > t && (t = e.length)
                })), t
            }, N.color = b ? function (e) {
                return e instanceof CanvasGradient && (e = O.global.defaultColor), b(e)
            } : function (e) {
                return console.error("Color.js not found!"), e
            }, N.getHoverColor = function (e) {
                return e instanceof CanvasPattern || e instanceof CanvasGradient ? e : N.color(e).saturate(.5).darken(.1).rgbString()
            }
        }(), Jt._adapters = en, Jt.Animation = J, Jt.animationService = K, Jt.controllers = Ke, Jt.DatasetController = ie, Jt.defaults = O, Jt.Element = $, Jt.elements = we, Jt.Interaction = ot, Jt.layouts = mt, Jt.platform = Et, Jt.plugins = Ct, Jt.Scale = _n, Jt.scaleService = At, Jt.Ticks = tn, Jt.Tooltip = Nt, Jt.helpers.each(ci, (function (e, t) {
            Jt.scaleService.registerScaleType(t, e, e._defaults)
        })), Ci) Ci.hasOwnProperty(Ri) && Jt.plugins.register(Ci[Ri]);
        Jt.platform.initialize();
        var Yi = Jt;
        return "undefined" != typeof window && (window.Chart = Jt), Jt.Chart = Jt, Jt.Legend = Ci.legend._element, Jt.Title = Ci.title._element, Jt.pluginService = Jt.plugins, Jt.PluginBase = Jt.Element.extend({}), Jt.canvasHelpers = Jt.helpers.canvas, Jt.layoutService = Jt.layouts, Jt.LinearScaleBase = wn, Jt.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], (function (e) {
            Jt[e] = function (t, n) {
                return new Jt(t, Jt.helpers.merge(n || {}, {type: e.charAt(0).toLowerCase() + e.slice(1)}))
            }
        })), Yi
    }(function () {
        try {
            return n(0)
        } catch (e) {
        }
    }())
}, function (e, t, n) {
    "use strict";

    /*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
    function i(e) {
        return getComputedStyle(e)
    }

    function r(e, t) {
        for (var n in t) {
            var i = t[n];
            "number" == typeof i && (i += "px"), e.style[n] = i
        }
        return e
    }

    function o(e) {
        var t = document.createElement("div");
        return t.className = e, t
    }

    var a = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);

    function s(e, t) {
        if (!a) throw new Error("No element matching method supported");
        return a.call(e, t)
    }

    function l(e) {
        e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e)
    }

    function c(e, t) {
        return Array.prototype.filter.call(e.children, (function (e) {
            return s(e, t)
        }))
    }

    var u = "ps", d = "ps__rtl", h = {
        thumb: function (e) {
            return "ps__thumb-" + e
        }, rail: function (e) {
            return "ps__rail-" + e
        }, consuming: "ps__child--consume"
    }, p = {
        focus: "ps--focus", clicking: "ps--clicking", active: function (e) {
            return "ps--active-" + e
        }, scrolling: function (e) {
            return "ps--scrolling-" + e
        }
    }, f = {x: null, y: null};

    function m(e, t) {
        var n = e.element.classList, i = p.scrolling(t);
        n.contains(i) ? clearTimeout(f[t]) : n.add(i)
    }

    function _(e, t) {
        f[t] = setTimeout((function () {
            return e.isAlive && e.element.classList.remove(p.scrolling(t))
        }), e.settings.scrollingThreshold)
    }

    var g = function (e) {
        this.element = e, this.handlers = {}
    }, y = {isEmpty: {configurable: !0}};
    g.prototype.bind = function (e, t) {
        void 0 === this.handlers[e] && (this.handlers[e] = []), this.handlers[e].push(t), this.element.addEventListener(e, t, !1)
    }, g.prototype.unbind = function (e, t) {
        var n = this;
        this.handlers[e] = this.handlers[e].filter((function (i) {
            return !(!t || i === t) || (n.element.removeEventListener(e, i, !1), !1)
        }))
    }, g.prototype.unbindAll = function () {
        for (var e in this.handlers) this.unbind(e)
    }, y.isEmpty.get = function () {
        var e = this;
        return Object.keys(this.handlers).every((function (t) {
            return 0 === e.handlers[t].length
        }))
    }, Object.defineProperties(g.prototype, y);
    var v = function () {
        this.eventElements = []
    };

    function x(e) {
        if ("function" == typeof window.CustomEvent) return new CustomEvent(e);
        var t = document.createEvent("CustomEvent");
        return t.initCustomEvent(e, !1, !1, void 0), t
    }

    function b(e, t, n, i, r) {
        var o;
        if (void 0 === i && (i = !0), void 0 === r && (r = !1), "top" === t) o = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"]; else {
            if ("left" !== t) throw new Error("A proper axis should be provided");
            o = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"]
        }
        !function (e, t, n, i, r) {
            var o = n[0], a = n[1], s = n[2], l = n[3], c = n[4], u = n[5];
            void 0 === i && (i = !0);
            void 0 === r && (r = !1);
            var d = e.element;
            e.reach[l] = null, d[s] < 1 && (e.reach[l] = "start");
            d[s] > e[o] - e[a] - 1 && (e.reach[l] = "end");
            t && (d.dispatchEvent(x("ps-scroll-" + l)), t < 0 ? d.dispatchEvent(x("ps-scroll-" + c)) : t > 0 && d.dispatchEvent(x("ps-scroll-" + u)), i && function (e, t) {
                m(e, t), _(e, t)
            }(e, l));
            e.reach[l] && (t || r) && d.dispatchEvent(x("ps-" + l + "-reach-" + e.reach[l]))
        }(e, n, o, i, r)
    }

    function w(e) {
        return parseInt(e, 10) || 0
    }

    v.prototype.eventElement = function (e) {
        var t = this.eventElements.filter((function (t) {
            return t.element === e
        }))[0];
        return t || (t = new g(e), this.eventElements.push(t)), t
    }, v.prototype.bind = function (e, t, n) {
        this.eventElement(e).bind(t, n)
    }, v.prototype.unbind = function (e, t, n) {
        var i = this.eventElement(e);
        i.unbind(t, n), i.isEmpty && this.eventElements.splice(this.eventElements.indexOf(i), 1)
    }, v.prototype.unbindAll = function () {
        this.eventElements.forEach((function (e) {
            return e.unbindAll()
        })), this.eventElements = []
    }, v.prototype.once = function (e, t, n) {
        var i = this.eventElement(e), r = function (e) {
            i.unbind(t, r), n(e)
        };
        i.bind(t, r)
    };
    var M = {
        isWebKit: "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style,
        supportsTouch: "undefined" != typeof window && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
        supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
        isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
    };

    function T(e) {
        var t = e.element, n = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
        e.containerWidth = Math.round(i.width), e.containerHeight = Math.round(i.height), e.contentWidth = t.scrollWidth, e.contentHeight = t.scrollHeight, t.contains(e.scrollbarXRail) || (c(t, h.rail("x")).forEach((function (e) {
            return l(e)
        })), t.appendChild(e.scrollbarXRail)), t.contains(e.scrollbarYRail) || (c(t, h.rail("y")).forEach((function (e) {
            return l(e)
        })), t.appendChild(e.scrollbarYRail)), !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0, e.railXWidth = e.containerWidth - e.railXMarginWidth, e.railXRatio = e.containerWidth / e.railXWidth, e.scrollbarXWidth = k(e, w(e.railXWidth * e.containerWidth / e.contentWidth)), e.scrollbarXLeft = w((e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth))) : e.scrollbarXActive = !1, !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0, e.railYHeight = e.containerHeight - e.railYMarginHeight, e.railYRatio = e.containerHeight / e.railYHeight, e.scrollbarYHeight = k(e, w(e.railYHeight * e.containerHeight / e.contentHeight)), e.scrollbarYTop = w(n * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight))) : e.scrollbarYActive = !1, e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth), e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight), function (e, t) {
            var n = {width: t.railXWidth}, i = Math.floor(e.scrollTop);
            t.isRtl ? n.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : n.left = e.scrollLeft;
            t.isScrollbarXUsingBottom ? n.bottom = t.scrollbarXBottom - i : n.top = t.scrollbarXTop + i;
            r(t.scrollbarXRail, n);
            var o = {top: i, height: t.railYHeight};
            t.isScrollbarYUsingRight ? t.isRtl ? o.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : o.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? o.left = t.negativeScrollAdjustment + e.scrollLeft + 2 * t.containerWidth - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : o.left = t.scrollbarYLeft + e.scrollLeft;
            r(t.scrollbarYRail, o), r(t.scrollbarX, {
                left: t.scrollbarXLeft,
                width: t.scrollbarXWidth - t.railBorderXWidth
            }), r(t.scrollbarY, {top: t.scrollbarYTop, height: t.scrollbarYHeight - t.railBorderYWidth})
        }(t, e), e.scrollbarXActive ? t.classList.add(p.active("x")) : (t.classList.remove(p.active("x")), e.scrollbarXWidth = 0, e.scrollbarXLeft = 0, t.scrollLeft = !0 === e.isRtl ? e.contentWidth : 0), e.scrollbarYActive ? t.classList.add(p.active("y")) : (t.classList.remove(p.active("y")), e.scrollbarYHeight = 0, e.scrollbarYTop = 0, t.scrollTop = 0)
    }

    function k(e, t) {
        return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t
    }

    function S(e, t) {
        var n = t[0], i = t[1], r = t[2], o = t[3], a = t[4], s = t[5], l = t[6], c = t[7], u = t[8], d = e.element,
            h = null, f = null, g = null;

        function y(t) {
            t.touches && t.touches[0] && (t[r] = t.touches[0].pageY), d[l] = h + g * (t[r] - f), m(e, c), T(e), t.stopPropagation(), t.type.startsWith("touch") && t.changedTouches.length > 1 && t.preventDefault()
        }

        function v() {
            _(e, c), e[u].classList.remove(p.clicking), e.event.unbind(e.ownerDocument, "mousemove", y)
        }

        function x(t, a) {
            h = d[l], a && t.touches && (t[r] = t.touches[0].pageY), f = t[r], g = (e[i] - e[n]) / (e[o] - e[s]), a ? e.event.bind(e.ownerDocument, "touchmove", y) : (e.event.bind(e.ownerDocument, "mousemove", y), e.event.once(e.ownerDocument, "mouseup", v), t.preventDefault()), e[u].classList.add(p.clicking), t.stopPropagation()
        }

        e.event.bind(e[a], "mousedown", (function (e) {
            x(e)
        })), e.event.bind(e[a], "touchstart", (function (e) {
            x(e, !0)
        }))
    }

    var D = {
        "click-rail": function (e) {
            e.element, e.event.bind(e.scrollbarY, "mousedown", (function (e) {
                return e.stopPropagation()
            })), e.event.bind(e.scrollbarYRail, "mousedown", (function (t) {
                var n = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top > e.scrollbarYTop ? 1 : -1;
                e.element.scrollTop += n * e.containerHeight, T(e), t.stopPropagation()
            })), e.event.bind(e.scrollbarX, "mousedown", (function (e) {
                return e.stopPropagation()
            })), e.event.bind(e.scrollbarXRail, "mousedown", (function (t) {
                var n = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left > e.scrollbarXLeft ? 1 : -1;
                e.element.scrollLeft += n * e.containerWidth, T(e), t.stopPropagation()
            }))
        }, "drag-thumb": function (e) {
            S(e, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]), S(e, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"])
        }, keyboard: function (e) {
            var t = e.element;
            e.event.bind(e.ownerDocument, "keydown", (function (n) {
                if (!(n.isDefaultPrevented && n.isDefaultPrevented() || n.defaultPrevented) && (s(t, ":hover") || s(e.scrollbarX, ":focus") || s(e.scrollbarY, ":focus"))) {
                    var i, r = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
                    if (r) {
                        if ("IFRAME" === r.tagName) r = r.contentDocument.activeElement; else for (; r.shadowRoot;) r = r.shadowRoot.activeElement;
                        if (s(i = r, "input,[contenteditable]") || s(i, "select,[contenteditable]") || s(i, "textarea,[contenteditable]") || s(i, "button,[contenteditable]")) return
                    }
                    var o = 0, a = 0;
                    switch (n.which) {
                        case 37:
                            o = n.metaKey ? -e.contentWidth : n.altKey ? -e.containerWidth : -30;
                            break;
                        case 38:
                            a = n.metaKey ? e.contentHeight : n.altKey ? e.containerHeight : 30;
                            break;
                        case 39:
                            o = n.metaKey ? e.contentWidth : n.altKey ? e.containerWidth : 30;
                            break;
                        case 40:
                            a = n.metaKey ? -e.contentHeight : n.altKey ? -e.containerHeight : -30;
                            break;
                        case 32:
                            a = n.shiftKey ? e.containerHeight : -e.containerHeight;
                            break;
                        case 33:
                            a = e.containerHeight;
                            break;
                        case 34:
                            a = -e.containerHeight;
                            break;
                        case 36:
                            a = e.contentHeight;
                            break;
                        case 35:
                            a = -e.contentHeight;
                            break;
                        default:
                            return
                    }
                    e.settings.suppressScrollX && 0 !== o || e.settings.suppressScrollY && 0 !== a || (t.scrollTop -= a, t.scrollLeft += o, T(e), function (n, i) {
                        var r = Math.floor(t.scrollTop);
                        if (0 === n) {
                            if (!e.scrollbarYActive) return !1;
                            if (0 === r && i > 0 || r >= e.contentHeight - e.containerHeight && i < 0) return !e.settings.wheelPropagation
                        }
                        var o = t.scrollLeft;
                        if (0 === i) {
                            if (!e.scrollbarXActive) return !1;
                            if (0 === o && n < 0 || o >= e.contentWidth - e.containerWidth && n > 0) return !e.settings.wheelPropagation
                        }
                        return !0
                    }(o, a) && n.preventDefault())
                }
            }))
        }, wheel: function (e) {
            var t = e.element;

            function n(n) {
                var r = function (e) {
                    var t = e.deltaX, n = -1 * e.deltaY;
                    return void 0 !== t && void 0 !== n || (t = -1 * e.wheelDeltaX / 6, n = e.wheelDeltaY / 6), e.deltaMode && 1 === e.deltaMode && (t *= 10, n *= 10), t != t && n != n && (t = 0, n = e.wheelDelta), e.shiftKey ? [-n, -t] : [t, n]
                }(n), o = r[0], a = r[1];
                if (!function (e, n, r) {
                    if (!M.isWebKit && t.querySelector("select:focus")) return !0;
                    if (!t.contains(e)) return !1;
                    for (var o = e; o && o !== t;) {
                        if (o.classList.contains(h.consuming)) return !0;
                        var a = i(o);
                        if (r && a.overflowY.match(/(scroll|auto)/)) {
                            var s = o.scrollHeight - o.clientHeight;
                            if (s > 0 && (o.scrollTop > 0 && r < 0 || o.scrollTop < s && r > 0)) return !0
                        }
                        if (n && a.overflowX.match(/(scroll|auto)/)) {
                            var l = o.scrollWidth - o.clientWidth;
                            if (l > 0 && (o.scrollLeft > 0 && n < 0 || o.scrollLeft < l && n > 0)) return !0
                        }
                        o = o.parentNode
                    }
                    return !1
                }(n.target, o, a)) {
                    var s = !1;
                    e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (a ? t.scrollTop -= a * e.settings.wheelSpeed : t.scrollTop += o * e.settings.wheelSpeed, s = !0) : e.scrollbarXActive && !e.scrollbarYActive && (o ? t.scrollLeft += o * e.settings.wheelSpeed : t.scrollLeft -= a * e.settings.wheelSpeed, s = !0) : (t.scrollTop -= a * e.settings.wheelSpeed, t.scrollLeft += o * e.settings.wheelSpeed), T(e), (s = s || function (n, i) {
                        var r = Math.floor(t.scrollTop), o = 0 === t.scrollTop,
                            a = r + t.offsetHeight === t.scrollHeight, s = 0 === t.scrollLeft,
                            l = t.scrollLeft + t.offsetWidth === t.scrollWidth;
                        return !(Math.abs(i) > Math.abs(n) ? o || a : s || l) || !e.settings.wheelPropagation
                    }(o, a)) && !n.ctrlKey && (n.stopPropagation(), n.preventDefault())
                }
            }

            void 0 !== window.onwheel ? e.event.bind(t, "wheel", n) : void 0 !== window.onmousewheel && e.event.bind(t, "mousewheel", n)
        }, touch: function (e) {
            if (M.supportsTouch || M.supportsIePointer) {
                var t = e.element, n = {}, r = 0, o = {}, a = null;
                M.supportsTouch ? (e.event.bind(t, "touchstart", u), e.event.bind(t, "touchmove", d), e.event.bind(t, "touchend", p)) : M.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", u), e.event.bind(t, "pointermove", d), e.event.bind(t, "pointerup", p)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", u), e.event.bind(t, "MSPointerMove", d), e.event.bind(t, "MSPointerUp", p)))
            }

            function s(n, i) {
                t.scrollTop -= i, t.scrollLeft -= n, T(e)
            }

            function l(e) {
                return e.targetTouches ? e.targetTouches[0] : e
            }

            function c(e) {
                return (!e.pointerType || "pen" !== e.pointerType || 0 !== e.buttons) && (!(!e.targetTouches || 1 !== e.targetTouches.length) || !(!e.pointerType || "mouse" === e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE))
            }

            function u(e) {
                if (c(e)) {
                    var t = l(e);
                    n.pageX = t.pageX, n.pageY = t.pageY, r = (new Date).getTime(), null !== a && clearInterval(a)
                }
            }

            function d(a) {
                if (c(a)) {
                    var u = l(a), d = {pageX: u.pageX, pageY: u.pageY}, p = d.pageX - n.pageX, f = d.pageY - n.pageY;
                    if (function (e, n, r) {
                        if (!t.contains(e)) return !1;
                        for (var o = e; o && o !== t;) {
                            if (o.classList.contains(h.consuming)) return !0;
                            var a = i(o);
                            if (r && a.overflowY.match(/(scroll|auto)/)) {
                                var s = o.scrollHeight - o.clientHeight;
                                if (s > 0 && (o.scrollTop > 0 && r < 0 || o.scrollTop < s && r > 0)) return !0
                            }
                            if (n && a.overflowX.match(/(scroll|auto)/)) {
                                var l = o.scrollWidth - o.clientWidth;
                                if (l > 0 && (o.scrollLeft > 0 && n < 0 || o.scrollLeft < l && n > 0)) return !0
                            }
                            o = o.parentNode
                        }
                        return !1
                    }(a.target, p, f)) return;
                    s(p, f), n = d;
                    var m = (new Date).getTime(), _ = m - r;
                    _ > 0 && (o.x = p / _, o.y = f / _, r = m), function (n, i) {
                        var r = Math.floor(t.scrollTop), o = t.scrollLeft, a = Math.abs(n), s = Math.abs(i);
                        if (s > a) {
                            if (i < 0 && r === e.contentHeight - e.containerHeight || i > 0 && 0 === r) return 0 === window.scrollY && i > 0 && M.isChrome
                        } else if (a > s && (n < 0 && o === e.contentWidth - e.containerWidth || n > 0 && 0 === o)) return !0;
                        return !0
                    }(p, f) && a.preventDefault()
                }
            }

            function p() {
                e.settings.swipeEasing && (clearInterval(a), a = setInterval((function () {
                    e.isInitialized ? clearInterval(a) : o.x || o.y ? Math.abs(o.x) < .01 && Math.abs(o.y) < .01 ? clearInterval(a) : e.element ? (s(30 * o.x, 30 * o.y), o.x *= .8, o.y *= .8) : clearInterval(a) : clearInterval(a)
                }), 10))
            }
        }
    }, L = function (e, t) {
        var n = this;
        if (void 0 === t && (t = {}), "string" == typeof e && (e = document.querySelector(e)), !e || !e.nodeName) throw new Error("no element is specified to initialize PerfectScrollbar");
        for (var a in this.element = e, e.classList.add(u), this.settings = {
            handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
            maxScrollbarLength: null,
            minScrollbarLength: null,
            scrollingThreshold: 1e3,
            scrollXMarginOffset: 0,
            scrollYMarginOffset: 0,
            suppressScrollX: !1,
            suppressScrollY: !1,
            swipeEasing: !0,
            useBothWheelAxes: !1,
            wheelPropagation: !0,
            wheelSpeed: 1
        }, t) this.settings[a] = t[a];
        this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
        var s, l, c = function () {
            return e.classList.add(p.focus)
        }, f = function () {
            return e.classList.remove(p.focus)
        };
        this.isRtl = "rtl" === i(e).direction, !0 === this.isRtl && e.classList.add(d), this.isNegativeScroll = (l = e.scrollLeft, e.scrollLeft = -1, s = e.scrollLeft < 0, e.scrollLeft = l, s), this.negativeScrollAdjustment = this.isNegativeScroll ? e.scrollWidth - e.clientWidth : 0, this.event = new v, this.ownerDocument = e.ownerDocument || document, this.scrollbarXRail = o(h.rail("x")), e.appendChild(this.scrollbarXRail), this.scrollbarX = o(h.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", c), this.event.bind(this.scrollbarX, "blur", f), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
        var m = i(this.scrollbarXRail);
        this.scrollbarXBottom = parseInt(m.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = w(m.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = w(m.borderLeftWidth) + w(m.borderRightWidth), r(this.scrollbarXRail, {display: "block"}), this.railXMarginWidth = w(m.marginLeft) + w(m.marginRight), r(this.scrollbarXRail, {display: ""}), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = o(h.rail("y")), e.appendChild(this.scrollbarYRail), this.scrollbarY = o(h.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", c), this.event.bind(this.scrollbarY, "blur", f), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
        var _ = i(this.scrollbarYRail);
        this.scrollbarYRight = parseInt(_.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = w(_.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? function (e) {
            var t = i(e);
            return w(t.width) + w(t.paddingLeft) + w(t.paddingRight) + w(t.borderLeftWidth) + w(t.borderRightWidth)
        }(this.scrollbarY) : null, this.railBorderYWidth = w(_.borderTopWidth) + w(_.borderBottomWidth), r(this.scrollbarYRail, {display: "block"}), this.railYMarginHeight = w(_.marginTop) + w(_.marginBottom), r(this.scrollbarYRail, {display: ""}), this.railYHeight = null, this.railYRatio = null, this.reach = {
            x: e.scrollLeft <= 0 ? "start" : e.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
            y: e.scrollTop <= 0 ? "start" : e.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
        }, this.isAlive = !0, this.settings.handlers.forEach((function (e) {
            return D[e](n)
        })), this.lastScrollTop = Math.floor(e.scrollTop), this.lastScrollLeft = e.scrollLeft, this.event.bind(this.element, "scroll", (function (e) {
            return n.onScroll(e)
        })), T(this)
    };
    L.prototype.update = function () {
        this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, r(this.scrollbarXRail, {display: "block"}), r(this.scrollbarYRail, {display: "block"}), this.railXMarginWidth = w(i(this.scrollbarXRail).marginLeft) + w(i(this.scrollbarXRail).marginRight), this.railYMarginHeight = w(i(this.scrollbarYRail).marginTop) + w(i(this.scrollbarYRail).marginBottom), r(this.scrollbarXRail, {display: "none"}), r(this.scrollbarYRail, {display: "none"}), T(this), b(this, "top", 0, !1, !0), b(this, "left", 0, !1, !0), r(this.scrollbarXRail, {display: ""}), r(this.scrollbarYRail, {display: ""}))
    }, L.prototype.onScroll = function (e) {
        this.isAlive && (T(this), b(this, "top", this.element.scrollTop - this.lastScrollTop), b(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft)
    }, L.prototype.destroy = function () {
        this.isAlive && (this.event.unbindAll(), l(this.scrollbarX), l(this.scrollbarY), l(this.scrollbarXRail), l(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1)
    }, L.prototype.removePsClasses = function () {
        this.element.className = this.element.className.split(" ").filter((function (e) {
            return !e.match(/^ps([-_].+|)$/)
        })).join(" ")
    }, t.a = L
}, function (e, t, n) {
    e.exports = function () {
        "use strict";
        var e, t, n;

        function i(i, r) {
            if (e) if (t) {
                var o = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + e + ")(sharedChunk); (" + t + ")(sharedChunk); self.onerror = null;",
                    a = {};
                e(a), n = r(a), "undefined" != typeof window && window && window.URL && window.URL.createObjectURL && (n.workerUrl = window.URL.createObjectURL(new Blob([o], {type: "text/javascript"})))
            } else t = r; else e = r
        }

        return i(0, (function (e) {
            var t = "2.7.1", n = i;

            function i(e, t, n, i) {
                this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (i - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = n, this.p2y = i
            }

            i.prototype.sampleCurveX = function (e) {
                return ((this.ax * e + this.bx) * e + this.cx) * e
            }, i.prototype.sampleCurveY = function (e) {
                return ((this.ay * e + this.by) * e + this.cy) * e
            }, i.prototype.sampleCurveDerivativeX = function (e) {
                return (3 * this.ax * e + 2 * this.bx) * e + this.cx
            }, i.prototype.solveCurveX = function (e, t) {
                var n, i, r, o, a;
                for (void 0 === t && (t = 1e-6), r = e, a = 0; a < 8; a++) {
                    if (o = this.sampleCurveX(r) - e, Math.abs(o) < t) return r;
                    var s = this.sampleCurveDerivativeX(r);
                    if (Math.abs(s) < 1e-6) break;
                    r -= o / s
                }
                if ((r = e) < (n = 0)) return n;
                if (r > (i = 1)) return i;
                for (; n < i;) {
                    if (o = this.sampleCurveX(r), Math.abs(o - e) < t) return r;
                    e > o ? n = r : i = r, r = .5 * (i - n) + n
                }
                return r
            }, i.prototype.solve = function (e, t) {
                return this.sampleCurveY(this.solveCurveX(e, t))
            };
            var r = o;

            function o(e, t) {
                this.x = e, this.y = t
            }

            o.prototype = {
                clone: function () {
                    return new o(this.x, this.y)
                }, add: function (e) {
                    return this.clone()._add(e)
                }, sub: function (e) {
                    return this.clone()._sub(e)
                }, multByPoint: function (e) {
                    return this.clone()._multByPoint(e)
                }, divByPoint: function (e) {
                    return this.clone()._divByPoint(e)
                }, mult: function (e) {
                    return this.clone()._mult(e)
                }, div: function (e) {
                    return this.clone()._div(e)
                }, rotate: function (e) {
                    return this.clone()._rotate(e)
                }, rotateAround: function (e, t) {
                    return this.clone()._rotateAround(e, t)
                }, matMult: function (e) {
                    return this.clone()._matMult(e)
                }, unit: function () {
                    return this.clone()._unit()
                }, perp: function () {
                    return this.clone()._perp()
                }, round: function () {
                    return this.clone()._round()
                }, mag: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }, equals: function (e) {
                    return this.x === e.x && this.y === e.y
                }, dist: function (e) {
                    return Math.sqrt(this.distSqr(e))
                }, distSqr: function (e) {
                    var t = e.x - this.x, n = e.y - this.y;
                    return t * t + n * n
                }, angle: function () {
                    return Math.atan2(this.y, this.x)
                }, angleTo: function (e) {
                    return Math.atan2(this.y - e.y, this.x - e.x)
                }, angleWith: function (e) {
                    return this.angleWithSep(e.x, e.y)
                }, angleWithSep: function (e, t) {
                    return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t)
                }, _matMult: function (e) {
                    var t = e[2] * this.x + e[3] * this.y;
                    return this.x = e[0] * this.x + e[1] * this.y, this.y = t, this
                }, _add: function (e) {
                    return this.x += e.x, this.y += e.y, this
                }, _sub: function (e) {
                    return this.x -= e.x, this.y -= e.y, this
                }, _mult: function (e) {
                    return this.x *= e, this.y *= e, this
                }, _div: function (e) {
                    return this.x /= e, this.y /= e, this
                }, _multByPoint: function (e) {
                    return this.x *= e.x, this.y *= e.y, this
                }, _divByPoint: function (e) {
                    return this.x /= e.x, this.y /= e.y, this
                }, _unit: function () {
                    return this._div(this.mag()), this
                }, _perp: function () {
                    var e = this.y;
                    return this.y = this.x, this.x = -e, this
                }, _rotate: function (e) {
                    var t = Math.cos(e), n = Math.sin(e), i = n * this.x + t * this.y;
                    return this.x = t * this.x - n * this.y, this.y = i, this
                }, _rotateAround: function (e, t) {
                    var n = Math.cos(e), i = Math.sin(e), r = t.y + i * (this.x - t.x) + n * (this.y - t.y);
                    return this.x = t.x + n * (this.x - t.x) - i * (this.y - t.y), this.y = r, this
                }, _round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
            }, o.convert = function (e) {
                return e instanceof o ? e : Array.isArray(e) ? new o(e[0], e[1]) : e
            };
            var a = "undefined" != typeof self ? self : {}, s = 1e-6,
                l = "undefined" != typeof Float32Array ? Float32Array : Array;

            function c() {
                var e = new l(9);
                return l != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e
            }

            function u(e) {
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            }

            function d(e, t, n) {
                var i = t[0], r = t[1], o = t[2], a = t[3], s = t[4], l = t[5], c = t[6], u = t[7], d = t[8], h = t[9],
                    p = t[10], f = t[11], m = t[12], _ = t[13], g = t[14], y = t[15], v = n[0], x = n[1], b = n[2],
                    w = n[3];
                return e[0] = v * i + x * s + b * d + w * m, e[1] = v * r + x * l + b * h + w * _, e[2] = v * o + x * c + b * p + w * g, e[3] = v * a + x * u + b * f + w * y, e[4] = (v = n[4]) * i + (x = n[5]) * s + (b = n[6]) * d + (w = n[7]) * m, e[5] = v * r + x * l + b * h + w * _, e[6] = v * o + x * c + b * p + w * g, e[7] = v * a + x * u + b * f + w * y, e[8] = (v = n[8]) * i + (x = n[9]) * s + (b = n[10]) * d + (w = n[11]) * m, e[9] = v * r + x * l + b * h + w * _, e[10] = v * o + x * c + b * p + w * g, e[11] = v * a + x * u + b * f + w * y, e[12] = (v = n[12]) * i + (x = n[13]) * s + (b = n[14]) * d + (w = n[15]) * m, e[13] = v * r + x * l + b * h + w * _, e[14] = v * o + x * c + b * p + w * g, e[15] = v * a + x * u + b * f + w * y, e
            }

            function h(e, t, n) {
                var i, r, o, a, s, l, c, u, d, h, p, f, m = n[0], _ = n[1], g = n[2];
                return t === e ? (e[12] = t[0] * m + t[4] * _ + t[8] * g + t[12], e[13] = t[1] * m + t[5] * _ + t[9] * g + t[13], e[14] = t[2] * m + t[6] * _ + t[10] * g + t[14], e[15] = t[3] * m + t[7] * _ + t[11] * g + t[15]) : (r = t[1], o = t[2], a = t[3], s = t[4], l = t[5], c = t[6], u = t[7], d = t[8], h = t[9], p = t[10], f = t[11], e[0] = i = t[0], e[1] = r, e[2] = o, e[3] = a, e[4] = s, e[5] = l, e[6] = c, e[7] = u, e[8] = d, e[9] = h, e[10] = p, e[11] = f, e[12] = i * m + s * _ + d * g + t[12], e[13] = r * m + l * _ + h * g + t[13], e[14] = o * m + c * _ + p * g + t[14], e[15] = a * m + u * _ + f * g + t[15]), e
            }

            function p(e, t, n) {
                var i = n[0], r = n[1], o = n[2];
                return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
            }

            function f(e, t, n) {
                var i = Math.sin(n), r = Math.cos(n), o = t[4], a = t[5], s = t[6], l = t[7], c = t[8], u = t[9],
                    d = t[10], h = t[11];
                return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * r + c * i, e[5] = a * r + u * i, e[6] = s * r + d * i, e[7] = l * r + h * i, e[8] = c * r - o * i, e[9] = u * r - a * i, e[10] = d * r - s * i, e[11] = h * r - l * i, e
            }

            function m(e, t, n) {
                var i = Math.sin(n), r = Math.cos(n), o = t[0], a = t[1], s = t[2], l = t[3], c = t[8], u = t[9],
                    d = t[10], h = t[11];
                return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * r - c * i, e[1] = a * r - u * i, e[2] = s * r - d * i, e[3] = l * r - h * i, e[8] = o * i + c * r, e[9] = a * i + u * r, e[10] = s * i + d * r, e[11] = l * i + h * r, e
            }

            Math.hypot || (Math.hypot = function () {
                for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
                return Math.sqrt(e)
            });
            var _ = d;

            function g() {
                var e = new l(3);
                return l != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
            }

            function y(e) {
                var t = new l(3);
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
            }

            function v(e) {
                return Math.hypot(e[0], e[1], e[2])
            }

            function x(e, t, n) {
                var i = new l(3);
                return i[0] = e, i[1] = t, i[2] = n, i
            }

            function b(e, t, n) {
                return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e
            }

            function w(e, t, n) {
                return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e
            }

            function M(e, t, n) {
                return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e
            }

            function T(e, t, n) {
                return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e
            }

            function k(e, t, n) {
                return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
            }

            function S(e, t, n, i) {
                return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e
            }

            function D(e, t) {
                var n = t[0], i = t[1], r = t[2], o = n * n + i * i + r * r;
                return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o, e
            }

            function L(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
            }

            function E(e, t, n) {
                var i = t[0], r = t[1], o = t[2], a = n[0], s = n[1], l = n[2];
                return e[0] = r * l - o * s, e[1] = o * a - i * l, e[2] = i * s - r * a, e
            }

            function C(e, t, n) {
                var i = t[0], r = t[1], o = t[2], a = n[3] * i + n[7] * r + n[11] * o + n[15];
                return e[0] = (n[0] * i + n[4] * r + n[8] * o + n[12]) / (a = a || 1), e[1] = (n[1] * i + n[5] * r + n[9] * o + n[13]) / a, e[2] = (n[2] * i + n[6] * r + n[10] * o + n[14]) / a, e
            }

            function A(e, t, n) {
                var i = n[0], r = n[1], o = n[2], a = t[0], s = t[1], l = t[2], c = r * l - o * s, u = o * a - i * l,
                    d = i * s - r * a, h = r * d - o * u, p = o * c - i * d, f = i * u - r * c, m = 2 * n[3];
                return u *= m, d *= m, p *= 2, f *= 2, e[0] = a + (c *= m) + (h *= 2), e[1] = s + u + p, e[2] = l + d + f, e
            }

            var I, P = w, R = M, Y = v;

            function z(e, t, n) {
                var i = t[0], r = t[1], o = t[2], a = t[3];
                return e[0] = n[0] * i + n[4] * r + n[8] * o + n[12] * a, e[1] = n[1] * i + n[5] * r + n[9] * o + n[13] * a, e[2] = n[2] * i + n[6] * r + n[10] * o + n[14] * a, e[3] = n[3] * i + n[7] * r + n[11] * o + n[15] * a, e
            }

            function O() {
                var e = new l(4);
                return l != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e
            }

            function F(e) {
                return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
            }

            function B(e, t, n) {
                n *= .5;
                var i = t[0], r = t[1], o = t[2], a = t[3], s = Math.sin(n), l = Math.cos(n);
                return e[0] = i * l + a * s, e[1] = r * l + o * s, e[2] = o * l - r * s, e[3] = a * l - i * s, e
            }

            function j(e, t) {
                return e[0] === t[0] && e[1] === t[1]
            }

            g(), I = new l(4), l != Float32Array && (I[0] = 0, I[1] = 0, I[2] = 0, I[3] = 0), g(), x(1, 0, 0), x(0, 1, 0), O(), O(), c(), function () {
                var e;
                e = new l(2), l != Float32Array && (e[0] = 0, e[1] = 0)
            }();
            const H = Math.PI / 180, N = 180 / Math.PI;

            function U(e) {
                return e * H
            }

            function W(e) {
                return e * N
            }

            const V = [[0, 0], [1, 0], [1, 1], [0, 1]];

            function G(e) {
                if (e <= 0) return 0;
                if (e >= 1) return 1;
                const t = e * e, n = t * e;
                return 4 * (e < .5 ? n : 3 * (e - t) + n - .75)
            }

            function q(e, t, i, r) {
                const o = new n(e, t, i, r);
                return function (e) {
                    return o.solve(e)
                }
            }

            const Z = q(.25, .1, .25, 1);

            function $(e, t, n) {
                return Math.min(n, Math.max(t, e))
            }

            function X(e, t, n) {
                return (n = $((n - e) / (t - e), 0, 1)) * n * (3 - 2 * n)
            }

            function J(e, t, n) {
                const i = n - t, r = ((e - t) % i + i) % i + t;
                return r === t ? n : r
            }

            function K(e, t, n) {
                if (!e.length) return n(null, []);
                let i = e.length;
                const r = new Array(e.length);
                let o = null;
                e.forEach((e, a) => {
                    t(e, (e, t) => {
                        e && (o = e), r[a] = t, 0 == --i && n(o, r)
                    })
                })
            }

            function Q(e) {
                const t = [];
                for (const n in e) t.push(e[n]);
                return t
            }

            function ee(e, ...t) {
                for (const n of t) for (const t in n) e[t] = n[t];
                return e
            }

            let te = 1;

            function ne() {
                return te++
            }

            function ie() {
                return function e(t) {
                    return t ? (t ^ 16 * Math.random() >> t / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e)
                }()
            }

            function re(e) {
                return e <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function oe(e) {
                return !!e && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e)
            }

            function ae(e, t) {
                e.forEach(e => {
                    t[e] && (t[e] = t[e].bind(t))
                })
            }

            function se(e, t) {
                return -1 !== e.indexOf(t, e.length - t.length)
            }

            function le(e, t, n) {
                const i = {};
                for (const r in e) i[r] = t.call(n || this, e[r], r, e);
                return i
            }

            function ce(e, t, n) {
                const i = {};
                for (const r in e) t.call(n || this, e[r], r, e) && (i[r] = e[r]);
                return i
            }

            function ue(e) {
                return Array.isArray(e) ? e.map(ue) : "object" == typeof e && e ? le(e, ue) : e
            }

            const de = {};

            function he(e) {
                de[e] || ("undefined" != typeof console && console.warn(e), de[e] = !0)
            }

            function pe(e, t, n) {
                return (n.y - e.y) * (t.x - e.x) > (t.y - e.y) * (n.x - e.x)
            }

            function fe(e) {
                let t = 0;
                for (let n, i, r = 0, o = e.length, a = o - 1; r < o; a = r++) n = e[r], i = e[a], t += (i.x - n.x) * (n.y + i.y);
                return t
            }

            function me() {
                return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope
            }

            function _e(e) {
                const t = {};
                if (e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e, n, i, r) => {
                    const o = i || r;
                    return t[n] = !o || o.toLowerCase(), ""
                }), t["max-age"]) {
                    const e = parseInt(t["max-age"], 10);
                    isNaN(e) ? delete t["max-age"] : t["max-age"] = e
                }
                return t
            }

            let ge, ye, ve, xe = null;

            function be(e) {
                if (null == xe) {
                    const t = e.navigator ? e.navigator.userAgent : null;
                    xe = !!e.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
                }
                return xe
            }

            function we(e) {
                try {
                    const t = a[e];
                    return t.setItem("_mapbox_test_", 1), t.removeItem("_mapbox_test_"), !0
                } catch (e) {
                    return !1
                }
            }

            const Me = {
                now: () => void 0 !== ve ? ve : a.performance.now(),
                setNow(e) {
                    ve = e
                },
                restoreNow() {
                    ve = void 0
                },
                frame(e) {
                    const t = a.requestAnimationFrame(e);
                    return {cancel: () => a.cancelAnimationFrame(t)}
                },
                getImageData(e, t = 0) {
                    const n = a.document.createElement("canvas"), i = n.getContext("2d");
                    if (!i) throw new Error("failed to create canvas 2d context");
                    return n.width = e.width, n.height = e.height, i.drawImage(e, 0, 0, e.width, e.height), i.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t)
                },
                resolveURL: e => (ge || (ge = a.document.createElement("a")), ge.href = e, ge.href),
                get devicePixelRatio() {
                    return a.devicePixelRatio
                },
                get prefersReducedMotion() {
                    return !!a.matchMedia && (null == ye && (ye = a.matchMedia("(prefers-reduced-motion: reduce)")), ye.matches)
                }
            };
            let Te;
            const ke = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                    if (null == Te) {
                        const e = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                        try {
                            Te = null != Object({NODE_ENV: "production"}).API_URL_REGEX ? new RegExp(Object({NODE_ENV: "production"}).API_URL_REGEX) : e
                        } catch (t) {
                            Te = e
                        }
                    }
                    return Te
                },
                get EVENTS_URL() {
                    return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                MAX_PARALLEL_IMAGE_REQUESTS: 16
            }, Se = {
                supported: !1, testSupport: function (e) {
                    !Ee && Le && (Ce ? Ae(e) : De = e)
                }
            };
            let De, Le, Ee = !1, Ce = !1;

            function Ae(e) {
                const t = e.createTexture();
                e.bindTexture(e.TEXTURE_2D, t);
                try {
                    if (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, Le), e.isContextLost()) return;
                    Se.supported = !0
                } catch (e) {
                }
                e.deleteTexture(t), Ee = !0
            }

            a.document && (Le = a.document.createElement("img"), Le.onload = function () {
                De && Ae(De), De = null, Ce = !0
            }, Le.onerror = function () {
                Ee = !0, De = null
            }, Le.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
            const Ie = "01", Pe = "NO_ACCESS_TOKEN";

            function Re(e) {
                return 0 === e.indexOf("mapbox:")
            }

            function Ye(e) {
                return ke.API_URL_REGEX.test(e)
            }

            const ze = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;

            function Oe(e) {
                const t = e.match(ze);
                if (!t) throw new Error("Unable to parse URL object");
                return {protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : []}
            }

            function Fe(e) {
                const t = e.params.length ? "?" + e.params.join("&") : "";
                return `${e.protocol}://${e.authority}${e.path}${t}`
            }

            function Be(e) {
                if (!e) return null;
                const t = e.split(".");
                if (!t || 3 !== t.length) return null;
                try {
                    return JSON.parse(decodeURIComponent(a.atob(t[1]).split("").map(e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join("")))
                } catch (e) {
                    return null
                }
            }

            class je {
                constructor(e) {
                    this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null
                }

                getStorageKey(e) {
                    const t = Be(ke.ACCESS_TOKEN);
                    let n = "";
                    return n = t && t.u ? a.btoa(encodeURIComponent(t.u).replace(/%([0-9A-F]{2})/g, (e, t) => String.fromCharCode(Number("0x" + t)))) : ke.ACCESS_TOKEN || "", e ? `mapbox.eventData.${e}:${n}` : "mapbox.eventData:" + n
                }

                fetchEventData() {
                    const e = we("localStorage"), t = this.getStorageKey(), n = this.getStorageKey("uuid");
                    if (e) try {
                        const e = a.localStorage.getItem(t);
                        e && (this.eventData = JSON.parse(e));
                        const i = a.localStorage.getItem(n);
                        i && (this.anonId = i)
                    } catch (e) {
                        he("Unable to read from LocalStorage")
                    }
                }

                saveEventData() {
                    const e = we("localStorage"), t = this.getStorageKey(), n = this.getStorageKey("uuid");
                    if (e) try {
                        a.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(t, JSON.stringify(this.eventData))
                    } catch (e) {
                        he("Unable to write to LocalStorage")
                    }
                }

                processRequests(e) {
                }

                postEvent(e, n, i, r) {
                    if (!ke.EVENTS_URL) return;
                    const o = Oe(ke.EVENTS_URL);
                    o.params.push("access_token=" + (r || ke.ACCESS_TOKEN || ""));
                    const a = {
                            event: this.type,
                            created: new Date(e).toISOString(),
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: t,
                            skuId: Ie,
                            userId: this.anonId
                        }, s = n ? ee(a, n) : a,
                        l = {url: Fe(o), headers: {"Content-Type": "text/plain"}, body: JSON.stringify([s])};
                    this.pendingRequest = st(l, e => {
                        this.pendingRequest = null, i(e), this.saveEventData(), this.processRequests(r)
                    })
                }

                queueRequest(e, t) {
                    this.queue.push(e), this.processRequests(t)
                }
            }

            const He = new class extends je {
                constructor(e) {
                    super("appUserTurnstile"), this._customAccessToken = e
                }

                postTurnstileEvent(e, t) {
                    ke.EVENTS_URL && ke.ACCESS_TOKEN && Array.isArray(e) && e.some(e => Re(e) || Ye(e)) && this.queueRequest(Date.now(), t)
                }

                processRequests(e) {
                    if (this.pendingRequest || 0 === this.queue.length) return;
                    this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                    const t = Be(ke.ACCESS_TOKEN), n = t ? t.u : ke.ACCESS_TOKEN;
                    let i = n !== this.eventData.tokenU;
                    oe(this.anonId) || (this.anonId = ie(), i = !0);
                    const r = this.queue.shift();
                    if (this.eventData.lastSuccess) {
                        const e = new Date(this.eventData.lastSuccess), t = new Date(r),
                            n = (r - this.eventData.lastSuccess) / 864e5;
                        i = i || n >= 1 || n < -1 || e.getDate() !== t.getDate()
                    } else i = !0;
                    if (!i) return this.processRequests();
                    this.postEvent(r, {"enabled.telemetry": !1}, e => {
                        e || (this.eventData.lastSuccess = r, this.eventData.tokenU = n)
                    }, e)
                }
            }, Ne = He.postTurnstileEvent.bind(He), Ue = new class extends je {
                constructor() {
                    super("map.load"), this.success = {}, this.skuToken = ""
                }

                postMapLoadEvent(e, t, n, i) {
                    this.skuToken = t, this.errorCb = i, ke.EVENTS_URL && (n || ke.ACCESS_TOKEN ? this.queueRequest({
                        id: e,
                        timestamp: Date.now()
                    }, n) : this.errorCb(new Error(Pe)))
                }

                processRequests(e) {
                    if (this.pendingRequest || 0 === this.queue.length) return;
                    const {id: t, timestamp: n} = this.queue.shift();
                    t && this.success[t] || (this.anonId || this.fetchEventData(), oe(this.anonId) || (this.anonId = ie()), this.postEvent(n, {skuToken: this.skuToken}, e => {
                        e ? this.errorCb(e) : t && (this.success[t] = !0)
                    }, e))
                }
            }, We = Ue.postMapLoadEvent.bind(Ue), Ve = new class extends je {
                constructor() {
                    super("map.auth"), this.success = {}, this.skuToken = ""
                }

                getSession(e, t, n, i) {
                    if (!ke.API_URL || !ke.SESSION_PATH) return;
                    const r = Oe(ke.API_URL + ke.SESSION_PATH);
                    r.params.push("sku=" + (t || "")), r.params.push("access_token=" + (i || ke.ACCESS_TOKEN || ""));
                    const o = {url: Fe(r), headers: {"Content-Type": "text/plain"}};
                    this.pendingRequest = lt(o, e => {
                        this.pendingRequest = null, n(e), this.saveEventData(), this.processRequests(i)
                    })
                }

                getSessionAPI(e, t, n, i) {
                    this.skuToken = t, this.errorCb = i, ke.SESSION_PATH && ke.API_URL && (n || ke.ACCESS_TOKEN ? this.queueRequest({
                        id: e,
                        timestamp: Date.now()
                    }, n) : this.errorCb(new Error(Pe)))
                }

                processRequests(e) {
                    if (this.pendingRequest || 0 === this.queue.length) return;
                    const {id: t, timestamp: n} = this.queue.shift();
                    t && this.success[t] || this.getSession(n, this.skuToken, e => {
                        e ? this.errorCb(e) : t && (this.success[t] = !0)
                    }, e)
                }
            }, Ge = Ve.getSessionAPI.bind(Ve), qe = new Set, Ze = "mapbox-tiles";
            let $e, Xe, Je = 500, Ke = 50;

            function Qe() {
                a.caches && !$e && ($e = a.caches.open(Ze))
            }

            function et(e) {
                const t = e.indexOf("?");
                return t < 0 ? e : e.slice(0, t)
            }

            let tt = 1 / 0;
            const nt = {
                Unknown: "Unknown",
                Style: "Style",
                Source: "Source",
                Tile: "Tile",
                Glyphs: "Glyphs",
                SpriteImage: "SpriteImage",
                SpriteJSON: "SpriteJSON",
                Image: "Image"
            };
            "function" == typeof Object.freeze && Object.freeze(nt);

            class it extends Error {
                constructor(e, t, n) {
                    401 === t && Ye(n) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(e), this.status = t, this.url = n
                }

                toString() {
                    return `${this.name}: ${this.message} (${this.status}): ${this.url}`
                }
            }

            const rt = me() ? () => self.worker && self.worker.referrer : () => ("blob:" === a.location.protocol ? a.parent : a).location.href,
                ot = function (e, t) {
                    if (!(/^file:/.test(n = e.url) || /^file:/.test(rt()) && !/^\w+:/.test(n))) {
                        if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal")) return function (e, t) {
                            const n = new a.AbortController, i = new a.Request(e.url, {
                                method: e.method || "GET",
                                body: e.body,
                                credentials: e.credentials,
                                headers: e.headers,
                                referrer: rt(),
                                signal: n.signal
                            });
                            let r = !1, o = !1;
                            const s = (l = i.url).indexOf("sku=") > 0 && Ye(l);
                            var l;
                            "json" === e.type && i.headers.set("Accept", "application/json");
                            const c = (n, r, l) => {
                                if (o) return;
                                if (n && "SecurityError" !== n.message && he(n), r && l) return u(r);
                                const c = Date.now();
                                a.fetch(i).then(n => {
                                    if (n.ok) {
                                        const e = s ? n.clone() : null;
                                        return u(n, e, c)
                                    }
                                    return t(new it(n.statusText, n.status, e.url))
                                }).catch(e => {
                                    20 !== e.code && t(new Error(e.message))
                                })
                            }, u = (n, s, l) => {
                                ("arrayBuffer" === e.type ? n.arrayBuffer() : "json" === e.type ? n.json() : n.text()).then(e => {
                                    o || (s && l && function (e, t, n) {
                                        if (Qe(), !$e) return;
                                        const i = {status: t.status, statusText: t.statusText, headers: new a.Headers};
                                        t.headers.forEach((e, t) => i.headers.set(t, e));
                                        const r = _e(t.headers.get("Cache-Control") || "");
                                        r["no-store"] || (r["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * r["max-age"]).toUTCString()), new Date(i.headers.get("Expires")).getTime() - n < 42e4 || function (e, t) {
                                            if (void 0 === Xe) try {
                                                new Response(new ReadableStream), Xe = !0
                                            } catch (e) {
                                                Xe = !1
                                            }
                                            Xe ? t(e.body) : e.blob().then(t)
                                        }(t, t => {
                                            const n = new a.Response(t, i);
                                            Qe(), $e && $e.then(t => t.put(et(e.url), n)).catch(e => he(e.message))
                                        }))
                                    }(i, s, l), r = !0, t(null, e, n.headers.get("Cache-Control"), n.headers.get("Expires")))
                                }).catch(e => {
                                    o || t(new Error(e.message))
                                })
                            };
                            return s ? function (e, t) {
                                if (Qe(), !$e) return t(null);
                                const n = et(e.url);
                                $e.then(e => {
                                    e.match(n).then(i => {
                                        const r = function (e) {
                                            if (!e) return !1;
                                            const t = new Date(e.headers.get("Expires") || 0),
                                                n = _e(e.headers.get("Cache-Control") || "");
                                            return t > Date.now() && !n["no-cache"]
                                        }(i);
                                        e.delete(n), r && e.put(n, i.clone()), t(null, i, r)
                                    }).catch(t)
                                }).catch(t)
                            }(i, c) : c(null, null), {
                                cancel: () => {
                                    o = !0, r || n.abort()
                                }
                            }
                        }(e, t);
                        if (me() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", e, t, void 0, !0)
                    }
                    var n;
                    return function (e, t) {
                        const n = new a.XMLHttpRequest;
                        n.open(e.method || "GET", e.url, !0), "arrayBuffer" === e.type && (n.responseType = "arraybuffer");
                        for (const t in e.headers) n.setRequestHeader(t, e.headers[t]);
                        return "json" === e.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === e.credentials, n.onerror = () => {
                            t(new Error(n.statusText))
                        }, n.onload = () => {
                            if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                                let i = n.response;
                                if ("json" === e.type) try {
                                    i = JSON.parse(n.response)
                                } catch (e) {
                                    return t(e)
                                }
                                t(null, i, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"))
                            } else t(new it(n.statusText, n.status, e.url))
                        }, n.send(e.body), {cancel: () => n.abort()}
                    }(e, t)
                }, at = function (e, t) {
                    return ot(ee(e, {type: "arrayBuffer"}), t)
                }, st = function (e, t) {
                    return ot(ee(e, {method: "POST"}), t)
                }, lt = function (e, t) {
                    return ot(ee(e, {method: "GET"}), t)
                };

            function ct(e) {
                const t = a.document.createElement("a");
                return t.href = e, t.protocol === a.document.location.protocol && t.host === a.document.location.host
            }

            const ut = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let dt, ht;
            dt = [], ht = 0;
            const pt = function (e, t) {
                if (Se.supported && (e.headers || (e.headers = {}), e.headers.accept = "image/webp,*/*"), ht >= ke.MAX_PARALLEL_IMAGE_REQUESTS) {
                    const n = {
                        requestParameters: e, callback: t, cancelled: !1, cancel() {
                            this.cancelled = !0
                        }
                    };
                    return dt.push(n), n
                }
                ht++;
                let n = !1;
                const i = () => {
                    if (!n) for (n = !0, ht--; dt.length && ht < ke.MAX_PARALLEL_IMAGE_REQUESTS;) {
                        const e = dt.shift(), {requestParameters: t, callback: n, cancelled: i} = e;
                        i || (e.cancel = pt(t, n).cancel)
                    }
                }, r = at(e, (e, n, r, o) => {
                    i(), e ? t(e) : n && (a.createImageBitmap ? function (e, t) {
                        const n = new a.Blob([new Uint8Array(e)], {type: "image/png"});
                        a.createImageBitmap(n).then(e => {
                            t(null, e)
                        }).catch(e => {
                            t(new Error(`Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`))
                        })
                    }(n, (e, n) => t(e, n, r, o)) : function (e, t) {
                        const n = new a.Image, i = a.URL;
                        n.onload = () => {
                            t(null, n), i.revokeObjectURL(n.src), n.onload = null, a.requestAnimationFrame(() => {
                                n.src = ut
                            })
                        }, n.onerror = () => t(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                        const r = new a.Blob([new Uint8Array(e)], {type: "image/png"});
                        n.src = e.byteLength ? i.createObjectURL(r) : ut
                    }(n, (e, n) => t(e, n, r, o)))
                });
                return {
                    cancel: () => {
                        r.cancel(), i()
                    }
                }
            };

            function ft(e, t, n) {
                n[e] && -1 !== n[e].indexOf(t) || (n[e] = n[e] || [], n[e].push(t))
            }

            function mt(e, t, n) {
                if (n && n[e]) {
                    const i = n[e].indexOf(t);
                    -1 !== i && n[e].splice(i, 1)
                }
            }

            class _t {
                constructor(e, t = {}) {
                    ee(this, t), this.type = e
                }
            }

            class gt extends _t {
                constructor(e, t = {}) {
                    super("error", ee({error: e}, t))
                }
            }

            class yt {
                on(e, t) {
                    return this._listeners = this._listeners || {}, ft(e, t, this._listeners), this
                }

                off(e, t) {
                    return mt(e, t, this._listeners), mt(e, t, this._oneTimeListeners), this
                }

                once(e, t) {
                    return t ? (this._oneTimeListeners = this._oneTimeListeners || {}, ft(e, t, this._oneTimeListeners), this) : new Promise(t => this.once(e, t))
                }

                fire(e, t) {
                    "string" == typeof e && (e = new _t(e, t || {}));
                    const n = e.type;
                    if (this.listens(n)) {
                        e.target = this;
                        const t = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                        for (const n of t) n.call(this, e);
                        const i = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                        for (const t of i) mt(n, t, this._oneTimeListeners), t.call(this, e);
                        const r = this._eventedParent;
                        r && (ee(e, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), r.fire(e))
                    } else e instanceof gt && console.error(e.error);
                    return this
                }

                listens(e) {
                    return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e))
                }

                setEventedParent(e, t) {
                    return this._eventedParent = e, this._eventedParentData = t, this
                }
            }

            var vt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":0.1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"cross-faded"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"cross-faded":{"type":"property-type"},"cross-faded-data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');

            class xt {
                constructor(e, t, n, i) {
                    this.message = (e ? e + ": " : "") + n, i && (this.identifier = i), null != t && t.__line__ && (this.line = t.__line__)
                }
            }

            function bt(e) {
                const t = e.value;
                return t ? [new xt(e.key, t, "constants have been deprecated as of v8")] : []
            }

            function wt(e, ...t) {
                for (const n of t) for (const t in n) e[t] = n[t];
                return e
            }

            function Mt(e) {
                return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e
            }

            function Tt(e) {
                if (Array.isArray(e)) return e.map(Tt);
                if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
                    const t = {};
                    for (const n in e) t[n] = Tt(e[n]);
                    return t
                }
                return Mt(e)
            }

            class kt extends Error {
                constructor(e, t) {
                    super(t), this.message = t, this.key = e
                }
            }

            class St {
                constructor(e, t = []) {
                    this.parent = e, this.bindings = {};
                    for (const [e, n] of t) this.bindings[e] = n
                }

                concat(e) {
                    return new St(this, e)
                }

                get(e) {
                    if (this.bindings[e]) return this.bindings[e];
                    if (this.parent) return this.parent.get(e);
                    throw new Error(e + " not found in scope.")
                }

                has(e) {
                    return !!this.bindings[e] || !!this.parent && this.parent.has(e)
                }
            }

            const Dt = {kind: "null"}, Lt = {kind: "number"}, Et = {kind: "string"}, Ct = {kind: "boolean"},
                At = {kind: "color"}, It = {kind: "object"}, Pt = {kind: "value"}, Rt = {kind: "collator"},
                Yt = {kind: "formatted"}, zt = {kind: "resolvedImage"};

            function Ot(e, t) {
                return {kind: "array", itemType: e, N: t}
            }

            function Ft(e) {
                if ("array" === e.kind) {
                    const t = Ft(e.itemType);
                    return "number" == typeof e.N ? `array<${t}, ${e.N}>` : "value" === e.itemType.kind ? "array" : `array<${t}>`
                }
                return e.kind
            }

            const Bt = [Dt, Lt, Et, Ct, At, Yt, It, Ot(Pt), zt];

            function jt(e, t) {
                if ("error" === t.kind) return null;
                if ("array" === e.kind) {
                    if ("array" === t.kind && (0 === t.N && "value" === t.itemType.kind || !jt(e.itemType, t.itemType)) && ("number" != typeof e.N || e.N === t.N)) return null
                } else {
                    if (e.kind === t.kind) return null;
                    if ("value" === e.kind) for (const e of Bt) if (!jt(e, t)) return null
                }
                return `Expected ${Ft(e)} but found ${Ft(t)} instead.`
            }

            function Ht(e, t) {
                return t.some(t => t.kind === e.kind)
            }

            function Nt(e, t) {
                return t.some(t => "null" === t ? null === e : "array" === t ? Array.isArray(e) : "object" === t ? e && !Array.isArray(e) && "object" == typeof e : t === typeof e)
            }

            function Ut(e) {
                var t = {exports: {}};
                return e(t, t.exports), t.exports
            }

            var Wt = Ut((function (e, t) {
                var n = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    rebeccapurple: [102, 51, 153, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                };

                function i(e) {
                    return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e
                }

                function r(e) {
                    return i("%" === e[e.length - 1] ? parseFloat(e) / 100 * 255 : parseInt(e))
                }

                function o(e) {
                    return (t = "%" === e[e.length - 1] ? parseFloat(e) / 100 : parseFloat(e)) < 0 ? 0 : t > 1 ? 1 : t;
                    var t
                }

                function a(e, t, n) {
                    return n < 0 ? n += 1 : n > 1 && (n -= 1), 6 * n < 1 ? e + (t - e) * n * 6 : 2 * n < 1 ? t : 3 * n < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e
                }

                try {
                    t.parseCSSColor = function (e) {
                        var t, s = e.replace(/ /g, "").toLowerCase();
                        if (s in n) return n[s].slice();
                        if ("#" === s[0]) return 4 === s.length ? (t = parseInt(s.substr(1), 16)) >= 0 && t <= 4095 ? [(3840 & t) >> 4 | (3840 & t) >> 8, 240 & t | (240 & t) >> 4, 15 & t | (15 & t) << 4, 1] : null : 7 === s.length && (t = parseInt(s.substr(1), 16)) >= 0 && t <= 16777215 ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1] : null;
                        var l = s.indexOf("("), c = s.indexOf(")");
                        if (-1 !== l && c + 1 === s.length) {
                            var u = s.substr(0, l), d = s.substr(l + 1, c - (l + 1)).split(","), h = 1;
                            switch (u) {
                                case"rgba":
                                    if (4 !== d.length) return null;
                                    h = o(d.pop());
                                case"rgb":
                                    return 3 !== d.length ? null : [r(d[0]), r(d[1]), r(d[2]), h];
                                case"hsla":
                                    if (4 !== d.length) return null;
                                    h = o(d.pop());
                                case"hsl":
                                    if (3 !== d.length) return null;
                                    var p = (parseFloat(d[0]) % 360 + 360) % 360 / 360, f = o(d[1]), m = o(d[2]),
                                        _ = m <= .5 ? m * (f + 1) : m + f - m * f, g = 2 * m - _;
                                    return [i(255 * a(g, _, p + 1 / 3)), i(255 * a(g, _, p)), i(255 * a(g, _, p - 1 / 3)), h];
                                default:
                                    return null
                            }
                        }
                        return null
                    }
                } catch (e) {
                }
            }));

            class Vt {
                constructor(e, t, n, i = 1) {
                    this.r = e, this.g = t, this.b = n, this.a = i
                }

                static parse(e) {
                    if (!e) return;
                    if (e instanceof Vt) return e;
                    if ("string" != typeof e) return;
                    const t = Wt.parseCSSColor(e);
                    return t ? new Vt(t[0] / 255 * t[3], t[1] / 255 * t[3], t[2] / 255 * t[3], t[3]) : void 0
                }

                toString() {
                    const [e, t, n, i] = this.toArray();
                    return `rgba(${Math.round(e)},${Math.round(t)},${Math.round(n)},${i})`
                }

                toArray() {
                    const {r: e, g: t, b: n, a: i} = this;
                    return 0 === i ? [0, 0, 0, 0] : [255 * e / i, 255 * t / i, 255 * n / i, i]
                }
            }

            Vt.black = new Vt(0, 0, 0, 1), Vt.white = new Vt(1, 1, 1, 1), Vt.transparent = new Vt(0, 0, 0, 0), Vt.red = new Vt(1, 0, 0, 1), Vt.blue = new Vt(0, 0, 1, 1);

            class Gt {
                constructor(e, t, n) {
                    this.sensitivity = e ? t ? "variant" : "case" : t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                        sensitivity: this.sensitivity,
                        usage: "search"
                    })
                }

                compare(e, t) {
                    return this.collator.compare(e, t)
                }

                resolvedLocale() {
                    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                }
            }

            class qt {
                constructor(e, t, n, i, r) {
                    this.text = e.normalize ? e.normalize() : e, this.image = t, this.scale = n, this.fontStack = i, this.textColor = r
                }
            }

            class Zt {
                constructor(e) {
                    this.sections = e
                }

                static fromString(e) {
                    return new Zt([new qt(e, null, null, null, null)])
                }

                isEmpty() {
                    return 0 === this.sections.length || !this.sections.some(e => 0 !== e.text.length || e.image && 0 !== e.image.name.length)
                }

                static factory(e) {
                    return e instanceof Zt ? e : Zt.fromString(e)
                }

                toString() {
                    return 0 === this.sections.length ? "" : this.sections.map(e => e.text).join("")
                }

                serialize() {
                    const e = ["format"];
                    for (const t of this.sections) {
                        if (t.image) {
                            e.push(["image", t.image.name]);
                            continue
                        }
                        e.push(t.text);
                        const n = {};
                        t.fontStack && (n["text-font"] = ["literal", t.fontStack.split(",")]), t.scale && (n["font-scale"] = t.scale), t.textColor && (n["text-color"] = ["rgba"].concat(t.textColor.toArray())), e.push(n)
                    }
                    return e
                }
            }

            class $t {
                constructor(e) {
                    this.name = e.name, this.available = e.available
                }

                toString() {
                    return this.name
                }

                static fromString(e) {
                    return e ? new $t({name: e, available: !1}) : null
                }

                serialize() {
                    return ["image", this.name]
                }
            }

            function Xt(e, t, n, i) {
                return "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof n && n >= 0 && n <= 255 ? void 0 === i || "number" == typeof i && i >= 0 && i <= 1 ? null : `Invalid rgba value [${[e, t, n, i].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof i ? [e, t, n, i] : [e, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
            }

            function Jt(e) {
                if (null === e) return !0;
                if ("string" == typeof e) return !0;
                if ("boolean" == typeof e) return !0;
                if ("number" == typeof e) return !0;
                if (e instanceof Vt) return !0;
                if (e instanceof Gt) return !0;
                if (e instanceof Zt) return !0;
                if (e instanceof $t) return !0;
                if (Array.isArray(e)) {
                    for (const t of e) if (!Jt(t)) return !1;
                    return !0
                }
                if ("object" == typeof e) {
                    for (const t in e) if (!Jt(e[t])) return !1;
                    return !0
                }
                return !1
            }

            function Kt(e) {
                if (null === e) return Dt;
                if ("string" == typeof e) return Et;
                if ("boolean" == typeof e) return Ct;
                if ("number" == typeof e) return Lt;
                if (e instanceof Vt) return At;
                if (e instanceof Gt) return Rt;
                if (e instanceof Zt) return Yt;
                if (e instanceof $t) return zt;
                if (Array.isArray(e)) {
                    const t = e.length;
                    let n;
                    for (const t of e) {
                        const e = Kt(t);
                        if (n) {
                            if (n === e) continue;
                            n = Pt;
                            break
                        }
                        n = e
                    }
                    return Ot(n || Pt, t)
                }
                return It
            }

            function Qt(e) {
                const t = typeof e;
                return null === e ? "" : "string" === t || "number" === t || "boolean" === t ? String(e) : e instanceof Vt || e instanceof Zt || e instanceof $t ? e.toString() : JSON.stringify(e)
            }

            class en {
                constructor(e, t) {
                    this.type = e, this.value = t
                }

                static parse(e, t) {
                    if (2 !== e.length) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                    if (!Jt(e[1])) return t.error("invalid value");
                    const n = e[1];
                    let i = Kt(n);
                    const r = t.expectedType;
                    return "array" !== i.kind || 0 !== i.N || !r || "array" !== r.kind || "number" == typeof r.N && 0 !== r.N || (i = r), new en(i, n)
                }

                evaluate() {
                    return this.value
                }

                eachChild() {
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Vt ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Zt ? this.value.serialize() : this.value
                }
            }

            class tn {
                constructor(e) {
                    this.name = "ExpressionEvaluationError", this.message = e
                }

                toJSON() {
                    return this.message
                }
            }

            const nn = {string: Et, number: Lt, boolean: Ct, object: It};

            class rn {
                constructor(e, t) {
                    this.type = e, this.args = t
                }

                static parse(e, t) {
                    if (e.length < 2) return t.error("Expected at least one argument.");
                    let n, i = 1;
                    const r = e[0];
                    if ("array" === r) {
                        let r, o;
                        if (e.length > 2) {
                            const n = e[1];
                            if ("string" != typeof n || !(n in nn) || "object" === n) return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
                            r = nn[n], i++
                        } else r = Pt;
                        if (e.length > 3) {
                            if (null !== e[2] && ("number" != typeof e[2] || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error('The length argument to "array" must be a positive integer literal', 2);
                            o = e[2], i++
                        }
                        n = Ot(r, o)
                    } else n = nn[r];
                    const o = [];
                    for (; i < e.length; i++) {
                        const n = t.parse(e[i], i, Pt);
                        if (!n) return null;
                        o.push(n)
                    }
                    return new rn(n, o)
                }

                evaluate(e) {
                    for (let t = 0; t < this.args.length; t++) {
                        const n = this.args[t].evaluate(e);
                        if (!jt(this.type, Kt(n))) return n;
                        if (t === this.args.length - 1) throw new tn(`Expected value to be of type ${Ft(this.type)}, but found ${Ft(Kt(n))} instead.`)
                    }
                    return null
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    const e = this.type, t = [e.kind];
                    if ("array" === e.kind) {
                        const n = e.itemType;
                        if ("string" === n.kind || "number" === n.kind || "boolean" === n.kind) {
                            t.push(n.kind);
                            const i = e.N;
                            ("number" == typeof i || this.args.length > 1) && t.push(i)
                        }
                    }
                    return t.concat(this.args.map(e => e.serialize()))
                }
            }

            class on {
                constructor(e) {
                    this.type = Yt, this.sections = e
                }

                static parse(e, t) {
                    if (e.length < 2) return t.error("Expected at least one argument.");
                    const n = e[1];
                    if (!Array.isArray(n) && "object" == typeof n) return t.error("First argument must be an image or text section.");
                    const i = [];
                    let r = !1;
                    for (let n = 1; n <= e.length - 1; ++n) {
                        const o = e[n];
                        if (r && "object" == typeof o && !Array.isArray(o)) {
                            r = !1;
                            let e = null;
                            if (o["font-scale"] && (e = t.parse(o["font-scale"], 1, Lt), !e)) return null;
                            let n = null;
                            if (o["text-font"] && (n = t.parse(o["text-font"], 1, Ot(Et)), !n)) return null;
                            let a = null;
                            if (o["text-color"] && (a = t.parse(o["text-color"], 1, At), !a)) return null;
                            const s = i[i.length - 1];
                            s.scale = e, s.font = n, s.textColor = a
                        } else {
                            const o = t.parse(e[n], 1, Pt);
                            if (!o) return null;
                            const a = o.type.kind;
                            if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                            r = !0, i.push({content: o, scale: null, font: null, textColor: null})
                        }
                    }
                    return new on(i)
                }

                evaluate(e) {
                    return new Zt(this.sections.map(t => {
                        const n = t.content.evaluate(e);
                        return Kt(n) === zt ? new qt("", n, null, null, null) : new qt(Qt(n), null, t.scale ? t.scale.evaluate(e) : null, t.font ? t.font.evaluate(e).join(",") : null, t.textColor ? t.textColor.evaluate(e) : null)
                    }))
                }

                eachChild(e) {
                    for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = ["format"];
                    for (const t of this.sections) {
                        e.push(t.content.serialize());
                        const n = {};
                        t.scale && (n["font-scale"] = t.scale.serialize()), t.font && (n["text-font"] = t.font.serialize()), t.textColor && (n["text-color"] = t.textColor.serialize()), e.push(n)
                    }
                    return e
                }
            }

            class an {
                constructor(e) {
                    this.type = zt, this.input = e
                }

                static parse(e, t) {
                    if (2 !== e.length) return t.error("Expected two arguments.");
                    const n = t.parse(e[1], 1, Et);
                    return n ? new an(n) : t.error("No image name provided.")
                }

                evaluate(e) {
                    const t = this.input.evaluate(e), n = $t.fromString(t);
                    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n
                }

                eachChild(e) {
                    e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["image", this.input.serialize()]
                }
            }

            const sn = {"to-boolean": Ct, "to-color": At, "to-number": Lt, "to-string": Et};

            class ln {
                constructor(e, t) {
                    this.type = e, this.args = t
                }

                static parse(e, t) {
                    if (e.length < 2) return t.error("Expected at least one argument.");
                    const n = e[0];
                    if (("to-boolean" === n || "to-string" === n) && 2 !== e.length) return t.error("Expected one argument.");
                    const i = sn[n], r = [];
                    for (let n = 1; n < e.length; n++) {
                        const i = t.parse(e[n], n, Pt);
                        if (!i) return null;
                        r.push(i)
                    }
                    return new ln(i, r)
                }

                evaluate(e) {
                    if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(e));
                    if ("color" === this.type.kind) {
                        let t, n;
                        for (const i of this.args) {
                            if (t = i.evaluate(e), n = null, t instanceof Vt) return t;
                            if ("string" == typeof t) {
                                const n = e.parseColor(t);
                                if (n) return n
                            } else if (Array.isArray(t) && (n = t.length < 3 || t.length > 4 ? `Invalid rbga value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : Xt(t[0], t[1], t[2], t[3]), !n)) return new Vt(t[0] / 255, t[1] / 255, t[2] / 255, t[3])
                        }
                        throw new tn(n || `Could not parse color from value '${"string" == typeof t ? t : String(JSON.stringify(t))}'`)
                    }
                    if ("number" === this.type.kind) {
                        let t = null;
                        for (const n of this.args) {
                            if (t = n.evaluate(e), null === t) return 0;
                            const i = Number(t);
                            if (!isNaN(i)) return i
                        }
                        throw new tn(`Could not convert ${JSON.stringify(t)} to number.`)
                    }
                    return "formatted" === this.type.kind ? Zt.fromString(Qt(this.args[0].evaluate(e))) : "resolvedImage" === this.type.kind ? $t.fromString(Qt(this.args[0].evaluate(e))) : Qt(this.args[0].evaluate(e))
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    if ("formatted" === this.type.kind) return new on([{
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }]).serialize();
                    if ("resolvedImage" === this.type.kind) return new an(this.args[0]).serialize();
                    const e = ["to-" + this.type.kind];
                    return this.eachChild(t => {
                        e.push(t.serialize())
                    }), e
                }
            }

            const cn = ["Unknown", "Point", "LineString", "Polygon"];

            class un {
                constructor() {
                    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null
                }

                id() {
                    return this.feature && "id" in this.feature ? this.feature.id : null
                }

                geometryType() {
                    return this.feature ? "number" == typeof this.feature.type ? cn[this.feature.type] : this.feature.type : null
                }

                geometry() {
                    return this.feature && "geometry" in this.feature ? this.feature.geometry : null
                }

                canonicalID() {
                    return this.canonical
                }

                properties() {
                    return this.feature && this.feature.properties || {}
                }

                distanceFromCenter() {
                    if (this.featureTileCoord && this.featureDistanceData) {
                        const e = this.featureDistanceData.center, t = this.featureDistanceData.scale, {
                            x: n,
                            y: i
                        } = this.featureTileCoord;
                        return this.featureDistanceData.bearing[0] * (n * t - e[0]) + this.featureDistanceData.bearing[1] * (i * t - e[1])
                    }
                    return 0
                }

                parseColor(e) {
                    let t = this._parseColorCache[e];
                    return t || (t = this._parseColorCache[e] = Vt.parse(e)), t
                }
            }

            class dn {
                constructor(e, t, n, i) {
                    this.name = e, this.type = t, this._evaluate = n, this.args = i
                }

                evaluate(e) {
                    return this._evaluate(e, this.args)
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return [this.name].concat(this.args.map(e => e.serialize()))
                }

                static parse(e, t) {
                    const n = e[0], i = dn.definitions[n];
                    if (!i) return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                    const r = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads,
                        a = o.filter(([t]) => !Array.isArray(t) || t.length === e.length - 1);
                    let s = null;
                    for (const [i, o] of a) {
                        s = new Rn(t.registry, t.path, null, t.scope);
                        const a = [];
                        let l = !1;
                        for (let t = 1; t < e.length; t++) {
                            const n = e[t], r = Array.isArray(i) ? i[t - 1] : i.type, o = s.parse(n, 1 + a.length, r);
                            if (!o) {
                                l = !0;
                                break
                            }
                            a.push(o)
                        }
                        if (!l) if (Array.isArray(i) && i.length !== a.length) s.error(`Expected ${i.length} arguments, but found ${a.length} instead.`); else {
                            for (let e = 0; e < a.length; e++) {
                                const t = Array.isArray(i) ? i[e] : i.type, n = a[e];
                                s.concat(e + 1).checkSubtype(t, n.type)
                            }
                            if (0 === s.errors.length) return new dn(n, r, o, a)
                        }
                    }
                    if (1 === a.length) t.errors.push(...s.errors); else {
                        const n = (a.length ? a : o).map(([e]) => {
                            return t = e, Array.isArray(t) ? `(${t.map(Ft).join(", ")})` : `(${Ft(t.type)}...)`;
                            var t
                        }).join(" | "), i = [];
                        for (let n = 1; n < e.length; n++) {
                            const r = t.parse(e[n], 1 + i.length);
                            if (!r) return null;
                            i.push(Ft(r.type))
                        }
                        t.error(`Expected arguments of type ${n}, but found (${i.join(", ")}) instead.`)
                    }
                    return null
                }

                static register(e, t) {
                    dn.definitions = t;
                    for (const n in t) e[n] = dn
                }
            }

            class hn {
                constructor(e, t, n) {
                    this.type = Rt, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t
                }

                static parse(e, t) {
                    if (2 !== e.length) return t.error("Expected one argument.");
                    const n = e[1];
                    if ("object" != typeof n || Array.isArray(n)) return t.error("Collator options argument must be an object.");
                    const i = t.parse(void 0 !== n["case-sensitive"] && n["case-sensitive"], 1, Ct);
                    if (!i) return null;
                    const r = t.parse(void 0 !== n["diacritic-sensitive"] && n["diacritic-sensitive"], 1, Ct);
                    if (!r) return null;
                    let o = null;
                    return n.locale && (o = t.parse(n.locale, 1, Et), !o) ? null : new hn(i, r, o)
                }

                evaluate(e) {
                    return new Gt(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null)
                }

                eachChild(e) {
                    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = {};
                    return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e]
                }
            }

            const pn = 8192;

            function fn(e, t) {
                e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1])
            }

            function mn(e, t) {
                return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3])
            }

            function _n(e, t) {
                const n = (180 + e[0]) / 360,
                    i = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e[1] * Math.PI / 360))) / 360,
                    r = Math.pow(2, t.z);
                return [Math.round(n * r * pn), Math.round(i * r * pn)]
            }

            function gn(e, t, n) {
                const i = e[0] - t[0], r = e[1] - t[1], o = e[0] - n[0], a = e[1] - n[1];
                return i * a - o * r == 0 && i * o <= 0 && r * a <= 0
            }

            function yn(e, t) {
                let n = !1;
                for (let a = 0, s = t.length; a < s; a++) {
                    const s = t[a];
                    for (let t = 0, a = s.length; t < a - 1; t++) {
                        if (gn(e, s[t], s[t + 1])) return !1;
                        (r = s[t])[1] > (i = e)[1] != (o = s[t + 1])[1] > i[1] && i[0] < (o[0] - r[0]) * (i[1] - r[1]) / (o[1] - r[1]) + r[0] && (n = !n)
                    }
                }
                var i, r, o;
                return n
            }

            function vn(e, t) {
                for (let n = 0; n < t.length; n++) if (yn(e, t[n])) return !0;
                return !1
            }

            function xn(e, t, n, i) {
                const r = i[0] - n[0], o = i[1] - n[1], a = (e[0] - n[0]) * o - r * (e[1] - n[1]),
                    s = (t[0] - n[0]) * o - r * (t[1] - n[1]);
                return a > 0 && s < 0 || a < 0 && s > 0
            }

            function bn(e, t, n) {
                for (const c of n) for (let n = 0; n < c.length - 1; ++n) if (0 != (s = [(a = c[n + 1])[0] - (o = c[n])[0], a[1] - o[1]])[0] * (l = [(r = t)[0] - (i = e)[0], r[1] - i[1]])[1] - s[1] * l[0] && xn(i, r, o, a) && xn(o, a, i, r)) return !0;
                var i, r, o, a, s, l;
                return !1
            }

            function wn(e, t) {
                for (let n = 0; n < e.length; ++n) if (!yn(e[n], t)) return !1;
                for (let n = 0; n < e.length - 1; ++n) if (bn(e[n], e[n + 1], t)) return !1;
                return !0
            }

            function Mn(e, t) {
                for (let n = 0; n < t.length; n++) if (wn(e, t[n])) return !0;
                return !1
            }

            function Tn(e, t, n) {
                const i = [];
                for (let r = 0; r < e.length; r++) {
                    const o = [];
                    for (let i = 0; i < e[r].length; i++) {
                        const a = _n(e[r][i], n);
                        fn(t, a), o.push(a)
                    }
                    i.push(o)
                }
                return i
            }

            function kn(e, t, n) {
                const i = [];
                for (let r = 0; r < e.length; r++) {
                    const o = Tn(e[r], t, n);
                    i.push(o)
                }
                return i
            }

            function Sn(e, t, n, i) {
                if (e[0] < n[0] || e[0] > n[2]) {
                    const t = .5 * i;
                    let r = e[0] - n[0] > t ? -i : n[0] - e[0] > t ? i : 0;
                    0 === r && (r = e[0] - n[2] > t ? -i : n[2] - e[0] > t ? i : 0), e[0] += r
                }
                fn(t, e)
            }

            function Dn(e, t, n, i) {
                const r = Math.pow(2, i.z) * pn, o = [i.x * pn, i.y * pn], a = [];
                for (const i of e) for (const e of i) {
                    const i = [e.x + o[0], e.y + o[1]];
                    Sn(i, t, n, r), a.push(i)
                }
                return a
            }

            function Ln(e, t, n, i) {
                const r = Math.pow(2, i.z) * pn, o = [i.x * pn, i.y * pn], a = [];
                for (const n of e) {
                    const e = [];
                    for (const i of n) {
                        const n = [i.x + o[0], i.y + o[1]];
                        fn(t, n), e.push(n)
                    }
                    a.push(e)
                }
                if (t[2] - t[0] <= r / 2) {
                    (s = t)[0] = s[1] = 1 / 0, s[2] = s[3] = -1 / 0;
                    for (const e of a) for (const i of e) Sn(i, t, n, r)
                }
                var s;
                return a
            }

            class En {
                constructor(e, t) {
                    this.type = Ct, this.geojson = e, this.geometries = t
                }

                static parse(e, t) {
                    if (2 !== e.length) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                    if (Jt(e[1])) {
                        const t = e[1];
                        if ("FeatureCollection" === t.type) for (let e = 0; e < t.features.length; ++e) {
                            const n = t.features[e].geometry.type;
                            if ("Polygon" === n || "MultiPolygon" === n) return new En(t, t.features[e].geometry)
                        } else if ("Feature" === t.type) {
                            const e = t.geometry.type;
                            if ("Polygon" === e || "MultiPolygon" === e) return new En(t, t.geometry)
                        } else if ("Polygon" === t.type || "MultiPolygon" === t.type) return new En(t, t)
                    }
                    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                }

                evaluate(e) {
                    if (null != e.geometry() && null != e.canonicalID()) {
                        if ("Point" === e.geometryType()) return function (e, t) {
                            const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                r = e.canonicalID();
                            if ("Polygon" === t.type) {
                                const o = Tn(t.coordinates, i, r), a = Dn(e.geometry(), n, i, r);
                                if (!mn(n, i)) return !1;
                                for (const e of a) if (!yn(e, o)) return !1
                            }
                            if ("MultiPolygon" === t.type) {
                                const o = kn(t.coordinates, i, r), a = Dn(e.geometry(), n, i, r);
                                if (!mn(n, i)) return !1;
                                for (const e of a) if (!vn(e, o)) return !1
                            }
                            return !0
                        }(e, this.geometries);
                        if ("LineString" === e.geometryType()) return function (e, t) {
                            const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                r = e.canonicalID();
                            if ("Polygon" === t.type) {
                                const o = Tn(t.coordinates, i, r), a = Ln(e.geometry(), n, i, r);
                                if (!mn(n, i)) return !1;
                                for (const e of a) if (!wn(e, o)) return !1
                            }
                            if ("MultiPolygon" === t.type) {
                                const o = kn(t.coordinates, i, r), a = Ln(e.geometry(), n, i, r);
                                if (!mn(n, i)) return !1;
                                for (const e of a) if (!Mn(e, o)) return !1
                            }
                            return !0
                        }(e, this.geometries)
                    }
                    return !1
                }

                eachChild() {
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return ["within", this.geojson]
                }
            }

            function Cn(e) {
                if (e instanceof dn) {
                    if ("get" === e.name && 1 === e.args.length) return !1;
                    if ("feature-state" === e.name) return !1;
                    if ("has" === e.name && 1 === e.args.length) return !1;
                    if ("properties" === e.name || "geometry-type" === e.name || "id" === e.name) return !1;
                    if (/^filter-/.test(e.name)) return !1
                }
                if (e instanceof En) return !1;
                let t = !0;
                return e.eachChild(e => {
                    t && !Cn(e) && (t = !1)
                }), t
            }

            function An(e) {
                if (e instanceof dn && "feature-state" === e.name) return !1;
                let t = !0;
                return e.eachChild(e => {
                    t && !An(e) && (t = !1)
                }), t
            }

            function In(e, t) {
                if (e instanceof dn && t.indexOf(e.name) >= 0) return !1;
                let n = !0;
                return e.eachChild(e => {
                    n && !In(e, t) && (n = !1)
                }), n
            }

            class Pn {
                constructor(e, t) {
                    this.type = t.type, this.name = e, this.boundExpression = t
                }

                static parse(e, t) {
                    if (2 !== e.length || "string" != typeof e[1]) return t.error("'var' expression requires exactly one string literal argument.");
                    const n = e[1];
                    return t.scope.has(n) ? new Pn(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1)
                }

                evaluate(e) {
                    return this.boundExpression.evaluate(e)
                }

                eachChild() {
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["var", this.name]
                }
            }

            class Rn {
                constructor(e, t = [], n, i = new St, r = []) {
                    this.registry = e, this.path = t, this.key = t.map(e => `[${e}]`).join(""), this.scope = i, this.errors = r, this.expectedType = n
                }

                parse(e, t, n, i, r = {}) {
                    return t ? this.concat(t, n, i)._parse(e, r) : this._parse(e, r)
                }

                _parse(e, t) {
                    function n(e, t, n) {
                        return "assert" === n ? new rn(t, [e]) : "coerce" === n ? new ln(t, [e]) : e
                    }

                    if (null !== e && "string" != typeof e && "boolean" != typeof e && "number" != typeof e || (e = ["literal", e]), Array.isArray(e)) {
                        if (0 === e.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                        const i = e[0];
                        if ("string" != typeof i) return this.error(`Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                        const r = this.registry[i];
                        if (r) {
                            let i = r.parse(e, this);
                            if (!i) return null;
                            if (this.expectedType) {
                                const e = this.expectedType, r = i.type;
                                if ("string" !== e.kind && "number" !== e.kind && "boolean" !== e.kind && "object" !== e.kind && "array" !== e.kind || "value" !== r.kind) if ("color" !== e.kind && "formatted" !== e.kind && "resolvedImage" !== e.kind || "value" !== r.kind && "string" !== r.kind) {
                                    if (this.checkSubtype(e, r)) return null
                                } else i = n(i, e, t.typeAnnotation || "coerce"); else i = n(i, e, t.typeAnnotation || "assert")
                            }
                            if (!(i instanceof en) && "resolvedImage" !== i.type.kind && function e(t) {
                                if (t instanceof Pn) return e(t.boundExpression);
                                if (t instanceof dn && "error" === t.name) return !1;
                                if (t instanceof hn) return !1;
                                if (t instanceof En) return !1;
                                const n = t instanceof ln || t instanceof rn;
                                let i = !0;
                                return t.eachChild(t => {
                                    i = n ? i && e(t) : i && t instanceof en
                                }), !!i && Cn(t) && In(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"])
                            }(i)) {
                                const t = new un;
                                try {
                                    i = new en(i.type, i.evaluate(t))
                                } catch (e) {
                                    return this.error(e.message), null
                                }
                            }
                            return i
                        }
                        return this.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0)
                    }
                    return this.error(void 0 === e ? "'undefined' value invalid. Use null instead." : "object" == typeof e ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`)
                }

                concat(e, t, n) {
                    const i = "number" == typeof e ? this.path.concat(e) : this.path,
                        r = n ? this.scope.concat(n) : this.scope;
                    return new Rn(this.registry, i, t || null, r, this.errors)
                }

                error(e, ...t) {
                    const n = `${this.key}${t.map(e => `[${e}]`).join("")}`;
                    this.errors.push(new kt(n, e))
                }

                checkSubtype(e, t) {
                    const n = jt(e, t);
                    return n && this.error(n), n
                }
            }

            function Yn(e, t) {
                const n = e.length - 1;
                let i, r, o = 0, a = n, s = 0;
                for (; o <= a;) if (s = Math.floor((o + a) / 2), i = e[s], r = e[s + 1], i <= t) {
                    if (s === n || t < r) return s;
                    o = s + 1
                } else {
                    if (!(i > t)) throw new tn("Input is not a number.");
                    a = s - 1
                }
                return 0
            }

            class zn {
                constructor(e, t, n) {
                    this.type = e, this.input = t, this.labels = [], this.outputs = [];
                    for (const [e, t] of n) this.labels.push(e), this.outputs.push(t)
                }

                static parse(e, t) {
                    if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments.");
                    const n = t.parse(e[1], 1, Lt);
                    if (!n) return null;
                    const i = [];
                    let r = null;
                    t.expectedType && "value" !== t.expectedType.kind && (r = t.expectedType);
                    for (let n = 1; n < e.length; n += 2) {
                        const o = 1 === n ? -1 / 0 : e[n], a = e[n + 1], s = n, l = n + 1;
                        if ("number" != typeof o) return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', s);
                        if (i.length && i[i.length - 1][0] >= o) return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', s);
                        const c = t.parse(a, l, r);
                        if (!c) return null;
                        r = r || c.type, i.push([o, c])
                    }
                    return new zn(r, n, i)
                }

                evaluate(e) {
                    const t = this.labels, n = this.outputs;
                    if (1 === t.length) return n[0].evaluate(e);
                    const i = this.input.evaluate(e);
                    if (i <= t[0]) return n[0].evaluate(e);
                    const r = t.length;
                    return i >= t[r - 1] ? n[r - 1].evaluate(e) : n[Yn(t, i)].evaluate(e)
                }

                eachChild(e) {
                    e(this.input);
                    for (const t of this.outputs) e(t)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined())
                }

                serialize() {
                    const e = ["step", this.input.serialize()];
                    for (let t = 0; t < this.labels.length; t++) t > 0 && e.push(this.labels[t]), e.push(this.outputs[t].serialize());
                    return e
                }
            }

            function On(e, t, n) {
                return e * (1 - n) + t * n
            }

            var Fn = Object.freeze({
                __proto__: null, number: On, color: function (e, t, n) {
                    return new Vt(On(e.r, t.r, n), On(e.g, t.g, n), On(e.b, t.b, n), On(e.a, t.a, n))
                }, array: function (e, t, n) {
                    return e.map((e, i) => On(e, t[i], n))
                }
            });
            const Bn = 6 / 29 * 3 * (6 / 29), jn = Math.PI / 180, Hn = 180 / Math.PI;

            function Nn(e) {
                return e > .008856451679035631 ? Math.pow(e, 1 / 3) : e / Bn + 4 / 29
            }

            function Un(e) {
                return e > 6 / 29 ? e * e * e : Bn * (e - 4 / 29)
            }

            function Wn(e) {
                return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055)
            }

            function Vn(e) {
                return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
            }

            function Gn(e) {
                const t = Vn(e.r), n = Vn(e.g), i = Vn(e.b),
                    r = Nn((.4124564 * t + .3575761 * n + .1804375 * i) / .95047),
                    o = Nn((.2126729 * t + .7151522 * n + .072175 * i) / 1);
                return {
                    l: 116 * o - 16,
                    a: 500 * (r - o),
                    b: 200 * (o - Nn((.0193339 * t + .119192 * n + .9503041 * i) / 1.08883)),
                    alpha: e.a
                }
            }

            function qn(e) {
                let t = (e.l + 16) / 116, n = isNaN(e.a) ? t : t + e.a / 500, i = isNaN(e.b) ? t : t - e.b / 200;
                return t = 1 * Un(t), n = .95047 * Un(n), i = 1.08883 * Un(i), new Vt(Wn(3.2404542 * n - 1.5371385 * t - .4985314 * i), Wn(-.969266 * n + 1.8760108 * t + .041556 * i), Wn(.0556434 * n - .2040259 * t + 1.0572252 * i), e.alpha)
            }

            function Zn(e, t, n) {
                const i = t - e;
                return e + n * (i > 180 || i < -180 ? i - 360 * Math.round(i / 360) : i)
            }

            const $n = {
                forward: Gn, reverse: qn, interpolate: function (e, t, n) {
                    return {l: On(e.l, t.l, n), a: On(e.a, t.a, n), b: On(e.b, t.b, n), alpha: On(e.alpha, t.alpha, n)}
                }
            }, Xn = {
                forward: function (e) {
                    const {l: t, a: n, b: i} = Gn(e), r = Math.atan2(i, n) * Hn;
                    return {h: r < 0 ? r + 360 : r, c: Math.sqrt(n * n + i * i), l: t, alpha: e.a}
                }, reverse: function (e) {
                    const t = e.h * jn, n = e.c;
                    return qn({l: e.l, a: Math.cos(t) * n, b: Math.sin(t) * n, alpha: e.alpha})
                }, interpolate: function (e, t, n) {
                    return {h: Zn(e.h, t.h, n), c: On(e.c, t.c, n), l: On(e.l, t.l, n), alpha: On(e.alpha, t.alpha, n)}
                }
            };
            var Jn = Object.freeze({__proto__: null, lab: $n, hcl: Xn});

            class Kn {
                constructor(e, t, n, i, r) {
                    this.type = e, this.operator = t, this.interpolation = n, this.input = i, this.labels = [], this.outputs = [];
                    for (const [e, t] of r) this.labels.push(e), this.outputs.push(t)
                }

                static interpolationFactor(e, t, i, r) {
                    let o = 0;
                    if ("exponential" === e.name) o = Qn(t, e.base, i, r); else if ("linear" === e.name) o = Qn(t, 1, i, r); else if ("cubic-bezier" === e.name) {
                        const a = e.controlPoints;
                        o = new n(a[0], a[1], a[2], a[3]).solve(Qn(t, 1, i, r))
                    }
                    return o
                }

                static parse(e, t) {
                    let [n, i, r, ...o] = e;
                    if (!Array.isArray(i) || 0 === i.length) return t.error("Expected an interpolation type expression.", 1);
                    if ("linear" === i[0]) i = {name: "linear"}; else if ("exponential" === i[0]) {
                        const e = i[1];
                        if ("number" != typeof e) return t.error("Exponential interpolation requires a numeric base.", 1, 1);
                        i = {name: "exponential", base: e}
                    } else {
                        if ("cubic-bezier" !== i[0]) return t.error("Unknown interpolation type " + String(i[0]), 1, 0);
                        {
                            const e = i.slice(1);
                            if (4 !== e.length || e.some(e => "number" != typeof e || e < 0 || e > 1)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                            i = {name: "cubic-bezier", controlPoints: e}
                        }
                    }
                    if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments.");
                    if (r = t.parse(r, 2, Lt), !r) return null;
                    const a = [];
                    let s = null;
                    "interpolate-hcl" === n || "interpolate-lab" === n ? s = At : t.expectedType && "value" !== t.expectedType.kind && (s = t.expectedType);
                    for (let e = 0; e < o.length; e += 2) {
                        const n = o[e], i = o[e + 1], r = e + 3, l = e + 4;
                        if ("number" != typeof n) return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', r);
                        if (a.length && a[a.length - 1][0] >= n) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', r);
                        const c = t.parse(i, l, s);
                        if (!c) return null;
                        s = s || c.type, a.push([n, c])
                    }
                    return "number" === s.kind || "color" === s.kind || "array" === s.kind && "number" === s.itemType.kind && "number" == typeof s.N ? new Kn(s, n, i, r, a) : t.error(`Type ${Ft(s)} is not interpolatable.`)
                }

                evaluate(e) {
                    const t = this.labels, n = this.outputs;
                    if (1 === t.length) return n[0].evaluate(e);
                    const i = this.input.evaluate(e);
                    if (i <= t[0]) return n[0].evaluate(e);
                    const r = t.length;
                    if (i >= t[r - 1]) return n[r - 1].evaluate(e);
                    const o = Yn(t, i), a = Kn.interpolationFactor(this.interpolation, i, t[o], t[o + 1]),
                        s = n[o].evaluate(e), l = n[o + 1].evaluate(e);
                    return "interpolate" === this.operator ? Fn[this.type.kind.toLowerCase()](s, l, a) : "interpolate-hcl" === this.operator ? Xn.reverse(Xn.interpolate(Xn.forward(s), Xn.forward(l), a)) : $n.reverse($n.interpolate($n.forward(s), $n.forward(l), a))
                }

                eachChild(e) {
                    e(this.input);
                    for (const t of this.outputs) e(t)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined())
                }

                serialize() {
                    let e;
                    e = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                    const t = [this.operator, e, this.input.serialize()];
                    for (let e = 0; e < this.labels.length; e++) t.push(this.labels[e], this.outputs[e].serialize());
                    return t
                }
            }

            function Qn(e, t, n, i) {
                const r = i - n, o = e - n;
                return 0 === r ? 0 : 1 === t ? o / r : (Math.pow(t, o) - 1) / (Math.pow(t, r) - 1)
            }

            class ei {
                constructor(e, t) {
                    this.type = e, this.args = t
                }

                static parse(e, t) {
                    if (e.length < 2) return t.error("Expectected at least one argument.");
                    let n = null;
                    const i = t.expectedType;
                    i && "value" !== i.kind && (n = i);
                    const r = [];
                    for (const i of e.slice(1)) {
                        const e = t.parse(i, 1 + r.length, n, void 0, {typeAnnotation: "omit"});
                        if (!e) return null;
                        n = n || e.type, r.push(e)
                    }
                    const o = i && r.some(e => jt(i, e.type));
                    return new ei(o ? Pt : n, r)
                }

                evaluate(e) {
                    let t, n = null, i = 0;
                    for (const r of this.args) {
                        if (i++, n = r.evaluate(e), n && n instanceof $t && !n.available && (t || (t = n), n = null, i === this.args.length)) return t;
                        if (null !== n) break
                    }
                    return n
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    const e = ["coalesce"];
                    return this.eachChild(t => {
                        e.push(t.serialize())
                    }), e
                }
            }

            class ti {
                constructor(e, t) {
                    this.type = t.type, this.bindings = [].concat(e), this.result = t
                }

                evaluate(e) {
                    return this.result.evaluate(e)
                }

                eachChild(e) {
                    for (const t of this.bindings) e(t[1]);
                    e(this.result)
                }

                static parse(e, t) {
                    if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
                    const n = [];
                    for (let i = 1; i < e.length - 1; i += 2) {
                        const r = e[i];
                        if ("string" != typeof r) return t.error(`Expected string, but found ${typeof r} instead.`, i);
                        if (/[^a-zA-Z0-9_]/.test(r)) return t.error("Variable names must contain only alphanumeric characters or '_'.", i);
                        const o = t.parse(e[i + 1], i + 1);
                        if (!o) return null;
                        n.push([r, o])
                    }
                    const i = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
                    return i ? new ti(n, i) : null
                }

                outputDefined() {
                    return this.result.outputDefined()
                }

                serialize() {
                    const e = ["let"];
                    for (const [t, n] of this.bindings) e.push(t, n.serialize());
                    return e.push(this.result.serialize()), e
                }
            }

            class ni {
                constructor(e, t, n) {
                    this.type = e, this.index = t, this.input = n
                }

                static parse(e, t) {
                    if (3 !== e.length) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const n = t.parse(e[1], 1, Lt), i = t.parse(e[2], 2, Ot(t.expectedType || Pt));
                    return n && i ? new ni(i.type.itemType, n, i) : null
                }

                evaluate(e) {
                    const t = this.index.evaluate(e), n = this.input.evaluate(e);
                    if (t < 0) throw new tn(`Array index out of bounds: ${t} < 0.`);
                    if (t >= n.length) throw new tn(`Array index out of bounds: ${t} > ${n.length - 1}.`);
                    if (t !== Math.floor(t)) throw new tn(`Array index must be an integer, but found ${t} instead.`);
                    return n[t]
                }

                eachChild(e) {
                    e(this.index), e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["at", this.index.serialize(), this.input.serialize()]
                }
            }

            class ii {
                constructor(e, t) {
                    this.type = Ct, this.needle = e, this.haystack = t
                }

                static parse(e, t) {
                    if (3 !== e.length) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const n = t.parse(e[1], 1, Pt), i = t.parse(e[2], 2, Pt);
                    return n && i ? Ht(n.type, [Ct, Et, Lt, Dt, Pt]) ? new ii(n, i) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ft(n.type)} instead`) : null
                }

                evaluate(e) {
                    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
                    if (!n) return !1;
                    if (!Nt(t, ["boolean", "string", "number", "null"])) throw new tn(`Expected first argument to be of type boolean, string, number or null, but found ${Ft(Kt(t))} instead.`);
                    if (!Nt(n, ["string", "array"])) throw new tn(`Expected second argument to be of type array or string, but found ${Ft(Kt(n))} instead.`);
                    return n.indexOf(t) >= 0
                }

                eachChild(e) {
                    e(this.needle), e(this.haystack)
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return ["in", this.needle.serialize(), this.haystack.serialize()]
                }
            }

            class ri {
                constructor(e, t, n) {
                    this.type = Lt, this.needle = e, this.haystack = t, this.fromIndex = n
                }

                static parse(e, t) {
                    if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                    const n = t.parse(e[1], 1, Pt), i = t.parse(e[2], 2, Pt);
                    if (!n || !i) return null;
                    if (!Ht(n.type, [Ct, Et, Lt, Dt, Pt])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ft(n.type)} instead`);
                    if (4 === e.length) {
                        const r = t.parse(e[3], 3, Lt);
                        return r ? new ri(n, i, r) : null
                    }
                    return new ri(n, i)
                }

                evaluate(e) {
                    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
                    if (!Nt(t, ["boolean", "string", "number", "null"])) throw new tn(`Expected first argument to be of type boolean, string, number or null, but found ${Ft(Kt(t))} instead.`);
                    if (!Nt(n, ["string", "array"])) throw new tn(`Expected second argument to be of type array or string, but found ${Ft(Kt(n))} instead.`);
                    if (this.fromIndex) {
                        const i = this.fromIndex.evaluate(e);
                        return n.indexOf(t, i)
                    }
                    return n.indexOf(t)
                }

                eachChild(e) {
                    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    if (null != this.fromIndex && void 0 !== this.fromIndex) {
                        const e = this.fromIndex.serialize();
                        return ["index-of", this.needle.serialize(), this.haystack.serialize(), e]
                    }
                    return ["index-of", this.needle.serialize(), this.haystack.serialize()]
                }
            }

            class oi {
                constructor(e, t, n, i, r, o) {
                    this.inputType = e, this.type = t, this.input = n, this.cases = i, this.outputs = r, this.otherwise = o
                }

                static parse(e, t) {
                    if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if (e.length % 2 != 1) return t.error("Expected an even number of arguments.");
                    let n, i;
                    t.expectedType && "value" !== t.expectedType.kind && (i = t.expectedType);
                    const r = {}, o = [];
                    for (let a = 2; a < e.length - 1; a += 2) {
                        let s = e[a];
                        const l = e[a + 1];
                        Array.isArray(s) || (s = [s]);
                        const c = t.concat(a);
                        if (0 === s.length) return c.error("Expected at least one branch label.");
                        for (const e of s) {
                            if ("number" != typeof e && "string" != typeof e) return c.error("Branch labels must be numbers or strings.");
                            if ("number" == typeof e && Math.abs(e) > Number.MAX_SAFE_INTEGER) return c.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                            if ("number" == typeof e && Math.floor(e) !== e) return c.error("Numeric branch labels must be integer values.");
                            if (n) {
                                if (c.checkSubtype(n, Kt(e))) return null
                            } else n = Kt(e);
                            if (void 0 !== r[String(e)]) return c.error("Branch labels must be unique.");
                            r[String(e)] = o.length
                        }
                        const u = t.parse(l, a, i);
                        if (!u) return null;
                        i = i || u.type, o.push(u)
                    }
                    const a = t.parse(e[1], 1, Pt);
                    if (!a) return null;
                    const s = t.parse(e[e.length - 1], e.length - 1, i);
                    return s ? "value" !== a.type.kind && t.concat(1).checkSubtype(n, a.type) ? null : new oi(n, i, a, r, o, s) : null
                }

                evaluate(e) {
                    const t = this.input.evaluate(e);
                    return (Kt(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e)
                }

                eachChild(e) {
                    e(this.input), this.outputs.forEach(e), e(this.otherwise)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined()
                }

                serialize() {
                    const e = ["match", this.input.serialize()], t = Object.keys(this.cases).sort(), n = [], i = {};
                    for (const e of t) {
                        const t = i[this.cases[e]];
                        void 0 === t ? (i[this.cases[e]] = n.length, n.push([this.cases[e], [e]])) : n[t][1].push(e)
                    }
                    const r = e => "number" === this.inputType.kind ? Number(e) : e;
                    for (const [t, i] of n) e.push(1 === i.length ? r(i[0]) : i.map(r)), e.push(this.outputs[t].serialize());
                    return e.push(this.otherwise.serialize()), e
                }
            }

            class ai {
                constructor(e, t, n) {
                    this.type = e, this.branches = t, this.otherwise = n
                }

                static parse(e, t) {
                    if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
                    if (e.length % 2 != 0) return t.error("Expected an odd number of arguments.");
                    let n;
                    t.expectedType && "value" !== t.expectedType.kind && (n = t.expectedType);
                    const i = [];
                    for (let r = 1; r < e.length - 1; r += 2) {
                        const o = t.parse(e[r], r, Ct);
                        if (!o) return null;
                        const a = t.parse(e[r + 1], r + 1, n);
                        if (!a) return null;
                        i.push([o, a]), n = n || a.type
                    }
                    const r = t.parse(e[e.length - 1], e.length - 1, n);
                    return r ? new ai(n, i, r) : null
                }

                evaluate(e) {
                    for (const [t, n] of this.branches) if (t.evaluate(e)) return n.evaluate(e);
                    return this.otherwise.evaluate(e)
                }

                eachChild(e) {
                    for (const [t, n] of this.branches) e(t), e(n);
                    e(this.otherwise)
                }

                outputDefined() {
                    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined()
                }

                serialize() {
                    const e = ["case"];
                    return this.eachChild(t => {
                        e.push(t.serialize())
                    }), e
                }
            }

            class si {
                constructor(e, t, n, i) {
                    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = i
                }

                static parse(e, t) {
                    if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                    const n = t.parse(e[1], 1, Pt), i = t.parse(e[2], 2, Lt);
                    if (!n || !i) return null;
                    if (!Ht(n.type, [Ot(Pt), Et, Pt])) return t.error(`Expected first argument to be of type array or string, but found ${Ft(n.type)} instead`);
                    if (4 === e.length) {
                        const r = t.parse(e[3], 3, Lt);
                        return r ? new si(n.type, n, i, r) : null
                    }
                    return new si(n.type, n, i)
                }

                evaluate(e) {
                    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
                    if (!Nt(t, ["string", "array"])) throw new tn(`Expected first argument to be of type array or string, but found ${Ft(Kt(t))} instead.`);
                    if (this.endIndex) {
                        const i = this.endIndex.evaluate(e);
                        return t.slice(n, i)
                    }
                    return t.slice(n)
                }

                eachChild(e) {
                    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    if (null != this.endIndex && void 0 !== this.endIndex) {
                        const e = this.endIndex.serialize();
                        return ["slice", this.input.serialize(), this.beginIndex.serialize(), e]
                    }
                    return ["slice", this.input.serialize(), this.beginIndex.serialize()]
                }
            }

            function li(e, t) {
                return "==" === e || "!=" === e ? "boolean" === t.kind || "string" === t.kind || "number" === t.kind || "null" === t.kind || "value" === t.kind : "string" === t.kind || "number" === t.kind || "value" === t.kind
            }

            function ci(e, t, n, i) {
                return 0 === i.compare(t, n)
            }

            function ui(e, t, n) {
                const i = "==" !== e && "!=" !== e;
                return class r {
                    constructor(e, t, n) {
                        this.type = Ct, this.lhs = e, this.rhs = t, this.collator = n, this.hasUntypedArgument = "value" === e.type.kind || "value" === t.type.kind
                    }

                    static parse(e, t) {
                        if (3 !== e.length && 4 !== e.length) return t.error("Expected two or three arguments.");
                        const n = e[0];
                        let o = t.parse(e[1], 1, Pt);
                        if (!o) return null;
                        if (!li(n, o.type)) return t.concat(1).error(`"${n}" comparisons are not supported for type '${Ft(o.type)}'.`);
                        let a = t.parse(e[2], 2, Pt);
                        if (!a) return null;
                        if (!li(n, a.type)) return t.concat(2).error(`"${n}" comparisons are not supported for type '${Ft(a.type)}'.`);
                        if (o.type.kind !== a.type.kind && "value" !== o.type.kind && "value" !== a.type.kind) return t.error(`Cannot compare types '${Ft(o.type)}' and '${Ft(a.type)}'.`);
                        i && ("value" === o.type.kind && "value" !== a.type.kind ? o = new rn(a.type, [o]) : "value" !== o.type.kind && "value" === a.type.kind && (a = new rn(o.type, [a])));
                        let s = null;
                        if (4 === e.length) {
                            if ("string" !== o.type.kind && "string" !== a.type.kind && "value" !== o.type.kind && "value" !== a.type.kind) return t.error("Cannot use collator to compare non-string types.");
                            if (s = t.parse(e[3], 3, Rt), !s) return null
                        }
                        return new r(o, a, s)
                    }

                    evaluate(r) {
                        const o = this.lhs.evaluate(r), a = this.rhs.evaluate(r);
                        if (i && this.hasUntypedArgument) {
                            const t = Kt(o), n = Kt(a);
                            if (t.kind !== n.kind || "string" !== t.kind && "number" !== t.kind) throw new tn(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${t.kind}, ${n.kind}) instead.`)
                        }
                        if (this.collator && !i && this.hasUntypedArgument) {
                            const e = Kt(o), n = Kt(a);
                            if ("string" !== e.kind || "string" !== n.kind) return t(r, o, a)
                        }
                        return this.collator ? n(r, o, a, this.collator.evaluate(r)) : t(r, o, a)
                    }

                    eachChild(e) {
                        e(this.lhs), e(this.rhs), this.collator && e(this.collator)
                    }

                    outputDefined() {
                        return !0
                    }

                    serialize() {
                        const t = [e];
                        return this.eachChild(e => {
                            t.push(e.serialize())
                        }), t
                    }
                }
            }

            const di = ui("==", (function (e, t, n) {
                return t === n
            }), ci), hi = ui("!=", (function (e, t, n) {
                return t !== n
            }), (function (e, t, n, i) {
                return !ci(0, t, n, i)
            })), pi = ui("<", (function (e, t, n) {
                return t < n
            }), (function (e, t, n, i) {
                return i.compare(t, n) < 0
            })), fi = ui(">", (function (e, t, n) {
                return t > n
            }), (function (e, t, n, i) {
                return i.compare(t, n) > 0
            })), mi = ui("<=", (function (e, t, n) {
                return t <= n
            }), (function (e, t, n, i) {
                return i.compare(t, n) <= 0
            })), _i = ui(">=", (function (e, t, n) {
                return t >= n
            }), (function (e, t, n, i) {
                return i.compare(t, n) >= 0
            }));

            class gi {
                constructor(e, t, n, i, r) {
                    this.type = Et, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = i, this.maxFractionDigits = r
                }

                static parse(e, t) {
                    if (3 !== e.length) return t.error("Expected two arguments.");
                    const n = t.parse(e[1], 1, Lt);
                    if (!n) return null;
                    const i = e[2];
                    if ("object" != typeof i || Array.isArray(i)) return t.error("NumberFormat options argument must be an object.");
                    let r = null;
                    if (i.locale && (r = t.parse(i.locale, 1, Et), !r)) return null;
                    let o = null;
                    if (i.currency && (o = t.parse(i.currency, 1, Et), !o)) return null;
                    let a = null;
                    if (i["min-fraction-digits"] && (a = t.parse(i["min-fraction-digits"], 1, Lt), !a)) return null;
                    let s = null;
                    return i["max-fraction-digits"] && (s = t.parse(i["max-fraction-digits"], 1, Lt), !s) ? null : new gi(n, r, o, a, s)
                }

                evaluate(e) {
                    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
                        style: this.currency ? "currency" : "decimal",
                        currency: this.currency ? this.currency.evaluate(e) : void 0,
                        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
                        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
                    }).format(this.number.evaluate(e))
                }

                eachChild(e) {
                    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = {};
                    return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e]
                }
            }

            class yi {
                constructor(e) {
                    this.type = Lt, this.input = e
                }

                static parse(e, t) {
                    if (2 !== e.length) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
                    const n = t.parse(e[1], 1);
                    return n ? "array" !== n.type.kind && "string" !== n.type.kind && "value" !== n.type.kind ? t.error(`Expected argument of type string or array, but found ${Ft(n.type)} instead.`) : new yi(n) : null
                }

                evaluate(e) {
                    const t = this.input.evaluate(e);
                    if ("string" == typeof t) return t.length;
                    if (Array.isArray(t)) return t.length;
                    throw new tn(`Expected value to be of type string or array, but found ${Ft(Kt(t))} instead.`)
                }

                eachChild(e) {
                    e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = ["length"];
                    return this.eachChild(t => {
                        e.push(t.serialize())
                    }), e
                }
            }

            const vi = {
                "==": di,
                "!=": hi,
                ">": fi,
                "<": pi,
                ">=": _i,
                "<=": mi,
                array: rn,
                at: ni,
                boolean: rn,
                case: ai,
                coalesce: ei,
                collator: hn,
                format: on,
                image: an,
                in: ii,
                "index-of": ri,
                interpolate: Kn,
                "interpolate-hcl": Kn,
                "interpolate-lab": Kn,
                length: yi,
                let: ti,
                literal: en,
                match: oi,
                number: rn,
                "number-format": gi,
                object: rn,
                slice: si,
                step: zn,
                string: rn,
                "to-boolean": ln,
                "to-color": ln,
                "to-number": ln,
                "to-string": ln,
                var: Pn,
                within: En
            };

            function xi(e, [t, n, i, r]) {
                t = t.evaluate(e), n = n.evaluate(e), i = i.evaluate(e);
                const o = r ? r.evaluate(e) : 1, a = Xt(t, n, i, o);
                if (a) throw new tn(a);
                return new Vt(t / 255 * o, n / 255 * o, i / 255 * o, o)
            }

            function bi(e, t) {
                return e in t
            }

            function wi(e, t) {
                const n = t[e];
                return void 0 === n ? null : n
            }

            function Mi(e) {
                return {type: e}
            }

            function Ti(e) {
                return {result: "success", value: e}
            }

            function ki(e) {
                return {result: "error", value: e}
            }

            function Si(e) {
                return "data-driven" === e["property-type"] || "cross-faded-data-driven" === e["property-type"]
            }

            function Di(e) {
                return !!e.expression && e.expression.parameters.indexOf("zoom") > -1
            }

            function Li(e) {
                return !!e.expression && e.expression.interpolated
            }

            function Ei(e) {
                return e instanceof Number ? "number" : e instanceof String ? "string" : e instanceof Boolean ? "boolean" : Array.isArray(e) ? "array" : null === e ? "null" : typeof e
            }

            function Ci(e) {
                return "object" == typeof e && null !== e && !Array.isArray(e)
            }

            function Ai(e) {
                return e
            }

            function Ii(e, t, n) {
                return void 0 !== e ? e : void 0 !== t ? t : void 0 !== n ? n : void 0
            }

            function Pi(e, t, n, i, r) {
                return Ii(typeof n === r ? i[n] : void 0, e.default, t.default)
            }

            function Ri(e, t, n) {
                if ("number" !== Ei(n)) return Ii(e.default, t.default);
                const i = e.stops.length;
                if (1 === i) return e.stops[0][1];
                if (n <= e.stops[0][0]) return e.stops[0][1];
                if (n >= e.stops[i - 1][0]) return e.stops[i - 1][1];
                const r = Yn(e.stops.map(e => e[0]), n);
                return e.stops[r][1]
            }

            function Yi(e, t, n) {
                const i = void 0 !== e.base ? e.base : 1;
                if ("number" !== Ei(n)) return Ii(e.default, t.default);
                const r = e.stops.length;
                if (1 === r) return e.stops[0][1];
                if (n <= e.stops[0][0]) return e.stops[0][1];
                if (n >= e.stops[r - 1][0]) return e.stops[r - 1][1];
                const o = Yn(e.stops.map(e => e[0]), n), a = function (e, t, n, i) {
                    const r = i - n, o = e - n;
                    return 0 === r ? 0 : 1 === t ? o / r : (Math.pow(t, o) - 1) / (Math.pow(t, r) - 1)
                }(n, i, e.stops[o][0], e.stops[o + 1][0]), s = e.stops[o][1], l = e.stops[o + 1][1];
                let c = Fn[t.type] || Ai;
                if (e.colorSpace && "rgb" !== e.colorSpace) {
                    const t = Jn[e.colorSpace];
                    c = (e, n) => t.reverse(t.interpolate(t.forward(e), t.forward(n), a))
                }
                return "function" == typeof s.evaluate ? {
                    evaluate(...e) {
                        const t = s.evaluate.apply(void 0, e), n = l.evaluate.apply(void 0, e);
                        if (void 0 !== t && void 0 !== n) return c(t, n, a)
                    }
                } : c(s, l, a)
            }

            function zi(e, t, n) {
                return "color" === t.type ? n = Vt.parse(n) : "formatted" === t.type ? n = Zt.fromString(n.toString()) : "resolvedImage" === t.type ? n = $t.fromString(n.toString()) : Ei(n) === t.type || "enum" === t.type && t.values[n] || (n = void 0), Ii(n, e.default, t.default)
            }

            dn.register(vi, {
                error: [{kind: "error"}, [Et], (e, [t]) => {
                    throw new tn(t.evaluate(e))
                }],
                typeof: [Et, [Pt], (e, [t]) => Ft(Kt(t.evaluate(e)))],
                "to-rgba": [Ot(Lt, 4), [At], (e, [t]) => t.evaluate(e).toArray()],
                rgb: [At, [Lt, Lt, Lt], xi],
                rgba: [At, [Lt, Lt, Lt, Lt], xi],
                has: {
                    type: Ct,
                    overloads: [[[Et], (e, [t]) => bi(t.evaluate(e), e.properties())], [[Et, It], (e, [t, n]) => bi(t.evaluate(e), n.evaluate(e))]]
                },
                get: {
                    type: Pt,
                    overloads: [[[Et], (e, [t]) => wi(t.evaluate(e), e.properties())], [[Et, It], (e, [t, n]) => wi(t.evaluate(e), n.evaluate(e))]]
                },
                "feature-state": [Pt, [Et], (e, [t]) => wi(t.evaluate(e), e.featureState || {})],
                properties: [It, [], e => e.properties()],
                "geometry-type": [Et, [], e => e.geometryType()],
                id: [Pt, [], e => e.id()],
                zoom: [Lt, [], e => e.globals.zoom],
                pitch: [Lt, [], e => e.globals.pitch || 0],
                "distance-from-center": [Lt, [], e => e.distanceFromCenter()],
                "heatmap-density": [Lt, [], e => e.globals.heatmapDensity || 0],
                "line-progress": [Lt, [], e => e.globals.lineProgress || 0],
                "sky-radial-progress": [Lt, [], e => e.globals.skyRadialProgress || 0],
                accumulated: [Pt, [], e => void 0 === e.globals.accumulated ? null : e.globals.accumulated],
                "+": [Lt, Mi(Lt), (e, t) => {
                    let n = 0;
                    for (const i of t) n += i.evaluate(e);
                    return n
                }],
                "*": [Lt, Mi(Lt), (e, t) => {
                    let n = 1;
                    for (const i of t) n *= i.evaluate(e);
                    return n
                }],
                "-": {
                    type: Lt,
                    overloads: [[[Lt, Lt], (e, [t, n]) => t.evaluate(e) - n.evaluate(e)], [[Lt], (e, [t]) => -t.evaluate(e)]]
                },
                "/": [Lt, [Lt, Lt], (e, [t, n]) => t.evaluate(e) / n.evaluate(e)],
                "%": [Lt, [Lt, Lt], (e, [t, n]) => t.evaluate(e) % n.evaluate(e)],
                ln2: [Lt, [], () => Math.LN2],
                pi: [Lt, [], () => Math.PI],
                e: [Lt, [], () => Math.E],
                "^": [Lt, [Lt, Lt], (e, [t, n]) => Math.pow(t.evaluate(e), n.evaluate(e))],
                sqrt: [Lt, [Lt], (e, [t]) => Math.sqrt(t.evaluate(e))],
                log10: [Lt, [Lt], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10],
                ln: [Lt, [Lt], (e, [t]) => Math.log(t.evaluate(e))],
                log2: [Lt, [Lt], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2],
                sin: [Lt, [Lt], (e, [t]) => Math.sin(t.evaluate(e))],
                cos: [Lt, [Lt], (e, [t]) => Math.cos(t.evaluate(e))],
                tan: [Lt, [Lt], (e, [t]) => Math.tan(t.evaluate(e))],
                asin: [Lt, [Lt], (e, [t]) => Math.asin(t.evaluate(e))],
                acos: [Lt, [Lt], (e, [t]) => Math.acos(t.evaluate(e))],
                atan: [Lt, [Lt], (e, [t]) => Math.atan(t.evaluate(e))],
                min: [Lt, Mi(Lt), (e, t) => Math.min(...t.map(t => t.evaluate(e)))],
                max: [Lt, Mi(Lt), (e, t) => Math.max(...t.map(t => t.evaluate(e)))],
                abs: [Lt, [Lt], (e, [t]) => Math.abs(t.evaluate(e))],
                round: [Lt, [Lt], (e, [t]) => {
                    const n = t.evaluate(e);
                    return n < 0 ? -Math.round(-n) : Math.round(n)
                }],
                floor: [Lt, [Lt], (e, [t]) => Math.floor(t.evaluate(e))],
                ceil: [Lt, [Lt], (e, [t]) => Math.ceil(t.evaluate(e))],
                "filter-==": [Ct, [Et, Pt], (e, [t, n]) => e.properties()[t.value] === n.value],
                "filter-id-==": [Ct, [Pt], (e, [t]) => e.id() === t.value],
                "filter-type-==": [Ct, [Et], (e, [t]) => e.geometryType() === t.value],
                "filter-<": [Ct, [Et, Pt], (e, [t, n]) => {
                    const i = e.properties()[t.value], r = n.value;
                    return typeof i == typeof r && i < r
                }],
                "filter-id-<": [Ct, [Pt], (e, [t]) => {
                    const n = e.id(), i = t.value;
                    return typeof n == typeof i && n < i
                }],
                "filter->": [Ct, [Et, Pt], (e, [t, n]) => {
                    const i = e.properties()[t.value], r = n.value;
                    return typeof i == typeof r && i > r
                }],
                "filter-id->": [Ct, [Pt], (e, [t]) => {
                    const n = e.id(), i = t.value;
                    return typeof n == typeof i && n > i
                }],
                "filter-<=": [Ct, [Et, Pt], (e, [t, n]) => {
                    const i = e.properties()[t.value], r = n.value;
                    return typeof i == typeof r && i <= r
                }],
                "filter-id-<=": [Ct, [Pt], (e, [t]) => {
                    const n = e.id(), i = t.value;
                    return typeof n == typeof i && n <= i
                }],
                "filter->=": [Ct, [Et, Pt], (e, [t, n]) => {
                    const i = e.properties()[t.value], r = n.value;
                    return typeof i == typeof r && i >= r
                }],
                "filter-id->=": [Ct, [Pt], (e, [t]) => {
                    const n = e.id(), i = t.value;
                    return typeof n == typeof i && n >= i
                }],
                "filter-has": [Ct, [Pt], (e, [t]) => t.value in e.properties()],
                "filter-has-id": [Ct, [], e => null !== e.id() && void 0 !== e.id()],
                "filter-type-in": [Ct, [Ot(Et)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0],
                "filter-id-in": [Ct, [Ot(Pt)], (e, [t]) => t.value.indexOf(e.id()) >= 0],
                "filter-in-small": [Ct, [Et, Ot(Pt)], (e, [t, n]) => n.value.indexOf(e.properties()[t.value]) >= 0],
                "filter-in-large": [Ct, [Et, Ot(Pt)], (e, [t, n]) => function (e, t, n, i) {
                    for (; n <= i;) {
                        const r = n + i >> 1;
                        if (t[r] === e) return !0;
                        t[r] > e ? i = r - 1 : n = r + 1
                    }
                    return !1
                }(e.properties()[t.value], n.value, 0, n.value.length - 1)],
                all: {
                    type: Ct,
                    overloads: [[[Ct, Ct], (e, [t, n]) => t.evaluate(e) && n.evaluate(e)], [Mi(Ct), (e, t) => {
                        for (const n of t) if (!n.evaluate(e)) return !1;
                        return !0
                    }]]
                },
                any: {
                    type: Ct,
                    overloads: [[[Ct, Ct], (e, [t, n]) => t.evaluate(e) || n.evaluate(e)], [Mi(Ct), (e, t) => {
                        for (const n of t) if (n.evaluate(e)) return !0;
                        return !1
                    }]]
                },
                "!": [Ct, [Ct], (e, [t]) => !t.evaluate(e)],
                "is-supported-script": [Ct, [Et], (e, [t]) => {
                    const n = e.globals && e.globals.isSupportedScript;
                    return !n || n(t.evaluate(e))
                }],
                upcase: [Et, [Et], (e, [t]) => t.evaluate(e).toUpperCase()],
                downcase: [Et, [Et], (e, [t]) => t.evaluate(e).toLowerCase()],
                concat: [Et, Mi(Pt), (e, t) => t.map(t => Qt(t.evaluate(e))).join("")],
                "resolved-locale": [Et, [Rt], (e, [t]) => t.evaluate(e).resolvedLocale()]
            });

            class Oi {
                constructor(e, t) {
                    this.expression = e, this._warningHistory = {}, this._evaluator = new un, this._defaultValue = t ? function (e) {
                        return "color" === e.type && Ci(e.default) ? new Vt(0, 0, 0, 0) : "color" === e.type ? Vt.parse(e.default) || null : void 0 === e.default ? null : e.default
                    }(t) : null, this._enumValues = t && "enum" === t.type ? t.values : null
                }

                evaluateWithoutErrorHandling(e, t, n, i, r, o, a, s) {
                    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = i, this._evaluator.availableImages = r || null, this._evaluator.formattedSection = o, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = s || null, this.expression.evaluate(this._evaluator)
                }

                evaluate(e, t, n, i, r, o, a, s) {
                    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = i, this._evaluator.availableImages = r || null, this._evaluator.formattedSection = o || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = s || null;
                    try {
                        const e = this.expression.evaluate(this._evaluator);
                        if (null == e || "number" == typeof e && e != e) return this._defaultValue;
                        if (this._enumValues && !(e in this._enumValues)) throw new tn(`Expected value to be one of ${Object.keys(this._enumValues).map(e => JSON.stringify(e)).join(", ")}, but found ${JSON.stringify(e)} instead.`);
                        return e
                    } catch (e) {
                        return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, "undefined" != typeof console && console.warn(e.message)), this._defaultValue
                    }
                }
            }

            function Fi(e) {
                return Array.isArray(e) && e.length > 0 && "string" == typeof e[0] && e[0] in vi
            }

            function Bi(e, t) {
                const n = new Rn(vi, [], t ? function (e) {
                        const t = {
                            color: At,
                            string: Et,
                            number: Lt,
                            enum: Et,
                            boolean: Ct,
                            formatted: Yt,
                            resolvedImage: zt
                        };
                        return "array" === e.type ? Ot(t[e.value] || Pt, e.length) : t[e.type]
                    }(t) : void 0),
                    i = n.parse(e, void 0, void 0, void 0, t && "string" === t.type ? {typeAnnotation: "coerce"} : void 0);
                return i ? Ti(new Oi(i, t)) : ki(n.errors)
            }

            class ji {
                constructor(e, t) {
                    this.kind = e, this._styleExpression = t, this.isStateDependent = "constant" !== e && !An(t.expression)
                }

                evaluateWithoutErrorHandling(e, t, n, i, r, o) {
                    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, r, o)
                }

                evaluate(e, t, n, i, r, o) {
                    return this._styleExpression.evaluate(e, t, n, i, r, o)
                }
            }

            class Hi {
                constructor(e, t, n, i) {
                    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = "camera" !== e && !An(t.expression), this.interpolationType = i
                }

                evaluateWithoutErrorHandling(e, t, n, i, r, o) {
                    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, r, o)
                }

                evaluate(e, t, n, i, r, o) {
                    return this._styleExpression.evaluate(e, t, n, i, r, o)
                }

                interpolationFactor(e, t, n) {
                    return this.interpolationType ? Kn.interpolationFactor(this.interpolationType, e, t, n) : 0
                }
            }

            function Ni(e, t) {
                if ("error" === (e = Bi(e, t)).result) return e;
                const n = e.value.expression, i = Cn(n);
                if (!i && !Si(t)) return ki([new kt("", "data expressions not supported")]);
                const r = In(n, ["zoom", "pitch", "distance-from-center"]);
                if (!r && !Di(t)) return ki([new kt("", "zoom expressions not supported")]);
                const o = function e(t) {
                    let n = null;
                    if (t instanceof ti) n = e(t.result); else if (t instanceof ei) {
                        for (const i of t.args) if (n = e(i), n) break
                    } else (t instanceof zn || t instanceof Kn) && t.input instanceof dn && "zoom" === t.input.name && (n = t);
                    return n instanceof kt || t.eachChild(t => {
                        const i = e(t);
                        i instanceof kt ? n = i : !n && i ? n = new kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && i && n !== i && (n = new kt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }), n
                }(n);
                return o || r ? o instanceof kt ? ki([o]) : o instanceof Kn && !Li(t) ? ki([new kt("", '"interpolate" expressions cannot be used with this property')]) : Ti(o ? new Hi(i ? "camera" : "composite", e.value, o.labels, o instanceof Kn ? o.interpolation : void 0) : new ji(i ? "constant" : "source", e.value)) : ki([new kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
            }

            class Ui {
                constructor(e, t) {
                    this._parameters = e, this._specification = t, wt(this, function e(t, n) {
                        const i = "color" === n.type, r = t.stops && "object" == typeof t.stops[0][0],
                            o = r || !(r || void 0 !== t.property), a = t.type || (Li(n) ? "exponential" : "interval");
                        if (i && ((t = wt({}, t)).stops && (t.stops = t.stops.map(e => [e[0], Vt.parse(e[1])])), t.default = Vt.parse(t.default ? t.default : n.default)), t.colorSpace && "rgb" !== t.colorSpace && !Jn[t.colorSpace]) throw new Error("Unknown color space: " + t.colorSpace);
                        let s, l, c;
                        if ("exponential" === a) s = Yi; else if ("interval" === a) s = Ri; else if ("categorical" === a) {
                            s = Pi, l = Object.create(null);
                            for (const e of t.stops) l[e[0]] = e[1];
                            c = typeof t.stops[0][0]
                        } else {
                            if ("identity" !== a) throw new Error(`Unknown function type "${a}"`);
                            s = zi
                        }
                        if (r) {
                            const i = {}, r = [];
                            for (let e = 0; e < t.stops.length; e++) {
                                const n = t.stops[e], o = n[0].zoom;
                                void 0 === i[o] && (i[o] = {
                                    zoom: o,
                                    type: t.type,
                                    property: t.property,
                                    default: t.default,
                                    stops: []
                                }, r.push(o)), i[o].stops.push([n[0].value, n[1]])
                            }
                            const o = [];
                            for (const t of r) o.push([i[t].zoom, e(i[t], n)]);
                            const a = {name: "linear"};
                            return {
                                kind: "composite",
                                interpolationType: a,
                                interpolationFactor: Kn.interpolationFactor.bind(void 0, a),
                                zoomStops: o.map(e => e[0]),
                                evaluate: ({zoom: e}, i) => Yi({stops: o, base: t.base}, n, e).evaluate(e, i)
                            }
                        }
                        if (o) {
                            const e = "exponential" === a ? {
                                name: "exponential",
                                base: void 0 !== t.base ? t.base : 1
                            } : null;
                            return {
                                kind: "camera",
                                interpolationType: e,
                                interpolationFactor: Kn.interpolationFactor.bind(void 0, e),
                                zoomStops: t.stops.map(e => e[0]),
                                evaluate: ({zoom: e}) => s(t, n, e, l, c)
                            }
                        }
                        return {
                            kind: "source", evaluate(e, i) {
                                const r = i && i.properties ? i.properties[t.property] : void 0;
                                return void 0 === r ? Ii(t.default, n.default) : s(t, n, r, l, c)
                            }
                        }
                    }(this._parameters, this._specification))
                }

                static deserialize(e) {
                    return new Ui(e._parameters, e._specification)
                }

                static serialize(e) {
                    return {_parameters: e._parameters, _specification: e._specification}
                }
            }

            function Wi(e) {
                const t = e.key, n = e.value, i = e.valueSpec || {}, r = e.objectElementValidators || {}, o = e.style,
                    a = e.styleSpec;
                let s = [];
                const l = Ei(n);
                if ("object" !== l) return [new xt(t, n, `object expected, ${l} found`)];
                for (const e in n) {
                    const l = e.split(".")[0], c = i[l] || i["*"];
                    let u;
                    if (r[l]) u = r[l]; else if (i[l]) u = vr; else if (r["*"]) u = r["*"]; else {
                        if (!i["*"]) {
                            s.push(new xt(t, n[e], `unknown property "${e}"`));
                            continue
                        }
                        u = vr
                    }
                    s = s.concat(u({
                        key: (t ? t + "." : t) + e,
                        value: n[e],
                        valueSpec: c,
                        style: o,
                        styleSpec: a,
                        object: n,
                        objectKey: e
                    }, n))
                }
                for (const e in i) r[e] || i[e].required && void 0 === i[e].default && void 0 === n[e] && s.push(new xt(t, n, `missing required property "${e}"`));
                return s
            }

            function Vi(e) {
                const t = e.value, n = e.valueSpec, i = e.style, r = e.styleSpec, o = e.key,
                    a = e.arrayElementValidator || vr;
                if ("array" !== Ei(t)) return [new xt(o, t, `array expected, ${Ei(t)} found`)];
                if (n.length && t.length !== n.length) return [new xt(o, t, `array length ${n.length} expected, length ${t.length} found`)];
                if (n["min-length"] && t.length < n["min-length"]) return [new xt(o, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
                let s = {type: n.value, values: n.values, minimum: n.minimum, maximum: n.maximum};
                r.$version < 7 && (s.function = n.function), "object" === Ei(n.value) && (s = n.value);
                let l = [];
                for (let e = 0; e < t.length; e++) l = l.concat(a({
                    array: t,
                    arrayIndex: e,
                    value: t[e],
                    valueSpec: s,
                    style: i,
                    styleSpec: r,
                    key: `${o}[${e}]`
                }));
                return l
            }

            function Gi(e) {
                const t = e.key, n = e.value, i = e.valueSpec;
                let r = Ei(n);
                if ("number" === r && n != n && (r = "NaN"), "number" !== r) return [new xt(t, n, `number expected, ${r} found`)];
                if ("minimum" in i) {
                    let r = i.minimum;
                    if ("array" === Ei(i.minimum) && (r = i.minimum[e.arrayIndex]), n < r) return [new xt(t, n, `${n} is less than the minimum value ${r}`)]
                }
                if ("maximum" in i) {
                    let r = i.maximum;
                    if ("array" === Ei(i.maximum) && (r = i.maximum[e.arrayIndex]), n > r) return [new xt(t, n, `${n} is greater than the maximum value ${r}`)]
                }
                return []
            }

            function qi(e) {
                const t = e.valueSpec, n = Mt(e.value.type);
                let i, r, o, a = {};
                const s = "categorical" !== n && void 0 === e.value.property, l = !s,
                    c = "array" === Ei(e.value.stops) && "array" === Ei(e.value.stops[0]) && "object" === Ei(e.value.stops[0][0]),
                    u = Wi({
                        key: e.key,
                        value: e.value,
                        valueSpec: e.styleSpec.function,
                        style: e.style,
                        styleSpec: e.styleSpec,
                        objectElementValidators: {
                            stops: function (e) {
                                if ("identity" === n) return [new xt(e.key, e.value, 'identity function may not have a "stops" property')];
                                let t = [];
                                const i = e.value;
                                return t = t.concat(Vi({
                                    key: e.key,
                                    value: i,
                                    valueSpec: e.valueSpec,
                                    style: e.style,
                                    styleSpec: e.styleSpec,
                                    arrayElementValidator: d
                                })), "array" === Ei(i) && 0 === i.length && t.push(new xt(e.key, i, "array must have at least one stop")), t
                            }, default: function (e) {
                                return vr({
                                    key: e.key,
                                    value: e.value,
                                    valueSpec: t,
                                    style: e.style,
                                    styleSpec: e.styleSpec
                                })
                            }
                        }
                    });
                return "identity" === n && s && u.push(new xt(e.key, e.value, 'missing required property "property"')), "identity" === n || e.value.stops || u.push(new xt(e.key, e.value, 'missing required property "stops"')), "exponential" === n && e.valueSpec.expression && !Li(e.valueSpec) && u.push(new xt(e.key, e.value, "exponential functions not supported")), e.styleSpec.$version >= 8 && (l && !Si(e.valueSpec) ? u.push(new xt(e.key, e.value, "property functions not supported")) : s && !Di(e.valueSpec) && u.push(new xt(e.key, e.value, "zoom functions not supported"))), "categorical" !== n && !c || void 0 !== e.value.property || u.push(new xt(e.key, e.value, '"property" property is required')), u;

                function d(e) {
                    let n = [];
                    const i = e.value, s = e.key;
                    if ("array" !== Ei(i)) return [new xt(s, i, `array expected, ${Ei(i)} found`)];
                    if (2 !== i.length) return [new xt(s, i, `array length 2 expected, length ${i.length} found`)];
                    if (c) {
                        if ("object" !== Ei(i[0])) return [new xt(s, i, `object expected, ${Ei(i[0])} found`)];
                        if (void 0 === i[0].zoom) return [new xt(s, i, "object stop key must have zoom")];
                        if (void 0 === i[0].value) return [new xt(s, i, "object stop key must have value")];
                        if (o && o > Mt(i[0].zoom)) return [new xt(s, i[0].zoom, "stop zoom values must appear in ascending order")];
                        Mt(i[0].zoom) !== o && (o = Mt(i[0].zoom), r = void 0, a = {}), n = n.concat(Wi({
                            key: s + "[0]",
                            value: i[0],
                            valueSpec: {zoom: {}},
                            style: e.style,
                            styleSpec: e.styleSpec,
                            objectElementValidators: {zoom: Gi, value: h}
                        }))
                    } else n = n.concat(h({
                        key: s + "[0]",
                        value: i[0],
                        valueSpec: {},
                        style: e.style,
                        styleSpec: e.styleSpec
                    }, i));
                    return Fi(Tt(i[1])) ? n.concat([new xt(s + "[1]", i[1], "expressions are not allowed in function stops.")]) : n.concat(vr({
                        key: s + "[1]",
                        value: i[1],
                        valueSpec: t,
                        style: e.style,
                        styleSpec: e.styleSpec
                    }))
                }

                function h(e, o) {
                    const s = Ei(e.value), l = Mt(e.value), c = null !== e.value ? e.value : o;
                    if (i) {
                        if (s !== i) return [new xt(e.key, c, `${s} stop domain type must match previous stop domain type ${i}`)]
                    } else i = s;
                    if ("number" !== s && "string" !== s && "boolean" !== s) return [new xt(e.key, c, "stop domain value must be a number, string, or boolean")];
                    if ("number" !== s && "categorical" !== n) {
                        let i = `number expected, ${s} found`;
                        return Si(t) && void 0 === n && (i += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new xt(e.key, c, i)]
                    }
                    return "categorical" !== n || "number" !== s || isFinite(l) && Math.floor(l) === l ? "categorical" !== n && "number" === s && void 0 !== r && l < r ? [new xt(e.key, c, "stop domain values must appear in ascending order")] : (r = l, "categorical" === n && l in a ? [new xt(e.key, c, "stop domain values must be unique")] : (a[l] = !0, [])) : [new xt(e.key, c, "integer expected, found " + l)]
                }
            }

            function Zi(e) {
                const t = ("property" === e.expressionContext ? Ni : Bi)(Tt(e.value), e.valueSpec);
                if ("error" === t.result) return t.value.map(t => new xt(`${e.key}${t.key}`, e.value, t.message));
                const n = t.value.expression || t.value._styleExpression.expression;
                if ("property" === e.expressionContext && "text-font" === e.propertyKey && !n.outputDefined()) return [new xt(e.key, e.value, `Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)];
                if ("property" === e.expressionContext && "layout" === e.propertyType && !An(n)) return [new xt(e.key, e.value, '"feature-state" data expressions are not supported with layout properties.')];
                if ("filter" === e.expressionContext) return function e(t, n) {
                    const i = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
                    for (const e of n.valueSpec.expression.parameters) i.delete(e);
                    if (0 === i.size) return [];
                    const r = [];
                    return t instanceof dn && i.has(t.name) ? [new xt(n.key, n.value, `["${t.name}"] expression is not supported in a filter for a ${n.object.type} layer with id: ${n.object.id}`)] : (t.eachChild(t => {
                        r.push(...e(t, n))
                    }), r)
                }(n, e);
                if (e.expressionContext && 0 === e.expressionContext.indexOf("cluster")) {
                    if (!In(n, ["zoom", "feature-state"])) return [new xt(e.key, e.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                    if ("cluster-initial" === e.expressionContext && !Cn(n)) return [new xt(e.key, e.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
                }
                return []
            }

            function $i(e) {
                const t = e.key, n = e.value, i = e.valueSpec, r = [];
                return Array.isArray(i.values) ? -1 === i.values.indexOf(Mt(n)) && r.push(new xt(t, n, `expected one of [${i.values.join(", ")}], ${JSON.stringify(n)} found`)) : -1 === Object.keys(i.values).indexOf(Mt(n)) && r.push(new xt(t, n, `expected one of [${Object.keys(i.values).join(", ")}], ${JSON.stringify(n)} found`)), r
            }

            function Xi(e) {
                if (!0 === e || !1 === e) return !0;
                if (!Array.isArray(e) || 0 === e.length) return !1;
                switch (e[0]) {
                    case"has":
                        return e.length >= 2 && "$id" !== e[1] && "$type" !== e[1];
                    case"in":
                        return e.length >= 3 && ("string" != typeof e[1] || Array.isArray(e[2]));
                    case"!in":
                    case"!has":
                    case"none":
                        return !1;
                    case"==":
                    case"!=":
                    case">":
                    case">=":
                    case"<":
                    case"<=":
                        return 3 !== e.length || Array.isArray(e[1]) || Array.isArray(e[2]);
                    case"any":
                    case"all":
                        for (const t of e.slice(1)) if (!Xi(t) && "boolean" != typeof t) return !1;
                        return !0;
                    default:
                        return !0
                }
            }

            function Ji(e, t = "fill") {
                if (null == e) return {filter: () => !0, needGeometry: !1, needFeature: !1};
                Xi(e) || (e = nr(e));
                const n = e;
                let i = !0;
                try {
                    i = function (e) {
                        if (!Ki(e)) return e;
                        let t = Tt(e);
                        return function e(t) {
                            let n = !1;
                            const i = [];
                            if ("case" === t[0]) {
                                for (let e = 1; e < t.length - 1; e += 2) n = n || Ki(t[e]), i.push(t[e + 1]);
                                i.push(t[t.length - 1])
                            } else if ("match" === t[0]) {
                                n = n || Ki(t[1]);
                                for (let e = 2; e < t.length - 1; e += 2) i.push(t[e + 1]);
                                i.push(t[t.length - 1])
                            } else if ("step" === t[0]) {
                                n = n || Ki(t[1]);
                                for (let e = 1; e < t.length - 1; e += 2) i.push(t[e + 1])
                            }
                            n && (t.length = 0, t.push("any", ...i));
                            for (let n = 1; n < t.length; n++) e(t[n])
                        }(t), t = function e(t) {
                            if (!Array.isArray(t)) return t;
                            const n = function (e) {
                                if (Qi.has(e[0])) for (let t = 1; t < e.length; t++) if (Ki(e[t])) return !0;
                                return e
                            }(t);
                            return !0 === n ? n : n.map(t => e(t))
                        }(t), t
                    }(n)
                } catch (e) {
                    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(n, null, 2)}\n        `)
                }
                const r = vt["filter_" + t], o = Bi(i, r);
                let a = null;
                if ("error" === o.result) throw new Error(o.value.map(e => `${e.key}: ${e.message}`).join(", "));
                a = (e, t, n) => o.value.evaluate(e, t, {}, n);
                let s = null, l = null;
                if (i !== n) {
                    const e = Bi(n, r);
                    if ("error" === e.result) throw new Error(e.value.map(e => `${e.key}: ${e.message}`).join(", "));
                    s = (t, n, i, r, o) => e.value.evaluate(t, n, {}, i, void 0, void 0, r, o), l = !Cn(e.value.expression)
                }
                return a = a, {filter: a, dynamicFilter: s || void 0, needGeometry: tr(i), needFeature: !!l}
            }

            function Ki(e) {
                if (!Array.isArray(e)) return !1;
                if ("pitch" === (t = e[0]) || "distance-from-center" === t) return !0;
                var t;
                for (let t = 1; t < e.length; t++) if (Ki(e[t])) return !0;
                return !1
            }

            const Qi = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);

            function er(e, t) {
                return e < t ? -1 : e > t ? 1 : 0
            }

            function tr(e) {
                if (!Array.isArray(e)) return !1;
                if ("within" === e[0]) return !0;
                for (let t = 1; t < e.length; t++) if (tr(e[t])) return !0;
                return !1
            }

            function nr(e) {
                if (!e) return !0;
                const t = e[0];
                return e.length <= 1 ? "any" !== t : "==" === t ? ir(e[1], e[2], "==") : "!=" === t ? ar(ir(e[1], e[2], "==")) : "<" === t || ">" === t || "<=" === t || ">=" === t ? ir(e[1], e[2], t) : "any" === t ? (n = e.slice(1), ["any"].concat(n.map(nr))) : "all" === t ? ["all"].concat(e.slice(1).map(nr)) : "none" === t ? ["all"].concat(e.slice(1).map(nr).map(ar)) : "in" === t ? rr(e[1], e.slice(2)) : "!in" === t ? ar(rr(e[1], e.slice(2))) : "has" === t ? or(e[1]) : "!has" === t ? ar(or(e[1])) : "within" !== t || e;
                var n
            }

            function ir(e, t, n) {
                switch (e) {
                    case"$type":
                        return ["filter-type-" + n, t];
                    case"$id":
                        return ["filter-id-" + n, t];
                    default:
                        return ["filter-" + n, e, t]
                }
            }

            function rr(e, t) {
                if (0 === t.length) return !1;
                switch (e) {
                    case"$type":
                        return ["filter-type-in", ["literal", t]];
                    case"$id":
                        return ["filter-id-in", ["literal", t]];
                    default:
                        return t.length > 200 && !t.some(e => typeof e != typeof t[0]) ? ["filter-in-large", e, ["literal", t.sort(er)]] : ["filter-in-small", e, ["literal", t]]
                }
            }

            function or(e) {
                switch (e) {
                    case"$type":
                        return !0;
                    case"$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", e]
                }
            }

            function ar(e) {
                return ["!", e]
            }

            function sr(e) {
                if (Xi(Tt(e.value))) {
                    const t = Tt(e.layerType);
                    return Zi(wt({}, e, {
                        expressionContext: "filter",
                        valueSpec: e.styleSpec["filter_" + (t || "fill")]
                    }))
                }
                return function e(t) {
                    const n = t.value, i = t.key;
                    if ("array" !== Ei(n)) return [new xt(i, n, `array expected, ${Ei(n)} found`)];
                    const r = t.styleSpec;
                    let o, a = [];
                    if (n.length < 1) return [new xt(i, n, "filter array must have at least 1 element")];
                    switch (a = a.concat($i({
                        key: i + "[0]",
                        value: n[0],
                        valueSpec: r.filter_operator,
                        style: t.style,
                        styleSpec: t.styleSpec
                    })), Mt(n[0])) {
                        case"<":
                        case"<=":
                        case">":
                        case">=":
                            n.length >= 2 && "$type" === Mt(n[1]) && a.push(new xt(i, n, `"$type" cannot be use with operator "${n[0]}"`));
                        case"==":
                        case"!=":
                            3 !== n.length && a.push(new xt(i, n, `filter array for operator "${n[0]}" must have 3 elements`));
                        case"in":
                        case"!in":
                            n.length >= 2 && (o = Ei(n[1]), "string" !== o && a.push(new xt(i + "[1]", n[1], `string expected, ${o} found`)));
                            for (let e = 2; e < n.length; e++) o = Ei(n[e]), "$type" === Mt(n[1]) ? a = a.concat($i({
                                key: `${i}[${e}]`,
                                value: n[e],
                                valueSpec: r.geometry_type,
                                style: t.style,
                                styleSpec: t.styleSpec
                            })) : "string" !== o && "number" !== o && "boolean" !== o && a.push(new xt(`${i}[${e}]`, n[e], `string, number, or boolean expected, ${o} found`));
                            break;
                        case"any":
                        case"all":
                        case"none":
                            for (let r = 1; r < n.length; r++) a = a.concat(e({
                                key: `${i}[${r}]`,
                                value: n[r],
                                style: t.style,
                                styleSpec: t.styleSpec
                            }));
                            break;
                        case"has":
                        case"!has":
                            o = Ei(n[1]), 2 !== n.length ? a.push(new xt(i, n, `filter array for "${n[0]}" operator must have 2 elements`)) : "string" !== o && a.push(new xt(i + "[1]", n[1], `string expected, ${o} found`));
                            break;
                        case"within":
                            o = Ei(n[1]), 2 !== n.length ? a.push(new xt(i, n, `filter array for "${n[0]}" operator must have 2 elements`)) : "object" !== o && a.push(new xt(i + "[1]", n[1], `object expected, ${o} found`))
                    }
                    return a
                }(e)
            }

            function lr(e, t) {
                const n = e.key, i = e.style, r = e.styleSpec, o = e.value, a = e.objectKey,
                    s = r[`${t}_${e.layerType}`];
                if (!s) return [];
                const l = a.match(/^(.*)-transition$/);
                if ("paint" === t && l && s[l[1]] && s[l[1]].transition) return vr({
                    key: n,
                    value: o,
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                });
                const c = e.valueSpec || s[a];
                if (!c) return [new xt(n, o, `unknown property "${a}"`)];
                let u;
                if ("string" === Ei(o) && Si(c) && !c.tokens && (u = /^{([^}]+)}$/.exec(o))) return [new xt(n, o, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u[1])} }\`.`)];
                const d = [];
                return "symbol" === e.layerType && ("text-field" === a && i && !i.glyphs && d.push(new xt(n, o, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Ci(Tt(o)) && "identity" === Mt(o.type) && d.push(new xt(n, o, '"text-font" does not support identity functions'))), d.concat(vr({
                    key: e.key,
                    value: o,
                    valueSpec: c,
                    style: i,
                    styleSpec: r,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: a
                }))
            }

            function cr(e) {
                return lr(e, "paint")
            }

            function ur(e) {
                return lr(e, "layout")
            }

            function dr(e) {
                let t = [];
                const n = e.value, i = e.key, r = e.style, o = e.styleSpec;
                n.type || n.ref || t.push(new xt(i, n, 'either "type" or "ref" is required'));
                let a = Mt(n.type);
                const s = Mt(n.ref);
                if (n.id) {
                    const o = Mt(n.id);
                    for (let a = 0; a < e.arrayIndex; a++) {
                        const e = r.layers[a];
                        Mt(e.id) === o && t.push(new xt(i, n.id, `duplicate layer id "${n.id}", previously used at line ${e.id.__line__}`))
                    }
                }
                if ("ref" in n) {
                    let e;
                    ["type", "source", "source-layer", "filter", "layout"].forEach(e => {
                        e in n && t.push(new xt(i, n[e], `"${e}" is prohibited for ref layers`))
                    }), r.layers.forEach(t => {
                        Mt(t.id) === s && (e = t)
                    }), e ? e.ref ? t.push(new xt(i, n.ref, "ref cannot reference another ref layer")) : a = Mt(e.type) : t.push(new xt(i, n.ref, `ref layer "${s}" not found`))
                } else if ("background" !== a && "sky" !== a) if (n.source) {
                    const e = r.sources && r.sources[n.source], o = e && Mt(e.type);
                    e ? "vector" === o && "raster" === a ? t.push(new xt(i, n.source, `layer "${n.id}" requires a raster source`)) : "raster" === o && "raster" !== a ? t.push(new xt(i, n.source, `layer "${n.id}" requires a vector source`)) : "vector" !== o || n["source-layer"] ? "raster-dem" === o && "hillshade" !== a ? t.push(new xt(i, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !n.paint || !n.paint["line-gradient"] || "geojson" === o && e.lineMetrics || t.push(new xt(i, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new xt(i, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new xt(i, n.source, `source "${n.source}" not found`))
                } else t.push(new xt(i, n, 'missing required property "source"'));
                return t = t.concat(Wi({
                    key: i,
                    value: n,
                    valueSpec: o.layer,
                    style: e.style,
                    styleSpec: e.styleSpec,
                    objectElementValidators: {
                        "*": () => [],
                        type: () => vr({
                            key: i + ".type",
                            value: n.type,
                            valueSpec: o.layer.type,
                            style: e.style,
                            styleSpec: e.styleSpec,
                            object: n,
                            objectKey: "type"
                        }),
                        filter: e => sr(wt({layerType: a}, e)),
                        layout: e => Wi({
                            layer: n,
                            key: e.key,
                            value: e.value,
                            style: e.style,
                            styleSpec: e.styleSpec,
                            objectElementValidators: {"*": e => ur(wt({layerType: a}, e))}
                        }),
                        paint: e => Wi({
                            layer: n,
                            key: e.key,
                            value: e.value,
                            style: e.style,
                            styleSpec: e.styleSpec,
                            objectElementValidators: {"*": e => cr(wt({layerType: a}, e))}
                        })
                    }
                })), t
            }

            function hr(e) {
                const t = e.value, n = e.key, i = Ei(t);
                return "string" !== i ? [new xt(n, t, `string expected, ${i} found`)] : []
            }

            const pr = {
                promoteId: function ({key: e, value: t}) {
                    if ("string" === Ei(t)) return hr({key: e, value: t});
                    {
                        const n = [];
                        for (const i in t) n.push(...hr({key: `${e}.${i}`, value: t[i]}));
                        return n
                    }
                }
            };

            function fr(e) {
                const t = e.value, n = e.key, i = e.styleSpec, r = e.style;
                if (!t.type) return [new xt(n, t, '"type" is required')];
                const o = Mt(t.type);
                let a;
                switch (o) {
                    case"vector":
                    case"raster":
                    case"raster-dem":
                        return a = Wi({
                            key: n,
                            value: t,
                            valueSpec: i["source_" + o.replace("-", "_")],
                            style: e.style,
                            styleSpec: i,
                            objectElementValidators: pr
                        }), a;
                    case"geojson":
                        if (a = Wi({
                            key: n,
                            value: t,
                            valueSpec: i.source_geojson,
                            style: r,
                            styleSpec: i,
                            objectElementValidators: pr
                        }), t.cluster) for (const e in t.clusterProperties) {
                            const [i, r] = t.clusterProperties[e],
                                o = "string" == typeof i ? [i, ["accumulated"], ["get", e]] : i;
                            a.push(...Zi({
                                key: `${n}.${e}.map`,
                                value: r,
                                expressionContext: "cluster-map"
                            })), a.push(...Zi({key: `${n}.${e}.reduce`, value: o, expressionContext: "cluster-reduce"}))
                        }
                        return a;
                    case"video":
                        return Wi({key: n, value: t, valueSpec: i.source_video, style: r, styleSpec: i});
                    case"image":
                        return Wi({key: n, value: t, valueSpec: i.source_image, style: r, styleSpec: i});
                    case"canvas":
                        return [new xt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
                    default:
                        return $i({
                            key: n + ".type",
                            value: t.type,
                            valueSpec: {values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]},
                            style: r,
                            styleSpec: i
                        })
                }
            }

            function mr(e) {
                const t = e.value, n = e.styleSpec, i = n.light, r = e.style;
                let o = [];
                const a = Ei(t);
                if (void 0 === t) return o;
                if ("object" !== a) return o = o.concat([new xt("light", t, `object expected, ${a} found`)]), o;
                for (const e in t) {
                    const a = e.match(/^(.*)-transition$/);
                    o = o.concat(a && i[a[1]] && i[a[1]].transition ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: n.transition,
                        style: r,
                        styleSpec: n
                    }) : i[e] ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: i[e],
                        style: r,
                        styleSpec: n
                    }) : [new xt(e, t[e], `unknown property "${e}"`)])
                }
                return o
            }

            function _r(e) {
                const t = e.value, n = e.key, i = e.style, r = e.styleSpec, o = r.terrain;
                let a = [];
                const s = Ei(t);
                if (void 0 === t) return a;
                if ("object" !== s) return a = a.concat([new xt("terrain", t, `object expected, ${s} found`)]), a;
                for (const e in t) {
                    const n = e.match(/^(.*)-transition$/);
                    a = a.concat(n && o[n[1]] && o[n[1]].transition ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: r.transition,
                        style: i,
                        styleSpec: r
                    }) : o[e] ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: o[e],
                        style: i,
                        styleSpec: r
                    }) : [new xt(e, t[e], `unknown property "${e}"`)])
                }
                if (t.source) {
                    const e = i.sources && i.sources[t.source], r = e && Mt(e.type);
                    e ? "raster-dem" !== r && a.push(new xt(n, t.source, `terrain cannot be used with a source of type ${r}, it only be used with a "raster-dem" source type`)) : a.push(new xt(n, t.source, `source "${t.source}" not found`))
                } else a.push(new xt(n, t, 'terrain is missing required property "source"'));
                return a
            }

            function gr(e) {
                const t = e.value, n = e.style, i = e.styleSpec, r = i.fog;
                let o = [];
                const a = Ei(t);
                if (void 0 === t) return o;
                if ("object" !== a) return o = o.concat([new xt("fog", t, `object expected, ${a} found`)]), o;
                for (const e in t) {
                    const a = e.match(/^(.*)-transition$/);
                    o = o.concat(a && r[a[1]] && r[a[1]].transition ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: i.transition,
                        style: n,
                        styleSpec: i
                    }) : r[e] ? vr({
                        key: e,
                        value: t[e],
                        valueSpec: r[e],
                        style: n,
                        styleSpec: i
                    }) : [new xt(e, t[e], `unknown property "${e}"`)])
                }
                return o
            }

            const yr = {
                "*": () => [],
                array: Vi,
                boolean: function (e) {
                    const t = e.value, n = e.key, i = Ei(t);
                    return "boolean" !== i ? [new xt(n, t, `boolean expected, ${i} found`)] : []
                },
                number: Gi,
                color: function (e) {
                    const t = e.key, n = e.value, i = Ei(n);
                    return "string" !== i ? [new xt(t, n, `color expected, ${i} found`)] : null === Wt.parseCSSColor(n) ? [new xt(t, n, `color expected, "${n}" found`)] : []
                },
                constants: bt,
                enum: $i,
                filter: sr,
                function: qi,
                layer: dr,
                object: Wi,
                source: fr,
                light: mr,
                terrain: _r,
                fog: gr,
                string: hr,
                formatted: function (e) {
                    return 0 === hr(e).length ? [] : Zi(e)
                },
                resolvedImage: function (e) {
                    return 0 === hr(e).length ? [] : Zi(e)
                },
                projection: function (e) {
                    const t = e.value, n = e.styleSpec, i = n.projection, r = e.style;
                    let o = [];
                    const a = Ei(t);
                    if ("object" === a) for (const e in t) o = o.concat(vr({
                        key: e,
                        value: t[e],
                        valueSpec: i[e],
                        style: r,
                        styleSpec: n
                    })); else "string" !== a && (o = o.concat([new xt("projection", t, `object or string expected, ${a} found`)]));
                    return o
                }
            };

            function vr(e) {
                const t = e.value, n = e.valueSpec, i = e.styleSpec;
                return n.expression && Ci(Mt(t)) ? qi(e) : n.expression && Fi(Tt(t)) ? Zi(e) : n.type && yr[n.type] ? yr[n.type](e) : Wi(wt({}, e, {valueSpec: n.type ? i[n.type] : n}))
            }

            function xr(e) {
                const t = e.value, n = e.key, i = hr(e);
                return i.length || (-1 === t.indexOf("{fontstack}") && i.push(new xt(n, t, '"glyphs" url must include a "{fontstack}" token')), -1 === t.indexOf("{range}") && i.push(new xt(n, t, '"glyphs" url must include a "{range}" token'))), i
            }

            function br(e, t = vt) {
                let n = [];
                return n = n.concat(vr({
                    key: "",
                    value: e,
                    valueSpec: t.$root,
                    styleSpec: t,
                    style: e,
                    objectElementValidators: {glyphs: xr, "*": () => []}
                })), e.constants && (n = n.concat(bt({
                    key: "constants",
                    value: e.constants,
                    style: e,
                    styleSpec: t
                }))), wr(n)
            }

            function wr(e) {
                return [].concat(e).sort((e, t) => e.line - t.line)
            }

            function Mr(e) {
                return function (...t) {
                    return wr(e.apply(this, t))
                }
            }

            br.source = Mr(fr), br.light = Mr(mr), br.terrain = Mr(_r), br.fog = Mr(gr), br.layer = Mr(dr), br.filter = Mr(sr), br.paintProperty = Mr(cr), br.layoutProperty = Mr(ur);
            const Tr = br, kr = Tr.light, Sr = Tr.fog, Dr = Tr.paintProperty, Lr = Tr.layoutProperty;

            function Er(e, t) {
                let n = !1;
                if (t && t.length) for (const i of t) e.fire(new gt(new Error(i.message))), n = !0;
                return n
            }

            var Cr = Ar;

            function Ar(e, t, n) {
                var i = this.cells = [];
                if (e instanceof ArrayBuffer) {
                    this.arrayBuffer = e;
                    var r = new Int32Array(this.arrayBuffer);
                    e = r[0], this.d = (t = r[1]) + 2 * (n = r[2]);
                    for (var o = 0; o < this.d * this.d; o++) {
                        var a = r[3 + o], s = r[3 + o + 1];
                        i.push(a === s ? null : r.subarray(a, s))
                    }
                    var l = r[3 + i.length + 1];
                    this.keys = r.subarray(r[3 + i.length], l), this.bboxes = r.subarray(l), this.insert = this._insertReadonly
                } else {
                    this.d = t + 2 * n;
                    for (var c = 0; c < this.d * this.d; c++) i.push([]);
                    this.keys = [], this.bboxes = []
                }
                this.n = t, this.extent = e, this.padding = n, this.scale = t / e, this.uid = 0;
                var u = n / t * e;
                this.min = -u, this.max = e + u
            }

            Ar.prototype.insert = function (e, t, n, i, r) {
                this._forEachCell(t, n, i, r, this._insertCell, this.uid++), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(r)
            }, Ar.prototype._insertReadonly = function () {
                throw"Cannot insert into a GridIndex created from an ArrayBuffer."
            }, Ar.prototype._insertCell = function (e, t, n, i, r, o) {
                this.cells[r].push(o)
            }, Ar.prototype.query = function (e, t, n, i, r) {
                var o = this.min, a = this.max;
                if (e <= o && t <= o && a <= n && a <= i && !r) return Array.prototype.slice.call(this.keys);
                var s = [];
                return this._forEachCell(e, t, n, i, this._queryCell, s, {}, r), s
            }, Ar.prototype._queryCell = function (e, t, n, i, r, o, a, s) {
                var l = this.cells[r];
                if (null !== l) for (var c = this.keys, u = this.bboxes, d = 0; d < l.length; d++) {
                    var h = l[d];
                    if (void 0 === a[h]) {
                        var p = 4 * h;
                        (s ? s(u[p + 0], u[p + 1], u[p + 2], u[p + 3]) : e <= u[p + 2] && t <= u[p + 3] && n >= u[p + 0] && i >= u[p + 1]) ? (a[h] = !0, o.push(c[h])) : a[h] = !1
                    }
                }
            }, Ar.prototype._forEachCell = function (e, t, n, i, r, o, a, s) {
                for (var l = this._convertToCellCoord(e), c = this._convertToCellCoord(t), u = this._convertToCellCoord(n), d = this._convertToCellCoord(i), h = l; h <= u; h++) for (var p = c; p <= d; p++) {
                    var f = this.d * p + h;
                    if ((!s || s(this._convertFromCellCoord(h), this._convertFromCellCoord(p), this._convertFromCellCoord(h + 1), this._convertFromCellCoord(p + 1))) && r.call(this, e, t, n, i, f, o, a, s)) return
                }
            }, Ar.prototype._convertFromCellCoord = function (e) {
                return (e - this.padding) / this.scale
            }, Ar.prototype._convertToCellCoord = function (e) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding))
            }, Ar.prototype.toArrayBuffer = function () {
                if (this.arrayBuffer) return this.arrayBuffer;
                for (var e = this.cells, t = 3 + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++) n += this.cells[i].length;
                var r = new Int32Array(t + n + this.keys.length + this.bboxes.length);
                r[0] = this.extent, r[1] = this.n, r[2] = this.padding;
                for (var o = t, a = 0; a < e.length; a++) {
                    var s = e[a];
                    r[3 + a] = o, r.set(s, o), o += s.length
                }
                return r[3 + e.length] = o, r.set(this.keys, o), r[3 + e.length + 1] = o += this.keys.length, r.set(this.bboxes, o), o += this.bboxes.length, r.buffer
            };
            const {ImageData: Ir, ImageBitmap: Pr} = a, Rr = {};

            function Yr(e, t, n = {}) {
                Object.defineProperty(t, "_classRegistryKey", {value: e, writeable: !1}), Rr[e] = {
                    klass: t,
                    omit: n.omit || [],
                    shallow: n.shallow || []
                }
            }

            Yr("Object", Object), Cr.serialize = function (e, t) {
                const n = e.toArrayBuffer();
                return t && t.push(n), {buffer: n}
            }, Cr.deserialize = function (e) {
                return new Cr(e.buffer)
            }, Yr("Grid", Cr), Yr("Color", Vt), Yr("Error", Error), Yr("ResolvedImage", $t), Yr("StylePropertyFunction", Ui), Yr("StyleExpression", Oi, {omit: ["_evaluator"]}), Yr("ZoomDependentExpression", Hi), Yr("ZoomConstantExpression", ji), Yr("CompoundExpression", dn, {omit: ["_evaluate"]});
            for (const e in vi) vi[e]._classRegistryKey || Yr("Expression_" + e, vi[e]);

            function zr(e) {
                return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name)
            }

            function Or(e) {
                return Pr && e instanceof Pr
            }

            function Fr(e, t) {
                if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp) return e;
                if (zr(e) || Or(e)) return t && t.push(e), e;
                if (ArrayBuffer.isView(e)) {
                    const n = e;
                    return t && t.push(n.buffer), n
                }
                if (e instanceof Ir) return t && t.push(e.data.buffer), e;
                if (Array.isArray(e)) {
                    const n = [];
                    for (const i of e) n.push(Fr(i, t));
                    return n
                }
                if ("object" == typeof e) {
                    const n = e.constructor, i = n._classRegistryKey;
                    if (!i) throw new Error("can't serialize object of unregistered class");
                    const r = n.serialize ? n.serialize(e, t) : {};
                    if (!n.serialize) {
                        for (const n in e) {
                            if (!e.hasOwnProperty(n)) continue;
                            if (Rr[i].omit.indexOf(n) >= 0) continue;
                            const o = e[n];
                            r[n] = Rr[i].shallow.indexOf(n) >= 0 ? o : Fr(o, t)
                        }
                        e instanceof Error && (r.message = e.message)
                    }
                    if (r.$name) throw new Error("$name property is reserved for worker serialization logic.");
                    return "Object" !== i && (r.$name = i), r
                }
                throw new Error("can't serialize object of type " + typeof e)
            }

            function Br(e) {
                if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || zr(e) || Or(e) || ArrayBuffer.isView(e) || e instanceof Ir) return e;
                if (Array.isArray(e)) return e.map(Br);
                if ("object" == typeof e) {
                    const t = e.$name || "Object", {klass: n} = Rr[t];
                    if (!n) throw new Error("can't deserialize unregistered class " + t);
                    if (n.deserialize) return n.deserialize(e);
                    const i = Object.create(n.prototype);
                    for (const n of Object.keys(e)) {
                        if ("$name" === n) continue;
                        const r = e[n];
                        i[n] = Rr[t].shallow.indexOf(n) >= 0 ? r : Br(r)
                    }
                    return i
                }
                throw new Error("can't deserialize object of type " + typeof e)
            }

            class jr {
                constructor() {
                    this.first = !0
                }

                update(e, t) {
                    const n = Math.floor(e);
                    return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = t), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = n, !0))
                }
            }

            const Hr = e => e >= 1536 && e <= 1791, Nr = e => e >= 1872 && e <= 1919, Ur = e => e >= 2208 && e <= 2303,
                Wr = e => e >= 11904 && e <= 12031, Vr = e => e >= 12032 && e <= 12255,
                Gr = e => e >= 12272 && e <= 12287, qr = e => e >= 12288 && e <= 12351,
                Zr = e => e >= 12352 && e <= 12447, $r = e => e >= 12448 && e <= 12543,
                Xr = e => e >= 12544 && e <= 12591, Jr = e => e >= 12704 && e <= 12735,
                Kr = e => e >= 12736 && e <= 12783, Qr = e => e >= 12784 && e <= 12799,
                eo = e => e >= 12800 && e <= 13055, to = e => e >= 13056 && e <= 13311,
                no = e => e >= 13312 && e <= 19903, io = e => e >= 19968 && e <= 40959,
                ro = e => e >= 40960 && e <= 42127, oo = e => e >= 42128 && e <= 42191,
                ao = e => e >= 44032 && e <= 55215, so = e => e >= 63744 && e <= 64255,
                lo = e => e >= 64336 && e <= 65023, co = e => e >= 65040 && e <= 65055,
                uo = e => e >= 65072 && e <= 65103, ho = e => e >= 65104 && e <= 65135,
                po = e => e >= 65136 && e <= 65279, fo = e => e >= 65280 && e <= 65519;

            function mo(e) {
                for (const t of e) if (yo(t.charCodeAt(0))) return !0;
                return !1
            }

            function _o(e) {
                for (const t of e) if (!go(t.charCodeAt(0))) return !1;
                return !0
            }

            function go(e) {
                return !(Hr(e) || Nr(e) || Ur(e) || lo(e) || po(e))
            }

            function yo(e) {
                return !(746 !== e && 747 !== e && (e < 4352 || !(Jr(e) || Xr(e) || uo(e) && !(e >= 65097 && e <= 65103) || so(e) || to(e) || Wr(e) || Kr(e) || !(!qr(e) || e >= 12296 && e <= 12305 || e >= 12308 && e <= 12319 || 12336 === e) || no(e) || io(e) || eo(e) || (e => e >= 12592 && e <= 12687)(e) || (e => e >= 43360 && e <= 43391)(e) || (e => e >= 55216 && e <= 55295)(e) || (e => e >= 4352 && e <= 4607)(e) || ao(e) || Zr(e) || Gr(e) || (e => e >= 12688 && e <= 12703)(e) || Vr(e) || Qr(e) || $r(e) && 12540 !== e || !(!fo(e) || 65288 === e || 65289 === e || 65293 === e || e >= 65306 && e <= 65310 || 65339 === e || 65341 === e || 65343 === e || e >= 65371 && e <= 65503 || 65507 === e || e >= 65512 && e <= 65519) || !(!ho(e) || e >= 65112 && e <= 65118 || e >= 65123 && e <= 65126) || (e => e >= 5120 && e <= 5759)(e) || (e => e >= 6320 && e <= 6399)(e) || co(e) || (e => e >= 19904 && e <= 19967)(e) || ro(e) || oo(e))))
            }

            function vo(e) {
                return !(yo(e) || function (e) {
                    return !!((e => e >= 128 && e <= 255)(e) && (167 === e || 169 === e || 174 === e || 177 === e || 188 === e || 189 === e || 190 === e || 215 === e || 247 === e) || (e => e >= 8192 && e <= 8303)(e) && (8214 === e || 8224 === e || 8225 === e || 8240 === e || 8241 === e || 8251 === e || 8252 === e || 8258 === e || 8263 === e || 8264 === e || 8265 === e || 8273 === e) || (e => e >= 8448 && e <= 8527)(e) || (e => e >= 8528 && e <= 8591)(e) || (e => e >= 8960 && e <= 9215)(e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || 9003 === e || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || 9167 === e || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || (e => e >= 9216 && e <= 9279)(e) && 9251 !== e || (e => e >= 9280 && e <= 9311)(e) || (e => e >= 9312 && e <= 9471)(e) || (e => e >= 9632 && e <= 9727)(e) || (e => e >= 9728 && e <= 9983)(e) && !(e >= 9754 && e <= 9759) || (e => e >= 11008 && e <= 11263)(e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || qr(e) || $r(e) || (e => e >= 57344 && e <= 63743)(e) || uo(e) || ho(e) || fo(e) || 8734 === e || 8756 === e || 8757 === e || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || 65532 === e || 65533 === e)
                }(e))
            }

            function xo(e) {
                return e >= 1424 && e <= 2303 || lo(e) || po(e)
            }

            function bo(e, t) {
                return !(!t && xo(e) || e >= 2304 && e <= 3583 || e >= 3840 && e <= 4255 || (e => e >= 6016 && e <= 6143)(e))
            }

            function wo(e) {
                for (const t of e) if (xo(t.charCodeAt(0))) return !0;
                return !1
            }

            const Mo = "deferred", To = "loading", ko = "loaded";
            let So = null, Do = "unavailable", Lo = null;
            const Eo = function (e) {
                e && "string" == typeof e && e.indexOf("NetworkError") > -1 && (Do = "error"), So && So(e)
            };

            function Co() {
                Ao.fire(new _t("pluginStateChange", {pluginStatus: Do, pluginURL: Lo}))
            }

            const Ao = new yt, Io = function () {
                return Do
            }, Po = function () {
                if (Do !== Mo || !Lo) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                Do = To, Co(), Lo && at({url: Lo}, e => {
                    e ? Eo(e) : (Do = ko, Co())
                })
            }, Ro = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => Do === ko || null != Ro.applyArabicShaping,
                isLoading: () => Do === To,
                setState(e) {
                    Do = e.pluginStatus, Lo = e.pluginURL
                },
                isParsed: () => null != Ro.applyArabicShaping && null != Ro.processBidirectionalText && null != Ro.processStyledBidirectionalText,
                getPluginURL: () => Lo
            };

            class Yo {
                constructor(e, t) {
                    this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.zoomHistory = t.zoomHistory, this.transition = t.transition, this.pitch = t.pitch) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new jr, this.transition = {}, this.pitch = 0)
                }

                isSupportedScript(e) {
                    return function (e, t) {
                        for (const n of e) if (!bo(n.charCodeAt(0), t)) return !1;
                        return !0
                    }(e, Ro.isLoaded())
                }

                crossFadingFactor() {
                    return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                }

                getCrossfadeParameters() {
                    const e = this.zoom, t = e - Math.floor(e), n = this.crossFadingFactor();
                    return e > this.zoomHistory.lastIntegerZoom ? {
                        fromScale: 2,
                        toScale: 1,
                        t: t + (1 - t) * n
                    } : {fromScale: .5, toScale: 1, t: 1 - (1 - n) * t}
                }
            }

            class zo {
                constructor(e, t) {
                    this.property = e, this.value = t, this.expression = function (e, t) {
                        if (Ci(e)) return new Ui(e, t);
                        if (Fi(e)) {
                            const n = Ni(e, t);
                            if ("error" === n.result) throw new Error(n.value.map(e => `${e.key}: ${e.message}`).join(", "));
                            return n.value
                        }
                        {
                            let n = e;
                            return "string" == typeof e && "color" === t.type && (n = Vt.parse(e)), {
                                kind: "constant",
                                evaluate: () => n
                            }
                        }
                    }(void 0 === t ? e.specification.default : t, e.specification)
                }

                isDataDriven() {
                    return "source" === this.expression.kind || "composite" === this.expression.kind
                }

                possiblyEvaluate(e, t, n) {
                    return this.property.possiblyEvaluate(this, e, t, n)
                }
            }

            class Oo {
                constructor(e) {
                    this.property = e, this.value = new zo(e, void 0)
                }

                transitioned(e, t) {
                    return new Bo(this.property, this.value, t, ee({}, e.transition, this.transition), e.now)
                }

                untransitioned() {
                    return new Bo(this.property, this.value, null, {}, 0)
                }
            }

            class Fo {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues)
                }

                getValue(e) {
                    return ue(this._values[e].value.value)
                }

                setValue(e, t) {
                    this._values.hasOwnProperty(e) || (this._values[e] = new Oo(this._values[e].property)), this._values[e].value = new zo(this._values[e].property, null === t ? void 0 : ue(t))
                }

                getTransition(e) {
                    return ue(this._values[e].transition)
                }

                setTransition(e, t) {
                    this._values.hasOwnProperty(e) || (this._values[e] = new Oo(this._values[e].property)), this._values[e].transition = ue(t) || void 0
                }

                serialize() {
                    const e = {};
                    for (const t of Object.keys(this._values)) {
                        const n = this.getValue(t);
                        void 0 !== n && (e[t] = n);
                        const i = this.getTransition(t);
                        void 0 !== i && (e[t + "-transition"] = i)
                    }
                    return e
                }

                transitioned(e, t) {
                    const n = new jo(this._properties);
                    for (const i of Object.keys(this._values)) n._values[i] = this._values[i].transitioned(e, t._values[i]);
                    return n
                }

                untransitioned() {
                    const e = new jo(this._properties);
                    for (const t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
                    return e
                }
            }

            class Bo {
                constructor(e, t, n, i, r) {
                    const o = i.delay || 0, a = i.duration || 0;
                    r = r || 0, this.property = e, this.value = t, this.begin = r + o, this.end = this.begin + a, e.specification.transition && (i.delay || i.duration) && (this.prior = n)
                }

                possiblyEvaluate(e, t, n) {
                    const i = e.now || 0, r = this.value.possiblyEvaluate(e, t, n), o = this.prior;
                    if (o) {
                        if (i > this.end) return this.prior = null, r;
                        if (this.value.isDataDriven()) return this.prior = null, r;
                        if (i < this.begin) return o.possiblyEvaluate(e, t, n);
                        {
                            const a = (i - this.begin) / (this.end - this.begin);
                            return this.property.interpolate(o.possiblyEvaluate(e, t, n), r, G(a))
                        }
                    }
                    return r
                }
            }

            class jo {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues)
                }

                possiblyEvaluate(e, t, n) {
                    const i = new Uo(this._properties);
                    for (const r of Object.keys(this._values)) i._values[r] = this._values[r].possiblyEvaluate(e, t, n);
                    return i
                }

                hasTransition() {
                    for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
                    return !1
                }
            }

            class Ho {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultPropertyValues)
                }

                getValue(e) {
                    return ue(this._values[e].value)
                }

                setValue(e, t) {
                    this._values[e] = new zo(this._values[e].property, null === t ? void 0 : ue(t))
                }

                serialize() {
                    const e = {};
                    for (const t of Object.keys(this._values)) {
                        const n = this.getValue(t);
                        void 0 !== n && (e[t] = n)
                    }
                    return e
                }

                possiblyEvaluate(e, t, n) {
                    const i = new Uo(this._properties);
                    for (const r of Object.keys(this._values)) i._values[r] = this._values[r].possiblyEvaluate(e, t, n);
                    return i
                }
            }

            class No {
                constructor(e, t, n) {
                    this.property = e, this.value = t, this.parameters = n
                }

                isConstant() {
                    return "constant" === this.value.kind
                }

                constantOr(e) {
                    return "constant" === this.value.kind ? this.value.value : e
                }

                evaluate(e, t, n, i) {
                    return this.property.evaluate(this.value, this.parameters, e, t, n, i)
                }
            }

            class Uo {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues)
                }

                get(e) {
                    return this._values[e]
                }
            }

            class Wo {
                constructor(e) {
                    this.specification = e
                }

                possiblyEvaluate(e, t) {
                    return e.expression.evaluate(t)
                }

                interpolate(e, t, n) {
                    const i = Fn[this.specification.type];
                    return i ? i(e, t, n) : e
                }
            }

            class Vo {
                constructor(e, t) {
                    this.specification = e, this.overrides = t
                }

                possiblyEvaluate(e, t, n, i) {
                    return new No(this, "constant" === e.expression.kind || "camera" === e.expression.kind ? {
                        kind: "constant",
                        value: e.expression.evaluate(t, null, {}, n, i)
                    } : e.expression, t)
                }

                interpolate(e, t, n) {
                    if ("constant" !== e.value.kind || "constant" !== t.value.kind) return e;
                    if (void 0 === e.value.value || void 0 === t.value.value) return new No(this, {
                        kind: "constant",
                        value: void 0
                    }, e.parameters);
                    const i = Fn[this.specification.type];
                    return i ? new No(this, {
                        kind: "constant",
                        value: i(e.value.value, t.value.value, n)
                    }, e.parameters) : e
                }

                evaluate(e, t, n, i, r, o) {
                    return "constant" === e.kind ? e.value : e.evaluate(t, n, i, r, o)
                }
            }

            class Go extends Vo {
                possiblyEvaluate(e, t, n, i) {
                    if (void 0 === e.value) return new No(this, {kind: "constant", value: void 0}, t);
                    if ("constant" === e.expression.kind) {
                        const r = e.expression.evaluate(t, null, {}, n, i),
                            o = "resolvedImage" === e.property.specification.type && "string" != typeof r ? r.name : r,
                            a = this._calculate(o, o, o, t);
                        return new No(this, {kind: "constant", value: a}, t)
                    }
                    if ("camera" === e.expression.kind) {
                        const n = this._calculate(e.expression.evaluate({zoom: t.zoom - 1}), e.expression.evaluate({zoom: t.zoom}), e.expression.evaluate({zoom: t.zoom + 1}), t);
                        return new No(this, {kind: "constant", value: n}, t)
                    }
                    return new No(this, e.expression, t)
                }

                evaluate(e, t, n, i, r, o) {
                    if ("source" === e.kind) {
                        const a = e.evaluate(t, n, i, r, o);
                        return this._calculate(a, a, a, t)
                    }
                    return "composite" === e.kind ? this._calculate(e.evaluate({zoom: Math.floor(t.zoom) - 1}, n, i), e.evaluate({zoom: Math.floor(t.zoom)}, n, i), e.evaluate({zoom: Math.floor(t.zoom) + 1}, n, i), t) : e.value
                }

                _calculate(e, t, n, i) {
                    return i.zoom > i.zoomHistory.lastIntegerZoom ? {from: e, to: t, other: n} : {
                        from: n,
                        to: t,
                        other: e
                    }
                }

                interpolate(e) {
                    return e
                }
            }

            class qo {
                constructor(e) {
                    this.specification = e
                }

                possiblyEvaluate(e, t, n, i) {
                    if (void 0 !== e.value) {
                        if ("constant" === e.expression.kind) {
                            const r = e.expression.evaluate(t, null, {}, n, i);
                            return this._calculate(r, r, r, t)
                        }
                        return this._calculate(e.expression.evaluate(new Yo(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new Yo(Math.floor(t.zoom), t)), e.expression.evaluate(new Yo(Math.floor(t.zoom + 1), t)), t)
                    }
                }

                _calculate(e, t, n, i) {
                    return i.zoom > i.zoomHistory.lastIntegerZoom ? {from: e, to: t} : {from: n, to: t}
                }

                interpolate(e) {
                    return e
                }
            }

            class Zo {
                constructor(e) {
                    this.specification = e
                }

                possiblyEvaluate(e, t, n, i) {
                    return !!e.expression.evaluate(t, null, {}, n, i)
                }

                interpolate() {
                    return !1
                }
            }

            class $o {
                constructor(e) {
                    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                    for (const t in e) {
                        const n = e[t];
                        n.specification.overridable && this.overridableProperties.push(t);
                        const i = this.defaultPropertyValues[t] = new zo(n, void 0),
                            r = this.defaultTransitionablePropertyValues[t] = new Oo(n);
                        this.defaultTransitioningPropertyValues[t] = r.untransitioned(), this.defaultPossiblyEvaluatedValues[t] = i.possiblyEvaluate({})
                    }
                }
            }

            function Xo(e, t) {
                return 256 * (e = $(Math.floor(e), 0, 255)) + $(Math.floor(t), 0, 255)
            }

            Yr("DataDrivenProperty", Vo), Yr("DataConstantProperty", Wo), Yr("CrossFadedDataDrivenProperty", Go), Yr("CrossFadedProperty", qo), Yr("ColorRampProperty", Zo);
            const Jo = {
                Int8: Int8Array,
                Uint8: Uint8Array,
                Int16: Int16Array,
                Uint16: Uint16Array,
                Int32: Int32Array,
                Uint32: Uint32Array,
                Float32: Float32Array
            };

            class Ko {
                constructor(e, t) {
                    this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
                }
            }

            class Qo {
                constructor() {
                    this.isTransferred = !1, this.capacity = -1, this.resize(0)
                }

                static serialize(e, t) {
                    return e._trim(), t && (e.isTransferred = !0, t.push(e.arrayBuffer)), {
                        length: e.length,
                        arrayBuffer: e.arrayBuffer
                    }
                }

                static deserialize(e) {
                    const t = Object.create(this.prototype);
                    return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t
                }

                _trim() {
                    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
                }

                clear() {
                    this.length = 0
                }

                resize(e) {
                    this.reserve(e), this.length = e
                }

                reserve(e) {
                    if (e > this.capacity) {
                        this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                        const t = this.uint8;
                        this._refreshViews(), t && this.uint8.set(t)
                    }
                }

                _refreshViews() {
                    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                }
            }

            function ea(e, t = 1) {
                let n = 0, i = 0;
                return {
                    members: e.map(e => {
                        const r = Jo[e.type].BYTES_PER_ELEMENT, o = n = ta(n, Math.max(t, r)), a = e.components || 1;
                        return i = Math.max(i, r), n += r * a, {name: e.name, type: e.type, components: a, offset: o}
                    }), size: ta(n, Math.max(i, t)), alignment: t
                }
            }

            function ta(e, t) {
                return Math.ceil(e / t) * t
            }

            class na extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, t) {
                    const n = this.length;
                    return this.resize(n + 1), this.emplace(n, e, t)
                }

                emplace(e, t, n) {
                    const i = 2 * e;
                    return this.int16[i + 0] = t, this.int16[i + 1] = n, e
                }
            }

            na.prototype.bytesPerElement = 4, Yr("StructArrayLayout2i4", na);

            class ia extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i) {
                    const r = this.length;
                    return this.resize(r + 1), this.emplace(r, e, t, n, i)
                }

                emplace(e, t, n, i, r) {
                    const o = 4 * e;
                    return this.int16[o + 0] = t, this.int16[o + 1] = n, this.int16[o + 2] = i, this.int16[o + 3] = r, e
                }
            }

            ia.prototype.bytesPerElement = 8, Yr("StructArrayLayout4i8", ia);

            class ra extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a) {
                    const s = this.length;
                    return this.resize(s + 1), this.emplace(s, e, t, n, i, r, o, a)
                }

                emplace(e, t, n, i, r, o, a, s) {
                    const l = 6 * e, c = 12 * e, u = 3 * e;
                    return this.int16[l + 0] = t, this.int16[l + 1] = n, this.uint8[c + 4] = i, this.uint8[c + 5] = r, this.uint8[c + 6] = o, this.uint8[c + 7] = a, this.float32[u + 2] = s, e
                }
            }

            ra.prototype.bytesPerElement = 12, Yr("StructArrayLayout2i4ub1f12", ra);

            class oa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e, t, n)
                }

                emplace(e, t, n, i) {
                    const r = 3 * e;
                    return this.float32[r + 0] = t, this.float32[r + 1] = n, this.float32[r + 2] = i, e
                }
            }

            oa.prototype.bytesPerElement = 12, Yr("StructArrayLayout3f12", oa);

            class aa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s, l, c) {
                    const u = this.length;
                    return this.resize(u + 1), this.emplace(u, e, t, n, i, r, o, a, s, l, c)
                }

                emplace(e, t, n, i, r, o, a, s, l, c, u) {
                    const d = 10 * e;
                    return this.uint16[d + 0] = t, this.uint16[d + 1] = n, this.uint16[d + 2] = i, this.uint16[d + 3] = r, this.uint16[d + 4] = o, this.uint16[d + 5] = a, this.uint16[d + 6] = s, this.uint16[d + 7] = l, this.uint16[d + 8] = c, this.uint16[d + 9] = u, e
                }
            }

            aa.prototype.bytesPerElement = 20, Yr("StructArrayLayout10ui20", aa);

            class sa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s) {
                    const l = this.length;
                    return this.resize(l + 1), this.emplace(l, e, t, n, i, r, o, a, s)
                }

                emplace(e, t, n, i, r, o, a, s, l) {
                    const c = 8 * e;
                    return this.uint16[c + 0] = t, this.uint16[c + 1] = n, this.uint16[c + 2] = i, this.uint16[c + 3] = r, this.uint16[c + 4] = o, this.uint16[c + 5] = a, this.uint16[c + 6] = s, this.uint16[c + 7] = l, e
                }
            }

            sa.prototype.bytesPerElement = 16, Yr("StructArrayLayout8ui16", sa);

            class la extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m) {
                    const _ = this.length;
                    return this.resize(_ + 1), this.emplace(_, e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m)
                }

                emplace(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _) {
                    const g = 16 * e;
                    return this.int16[g + 0] = t, this.int16[g + 1] = n, this.int16[g + 2] = i, this.int16[g + 3] = r, this.uint16[g + 4] = o, this.uint16[g + 5] = a, this.uint16[g + 6] = s, this.uint16[g + 7] = l, this.int16[g + 8] = c, this.int16[g + 9] = u, this.int16[g + 10] = d, this.int16[g + 11] = h, this.int16[g + 12] = p, this.int16[g + 13] = f, this.int16[g + 14] = m, this.int16[g + 15] = _, e
                }
            }

            la.prototype.bytesPerElement = 32, Yr("StructArrayLayout4i4ui4i4i32", la);

            class ca extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const t = this.length;
                    return this.resize(t + 1), this.emplace(t, e)
                }

                emplace(e, t) {
                    return this.uint32[1 * e + 0] = t, e
                }
            }

            ca.prototype.bytesPerElement = 4, Yr("StructArrayLayout1ul4", ca);

            class ua extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s, l, c, u, d, h) {
                    const p = this.length;
                    return this.resize(p + 1), this.emplace(p, e, t, n, i, r, o, a, s, l, c, u, d, h)
                }

                emplace(e, t, n, i, r, o, a, s, l, c, u, d, h, p) {
                    const f = 20 * e, m = 10 * e;
                    return this.int16[f + 0] = t, this.int16[f + 1] = n, this.int16[f + 2] = i, this.int16[f + 3] = r, this.int16[f + 4] = o, this.float32[m + 3] = a, this.float32[m + 4] = s, this.float32[m + 5] = l, this.float32[m + 6] = c, this.int16[f + 14] = u, this.uint32[m + 8] = d, this.uint16[f + 18] = h, this.uint16[f + 19] = p, e
                }
            }

            ua.prototype.bytesPerElement = 40, Yr("StructArrayLayout5i4f1i1ul2ui40", ua);

            class da extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a) {
                    const s = this.length;
                    return this.resize(s + 1), this.emplace(s, e, t, n, i, r, o, a)
                }

                emplace(e, t, n, i, r, o, a, s) {
                    const l = 8 * e;
                    return this.int16[l + 0] = t, this.int16[l + 1] = n, this.int16[l + 2] = i, this.int16[l + 4] = r, this.int16[l + 5] = o, this.int16[l + 6] = a, this.int16[l + 7] = s, e
                }
            }

            da.prototype.bytesPerElement = 16, Yr("StructArrayLayout3i2i2i16", da);

            class ha extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r) {
                    const o = this.length;
                    return this.resize(o + 1), this.emplace(o, e, t, n, i, r)
                }

                emplace(e, t, n, i, r, o) {
                    const a = 4 * e, s = 8 * e;
                    return this.float32[a + 0] = t, this.float32[a + 1] = n, this.float32[a + 2] = i, this.int16[s + 6] = r, this.int16[s + 7] = o, e
                }
            }

            ha.prototype.bytesPerElement = 16, Yr("StructArrayLayout2f1f2i16", ha);

            class pa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i) {
                    const r = this.length;
                    return this.resize(r + 1), this.emplace(r, e, t, n, i)
                }

                emplace(e, t, n, i, r) {
                    const o = 12 * e, a = 3 * e;
                    return this.uint8[o + 0] = t, this.uint8[o + 1] = n, this.float32[a + 1] = i, this.float32[a + 2] = r, e
                }
            }

            pa.prototype.bytesPerElement = 12, Yr("StructArrayLayout2ub2f12", pa);

            class fa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e, t, n)
                }

                emplace(e, t, n, i) {
                    const r = 3 * e;
                    return this.uint16[r + 0] = t, this.uint16[r + 1] = n, this.uint16[r + 2] = i, e
                }
            }

            fa.prototype.bytesPerElement = 6, Yr("StructArrayLayout3ui6", fa);

            class ma extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x) {
                    const b = this.length;
                    return this.resize(b + 1), this.emplace(b, e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x)
                }

                emplace(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x, b) {
                    const w = 30 * e, M = 15 * e, T = 60 * e;
                    return this.int16[w + 0] = t, this.int16[w + 1] = n, this.int16[w + 2] = i, this.float32[M + 2] = r, this.float32[M + 3] = o, this.uint16[w + 8] = a, this.uint16[w + 9] = s, this.uint32[M + 5] = l, this.uint32[M + 6] = c, this.uint32[M + 7] = u, this.uint16[w + 16] = d, this.uint16[w + 17] = h, this.uint16[w + 18] = p, this.float32[M + 10] = f, this.float32[M + 11] = m, this.uint8[T + 48] = _, this.uint8[T + 49] = g, this.uint8[T + 50] = y, this.uint32[M + 13] = v, this.int16[w + 28] = x, this.uint8[T + 58] = b, e
                }
            }

            ma.prototype.bytesPerElement = 60, Yr("StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60", ma);

            class _a extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x, b, w, M, T, k, S, D, L, E) {
                    const C = this.length;
                    return this.resize(C + 1), this.emplace(C, e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x, b, w, M, T, k, S, D, L, E)
                }

                emplace(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x, b, w, M, T, k, S, D, L, E, C) {
                    const A = 38 * e, I = 19 * e;
                    return this.int16[A + 0] = t, this.int16[A + 1] = n, this.int16[A + 2] = i, this.float32[I + 2] = r, this.float32[I + 3] = o, this.int16[A + 8] = a, this.int16[A + 9] = s, this.int16[A + 10] = l, this.int16[A + 11] = c, this.int16[A + 12] = u, this.int16[A + 13] = d, this.uint16[A + 14] = h, this.uint16[A + 15] = p, this.uint16[A + 16] = f, this.uint16[A + 17] = m, this.uint16[A + 18] = _, this.uint16[A + 19] = g, this.uint16[A + 20] = y, this.uint16[A + 21] = v, this.uint16[A + 22] = x, this.uint16[A + 23] = b, this.uint16[A + 24] = w, this.uint16[A + 25] = M, this.uint16[A + 26] = T, this.uint16[A + 27] = k, this.uint16[A + 28] = S, this.uint32[I + 15] = D, this.float32[I + 16] = L, this.float32[I + 17] = E, this.float32[I + 18] = C, e
                }
            }

            _a.prototype.bytesPerElement = 76, Yr("StructArrayLayout3i2f6i15ui1ul3f76", _a);

            class ga extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const t = this.length;
                    return this.resize(t + 1), this.emplace(t, e)
                }

                emplace(e, t) {
                    return this.float32[1 * e + 0] = t, e
                }
            }

            ga.prototype.bytesPerElement = 4, Yr("StructArrayLayout1f4", ga);

            class ya extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e, t, n)
                }

                emplace(e, t, n, i) {
                    const r = 3 * e;
                    return this.int16[r + 0] = t, this.int16[r + 1] = n, this.int16[r + 2] = i, e
                }
            }

            ya.prototype.bytesPerElement = 6, Yr("StructArrayLayout3i6", ya);

            class va extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i, r, o, a) {
                    const s = this.length;
                    return this.resize(s + 1), this.emplace(s, e, t, n, i, r, o, a)
                }

                emplace(e, t, n, i, r, o, a, s) {
                    const l = 7 * e;
                    return this.float32[l + 0] = t, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = r, this.float32[l + 4] = o, this.float32[l + 5] = a, this.float32[l + 6] = s, e
                }
            }

            va.prototype.bytesPerElement = 28, Yr("StructArrayLayout7f28", va);

            class xa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i) {
                    const r = this.length;
                    return this.resize(r + 1), this.emplace(r, e, t, n, i)
                }

                emplace(e, t, n, i, r) {
                    const o = 6 * e;
                    return this.uint32[3 * e + 0] = t, this.uint16[o + 2] = n, this.uint16[o + 3] = i, this.uint16[o + 4] = r, e
                }
            }

            xa.prototype.bytesPerElement = 12, Yr("StructArrayLayout1ul3ui12", xa);

            class ba extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, t) {
                    const n = this.length;
                    return this.resize(n + 1), this.emplace(n, e, t)
                }

                emplace(e, t, n) {
                    const i = 2 * e;
                    return this.uint16[i + 0] = t, this.uint16[i + 1] = n, e
                }
            }

            ba.prototype.bytesPerElement = 4, Yr("StructArrayLayout2ui4", ba);

            class wa extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const t = this.length;
                    return this.resize(t + 1), this.emplace(t, e)
                }

                emplace(e, t) {
                    return this.uint16[1 * e + 0] = t, e
                }
            }

            wa.prototype.bytesPerElement = 2, Yr("StructArrayLayout1ui2", wa);

            class Ma extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t) {
                    const n = this.length;
                    return this.resize(n + 1), this.emplace(n, e, t)
                }

                emplace(e, t, n) {
                    const i = 2 * e;
                    return this.float32[i + 0] = t, this.float32[i + 1] = n, e
                }
            }

            Ma.prototype.bytesPerElement = 8, Yr("StructArrayLayout2f8", Ma);

            class Ta extends Qo {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, t, n, i) {
                    const r = this.length;
                    return this.resize(r + 1), this.emplace(r, e, t, n, i)
                }

                emplace(e, t, n, i, r) {
                    const o = 4 * e;
                    return this.float32[o + 0] = t, this.float32[o + 1] = n, this.float32[o + 2] = i, this.float32[o + 3] = r, e
                }
            }

            Ta.prototype.bytesPerElement = 16, Yr("StructArrayLayout4f16", Ta);

            class ka extends Ko {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }

                get tileAnchorX() {
                    return this._structArray.int16[this._pos2 + 3]
                }

                get tileAnchorY() {
                    return this._structArray.int16[this._pos2 + 4]
                }

                get x1() {
                    return this._structArray.float32[this._pos4 + 3]
                }

                get y1() {
                    return this._structArray.float32[this._pos4 + 4]
                }

                get x2() {
                    return this._structArray.float32[this._pos4 + 5]
                }

                get y2() {
                    return this._structArray.float32[this._pos4 + 6]
                }

                get padding() {
                    return this._structArray.int16[this._pos2 + 14]
                }

                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 8]
                }

                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }
            }

            ka.prototype.size = 40;

            class Sa extends ua {
                get(e) {
                    return new ka(this, e)
                }
            }

            Yr("CollisionBoxArray", Sa);

            class Da extends Ko {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }

                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 2]
                }

                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 3]
                }

                get glyphStartIndex() {
                    return this._structArray.uint16[this._pos2 + 8]
                }

                get numGlyphs() {
                    return this._structArray.uint16[this._pos2 + 9]
                }

                get vertexStartIndex() {
                    return this._structArray.uint32[this._pos4 + 5]
                }

                get lineStartIndex() {
                    return this._structArray.uint32[this._pos4 + 6]
                }

                get lineLength() {
                    return this._structArray.uint32[this._pos4 + 7]
                }

                get segment() {
                    return this._structArray.uint16[this._pos2 + 16]
                }

                get lowerSize() {
                    return this._structArray.uint16[this._pos2 + 17]
                }

                get upperSize() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get lineOffsetX() {
                    return this._structArray.float32[this._pos4 + 10]
                }

                get lineOffsetY() {
                    return this._structArray.float32[this._pos4 + 11]
                }

                get writingMode() {
                    return this._structArray.uint8[this._pos1 + 48]
                }

                get placedOrientation() {
                    return this._structArray.uint8[this._pos1 + 49]
                }

                set placedOrientation(e) {
                    this._structArray.uint8[this._pos1 + 49] = e
                }

                get hidden() {
                    return this._structArray.uint8[this._pos1 + 50]
                }

                set hidden(e) {
                    this._structArray.uint8[this._pos1 + 50] = e
                }

                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 13]
                }

                set crossTileID(e) {
                    this._structArray.uint32[this._pos4 + 13] = e
                }

                get associatedIconIndex() {
                    return this._structArray.int16[this._pos2 + 28]
                }

                get flipState() {
                    return this._structArray.uint8[this._pos1 + 58]
                }

                set flipState(e) {
                    this._structArray.uint8[this._pos1 + 58] = e
                }
            }

            Da.prototype.size = 60;

            class La extends ma {
                get(e) {
                    return new Da(this, e)
                }
            }

            Yr("PlacedSymbolArray", La);

            class Ea extends Ko {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }

                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 2]
                }

                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 3]
                }

                get rightJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 8]
                }

                get centerJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 9]
                }

                get leftJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 10]
                }

                get verticalPlacedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 11]
                }

                get placedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 12]
                }

                get verticalPlacedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 13]
                }

                get key() {
                    return this._structArray.uint16[this._pos2 + 14]
                }

                get textBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 15]
                }

                get textBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 16]
                }

                get verticalTextBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 17]
                }

                get verticalTextBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get iconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }

                get iconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 20]
                }

                get verticalIconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 21]
                }

                get verticalIconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 22]
                }

                get featureIndex() {
                    return this._structArray.uint16[this._pos2 + 23]
                }

                get numHorizontalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 24]
                }

                get numVerticalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 25]
                }

                get numIconVertices() {
                    return this._structArray.uint16[this._pos2 + 26]
                }

                get numVerticalIconVertices() {
                    return this._structArray.uint16[this._pos2 + 27]
                }

                get useRuntimeCollisionCircles() {
                    return this._structArray.uint16[this._pos2 + 28]
                }

                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 15]
                }

                set crossTileID(e) {
                    this._structArray.uint32[this._pos4 + 15] = e
                }

                get textOffset0() {
                    return this._structArray.float32[this._pos4 + 16]
                }

                get textOffset1() {
                    return this._structArray.float32[this._pos4 + 17]
                }

                get collisionCircleDiameter() {
                    return this._structArray.float32[this._pos4 + 18]
                }
            }

            Ea.prototype.size = 76;

            class Ca extends _a {
                get(e) {
                    return new Ea(this, e)
                }
            }

            Yr("SymbolInstanceArray", Ca);

            class Aa extends ga {
                getoffsetX(e) {
                    return this.float32[1 * e + 0]
                }
            }

            Yr("GlyphOffsetArray", Aa);

            class Ia extends ya {
                getx(e) {
                    return this.int16[3 * e + 0]
                }

                gety(e) {
                    return this.int16[3 * e + 1]
                }

                gettileUnitDistanceFromAnchor(e) {
                    return this.int16[3 * e + 2]
                }
            }

            Yr("SymbolLineVertexArray", Ia);

            class Pa extends Ko {
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 0]
                }

                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 2]
                }

                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 3]
                }

                get layoutVertexArrayOffset() {
                    return this._structArray.uint16[this._pos2 + 4]
                }
            }

            Pa.prototype.size = 12;

            class Ra extends xa {
                get(e) {
                    return new Pa(this, e)
                }
            }

            Yr("FeatureIndexArray", Ra);

            class Ya extends Ko {
                get a_centroid_pos0() {
                    return this._structArray.uint16[this._pos2 + 0]
                }

                get a_centroid_pos1() {
                    return this._structArray.uint16[this._pos2 + 1]
                }
            }

            Ya.prototype.size = 4;

            class za extends ba {
                get(e) {
                    return new Ya(this, e)
                }
            }

            Yr("FillExtrusionCentroidArray", za);
            const Oa = ea([{name: "a_pattern_to", components: 4, type: "Uint16"}, {
                name: "a_pattern_from",
                components: 4,
                type: "Uint16"
            }, {name: "a_pixel_ratio_to", components: 1, type: "Uint16"}, {
                name: "a_pixel_ratio_from",
                components: 1,
                type: "Uint16"
            }]), Fa = ea([{name: "a_dash_to", components: 4, type: "Uint16"}, {
                name: "a_dash_from",
                components: 4,
                type: "Uint16"
            }]);
            var Ba = Ut((function (e) {
                e.exports = function (e, t) {
                    var n, i, r, o, a, s, l, c;
                    for (i = e.length - (n = 3 & e.length), r = t, a = 3432918353, s = 461845907, c = 0; c < i;) l = 255 & e.charCodeAt(c) | (255 & e.charCodeAt(++c)) << 8 | (255 & e.charCodeAt(++c)) << 16 | (255 & e.charCodeAt(++c)) << 24, ++c, r = 27492 + (65535 & (o = 5 * (65535 & (r = (r ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 13 | r >>> 19)) + ((5 * (r >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16);
                    switch (l = 0, n) {
                        case 3:
                            l ^= (255 & e.charCodeAt(c + 2)) << 16;
                        case 2:
                            l ^= (255 & e.charCodeAt(c + 1)) << 8;
                        case 1:
                            r ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & e.charCodeAt(c))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295
                    }
                    return r ^= e.length, r = 2246822507 * (65535 & (r ^= r >>> 16)) + ((2246822507 * (r >>> 16) & 65535) << 16) & 4294967295, r = 3266489909 * (65535 & (r ^= r >>> 13)) + ((3266489909 * (r >>> 16) & 65535) << 16) & 4294967295, (r ^= r >>> 16) >>> 0
                }
            })), ja = Ut((function (e) {
                e.exports = function (e, t) {
                    for (var n, i = e.length, r = t ^ i, o = 0; i >= 4;) n = 1540483477 * (65535 & (n = 255 & e.charCodeAt(o) | (255 & e.charCodeAt(++o)) << 8 | (255 & e.charCodeAt(++o)) << 16 | (255 & e.charCodeAt(++o)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), r = 1540483477 * (65535 & r) + ((1540483477 * (r >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), i -= 4, ++o;
                    switch (i) {
                        case 3:
                            r ^= (255 & e.charCodeAt(o + 2)) << 16;
                        case 2:
                            r ^= (255 & e.charCodeAt(o + 1)) << 8;
                        case 1:
                            r = 1540483477 * (65535 & (r ^= 255 & e.charCodeAt(o))) + ((1540483477 * (r >>> 16) & 65535) << 16)
                    }
                    return r = 1540483477 * (65535 & (r ^= r >>> 13)) + ((1540483477 * (r >>> 16) & 65535) << 16), (r ^= r >>> 15) >>> 0
                }
            })), Ha = Ba, Na = ja;
            Ha.murmur3 = Ba, Ha.murmur2 = Na;

            class Ua {
                constructor() {
                    this.ids = [], this.positions = [], this.indexed = !1
                }

                add(e, t, n, i) {
                    this.ids.push(Wa(e)), this.positions.push(t, n, i)
                }

                getPositions(e) {
                    const t = Wa(e);
                    let n = 0, i = this.ids.length - 1;
                    for (; n < i;) {
                        const e = n + i >> 1;
                        this.ids[e] >= t ? i = e : n = e + 1
                    }
                    const r = [];
                    for (; this.ids[n] === t;) r.push({
                        index: this.positions[3 * n],
                        start: this.positions[3 * n + 1],
                        end: this.positions[3 * n + 2]
                    }), n++;
                    return r
                }

                static serialize(e, t) {
                    const n = new Float64Array(e.ids), i = new Uint32Array(e.positions);
                    return function e(t, n, i, r) {
                        for (; i < r;) {
                            const o = t[i + r >> 1];
                            let a = i - 1, s = r + 1;
                            for (; ;) {
                                do {
                                    a++
                                } while (t[a] < o);
                                do {
                                    s--
                                } while (t[s] > o);
                                if (a >= s) break;
                                Va(t, a, s), Va(n, 3 * a, 3 * s), Va(n, 3 * a + 1, 3 * s + 1), Va(n, 3 * a + 2, 3 * s + 2)
                            }
                            s - i < r - s ? (e(t, n, i, s), i = s + 1) : (e(t, n, s + 1, r), r = s)
                        }
                    }(n, i, 0, n.length - 1), t && t.push(n.buffer, i.buffer), {ids: n, positions: i}
                }

                static deserialize(e) {
                    const t = new Ua;
                    return t.ids = e.ids, t.positions = e.positions, t.indexed = !0, t
                }
            }

            function Wa(e) {
                const t = +e;
                return !isNaN(t) && Number.MIN_SAFE_INTEGER <= t && t <= Number.MAX_SAFE_INTEGER ? t : Ha(String(e))
            }

            function Va(e, t, n) {
                const i = e[t];
                e[t] = e[n], e[n] = i
            }

            Yr("FeaturePositionMap", Ua);

            class Ga {
                constructor(e, t) {
                    this.gl = e.gl, this.location = t
                }
            }

            class qa extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = 0
                }

                set(e) {
                    this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e))
                }
            }

            class Za extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = [0, 0, 0, 0]
                }

                set(e) {
                    e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]))
                }
            }

            class $a extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = Vt.transparent
                }

                set(e) {
                    e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a))
                }
            }

            const Xa = new Float32Array(16), Ja = new Float32Array(9), Ka = new Float32Array(4);

            function Qa(e) {
                return [Xo(255 * e.r, 255 * e.g), Xo(255 * e.b, 255 * e.a)]
            }

            class es {
                constructor(e, t, n) {
                    this.value = e, this.uniformNames = t.map(e => "u_" + e), this.type = n
                }

                setUniform(e, t, n) {
                    e.set(n.constantOr(this.value))
                }

                getBinding(e, t, n) {
                    return "color" === this.type ? new $a(e, t) : new qa(e, t)
                }
            }

            class ts {
                constructor(e, t) {
                    this.uniformNames = t.map(e => "u_" + e), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
                }

                setConstantPatternPositions(e, t) {
                    this.pixelRatioFrom = t.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t.tl.concat(t.br), this.patternTo = e.tl.concat(e.br)
                }

                setUniform(e, t, n, i) {
                    const r = "u_pattern_to" === i || "u_dash_to" === i ? this.patternTo : "u_pattern_from" === i || "u_dash_from" === i ? this.patternFrom : "u_pixel_ratio_to" === i ? this.pixelRatioTo : "u_pixel_ratio_from" === i ? this.pixelRatioFrom : null;
                    r && e.set(r)
                }

                getBinding(e, t, n) {
                    return "u_pattern_from" === n || "u_pattern_to" === n || "u_dash_from" === n || "u_dash_to" === n ? new Za(e, t) : new qa(e, t)
                }
            }

            class ns {
                constructor(e, t, n, i) {
                    this.expression = e, this.type = n, this.maxValue = 0, this.paintVertexAttributes = t.map(e => ({
                        name: "a_" + e,
                        type: "Float32",
                        components: "color" === n ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new i
                }

                populatePaintArray(e, t, n, i, r, o) {
                    const a = this.paintVertexArray.length, s = this.expression.evaluate(new Yo(0), t, {}, r, i, o);
                    this.paintVertexArray.resize(e), this._setPaintValue(a, e, s)
                }

                updatePaintArray(e, t, n, i, r) {
                    const o = this.expression.evaluate({zoom: 0}, n, i, void 0, r);
                    this._setPaintValue(e, t, o)
                }

                _setPaintValue(e, t, n) {
                    if ("color" === this.type) {
                        const i = Qa(n);
                        for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, i[0], i[1])
                    } else {
                        for (let i = e; i < t; i++) this.paintVertexArray.emplace(i, n);
                        this.maxValue = Math.max(this.maxValue, Math.abs(n))
                    }
                }

                upload(e) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }

                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
            }

            class is {
                constructor(e, t, n, i, r, o) {
                    this.expression = e, this.uniformNames = t.map(e => `u_${e}_t`), this.type = n, this.useIntegerZoom = i, this.zoom = r, this.maxValue = 0, this.paintVertexAttributes = t.map(e => ({
                        name: "a_" + e,
                        type: "Float32",
                        components: "color" === n ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new o
                }

                populatePaintArray(e, t, n, i, r, o) {
                    const a = this.expression.evaluate(new Yo(this.zoom), t, {}, r, i, o),
                        s = this.expression.evaluate(new Yo(this.zoom + 1), t, {}, r, i, o),
                        l = this.paintVertexArray.length;
                    this.paintVertexArray.resize(e), this._setPaintValue(l, e, a, s)
                }

                updatePaintArray(e, t, n, i, r) {
                    const o = this.expression.evaluate({zoom: this.zoom}, n, i, void 0, r),
                        a = this.expression.evaluate({zoom: this.zoom + 1}, n, i, void 0, r);
                    this._setPaintValue(e, t, o, a)
                }

                _setPaintValue(e, t, n, i) {
                    if ("color" === this.type) {
                        const r = Qa(n), o = Qa(i);
                        for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, r[0], r[1], o[0], o[1])
                    } else {
                        for (let r = e; r < t; r++) this.paintVertexArray.emplace(r, n, i);
                        this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(i))
                    }
                }

                upload(e) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }

                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }

                setUniform(e, t) {
                    const n = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom,
                        i = $(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
                    e.set(i)
                }

                getBinding(e, t, n) {
                    return new qa(e, t)
                }
            }

            class rs {
                constructor(e, t, n, i, r, o, a) {
                    this.expression = e, this.type = n, this.useIntegerZoom = i, this.zoom = r, this.layerId = a, this.paintVertexAttributes = ("array" === n ? Fa : Oa).members;
                    for (let e = 0; e < t.length; ++e) ;
                    this.zoomInPaintVertexArray = new o, this.zoomOutPaintVertexArray = new o
                }

                populatePaintArray(e, t, n) {
                    const i = this.zoomInPaintVertexArray.length;
                    this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(i, e, t.patterns && t.patterns[this.layerId], n)
                }

                updatePaintArray(e, t, n, i, r, o) {
                    this._setPaintValues(e, t, n.patterns && n.patterns[this.layerId], o)
                }

                _setPaintValues(e, t, n, i) {
                    if (!i || !n) return;
                    const {min: r, mid: o, max: a} = n, s = i[r], l = i[o], c = i[a];
                    if (s && l && c) for (let n = e; n < t; n++) this._setPaintValue(this.zoomInPaintVertexArray, n, l, s), this._setPaintValue(this.zoomOutPaintVertexArray, n, l, c)
                }

                _setPaintValue(e, t, n, i) {
                    e.emplace(t, n.tl[0], n.tl[1], n.br[0], n.br[1], i.tl[0], i.tl[1], i.br[0], i.br[1], n.pixelRatio, i.pixelRatio)
                }

                upload(e) {
                    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }

                destroy() {
                    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                }
            }

            class os {
                constructor(e, t, n = (() => !0)) {
                    this.binders = {}, this._buffers = [];
                    const i = [];
                    for (const r in e.paint._values) {
                        if (!n(r)) continue;
                        const o = e.paint.get(r);
                        if (!(o instanceof No && Si(o.property.specification))) continue;
                        const a = ls(r, e.type), s = o.value, l = o.property.specification.type,
                            c = o.property.useIntegerZoom, u = o.property.specification["property-type"],
                            d = "cross-faded" === u || "cross-faded-data-driven" === u,
                            h = "line-dasharray" === String(r) && "constant" !== e.layout.get("line-cap").value.kind;
                        if ("constant" !== s.kind || h) if ("source" === s.kind || h || d) {
                            const n = ds(r, l, "source");
                            this.binders[r] = d ? new rs(s, a, l, c, t, n, e.id) : new ns(s, a, l, n), i.push("/a_" + r)
                        } else {
                            const e = ds(r, l, "composite");
                            this.binders[r] = new is(s, a, l, c, t, e), i.push("/z_" + r)
                        } else this.binders[r] = d ? new ts(s.value, a) : new es(s.value, a, l), i.push("/u_" + r)
                    }
                    this.cacheKey = i.sort().join("")
                }

                getMaxValue(e) {
                    const t = this.binders[e];
                    return t instanceof ns || t instanceof is ? t.maxValue : 0
                }

                populatePaintArrays(e, t, n, i, r, o) {
                    for (const a in this.binders) {
                        const s = this.binders[a];
                        (s instanceof ns || s instanceof is || s instanceof rs) && s.populatePaintArray(e, t, n, i, r, o)
                    }
                }

                setConstantPatternPositions(e, t) {
                    for (const n in this.binders) {
                        const i = this.binders[n];
                        i instanceof ts && i.setConstantPatternPositions(e, t)
                    }
                }

                updatePaintArrays(e, t, n, i, r, o) {
                    let a = !1;
                    for (const s in e) {
                        const l = t.getPositions(s);
                        for (const t of l) {
                            const l = n.feature(t.index);
                            for (const n in this.binders) {
                                const c = this.binders[n];
                                if ((c instanceof ns || c instanceof is || c instanceof rs) && !0 === c.expression.isStateDependent) {
                                    const u = i.paint.get(n);
                                    c.expression = u.value, c.updatePaintArray(t.start, t.end, l, e[s], r, o), a = !0
                                }
                            }
                        }
                    }
                    return a
                }

                defines() {
                    const e = [];
                    for (const t in this.binders) {
                        const n = this.binders[t];
                        (n instanceof es || n instanceof ts) && e.push(...n.uniformNames.map(e => "#define HAS_UNIFORM_" + e))
                    }
                    return e
                }

                getBinderAttributes() {
                    const e = [];
                    for (const t in this.binders) {
                        const n = this.binders[t];
                        if (n instanceof ns || n instanceof is || n instanceof rs) for (let t = 0; t < n.paintVertexAttributes.length; t++) e.push(n.paintVertexAttributes[t].name)
                    }
                    return e
                }

                getBinderUniforms() {
                    const e = [];
                    for (const t in this.binders) {
                        const n = this.binders[t];
                        if (n instanceof es || n instanceof ts || n instanceof is) for (const t of n.uniformNames) e.push(t)
                    }
                    return e
                }

                getPaintVertexBuffers() {
                    return this._buffers
                }

                getUniforms(e, t) {
                    const n = [];
                    for (const i in this.binders) {
                        const r = this.binders[i];
                        if (r instanceof es || r instanceof ts || r instanceof is) for (const o of r.uniformNames) if (t[o]) {
                            const a = r.getBinding(e, t[o], o);
                            n.push({name: o, property: i, binding: a})
                        }
                    }
                    return n
                }

                setUniforms(e, t, n, i) {
                    for (const {name: e, property: r, binding: o} of t) this.binders[r].setUniform(o, i, n.get(r), e)
                }

                updatePaintBuffers(e) {
                    this._buffers = [];
                    for (const t in this.binders) {
                        const n = this.binders[t];
                        if (e && n instanceof rs) {
                            const t = 2 === e.fromScale ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
                            t && this._buffers.push(t)
                        } else (n instanceof ns || n instanceof is) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer)
                    }
                }

                upload(e) {
                    for (const t in this.binders) {
                        const n = this.binders[t];
                        (n instanceof ns || n instanceof is || n instanceof rs) && n.upload(e)
                    }
                    this.updatePaintBuffers()
                }

                destroy() {
                    for (const e in this.binders) {
                        const t = this.binders[e];
                        (t instanceof ns || t instanceof is || t instanceof rs) && t.destroy()
                    }
                }
            }

            class as {
                constructor(e, t, n = (() => !0)) {
                    this.programConfigurations = {};
                    for (const i of e) this.programConfigurations[i.id] = new os(i, t, n);
                    this.needsUpload = !1, this._featureMap = new Ua, this._bufferOffset = 0
                }

                populatePaintArrays(e, t, n, i, r, o, a) {
                    for (const n in this.programConfigurations) this.programConfigurations[n].populatePaintArrays(e, t, i, r, o, a);
                    void 0 !== t.id && this._featureMap.add(t.id, n, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0
                }

                updatePaintArrays(e, t, n, i, r) {
                    for (const o of n) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(e, this._featureMap, t, o, i, r) || this.needsUpload
                }

                get(e) {
                    return this.programConfigurations[e]
                }

                upload(e) {
                    if (this.needsUpload) {
                        for (const t in this.programConfigurations) this.programConfigurations[t].upload(e);
                        this.needsUpload = !1
                    }
                }

                destroy() {
                    for (const e in this.programConfigurations) this.programConfigurations[e].destroy()
                }
            }

            const ss = {
                "text-opacity": ["opacity"],
                "icon-opacity": ["opacity"],
                "text-color": ["fill_color"],
                "icon-color": ["fill_color"],
                "text-halo-color": ["halo_color"],
                "icon-halo-color": ["halo_color"],
                "text-halo-blur": ["halo_blur"],
                "icon-halo-blur": ["halo_blur"],
                "text-halo-width": ["halo_width"],
                "icon-halo-width": ["halo_width"],
                "line-gap-width": ["gapwidth"],
                "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                "line-dasharray": ["dash_to", "dash_from"]
            };

            function ls(e, t) {
                return ss[e] || [e.replace(t + "-", "").replace(/-/g, "_")]
            }

            const cs = {
                "line-pattern": {source: aa, composite: aa},
                "fill-pattern": {source: aa, composite: aa},
                "fill-extrusion-pattern": {source: aa, composite: aa},
                "line-dasharray": {source: sa, composite: sa}
            }, us = {color: {source: Ma, composite: Ta}, number: {source: ga, composite: Ma}};

            function ds(e, t, n) {
                const i = cs[e];
                return i && i[n] || us[t][n]
            }

            Yr("ConstantBinder", es), Yr("CrossFadedConstantBinder", ts), Yr("SourceExpressionBinder", ns), Yr("CrossFadedCompositeBinder", rs), Yr("CompositeExpressionBinder", is), Yr("ProgramConfiguration", os, {omit: ["_buffers"]}), Yr("ProgramConfigurationSet", as);
            const hs = "-transition";

            class ps extends yt {
                constructor(e, t) {
                    if (super(), this.id = e.id, this.type = e.type, this._featureFilter = {
                        filter: () => !0,
                        needGeometry: !1,
                        needFeature: !1
                    }, this._filterCompiled = !1, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && "sky" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t.layout && (this._unevaluatedLayout = new Ho(t.layout)), t.paint)) {
                        this._transitionablePaint = new Fo(t.paint);
                        for (const t in e.paint) this.setPaintProperty(t, e.paint[t], {validate: !1});
                        for (const t in e.layout) this.setLayoutProperty(t, e.layout[t], {validate: !1});
                        this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Uo(t.paint)
                    }
                }

                getCrossfadeParameters() {
                    return this._crossfadeParameters
                }

                getLayoutProperty(e) {
                    return "visibility" === e ? this.visibility : this._unevaluatedLayout.getValue(e)
                }

                setLayoutProperty(e, t, n = {}) {
                    null != t && this._validate(Lr, `layers.${this.id}.layout.${e}`, e, t, n) || ("visibility" !== e ? this._unevaluatedLayout.setValue(e, t) : this.visibility = t)
                }

                getPaintProperty(e) {
                    return se(e, hs) ? this._transitionablePaint.getTransition(e.slice(0, -hs.length)) : this._transitionablePaint.getValue(e)
                }

                setPaintProperty(e, t, n = {}) {
                    if (null != t && this._validate(Dr, `layers.${this.id}.paint.${e}`, e, t, n)) return !1;
                    if (se(e, hs)) return this._transitionablePaint.setTransition(e.slice(0, -hs.length), t || void 0), !1;
                    {
                        const n = this._transitionablePaint._values[e],
                            i = "cross-faded-data-driven" === n.property.specification["property-type"],
                            r = n.value.isDataDriven(), o = n.value;
                        this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e);
                        const a = this._transitionablePaint._values[e].value;
                        return a.isDataDriven() || r || i || this._handleOverridablePaintPropertyUpdate(e, o, a)
                    }
                }

                _handleSpecialPaintPropertyUpdate(e) {
                }

                getProgramIds() {
                    return null
                }

                getProgramConfiguration(e) {
                    return null
                }

                _handleOverridablePaintPropertyUpdate(e, t, n) {
                    return !1
                }

                isHidden(e) {
                    return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || "none" === this.visibility
                }

                updateTransitions(e) {
                    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint)
                }

                hasTransition() {
                    return this._transitioningPaint.hasTransition()
                }

                recalculate(e, t) {
                    e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t)
                }

                serialize() {
                    const e = {
                        id: this.id,
                        type: this.type,
                        source: this.source,
                        "source-layer": this.sourceLayer,
                        metadata: this.metadata,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        filter: this.filter,
                        layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                        paint: this._transitionablePaint && this._transitionablePaint.serialize()
                    };
                    return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), ce(e, (e, t) => !(void 0 === e || "layout" === t && !Object.keys(e).length || "paint" === t && !Object.keys(e).length))
                }

                _validate(e, t, n, i, r = {}) {
                    return (!r || !1 !== r.validate) && Er(this, e.call(Tr, {
                        key: t,
                        layerType: this.type,
                        objectKey: n,
                        value: i,
                        styleSpec: vt,
                        style: {glyphs: !0, sprite: !0}
                    }))
                }

                is3D() {
                    return !1
                }

                isSky() {
                    return !1
                }

                isTileClipped() {
                    return !1
                }

                hasOffscreenPass() {
                    return !1
                }

                resize() {
                }

                isStateDependent() {
                    for (const e in this.paint._values) {
                        const t = this.paint.get(e);
                        if (t instanceof No && Si(t.property.specification) && ("source" === t.value.kind || "composite" === t.value.kind) && t.value.isStateDependent) return !0
                    }
                    return !1
                }

                compileFilter() {
                    this._filterCompiled || (this._featureFilter = Ji(this.filter), this._filterCompiled = !0)
                }

                invalidateCompiledFilter() {
                    this._filterCompiled = !1
                }

                dynamicFilter() {
                    return this._featureFilter.dynamicFilter
                }

                dynamicFilterNeedsFeature() {
                    return this._featureFilter.needFeature
                }
            }

            const fs = ea([{name: "a_pos", components: 2, type: "Int16"}], 4), {members: ms} = fs;

            class _s {
                constructor(e = []) {
                    this.segments = e
                }

                prepareSegment(e, t, n, i) {
                    let r = this.segments[this.segments.length - 1];
                    return e > _s.MAX_VERTEX_ARRAY_LENGTH && he(`Max vertices per segment is ${_s.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!r || r.vertexLength + e > _s.MAX_VERTEX_ARRAY_LENGTH || r.sortKey !== i) && (r = {
                        vertexOffset: t.length,
                        primitiveOffset: n.length,
                        vertexLength: 0,
                        primitiveLength: 0
                    }, void 0 !== i && (r.sortKey = i), this.segments.push(r)), r
                }

                get() {
                    return this.segments
                }

                destroy() {
                    for (const e of this.segments) for (const t in e.vaos) e.vaos[t].destroy()
                }

                static simpleSegment(e, t, n, i) {
                    return new _s([{
                        vertexOffset: e,
                        primitiveOffset: t,
                        vertexLength: n,
                        primitiveLength: i,
                        vaos: {},
                        sortKey: 0
                    }])
                }
            }

            _s.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Yr("SegmentVector", _s);
            var gs = 8192;

            class ys {
                constructor(e, t) {
                    e && (t ? this.setSouthWest(e).setNorthEast(t) : 4 === e.length ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1]))
                }

                setNorthEast(e) {
                    return this._ne = e instanceof xs ? new xs(e.lng, e.lat) : xs.convert(e), this
                }

                setSouthWest(e) {
                    return this._sw = e instanceof xs ? new xs(e.lng, e.lat) : xs.convert(e), this
                }

                extend(e) {
                    const t = this._sw, n = this._ne;
                    let i, r;
                    if (e instanceof xs) i = e, r = e; else {
                        if (!(e instanceof ys)) return Array.isArray(e) ? 4 === e.length || e.every(Array.isArray) ? this.extend(ys.convert(e)) : this.extend(xs.convert(e)) : this;
                        if (i = e._sw, r = e._ne, !i || !r) return this
                    }
                    return t || n ? (t.lng = Math.min(i.lng, t.lng), t.lat = Math.min(i.lat, t.lat), n.lng = Math.max(r.lng, n.lng), n.lat = Math.max(r.lat, n.lat)) : (this._sw = new xs(i.lng, i.lat), this._ne = new xs(r.lng, r.lat)), this
                }

                getCenter() {
                    return new xs((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
                }

                getSouthWest() {
                    return this._sw
                }

                getNorthEast() {
                    return this._ne
                }

                getNorthWest() {
                    return new xs(this.getWest(), this.getNorth())
                }

                getSouthEast() {
                    return new xs(this.getEast(), this.getSouth())
                }

                getWest() {
                    return this._sw.lng
                }

                getSouth() {
                    return this._sw.lat
                }

                getEast() {
                    return this._ne.lng
                }

                getNorth() {
                    return this._ne.lat
                }

                toArray() {
                    return [this._sw.toArray(), this._ne.toArray()]
                }

                toString() {
                    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                }

                isEmpty() {
                    return !(this._sw && this._ne)
                }

                contains(e) {
                    const {lng: t, lat: n} = xs.convert(e);
                    let i = this._sw.lng <= t && t <= this._ne.lng;
                    return this._sw.lng > this._ne.lng && (i = this._sw.lng >= t && t >= this._ne.lng), this._sw.lat <= n && n <= this._ne.lat && i
                }

                static convert(e) {
                    return !e || e instanceof ys ? e : new ys(e)
                }
            }

            const vs = 6371008.8;

            class xs {
                constructor(e, t) {
                    if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LngLat object: (${e}, ${t})`);
                    if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                }

                wrap() {
                    return new xs(J(this.lng, -180, 180), this.lat)
                }

                toArray() {
                    return [this.lng, this.lat]
                }

                toString() {
                    return `LngLat(${this.lng}, ${this.lat})`
                }

                distanceTo(e) {
                    const t = Math.PI / 180, n = this.lat * t, i = e.lat * t,
                        r = Math.sin(n) * Math.sin(i) + Math.cos(n) * Math.cos(i) * Math.cos((e.lng - this.lng) * t);
                    return vs * Math.acos(Math.min(r, 1))
                }

                toBounds(e = 0) {
                    const t = 360 * e / 40075017, n = t / Math.cos(Math.PI / 180 * this.lat);
                    return new ys(new xs(this.lng - n, this.lat - t), new xs(this.lng + n, this.lat + t))
                }

                static convert(e) {
                    if (e instanceof xs) return e;
                    if (Array.isArray(e) && (2 === e.length || 3 === e.length)) return new xs(Number(e[0]), Number(e[1]));
                    if (!Array.isArray(e) && "object" == typeof e && null !== e) return new xs(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
                    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                }
            }

            const bs = 2 * Math.PI * vs;

            function ws(e) {
                return bs * Math.cos(e * Math.PI / 180)
            }

            function Ms(e) {
                return (180 + e) / 360
            }

            function Ts(e) {
                return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360
            }

            function ks(e, t) {
                return e / ws(t)
            }

            function Ss(e) {
                return 360 * e - 180
            }

            function Ds(e) {
                return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e) * Math.PI / 180)) - 90
            }

            function Ls(e, t) {
                return e * ws(Ds(t))
            }

            const Es = 85.051129;

            class Cs {
                constructor(e, t, n = 0) {
                    this.x = +e, this.y = +t, this.z = +n
                }

                static fromLngLat(e, t = 0) {
                    const n = xs.convert(e);
                    return new Cs(Ms(n.lng), Ts(n.lat), ks(t, n.lat))
                }

                toLngLat() {
                    return new xs(Ss(this.x), Ds(this.y))
                }

                toAltitude() {
                    return Ls(this.z, this.y)
                }

                meterInMercatorCoordinateUnits() {
                    return 1 / bs * (e = Ds(this.y), 1 / Math.cos(e * Math.PI / 180));
                    var e
                }
            }

            function As(e, t, n, i, o, a, s, l, c) {
                const u = (t + i) / 2, d = (n + o) / 2, h = new r(u, d);
                l(h), function (e, t, n, i, r, o) {
                    const a = n - r, s = i - o;
                    return Math.abs((i - t) * a - (n - e) * s) / Math.hypot(a, s)
                }(h.x, h.y, a.x, a.y, s.x, s.y) >= c ? (As(e, t, n, u, d, a, h, l, c), As(e, u, d, i, o, h, s, l, c)) : e.push(s)
            }

            function Is(e, t, n) {
                const i = [];
                let r, o, a;
                for (const s of e) {
                    const {x: e, y: l} = s;
                    t(s), a ? As(i, r, o, e, l, a, s, t, n) : i.push(s), r = e, o = l, a = s
                }
                return i
            }

            const Ps = Math.pow(2, 14) - 1, Rs = -Ps - 1;

            function Ys(e, t) {
                const n = Math.round(e.x * t), i = Math.round(e.y * t);
                return e.x = $(n, Rs, Ps), e.y = $(i, Rs, Ps), (n < e.x || n > e.x + 1 || i < e.y || i > e.y + 1) && he("Geometry exceeds allowed extent, reduce your vector tile buffer size"), e
            }

            function zs(e, t, n) {
                const i = e.loadGeometry(), r = e.extent, o = gs / r;
                if (t && n && n.projection.isReprojectedInTileSpace) {
                    const o = 1 << t.z, {scale: a, x: s, y: l, projection: c} = n, u = e => {
                        const n = Ss((t.x + e.x / r) / o), i = Ds((t.y + e.y / r) / o), u = c.project(n, i);
                        e.x = (u.x * a - s) * r, e.y = (u.y * a - l) * r
                    };
                    for (let t = 0; t < i.length; t++) if (1 !== e.type) i[t] = Is(i[t], u, 1); else {
                        const e = [];
                        for (const n of i[t]) n.x < 0 || n.x >= r || n.y < 0 || n.y >= r || (u(n), e.push(n));
                        i[t] = e
                    }
                }
                for (const e of i) for (const t of e) Ys(t, o);
                return i
            }

            function Os(e, t) {
                return {type: e.type, id: e.id, properties: e.properties, geometry: t ? zs(e) : []}
            }

            function Fs(e, t, n, i, r) {
                e.emplaceBack(2 * t + (i + 1) / 2, 2 * n + (r + 1) / 2)
            }

            class Bs {
                constructor(e) {
                    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new na, this.indexArray = new fa, this.segments = new _s, this.programConfigurations = new as(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id)
                }

                populate(e, t, n, i) {
                    const r = this.layers[0], o = [];
                    let a = null;
                    "circle" === r.type && (a = r.layout.get("circle-sort-key"));
                    for (const {feature: t, id: r, index: s, sourceLayerIndex: l} of e) {
                        const e = this.layers[0]._featureFilter.needGeometry, c = Os(t, e);
                        if (!this.layers[0]._featureFilter.filter(new Yo(this.zoom), c, n)) continue;
                        const u = a ? a.evaluate(c, {}, n) : void 0, d = {
                            id: r,
                            properties: t.properties,
                            type: t.type,
                            sourceLayerIndex: l,
                            index: s,
                            geometry: e ? c.geometry : zs(t, n, i),
                            patterns: {},
                            sortKey: u
                        };
                        o.push(d)
                    }
                    a && o.sort((e, t) => e.sortKey - t.sortKey);
                    for (const i of o) {
                        const {geometry: r, index: o, sourceLayerIndex: a} = i, s = e[o].feature;
                        this.addFeature(i, r, o, t.availableImages, n), t.featureIndex.insert(s, r, o, a, this.index)
                    }
                }

                update(e, t, n, i) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, n, i)
                }

                isEmpty() {
                    return 0 === this.layoutVertexArray.length
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, ms), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }

                addFeature(e, t, n, i, r) {
                    for (const n of t) for (const t of n) {
                        const n = t.x, i = t.y;
                        if (n < 0 || n >= gs || i < 0 || i >= gs) continue;
                        const r = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey),
                            o = r.vertexLength;
                        Fs(this.layoutVertexArray, n, i, -1, -1), Fs(this.layoutVertexArray, n, i, 1, -1), Fs(this.layoutVertexArray, n, i, 1, 1), Fs(this.layoutVertexArray, n, i, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 3, o + 2), r.vertexLength += 4, r.primitiveLength += 2
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {}, i, r)
                }
            }

            function js(e, t) {
                for (let n = 0; n < e.length; n++) if ($s(t, e[n])) return !0;
                for (let n = 0; n < t.length; n++) if ($s(e, t[n])) return !0;
                return !!Ws(e, t)
            }

            function Hs(e, t, n) {
                return !!$s(e, t) || !!Gs(t, e, n)
            }

            function Ns(e, t) {
                if (1 === e.length) return Zs(t, e[0]);
                for (let n = 0; n < t.length; n++) {
                    const i = t[n];
                    for (let t = 0; t < i.length; t++) if ($s(e, i[t])) return !0
                }
                for (let n = 0; n < e.length; n++) if (Zs(t, e[n])) return !0;
                for (let n = 0; n < t.length; n++) if (Ws(e, t[n])) return !0;
                return !1
            }

            function Us(e, t, n) {
                if (e.length > 1) {
                    if (Ws(e, t)) return !0;
                    for (let i = 0; i < t.length; i++) if (Gs(t[i], e, n)) return !0
                }
                for (let i = 0; i < e.length; i++) if (Gs(e[i], t, n)) return !0;
                return !1
            }

            function Ws(e, t) {
                if (0 === e.length || 0 === t.length) return !1;
                for (let n = 0; n < e.length - 1; n++) {
                    const i = e[n], r = e[n + 1];
                    for (let e = 0; e < t.length - 1; e++) if (Vs(i, r, t[e], t[e + 1])) return !0
                }
                return !1
            }

            function Vs(e, t, n, i) {
                return pe(e, n, i) !== pe(t, n, i) && pe(e, t, n) !== pe(e, t, i)
            }

            function Gs(e, t, n) {
                const i = n * n;
                if (1 === t.length) return e.distSqr(t[0]) < i;
                for (let n = 1; n < t.length; n++) if (qs(e, t[n - 1], t[n]) < i) return !0;
                return !1
            }

            function qs(e, t, n) {
                const i = t.distSqr(n);
                if (0 === i) return e.distSqr(t);
                const r = ((e.x - t.x) * (n.x - t.x) + (e.y - t.y) * (n.y - t.y)) / i;
                return e.distSqr(r < 0 ? t : r > 1 ? n : n.sub(t)._mult(r)._add(t))
            }

            function Zs(e, t) {
                let n, i, r, o = !1;
                for (let a = 0; a < e.length; a++) {
                    n = e[a];
                    for (let e = 0, a = n.length - 1; e < n.length; a = e++) i = n[e], r = n[a], i.y > t.y != r.y > t.y && t.x < (r.x - i.x) * (t.y - i.y) / (r.y - i.y) + i.x && (o = !o)
                }
                return o
            }

            function $s(e, t) {
                let n = !1;
                for (let i = 0, r = e.length - 1; i < e.length; r = i++) {
                    const o = e[i], a = e[r];
                    o.y > t.y != a.y > t.y && t.x < (a.x - o.x) * (t.y - o.y) / (a.y - o.y) + o.x && (n = !n)
                }
                return n
            }

            function Xs(e, t, n, i, o) {
                for (const r of e) if (t <= r.x && n <= r.y && i >= r.x && o >= r.y) return !0;
                const a = [new r(t, n), new r(t, o), new r(i, o), new r(i, n)];
                if (e.length > 2) for (const t of a) if ($s(e, t)) return !0;
                for (let t = 0; t < e.length - 1; t++) if (Js(e[t], e[t + 1], a)) return !0;
                return !1
            }

            function Js(e, t, n) {
                const i = n[0], r = n[2];
                if (e.x < i.x && t.x < i.x || e.x > r.x && t.x > r.x || e.y < i.y && t.y < i.y || e.y > r.y && t.y > r.y) return !1;
                const o = pe(e, t, n[0]);
                return o !== pe(e, t, n[1]) || o !== pe(e, t, n[2]) || o !== pe(e, t, n[3])
            }

            function Ks(e, t, n) {
                const i = t.paint.get(e).value;
                return "constant" === i.kind ? i.value : n.programConfigurations.get(t.id).getMaxValue(e)
            }

            function Qs(e) {
                return Math.sqrt(e[0] * e[0] + e[1] * e[1])
            }

            function el(e, t, n, i, o) {
                if (!t[0] && !t[1]) return e;
                const a = r.convert(t)._mult(o);
                "viewport" === n && a._rotate(-i);
                const s = [];
                for (let t = 0; t < e.length; t++) s.push(e[t].sub(a));
                return s
            }

            function tl(e, t, n, i) {
                const o = r.convert(e)._mult(i);
                return "viewport" === t && o._rotate(-n), o
            }

            Yr("CircleBucket", Bs, {omit: ["layers"]});
            const nl = new $o({"circle-sort-key": new Vo(vt.layout_circle["circle-sort-key"])});
            var il = {
                paint: new $o({
                    "circle-radius": new Vo(vt.paint_circle["circle-radius"]),
                    "circle-color": new Vo(vt.paint_circle["circle-color"]),
                    "circle-blur": new Vo(vt.paint_circle["circle-blur"]),
                    "circle-opacity": new Vo(vt.paint_circle["circle-opacity"]),
                    "circle-translate": new Wo(vt.paint_circle["circle-translate"]),
                    "circle-translate-anchor": new Wo(vt.paint_circle["circle-translate-anchor"]),
                    "circle-pitch-scale": new Wo(vt.paint_circle["circle-pitch-scale"]),
                    "circle-pitch-alignment": new Wo(vt.paint_circle["circle-pitch-alignment"]),
                    "circle-stroke-width": new Vo(vt.paint_circle["circle-stroke-width"]),
                    "circle-stroke-color": new Vo(vt.paint_circle["circle-stroke-color"]),
                    "circle-stroke-opacity": new Vo(vt.paint_circle["circle-stroke-opacity"])
                }), layout: nl
            };

            class rl {
                constructor(e, t) {
                    this.points = e, this.planes = t
                }

                static fromInvProjectionMatrix(e, t, n, i) {
                    const r = Math.pow(2, n),
                        o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(n => {
                            const o = z([], n, e), a = 1 / o[3] / t * r;
                            return function (e, t, n) {
                                return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e
                            }(o, o, [a, a, i ? 1 / o[3] : a, a])
                        }), a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(e => {
                            const t = D([], E([], P([], o[e[0]], o[e[1]]), P([], o[e[2]], o[e[1]]))), n = -L(t, o[e[1]]);
                            return t.concat(n)
                        });
                    return new rl(o, a)
                }
            }

            class ol {
                constructor(e, t) {
                    this.min = e, this.max = t, this.center = k([], b([], this.min, this.max), .5)
                }

                quadrant(e) {
                    const t = [e % 2 == 0, e < 2], n = y(this.min), i = y(this.max);
                    for (let e = 0; e < t.length; e++) n[e] = t[e] ? this.min[e] : this.center[e], i[e] = t[e] ? this.center[e] : this.max[e];
                    return i[2] = this.max[2], new ol(n, i)
                }

                distanceX(e) {
                    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                }

                distanceY(e) {
                    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                }

                distanceZ(e) {
                    return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2]
                }

                getCorners() {
                    const e = this.min, t = this.max;
                    return [[e[0], e[1], e[2]], [t[0], e[1], e[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], t[2]], [e[0], t[1], t[2]]]
                }

                intersects(e) {
                    const t = this.getCorners();
                    let n = !0;
                    for (let i = 0; i < e.planes.length; i++) {
                        const r = e.planes[i];
                        let o = 0;
                        for (let e = 0; e < t.length; e++) o += L(r, t[e]) + r[3] >= 0;
                        if (0 === o) return 0;
                        o !== t.length && (n = !1)
                    }
                    if (n) return 2;
                    for (let t = 0; t < 3; t++) {
                        let n = Number.MAX_VALUE, i = -Number.MAX_VALUE;
                        for (let r = 0; r < e.points.length; r++) {
                            const o = e.points[r][t] - this.min[t];
                            n = Math.min(n, o), i = Math.max(i, o)
                        }
                        if (i < 0 || n > this.max[t] - this.min[t]) return 0
                    }
                    return 1
                }
            }

            function al(e, t, n, i, r, o, a, s, l) {
                if (o && e.queryGeometry.isAboveHorizon) return !1;
                o && (l *= e.pixelToTileUnitsFactor);
                for (const c of t) for (const t of c) {
                    const c = t.add(s),
                        u = r && n.elevation ? n.elevation.exaggeration() * r.getElevationAt(c.x, c.y, !0) : 0,
                        d = o ? c : sl(c, u, i),
                        h = o ? e.tilespaceRays.map(e => ul(e, u)) : e.queryGeometry.screenGeometry,
                        p = z([], [t.x, t.y, u, 1], i);
                    if (!a && o ? l *= p[3] / n.cameraToCenterDistance : a && !o && (l *= n.cameraToCenterDistance / p[3]), Hs(h, d, l)) return !0
                }
                return !1
            }

            function sl(e, t, n) {
                const i = z([], [e.x, e.y, t, 1], n);
                return new r(i[0] / i[3], i[1] / i[3])
            }

            const ll = x(0, 0, 0), cl = x(0, 0, 1);

            function ul(e, t) {
                const n = g();
                return ll[2] = t, e.intersectsPlane(ll, cl, n), new r(n[0], n[1])
            }

            class dl extends Bs {
            }

            function hl(e, {width: t, height: n}, i, r) {
                if (r) {
                    if (r instanceof Uint8ClampedArray) r = new Uint8Array(r.buffer); else if (r.length !== t * n * i) throw new RangeError("mismatched image size")
                } else r = new Uint8Array(t * n * i);
                return e.width = t, e.height = n, e.data = r, e
            }

            function pl(e, {width: t, height: n}, i) {
                if (t === e.width && n === e.height) return;
                const r = hl({}, {width: t, height: n}, i);
                fl(e, r, {x: 0, y: 0}, {x: 0, y: 0}, {
                    width: Math.min(e.width, t),
                    height: Math.min(e.height, n)
                }, i), e.width = t, e.height = n, e.data = r.data
            }

            function fl(e, t, n, i, r, o) {
                if (0 === r.width || 0 === r.height) return t;
                if (r.width > e.width || r.height > e.height || n.x > e.width - r.width || n.y > e.height - r.height) throw new RangeError("out of range source coordinates for image copy");
                if (r.width > t.width || r.height > t.height || i.x > t.width - r.width || i.y > t.height - r.height) throw new RangeError("out of range destination coordinates for image copy");
                const a = e.data, s = t.data;
                for (let l = 0; l < r.height; l++) {
                    const c = ((n.y + l) * e.width + n.x) * o, u = ((i.y + l) * t.width + i.x) * o;
                    for (let e = 0; e < r.width * o; e++) s[u + e] = a[c + e]
                }
                return t
            }

            Yr("HeatmapBucket", dl, {omit: ["layers"]});

            class ml {
                constructor(e, t) {
                    hl(this, e, 1, t)
                }

                resize(e) {
                    pl(this, e, 1)
                }

                clone() {
                    return new ml({width: this.width, height: this.height}, new Uint8Array(this.data))
                }

                static copy(e, t, n, i, r) {
                    fl(e, t, n, i, r, 1)
                }
            }

            class _l {
                constructor(e, t) {
                    hl(this, e, 4, t)
                }

                resize(e) {
                    pl(this, e, 4)
                }

                replace(e, t) {
                    t ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e
                }

                clone() {
                    return new _l({width: this.width, height: this.height}, new Uint8Array(this.data))
                }

                static copy(e, t, n, i, r) {
                    fl(e, t, n, i, r, 4)
                }
            }

            Yr("AlphaImage", ml), Yr("RGBAImage", _l);
            var gl = {
                paint: new $o({
                    "heatmap-radius": new Vo(vt.paint_heatmap["heatmap-radius"]),
                    "heatmap-weight": new Vo(vt.paint_heatmap["heatmap-weight"]),
                    "heatmap-intensity": new Wo(vt.paint_heatmap["heatmap-intensity"]),
                    "heatmap-color": new Zo(vt.paint_heatmap["heatmap-color"]),
                    "heatmap-opacity": new Wo(vt.paint_heatmap["heatmap-opacity"])
                })
            };

            function yl(e) {
                const t = {}, n = e.resolution || 256, i = e.clips ? e.clips.length : 1,
                    r = e.image || new _l({width: n, height: i}), o = (n, i, o) => {
                        t[e.evaluationKey] = o;
                        const a = e.expression.evaluate(t);
                        r.data[n + i + 0] = Math.floor(255 * a.r / a.a), r.data[n + i + 1] = Math.floor(255 * a.g / a.a), r.data[n + i + 2] = Math.floor(255 * a.b / a.a), r.data[n + i + 3] = Math.floor(255 * a.a)
                    };
                if (e.clips) for (let t = 0, r = 0; t < i; ++t, r += 4 * n) for (let i = 0, a = 0; i < n; i++, a += 4) {
                    const s = i / (n - 1), {start: l, end: c} = e.clips[t];
                    o(r, a, l * (1 - s) + c * s)
                } else for (let e = 0, t = 0; e < n; e++, t += 4) o(0, t, e / (n - 1));
                return r
            }

            var vl = {
                paint: new $o({
                    "hillshade-illumination-direction": new Wo(vt.paint_hillshade["hillshade-illumination-direction"]),
                    "hillshade-illumination-anchor": new Wo(vt.paint_hillshade["hillshade-illumination-anchor"]),
                    "hillshade-exaggeration": new Wo(vt.paint_hillshade["hillshade-exaggeration"]),
                    "hillshade-shadow-color": new Wo(vt.paint_hillshade["hillshade-shadow-color"]),
                    "hillshade-highlight-color": new Wo(vt.paint_hillshade["hillshade-highlight-color"]),
                    "hillshade-accent-color": new Wo(vt.paint_hillshade["hillshade-accent-color"])
                })
            };
            const xl = ea([{name: "a_pos", components: 2, type: "Int16"}], 4), {members: bl} = xl;
            var wl = Tl, Ml = Tl;

            function Tl(e, t, n) {
                n = n || 2;
                var i, r, o, a, s, l, c, u = t && t.length, d = u ? t[0] * n : e.length, h = kl(e, 0, d, n, !0), p = [];
                if (!h || h.next === h.prev) return p;
                if (u && (h = function (e, t, n, i) {
                    var r, o, a, s = [];
                    for (r = 0, o = t.length; r < o; r++) (a = kl(e, t[r] * i, r < o - 1 ? t[r + 1] * i : e.length, i, !1)) === a.next && (a.steiner = !0), s.push(zl(a));
                    for (s.sort(Il), r = 0; r < s.length; r++) n = Sl(n = Pl(s[r], n), n.next);
                    return n
                }(e, t, h, n)), e.length > 80 * n) {
                    i = o = e[0], r = a = e[1];
                    for (var f = n; f < d; f += n) (s = e[f]) < i && (i = s), (l = e[f + 1]) < r && (r = l), s > o && (o = s), l > a && (a = l);
                    c = 0 !== (c = Math.max(o - i, a - r)) ? 1 / c : 0
                }
                return Dl(h, p, n, i, r, c), p
            }

            function kl(e, t, n, i, r) {
                var o, a;
                if (r === $l(e, t, n, i) > 0) for (o = t; o < n; o += i) a = Gl(o, e[o], e[o + 1], a); else for (o = n - i; o >= t; o -= i) a = Gl(o, e[o], e[o + 1], a);
                return a && jl(a, a.next) && (ql(a), a = a.next), a
            }

            function Sl(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, i = e;
                do {
                    if (n = !1, i.steiner || !jl(i, i.next) && 0 !== Bl(i.prev, i, i.next)) i = i.next; else {
                        if (ql(i), (i = t = i.prev) === i.next) break;
                        n = !0
                    }
                } while (n || i !== t);
                return t
            }

            function Dl(e, t, n, i, r, o, a) {
                if (e) {
                    !a && o && function (e, t, n, i) {
                        var r = e;
                        do {
                            null === r.z && (r.z = Yl(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== e);
                        r.prevZ.nextZ = null, r.prevZ = null, function (e) {
                            var t, n, i, r, o, a, s, l, c = 1;
                            do {
                                for (n = e, e = null, o = null, a = 0; n;) {
                                    for (a++, i = n, s = 0, t = 0; t < c && (s++, i = i.nextZ); t++) ;
                                    for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : e = r, r.prevZ = o, o = r;
                                    n = i
                                }
                                o.nextZ = null, c *= 2
                            } while (a > 1)
                        }(r)
                    }(e, i, r, o);
                    for (var s, l, c = e; e.prev !== e.next;) if (s = e.prev, l = e.next, o ? El(e, i, r, o) : Ll(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), ql(e), e = l.next, c = l.next; else if ((e = l) === c) {
                        a ? 1 === a ? Dl(e = Cl(Sl(e), t, n), t, n, i, r, o, 2) : 2 === a && Al(e, t, n, i, r, o) : Dl(Sl(e), t, n, i, r, o, 1);
                        break
                    }
                }
            }

            function Ll(e) {
                var t = e.prev, n = e, i = e.next;
                if (Bl(t, n, i) >= 0) return !1;
                for (var r = e.next.next; r !== e.prev;) {
                    if (Ol(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && Bl(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function El(e, t, n, i) {
                var r = e.prev, o = e, a = e.next;
                if (Bl(r, o, a) >= 0) return !1;
                for (var s = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, l = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, c = Yl(r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, t, n, i), u = Yl(s, l, t, n, i), d = e.prevZ, h = e.nextZ; d && d.z >= c && h && h.z <= u;) {
                    if (d !== e.prev && d !== e.next && Ol(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Bl(d.prev, d, d.next) >= 0) return !1;
                    if (d = d.prevZ, h !== e.prev && h !== e.next && Ol(r.x, r.y, o.x, o.y, a.x, a.y, h.x, h.y) && Bl(h.prev, h, h.next) >= 0) return !1;
                    h = h.nextZ
                }
                for (; d && d.z >= c;) {
                    if (d !== e.prev && d !== e.next && Ol(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Bl(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                for (; h && h.z <= u;) {
                    if (h !== e.prev && h !== e.next && Ol(r.x, r.y, o.x, o.y, a.x, a.y, h.x, h.y) && Bl(h.prev, h, h.next) >= 0) return !1;
                    h = h.nextZ
                }
                return !0
            }

            function Cl(e, t, n) {
                var i = e;
                do {
                    var r = i.prev, o = i.next.next;
                    !jl(r, o) && Hl(r, i, i.next, o) && Wl(r, o) && Wl(o, r) && (t.push(r.i / n), t.push(i.i / n), t.push(o.i / n), ql(i), ql(i.next), i = e = o), i = i.next
                } while (i !== e);
                return Sl(i)
            }

            function Al(e, t, n, i, r, o) {
                var a = e;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && Fl(a, s)) {
                            var l = Vl(a, s);
                            return a = Sl(a, a.next), l = Sl(l, l.next), Dl(a, t, n, i, r, o), void Dl(l, t, n, i, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== e)
            }

            function Il(e, t) {
                return e.x - t.x
            }

            function Pl(e, t) {
                var n = function (e, t) {
                    var n, i = t, r = e.x, o = e.y, a = -1 / 0;
                    do {
                        if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                            var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                            if (s <= r && s > a) {
                                if (a = s, s === r) {
                                    if (o === i.y) return i;
                                    if (o === i.next.y) return i.next
                                }
                                n = i.x < i.next.x ? i : i.next
                            }
                        }
                        i = i.next
                    } while (i !== t);
                    if (!n) return null;
                    if (r === a) return n;
                    var l, c = n, u = n.x, d = n.y, h = 1 / 0;
                    i = n;
                    do {
                        r >= i.x && i.x >= u && r !== i.x && Ol(o < d ? r : a, o, u, d, o < d ? a : r, o, i.x, i.y) && (l = Math.abs(o - i.y) / (r - i.x), Wl(i, e) && (l < h || l === h && (i.x > n.x || i.x === n.x && Rl(n, i))) && (n = i, h = l)), i = i.next
                    } while (i !== c);
                    return n
                }(e, t);
                if (!n) return t;
                var i = Vl(n, e), r = Sl(n, n.next);
                return Sl(i, i.next), t === n ? r : t
            }

            function Rl(e, t) {
                return Bl(e.prev, e, t.prev) < 0 && Bl(t.next, e, e.next) < 0
            }

            function Yl(e, t, n, i, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function zl(e) {
                var t = e, n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
                } while (t !== e);
                return n
            }

            function Ol(e, t, n, i, r, o, a, s) {
                return (r - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (i - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
            }

            function Fl(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) {
                    var n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Hl(n, n.next, e, t)) return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && (Wl(e, t) && Wl(t, e) && function (e, t) {
                    var n = e, i = !1, r = (e.x + t.x) / 2, o = (e.y + t.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== e);
                    return i
                }(e, t) && (Bl(e.prev, e, t.prev) || Bl(e, t.prev, t)) || jl(e, t) && Bl(e.prev, e, e.next) > 0 && Bl(t.prev, t, t.next) > 0)
            }

            function Bl(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function jl(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function Hl(e, t, n, i) {
                var r = Ul(Bl(e, t, n)), o = Ul(Bl(e, t, i)), a = Ul(Bl(n, i, e)), s = Ul(Bl(n, i, t));
                return r !== o && a !== s || !(0 !== r || !Nl(e, n, t)) || !(0 !== o || !Nl(e, i, t)) || !(0 !== a || !Nl(n, e, i)) || !(0 !== s || !Nl(n, t, i))
            }

            function Nl(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function Ul(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function Wl(e, t) {
                return Bl(e.prev, e, e.next) < 0 ? Bl(e, t, e.next) >= 0 && Bl(e, e.prev, t) >= 0 : Bl(e, t, e.prev) < 0 || Bl(e, e.next, t) < 0
            }

            function Vl(e, t) {
                var n = new Zl(e.i, e.x, e.y), i = new Zl(t.i, t.x, t.y), r = e.next, o = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
            }

            function Gl(e, t, n, i) {
                var r = new Zl(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function ql(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function Zl(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function $l(e, t, n, i) {
                for (var r = 0, o = t, a = n - i; o < n; o += i) r += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                return r
            }

            function Xl(e, t, n, i, r) {
                !function e(t, n, i, r, o) {
                    for (; r > i;) {
                        if (r - i > 600) {
                            var a = r - i + 1, s = n - i + 1, l = Math.log(a), c = .5 * Math.exp(2 * l / 3),
                                u = .5 * Math.sqrt(l * c * (a - c) / a) * (s - a / 2 < 0 ? -1 : 1);
                            e(t, n, Math.max(i, Math.floor(n - s * c / a + u)), Math.min(r, Math.floor(n + (a - s) * c / a + u)), o)
                        }
                        var d = t[n], h = i, p = r;
                        for (Jl(t, i, n), o(t[r], d) > 0 && Jl(t, i, r); h < p;) {
                            for (Jl(t, h, p), h++, p--; o(t[h], d) < 0;) h++;
                            for (; o(t[p], d) > 0;) p--
                        }
                        0 === o(t[i], d) ? Jl(t, i, p) : Jl(t, ++p, r), p <= n && (i = p + 1), n <= p && (r = p - 1)
                    }
                }(e, t, n || 0, i || e.length - 1, r || Kl)
            }

            function Jl(e, t, n) {
                var i = e[t];
                e[t] = e[n], e[n] = i
            }

            function Kl(e, t) {
                return e < t ? -1 : e > t ? 1 : 0
            }

            function Ql(e, t) {
                const n = e.length;
                if (n <= 1) return [e];
                const i = [];
                let r, o;
                for (let t = 0; t < n; t++) {
                    const n = fe(e[t]);
                    0 !== n && (e[t].area = Math.abs(n), void 0 === o && (o = n < 0), o === n < 0 ? (r && i.push(r), r = [e[t]]) : r.push(e[t]))
                }
                if (r && i.push(r), t > 1) for (let e = 0; e < i.length; e++) i[e].length <= t || (Xl(i[e], t, 1, i[e].length - 1, ec), i[e] = i[e].slice(0, t));
                return i
            }

            function ec(e, t) {
                return t.area - e.area
            }

            function tc(e, t, n) {
                const i = n.patternDependencies;
                let r = !1;
                for (const n of t) {
                    const t = n.paint.get(e + "-pattern");
                    t.isConstant() || (r = !0);
                    const o = t.constantOr(null);
                    o && (r = !0, i[o.to] = !0, i[o.from] = !0)
                }
                return r
            }

            function nc(e, t, n, i, r) {
                const o = r.patternDependencies;
                for (const a of t) {
                    const t = a.paint.get(e + "-pattern").value;
                    if ("constant" !== t.kind) {
                        let e = t.evaluate({zoom: i - 1}, n, {}, r.availableImages),
                            s = t.evaluate({zoom: i}, n, {}, r.availableImages),
                            l = t.evaluate({zoom: i + 1}, n, {}, r.availableImages);
                        e = e && e.name ? e.name : e, s = s && s.name ? s.name : s, l = l && l.name ? l.name : l, o[e] = !0, o[s] = !0, o[l] = !0, n.patterns[a.id] = {
                            min: e,
                            mid: s,
                            max: l
                        }
                    }
                }
                return n
            }

            Tl.deviation = function (e, t, n, i) {
                var r = t && t.length, o = Math.abs($l(e, 0, r ? t[0] * n : e.length, n));
                if (r) for (var a = 0, s = t.length; a < s; a++) o -= Math.abs($l(e, t[a] * n, a < s - 1 ? t[a + 1] * n : e.length, n));
                var l = 0;
                for (a = 0; a < i.length; a += 3) {
                    var c = i[a] * n, u = i[a + 1] * n, d = i[a + 2] * n;
                    l += Math.abs((e[c] - e[d]) * (e[u + 1] - e[c + 1]) - (e[c] - e[u]) * (e[d + 1] - e[c + 1]))
                }
                return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o)
            }, Tl.flatten = function (e) {
                for (var t = e[0][0].length, n = {
                    vertices: [],
                    holes: [],
                    dimensions: t
                }, i = 0, r = 0; r < e.length; r++) {
                    for (var o = 0; o < e[r].length; o++) for (var a = 0; a < t; a++) n.vertices.push(e[r][o][a]);
                    r > 0 && n.holes.push(i += e[r - 1].length)
                }
                return n
            }, wl.default = Ml;

            class ic {
                constructor(e) {
                    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new na, this.indexArray = new fa, this.indexArray2 = new ba, this.programConfigurations = new as(e.layers, e.zoom), this.segments = new _s, this.segments2 = new _s, this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id)
                }

                populate(e, t, n, i) {
                    this.hasPattern = tc("fill", this.layers, t);
                    const r = this.layers[0].layout.get("fill-sort-key"), o = [];
                    for (const {feature: a, id: s, index: l, sourceLayerIndex: c} of e) {
                        const e = this.layers[0]._featureFilter.needGeometry, u = Os(a, e);
                        if (!this.layers[0]._featureFilter.filter(new Yo(this.zoom), u, n)) continue;
                        const d = r ? r.evaluate(u, {}, n, t.availableImages) : void 0, h = {
                            id: s,
                            properties: a.properties,
                            type: a.type,
                            sourceLayerIndex: c,
                            index: l,
                            geometry: e ? u.geometry : zs(a, n, i),
                            patterns: {},
                            sortKey: d
                        };
                        o.push(h)
                    }
                    r && o.sort((e, t) => e.sortKey - t.sortKey);
                    for (const i of o) {
                        const {geometry: r, index: o, sourceLayerIndex: a} = i;
                        if (this.hasPattern) {
                            const e = nc("fill", this.layers, i, this.zoom, t);
                            this.patternFeatures.push(e)
                        } else this.addFeature(i, r, o, n, {}, t.availableImages);
                        t.featureIndex.insert(e[o].feature, r, o, a, this.index)
                    }
                }

                update(e, t, n, i) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, n, i)
                }

                addFeatures(e, t, n, i) {
                    for (const e of this.patternFeatures) this.addFeature(e, e.geometry, e.index, t, n, i)
                }

                isEmpty() {
                    return 0 === this.layoutVertexArray.length
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, bl), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
                }

                addFeature(e, t, n, i, r, o = []) {
                    for (const e of Ql(t, 500)) {
                        let t = 0;
                        for (const n of e) t += n.length;
                        const n = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray),
                            i = n.vertexLength, r = [], o = [];
                        for (const t of e) {
                            if (0 === t.length) continue;
                            t !== e[0] && o.push(r.length / 2);
                            const n = this.segments2.prepareSegment(t.length, this.layoutVertexArray, this.indexArray2),
                                i = n.vertexLength;
                            this.layoutVertexArray.emplaceBack(t[0].x, t[0].y), this.indexArray2.emplaceBack(i + t.length - 1, i), r.push(t[0].x), r.push(t[0].y);
                            for (let e = 1; e < t.length; e++) this.layoutVertexArray.emplaceBack(t[e].x, t[e].y), this.indexArray2.emplaceBack(i + e - 1, i + e), r.push(t[e].x), r.push(t[e].y);
                            n.vertexLength += t.length, n.primitiveLength += t.length
                        }
                        const a = wl(r, o);
                        for (let e = 0; e < a.length; e += 3) this.indexArray.emplaceBack(i + a[e], i + a[e + 1], i + a[e + 2]);
                        n.vertexLength += t, n.primitiveLength += a.length / 3
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, r, o, i)
                }
            }

            Yr("FillBucket", ic, {omit: ["layers", "patternFeatures"]});
            const rc = new $o({"fill-sort-key": new Vo(vt.layout_fill["fill-sort-key"])});
            var oc = {
                paint: new $o({
                    "fill-antialias": new Wo(vt.paint_fill["fill-antialias"]),
                    "fill-opacity": new Vo(vt.paint_fill["fill-opacity"]),
                    "fill-color": new Vo(vt.paint_fill["fill-color"]),
                    "fill-outline-color": new Vo(vt.paint_fill["fill-outline-color"]),
                    "fill-translate": new Wo(vt.paint_fill["fill-translate"]),
                    "fill-translate-anchor": new Wo(vt.paint_fill["fill-translate-anchor"]),
                    "fill-pattern": new Go(vt.paint_fill["fill-pattern"])
                }), layout: rc
            };
            const ac = ea([{name: "a_pos_normal_ed", components: 4, type: "Int16"}]),
                sc = ea([{name: "a_centroid_pos", components: 2, type: "Uint16"}]), {members: lc} = ac;
            var cc = uc;

            function uc(e, t, n, i, r) {
                this.properties = {}, this.extent = n, this.type = 0, this._pbf = e, this._geometry = -1, this._keys = i, this._values = r, e.readFields(dc, this, t)
            }

            function dc(e, t, n) {
                1 == e ? t.id = n.readVarint() : 2 == e ? function (e, t) {
                    for (var n = e.readVarint() + e.pos; e.pos < n;) {
                        var i = t._keys[e.readVarint()], r = t._values[e.readVarint()];
                        t.properties[i] = r
                    }
                }(n, t) : 3 == e ? t.type = n.readVarint() : 4 == e && (t._geometry = n.pos)
            }

            function hc(e) {
                for (var t, n, i = 0, r = 0, o = e.length, a = o - 1; r < o; a = r++) i += ((n = e[a]).x - (t = e[r]).x) * (t.y + n.y);
                return i
            }

            uc.types = ["Unknown", "Point", "LineString", "Polygon"], uc.prototype.loadGeometry = function () {
                var e = this._pbf;
                e.pos = this._geometry;
                for (var t, n = e.readVarint() + e.pos, i = 1, o = 0, a = 0, s = 0, l = []; e.pos < n;) {
                    if (o <= 0) {
                        var c = e.readVarint();
                        i = 7 & c, o = c >> 3
                    }
                    if (o--, 1 === i || 2 === i) a += e.readSVarint(), s += e.readSVarint(), 1 === i && (t && l.push(t), t = []), t.push(new r(a, s)); else {
                        if (7 !== i) throw new Error("unknown command " + i);
                        t && t.push(t[0].clone())
                    }
                }
                return t && l.push(t), l
            }, uc.prototype.bbox = function () {
                var e = this._pbf;
                e.pos = this._geometry;
                for (var t = e.readVarint() + e.pos, n = 1, i = 0, r = 0, o = 0, a = 1 / 0, s = -1 / 0, l = 1 / 0, c = -1 / 0; e.pos < t;) {
                    if (i <= 0) {
                        var u = e.readVarint();
                        n = 7 & u, i = u >> 3
                    }
                    if (i--, 1 === n || 2 === n) (r += e.readSVarint()) < a && (a = r), r > s && (s = r), (o += e.readSVarint()) < l && (l = o), o > c && (c = o); else if (7 !== n) throw new Error("unknown command " + n)
                }
                return [a, l, s, c]
            }, uc.prototype.toGeoJSON = function (e, t, n) {
                var i, r, o = this.extent * Math.pow(2, n), a = this.extent * e, s = this.extent * t,
                    l = this.loadGeometry(), c = uc.types[this.type];

                function u(e) {
                    for (var t = 0; t < e.length; t++) {
                        var n = e[t];
                        e[t] = [360 * (n.x + a) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (n.y + s) / o) * Math.PI / 180)) - 90]
                    }
                }

                switch (this.type) {
                    case 1:
                        var d = [];
                        for (i = 0; i < l.length; i++) d[i] = l[i][0];
                        u(l = d);
                        break;
                    case 2:
                        for (i = 0; i < l.length; i++) u(l[i]);
                        break;
                    case 3:
                        for (l = function (e) {
                            var t = e.length;
                            if (t <= 1) return [e];
                            for (var n, i, r = [], o = 0; o < t; o++) {
                                var a = hc(e[o]);
                                0 !== a && (void 0 === i && (i = a < 0), i === a < 0 ? (n && r.push(n), n = [e[o]]) : n.push(e[o]))
                            }
                            return n && r.push(n), r
                        }(l), i = 0; i < l.length; i++) for (r = 0; r < l[i].length; r++) u(l[i][r])
                }
                1 === l.length ? l = l[0] : c = "Multi" + c;
                var h = {type: "Feature", geometry: {type: c, coordinates: l}, properties: this.properties};
                return "id" in this && (h.id = this.id), h
            };
            var pc = fc;

            function fc(e, t) {
                this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(mc, this, t), this.length = this._features.length
            }

            function mc(e, t, n) {
                15 === e ? t.version = n.readVarint() : 1 === e ? t.name = n.readString() : 5 === e ? t.extent = n.readVarint() : 2 === e ? t._features.push(n.pos) : 3 === e ? t._keys.push(n.readString()) : 4 === e && t._values.push(function (e) {
                    for (var t = null, n = e.readVarint() + e.pos; e.pos < n;) {
                        var i = e.readVarint() >> 3;
                        t = 1 === i ? e.readString() : 2 === i ? e.readFloat() : 3 === i ? e.readDouble() : 4 === i ? e.readVarint64() : 5 === i ? e.readVarint() : 6 === i ? e.readSVarint() : 7 === i ? e.readBoolean() : null
                    }
                    return t
                }(n))
            }

            function _c(e, t, n) {
                if (3 === e) {
                    var i = new pc(n, n.readVarint() + n.pos);
                    i.length && (t[i.name] = i)
                }
            }

            fc.prototype.feature = function (e) {
                if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[e];
                var t = this._pbf.readVarint() + this._pbf.pos;
                return new cc(this._pbf, t, this.extent, this._keys, this._values)
            };
            var gc = {
                VectorTile: function (e, t) {
                    this.layers = e.readFields(_c, {}, t)
                }, VectorTileFeature: cc, VectorTileLayer: pc
            };
            const yc = gc.VectorTileFeature.types, vc = Math.pow(2, 13);

            function xc(e, t, n, i, r, o, a, s) {
                e.emplaceBack((t << 1) + a, (n << 1) + o, (Math.floor(i * vc) << 1) + r, Math.round(s))
            }

            class bc {
                constructor() {
                    this.acc = new r(0, 0), this.polyCount = []
                }

                startRing(e) {
                    this.currentPolyCount = {
                        edges: 0,
                        top: 0
                    }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new r(e.x, e.y), this.max = new r(e.x, e.y))
                }

                append(e, t) {
                    this.currentPolyCount.edges++, this.acc._add(e);
                    let n = !!this.borders;
                    const i = this.min, r = this.max;
                    e.x < i.x ? (i.x = e.x, n = !0) : e.x > r.x && (r.x = e.x, n = !0), e.y < i.y ? (i.y = e.y, n = !0) : e.y > r.y && (r.y = e.y, n = !0), ((0 === e.x || e.x === gs) && e.x === t.x) != ((0 === e.y || e.y === gs) && e.y === t.y) && this.processBorderOverlap(e, t), n && this.checkBorderIntersection(e, t)
                }

                checkBorderIntersection(e, t) {
                    t.x < 0 != e.x < 0 && this.addBorderIntersection(0, On(t.y, e.y, (0 - t.x) / (e.x - t.x))), t.x > gs != e.x > gs && this.addBorderIntersection(1, On(t.y, e.y, (gs - t.x) / (e.x - t.x))), t.y < 0 != e.y < 0 && this.addBorderIntersection(2, On(t.x, e.x, (0 - t.y) / (e.y - t.y))), t.y > gs != e.y > gs && this.addBorderIntersection(3, On(t.x, e.x, (gs - t.y) / (e.y - t.y)))
                }

                addBorderIntersection(e, t) {
                    this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                    const n = this.borders[e];
                    t < n[0] && (n[0] = t), t > n[1] && (n[1] = t)
                }

                processBorderOverlap(e, t) {
                    if (e.x === t.x) {
                        if (e.y === t.y) return;
                        const n = 0 === e.x ? 0 : 1;
                        this.addBorderIntersection(n, t.y), this.addBorderIntersection(n, e.y)
                    } else {
                        const n = 0 === e.y ? 2 : 3;
                        this.addBorderIntersection(n, t.x), this.addBorderIntersection(n, e.x)
                    }
                }

                centroid() {
                    const e = this.polyCount.reduce((e, t) => e + t.edges, 0);
                    return 0 !== e ? this.acc.div(e)._round() : new r(0, 0)
                }

                span() {
                    return new r(this.max.x - this.min.x, this.max.y - this.min.y)
                }

                intersectsCount() {
                    return this.borders.reduce((e, t) => e + +(t[0] !== Number.MAX_VALUE), 0)
                }
            }

            class wc {
                constructor(e) {
                    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new ia, this.centroidVertexArray = new za, this.indexArray = new fa, this.programConfigurations = new as(e.layers, e.zoom), this.segments = new _s, this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id), this.enableTerrain = e.enableTerrain
                }

                populate(e, t, n, i) {
                    this.features = [], this.hasPattern = tc("fill-extrusion", this.layers, t), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDone = [!1, !1, !1, !1], this.tileToMeter = function (e) {
                        const t = Math.exp(Math.PI * (1 - e.y / (1 << e.z) * 2));
                        return 80150034 * t / (t * t + 1) / gs / (1 << e.z)
                    }(n);
                    for (const {feature: r, id: o, index: a, sourceLayerIndex: s} of e) {
                        const e = this.layers[0]._featureFilter.needGeometry, l = Os(r, e);
                        if (!this.layers[0]._featureFilter.filter(new Yo(this.zoom), l, n)) continue;
                        const c = {
                            id: o,
                            sourceLayerIndex: s,
                            index: a,
                            geometry: e ? l.geometry : zs(r, n, i),
                            properties: r.properties,
                            type: r.type,
                            patterns: {}
                        }, u = this.layoutVertexArray.length;
                        this.hasPattern ? this.features.push(nc("fill-extrusion", this.layers, c, this.zoom, t)) : this.addFeature(c, c.geometry, a, n, {}, t.availableImages), t.featureIndex.insert(r, c.geometry, a, s, this.index, u)
                    }
                    this.sortBorders()
                }

                addFeatures(e, t, n, i) {
                    for (const e of this.features) {
                        const {geometry: r} = e;
                        this.addFeature(e, r, e.index, t, n, i)
                    }
                    this.sortBorders()
                }

                update(e, t, n, i) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, n, i)
                }

                isEmpty() {
                    return 0 === this.layoutVertexArray.length
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, lc), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0
                }

                uploadCentroid(e) {
                    0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, sc.members, !0), this.needsCentroidUpdate = !1)
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }

                addFeature(e, t, n, i, r, o) {
                    const a = this.enableTerrain ? new bc : null;
                    for (const n of Ql(t, 500)) {
                        let t = 0, i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                        if (0 === n.length || (s = n[0]).every(e => e.x <= 0) || s.every(e => e.x >= gs) || s.every(e => e.y <= 0) || s.every(e => e.y >= gs)) continue;
                        for (let e = 0; e < n.length; e++) {
                            const r = n[e];
                            if (0 === r.length) continue;
                            t += r.length;
                            let o = 0;
                            a && a.startRing(r[0]);
                            for (let e = 0; e < r.length; e++) {
                                const t = r[e];
                                if (e >= 1) {
                                    const n = r[e - 1];
                                    if (!Mc(t, n)) {
                                        a && a.append(t, n), i.vertexLength + 4 > _s.MAX_VERTEX_ARRAY_LENGTH && (i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                                        const e = t.sub(n)._perp(), r = e.x / (Math.abs(e.x) + Math.abs(e.y)),
                                            s = e.y > 0 ? 1 : 0, l = n.dist(t);
                                        o + l > 32768 && (o = 0), xc(this.layoutVertexArray, t.x, t.y, r, s, 0, 0, o), xc(this.layoutVertexArray, t.x, t.y, r, s, 0, 1, o), o += l, xc(this.layoutVertexArray, n.x, n.y, r, s, 0, 0, o), xc(this.layoutVertexArray, n.x, n.y, r, s, 0, 1, o);
                                        const c = i.vertexLength;
                                        this.indexArray.emplaceBack(c, c + 2, c + 1), this.indexArray.emplaceBack(c + 1, c + 2, c + 3), i.vertexLength += 4, i.primitiveLength += 2
                                    }
                                }
                            }
                        }
                        if (i.vertexLength + t > _s.MAX_VERTEX_ARRAY_LENGTH && (i = this.segments.prepareSegment(t, this.layoutVertexArray, this.indexArray)), "Polygon" !== yc[e.type]) continue;
                        const r = [], o = [], l = i.vertexLength;
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e];
                            if (0 !== t.length) {
                                t !== n[0] && o.push(r.length / 2);
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e];
                                    xc(this.layoutVertexArray, n.x, n.y, 0, 0, 1, 1, 0), r.push(n.x), r.push(n.y), a && a.currentPolyCount.top++
                                }
                            }
                        }
                        const c = wl(r, o);
                        for (let e = 0; e < c.length; e += 3) this.indexArray.emplaceBack(l + c[e], l + c[e + 2], l + c[e + 1]);
                        i.primitiveLength += c.length / 3, i.vertexLength += t
                    }
                    var s;
                    if (a && a.polyCount.length > 0) {
                        if (a.borders) {
                            a.vertexArrayOffset = this.centroidVertexArray.length;
                            const e = a.borders, t = this.featuresOnBorder.push(a) - 1;
                            for (let n = 0; n < 4; n++) e[n][0] !== Number.MAX_VALUE && this.borders[n].push(t)
                        }
                        this.encodeCentroid(a.borders ? void 0 : a.centroid(), a)
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, r, o, i)
                }

                sortBorders() {
                    for (let e = 0; e < 4; e++) this.borders[e].sort((t, n) => this.featuresOnBorder[t].borders[e][0] - this.featuresOnBorder[n].borders[e][0])
                }

                encodeCentroid(e, t, n = !0) {
                    let i, r;
                    if (e) if (0 !== e.y) {
                        const n = t.span()._mult(this.tileToMeter);
                        i = (Math.max(e.x, 1) << 3) + Math.min(7, Math.round(n.x / 10)), r = (Math.max(e.y, 1) << 3) + Math.min(7, Math.round(n.y / 10))
                    } else i = Math.ceil(7 * (e.x + 450)), r = 0; else i = 0, r = +n;
                    let o = n ? this.centroidVertexArray.length : t.vertexArrayOffset;
                    for (const e of t.polyCount) {
                        n && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * e.edges + e.top);
                        for (let t = 0; t < 2 * e.edges; t++) this.centroidVertexArray.emplace(o++, 0, r), this.centroidVertexArray.emplace(o++, i, r);
                        for (let t = 0; t < e.top; t++) this.centroidVertexArray.emplace(o++, i, r)
                    }
                }
            }

            function Mc(e, t) {
                return e.x === t.x && (e.x < 0 || e.x > gs) || e.y === t.y && (e.y < 0 || e.y > gs)
            }

            Yr("FillExtrusionBucket", wc, {omit: ["layers", "features"]}), Yr("PartMetadata", bc);
            var Tc = {
                paint: new $o({
                    "fill-extrusion-opacity": new Wo(vt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                    "fill-extrusion-color": new Vo(vt["paint_fill-extrusion"]["fill-extrusion-color"]),
                    "fill-extrusion-translate": new Wo(vt["paint_fill-extrusion"]["fill-extrusion-translate"]),
                    "fill-extrusion-translate-anchor": new Wo(vt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                    "fill-extrusion-pattern": new Go(vt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                    "fill-extrusion-height": new Vo(vt["paint_fill-extrusion"]["fill-extrusion-height"]),
                    "fill-extrusion-base": new Vo(vt["paint_fill-extrusion"]["fill-extrusion-base"]),
                    "fill-extrusion-vertical-gradient": new Wo(vt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                })
            };

            function kc(e, t) {
                return e.x * t.x + e.y * t.y
            }

            function Sc(e, t) {
                if (1 === e.length) {
                    let n = 0;
                    const i = t[n++];
                    let r;
                    for (; !r || i.equals(r);) if (r = t[n++], !r) return 1 / 0;
                    for (; n < t.length; n++) {
                        const o = t[n], a = e[0], s = r.sub(i), l = o.sub(i), c = a.sub(i), u = kc(s, s), d = kc(s, l),
                            h = kc(l, l), p = kc(c, s), f = kc(c, l), m = u * h - d * d, _ = (h * p - d * f) / m,
                            g = (u * f - d * p) / m, y = i.z * (1 - _ - g) + r.z * _ + o.z * g;
                        if (isFinite(y)) return y
                    }
                    return 1 / 0
                }
                {
                    let e = 1 / 0;
                    for (const n of t) e = Math.min(e, n.z);
                    return e
                }
            }

            function Dc(e) {
                const t = new r(e[0], e[1]);
                return t.z = e[2], t
            }

            function Lc(e, t, n, i, r, o, a, s) {
                const l = a * r.getElevationAt(e, t, !0, !0), c = 0 !== o[0],
                    u = c ? 0 === o[1] ? a * (o[0] / 7 - 450) : a * function (e, t, n) {
                        const i = Math.floor(t[0] / 8), r = Math.floor(t[1] / 8), o = 10 * (t[0] - 8 * i),
                            a = 10 * (t[1] - 8 * r), s = e.getElevationAt(i, r, !0, !0), l = e.getMeterToDEM(n),
                            c = Math.floor(.5 * (o * l - 1)), u = Math.floor(.5 * (a * l - 1)),
                            d = e.tileCoordToPixel(i, r), h = 2 * c + 1, p = 2 * u + 1, f = function (e, t, n, i, r) {
                                return [e.getElevationAtPixel(t, n, !0), e.getElevationAtPixel(t + r, n, !0), e.getElevationAtPixel(t, n + r, !0), e.getElevationAtPixel(t + i, n + r, !0)]
                            }(e, d.x - c, d.y - u, h, p), m = Math.abs(f[0] - f[1]), _ = Math.abs(f[2] - f[3]),
                            g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]), y = Math.min(.25, .5 * l * (m + _) / h),
                            v = Math.min(.25, .5 * l * g / p);
                        return s + Math.max(y * o, v * a)
                    }(r, o, s) : l;
                return {base: l + (0 === n) ? -1 : n, top: c ? Math.max(u + i, l + n + 2) : l + i}
            }

            const Ec = ea([{name: "a_pos_normal", components: 2, type: "Int16"}, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }, {name: "a_linesofar", components: 1, type: "Float32"}], 4), {members: Cc} = Ec,
                Ac = ea([{name: "a_packed", components: 3, type: "Float32"}]), {members: Ic} = Ac,
                Pc = gc.VectorTileFeature.types, Rc = Math.cos(Math.PI / 180 * 37.5);

            class Yc {
                constructor(e) {
                    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(e => {
                        this.gradients[e.id] = {}
                    }), this.layoutVertexArray = new ra, this.layoutVertexArray2 = new oa, this.indexArray = new fa, this.programConfigurations = new as(e.layers, e.zoom), this.segments = new _s, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id)
                }

                populate(e, t, n, i) {
                    this.hasPattern = tc("line", this.layers, t);
                    const r = this.layers[0].layout.get("line-sort-key"), o = [];
                    for (const {feature: t, id: a, index: s, sourceLayerIndex: l} of e) {
                        const e = this.layers[0]._featureFilter.needGeometry, c = Os(t, e);
                        if (!this.layers[0]._featureFilter.filter(new Yo(this.zoom), c, n)) continue;
                        const u = r ? r.evaluate(c, {}, n) : void 0, d = {
                            id: a,
                            properties: t.properties,
                            type: t.type,
                            sourceLayerIndex: l,
                            index: s,
                            geometry: e ? c.geometry : zs(t, n, i),
                            patterns: {},
                            sortKey: u
                        };
                        o.push(d)
                    }
                    r && o.sort((e, t) => e.sortKey - t.sortKey);
                    const {lineAtlas: a, featureIndex: s} = t, l = this.addConstantDashes(a);
                    for (const i of o) {
                        const {geometry: r, index: o, sourceLayerIndex: c} = i;
                        if (l && this.addFeatureDashes(i, a), this.hasPattern) {
                            const e = nc("line", this.layers, i, this.zoom, t);
                            this.patternFeatures.push(e)
                        } else this.addFeature(i, r, o, n, a.positions, t.availableImages);
                        s.insert(e[o].feature, r, o, c, this.index)
                    }
                }

                addConstantDashes(e) {
                    let t = !1;
                    for (const n of this.layers) {
                        const i = n.paint.get("line-dasharray").value, r = n.layout.get("line-cap").value;
                        if ("constant" !== i.kind || "constant" !== r.kind) t = !0; else {
                            const t = r.value, n = i.value;
                            if (!n) continue;
                            e.addDash(n.from, t), e.addDash(n.to, t), n.other && e.addDash(n.other, t)
                        }
                    }
                    return t
                }

                addFeatureDashes(e, t) {
                    const n = this.zoom;
                    for (const i of this.layers) {
                        const r = i.paint.get("line-dasharray").value, o = i.layout.get("line-cap").value;
                        if ("constant" === r.kind && "constant" === o.kind) continue;
                        let a, s, l, c, u, d;
                        if ("constant" === r.kind) {
                            const e = r.value;
                            if (!e) continue;
                            a = e.other || e.to, s = e.to, l = e.from
                        } else a = r.evaluate({zoom: n - 1}, e), s = r.evaluate({zoom: n}, e), l = r.evaluate({zoom: n + 1}, e);
                        "constant" === o.kind ? c = u = d = o.value : (c = o.evaluate({zoom: n - 1}, e), u = o.evaluate({zoom: n}, e), d = o.evaluate({zoom: n + 1}, e)), t.addDash(a, c), t.addDash(s, u), t.addDash(l, d);
                        const h = t.getKey(a, c), p = t.getKey(s, u), f = t.getKey(l, d);
                        e.patterns[i.id] = {min: h, mid: p, max: f}
                    }
                }

                update(e, t, n, i) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, n, i)
                }

                addFeatures(e, t, n, i) {
                    for (const e of this.patternFeatures) this.addFeature(e, e.geometry, e.index, t, n, i)
                }

                isEmpty() {
                    return 0 === this.layoutVertexArray.length
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Ic)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Cc), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }

                lineFeatureClips(e) {
                    if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return {
                        start: +e.properties.mapbox_clip_start,
                        end: +e.properties.mapbox_clip_end
                    }
                }

                addFeature(e, t, n, i, r, o) {
                    const a = this.layers[0].layout, s = a.get("line-join").evaluate(e, {}),
                        l = a.get("line-cap").evaluate(e, {}), c = a.get("line-miter-limit"),
                        u = a.get("line-round-limit");
                    this.lineClips = this.lineFeatureClips(e);
                    for (const n of t) this.addLine(n, e, s, l, c, u);
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, r, o, i)
                }

                addLine(e, t, n, i, r, o) {
                    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                        this.lineClipsArray.push(this.lineClips);
                        for (let t = 0; t < e.length - 1; t++) this.totalDistance += e[t].dist(e[t + 1]);
                        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                    }
                    const a = "Polygon" === Pc[t.type];
                    let s = e.length;
                    for (; s >= 2 && e[s - 1].equals(e[s - 2]);) s--;
                    let l = 0;
                    for (; l < s - 1 && e[l].equals(e[l + 1]);) l++;
                    if (s < (a ? 3 : 2)) return;
                    "bevel" === n && (r = 1.05);
                    const c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
                        u = this.segments.prepareSegment(10 * s, this.layoutVertexArray, this.indexArray);
                    let d, h, p, f, m;
                    this.e1 = this.e2 = -1, a && (d = e[s - 2], m = e[l].sub(d)._unit()._perp());
                    for (let t = l; t < s; t++) {
                        if (p = t === s - 1 ? a ? e[l + 1] : void 0 : e[t + 1], p && e[t].equals(p)) continue;
                        m && (f = m), d && (h = d), d = e[t], m = p ? p.sub(d)._unit()._perp() : f, f = f || m;
                        let _ = f.add(m);
                        0 === _.x && 0 === _.y || _._unit();
                        const g = f.x * m.x + f.y * m.y, y = _.x * m.x + _.y * m.y, v = 0 !== y ? 1 / y : 1 / 0,
                            x = 2 * Math.sqrt(2 - 2 * y), b = y < Rc && h && p, w = f.x * m.y - f.y * m.x > 0;
                        if (b && t > l) {
                            const e = d.dist(h);
                            if (e > 2 * c) {
                                const t = d.sub(d.sub(h)._mult(c / e)._round());
                                this.updateDistance(h, t), this.addCurrentVertex(t, f, 0, 0, u), h = t
                            }
                        }
                        const M = h && p;
                        let T = M ? n : a ? "butt" : i;
                        if (M && "round" === T && (v < o ? T = "miter" : v <= 2 && (T = "fakeround")), "miter" === T && v > r && (T = "bevel"), "bevel" === T && (v > 2 && (T = "flipbevel"), v < r && (T = "miter")), h && this.updateDistance(h, d), "miter" === T) _._mult(v), this.addCurrentVertex(d, _, 0, 0, u); else if ("flipbevel" === T) {
                            if (v > 100) _ = m.mult(-1); else {
                                const e = v * f.add(m).mag() / f.sub(m).mag();
                                _._perp()._mult(e * (w ? -1 : 1))
                            }
                            this.addCurrentVertex(d, _, 0, 0, u), this.addCurrentVertex(d, _.mult(-1), 0, 0, u)
                        } else if ("bevel" === T || "fakeround" === T) {
                            const e = -Math.sqrt(v * v - 1), t = w ? e : 0, n = w ? 0 : e;
                            if (h && this.addCurrentVertex(d, f, t, n, u), "fakeround" === T) {
                                const e = Math.round(180 * x / Math.PI / 20);
                                for (let t = 1; t < e; t++) {
                                    let n = t / e;
                                    if (.5 !== n) {
                                        const e = n - .5;
                                        n += n * e * (n - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * e * e + (.848013 + g * (.215638 * g - 1.06021)))
                                    }
                                    const i = m.sub(f)._mult(n)._add(f)._unit()._mult(w ? -1 : 1);
                                    this.addHalfVertex(d, i.x, i.y, !1, w, 0, u)
                                }
                            }
                            p && this.addCurrentVertex(d, m, -t, -n, u)
                        } else if ("butt" === T) this.addCurrentVertex(d, _, 0, 0, u); else if ("square" === T) {
                            const e = h ? 1 : -1;
                            h || this.addCurrentVertex(d, _, e, e, u), this.addCurrentVertex(d, _, 0, 0, u), h && this.addCurrentVertex(d, _, e, e, u)
                        } else "round" === T && (h && (this.addCurrentVertex(d, f, 0, 0, u), this.addCurrentVertex(d, f, 1, 1, u, !0)), p && (this.addCurrentVertex(d, m, -1, -1, u, !0), this.addCurrentVertex(d, m, 0, 0, u)));
                        if (b && t < s - 1) {
                            const e = d.dist(p);
                            if (e > 2 * c) {
                                const t = d.add(p.sub(d)._mult(c / e)._round());
                                this.updateDistance(d, t), this.addCurrentVertex(t, m, 0, 0, u), d = t
                            }
                        }
                    }
                }

                addCurrentVertex(e, t, n, i, r, o = !1) {
                    const a = t.y * i - t.x, s = -t.y - t.x * i;
                    this.addHalfVertex(e, t.x + t.y * n, t.y - t.x * n, o, !1, n, r), this.addHalfVertex(e, a, s, o, !0, -i, r)
                }

                addHalfVertex({x: e, y: t}, n, i, r, o, a, s) {
                    this.layoutVertexArray.emplaceBack((e << 1) + (r ? 1 : 0), (t << 1) + (o ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * i) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineSoFar);
                    const l = s.vertexLength++;
                    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), s.primitiveLength++), o ? this.e2 = l : this.e1 = l
                }

                updateScaledDistance() {
                    if (this.lineClips) {
                        const e = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                        this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = e * this.lineClips.start + this.distance
                    } else this.lineSoFar = this.distance
                }

                updateDistance(e, t) {
                    this.distance += e.dist(t), this.updateScaledDistance()
                }
            }

            Yr("LineBucket", Yc, {omit: ["layers", "patternFeatures"]});
            const zc = new $o({
                "line-cap": new Vo(vt.layout_line["line-cap"]),
                "line-join": new Vo(vt.layout_line["line-join"]),
                "line-miter-limit": new Wo(vt.layout_line["line-miter-limit"]),
                "line-round-limit": new Wo(vt.layout_line["line-round-limit"]),
                "line-sort-key": new Vo(vt.layout_line["line-sort-key"])
            });
            var Oc = {
                paint: new $o({
                    "line-opacity": new Vo(vt.paint_line["line-opacity"]),
                    "line-color": new Vo(vt.paint_line["line-color"]),
                    "line-translate": new Wo(vt.paint_line["line-translate"]),
                    "line-translate-anchor": new Wo(vt.paint_line["line-translate-anchor"]),
                    "line-width": new Vo(vt.paint_line["line-width"]),
                    "line-gap-width": new Vo(vt.paint_line["line-gap-width"]),
                    "line-offset": new Vo(vt.paint_line["line-offset"]),
                    "line-blur": new Vo(vt.paint_line["line-blur"]),
                    "line-dasharray": new Go(vt.paint_line["line-dasharray"]),
                    "line-pattern": new Go(vt.paint_line["line-pattern"]),
                    "line-gradient": new Zo(vt.paint_line["line-gradient"])
                }), layout: zc
            };
            const Fc = new class extends Vo {
                possiblyEvaluate(e, t) {
                    return t = new Yo(Math.floor(t.zoom), {
                        now: t.now,
                        fadeDuration: t.fadeDuration,
                        zoomHistory: t.zoomHistory,
                        transition: t.transition
                    }), super.possiblyEvaluate(e, t)
                }

                evaluate(e, t, n, i) {
                    return t = ee({}, t, {zoom: Math.floor(t.zoom)}), super.evaluate(e, t, n, i)
                }
            }(Oc.paint.properties["line-width"].specification);

            function Bc(e, t) {
                return t > 0 ? t + 2 * e : e
            }

            Fc.useIntegerZoom = !0;
            const jc = ea([{name: "a_pos_offset", components: 4, type: "Int16"}, {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            }, {name: "a_pixeloffset", components: 4, type: "Int16"}, {
                name: "a_z_tile_anchor",
                components: 4,
                type: "Int16"
            }], 4), Hc = ea([{name: "a_projected_pos", components: 3, type: "Float32"}], 4);
            ea([{name: "a_fade_opacity", components: 1, type: "Uint32"}], 4);
            const Nc = ea([{name: "a_placed", components: 2, type: "Uint8"}, {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }]), Uc = ea([{name: "a_size_scale", components: 1, type: "Float32"}, {
                name: "a_padding",
                components: 2,
                type: "Float32"
            }]);
            ea([{type: "Int16", name: "projectedAnchorX"}, {type: "Int16", name: "projectedAnchorY"}, {
                type: "Int16",
                name: "projectedAnchorZ"
            }, {type: "Int16", name: "tileAnchorX"}, {type: "Int16", name: "tileAnchorY"}, {
                type: "Float32",
                name: "x1"
            }, {type: "Float32", name: "y1"}, {type: "Float32", name: "x2"}, {
                type: "Float32",
                name: "y2"
            }, {type: "Int16", name: "padding"}, {type: "Uint32", name: "featureIndex"}, {
                type: "Uint16",
                name: "sourceLayerIndex"
            }, {type: "Uint16", name: "bucketIndex"}]);
            const Wc = ea([{name: "a_pos", components: 3, type: "Int16"}, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {name: "a_extrude", components: 2, type: "Int16"}], 4),
                Vc = ea([{name: "a_pos_2f", components: 2, type: "Float32"}, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {name: "a_flags", components: 2, type: "Int16"}], 4);
            ea([{name: "triangle", components: 3, type: "Uint16"}]), ea([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {type: "Int16", name: "projectedAnchorY"}, {type: "Int16", name: "projectedAnchorZ"}, {
                type: "Float32",
                name: "tileAnchorX"
            }, {type: "Float32", name: "tileAnchorY"}, {type: "Uint16", name: "glyphStartIndex"}, {
                type: "Uint16",
                name: "numGlyphs"
            }, {type: "Uint32", name: "vertexStartIndex"}, {type: "Uint32", name: "lineStartIndex"}, {
                type: "Uint32",
                name: "lineLength"
            }, {type: "Uint16", name: "segment"}, {type: "Uint16", name: "lowerSize"}, {
                type: "Uint16",
                name: "upperSize"
            }, {type: "Float32", name: "lineOffsetX"}, {type: "Float32", name: "lineOffsetY"}, {
                type: "Uint8",
                name: "writingMode"
            }, {type: "Uint8", name: "placedOrientation"}, {type: "Uint8", name: "hidden"}, {
                type: "Uint32",
                name: "crossTileID"
            }, {type: "Int16", name: "associatedIconIndex"}, {type: "Uint8", name: "flipState"}]), ea([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {type: "Int16", name: "projectedAnchorY"}, {type: "Int16", name: "projectedAnchorZ"}, {
                type: "Float32",
                name: "tileAnchorX"
            }, {type: "Float32", name: "tileAnchorY"}, {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            }, {type: "Int16", name: "centerJustifiedTextSymbolIndex"}, {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            }, {type: "Int16", name: "verticalPlacedTextSymbolIndex"}, {
                type: "Int16",
                name: "placedIconSymbolIndex"
            }, {type: "Int16", name: "verticalPlacedIconSymbolIndex"}, {type: "Uint16", name: "key"}, {
                type: "Uint16",
                name: "textBoxStartIndex"
            }, {type: "Uint16", name: "textBoxEndIndex"}, {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            }, {type: "Uint16", name: "verticalTextBoxEndIndex"}, {
                type: "Uint16",
                name: "iconBoxStartIndex"
            }, {type: "Uint16", name: "iconBoxEndIndex"}, {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            }, {type: "Uint16", name: "verticalIconBoxEndIndex"}, {
                type: "Uint16",
                name: "featureIndex"
            }, {type: "Uint16", name: "numHorizontalGlyphVertices"}, {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            }, {type: "Uint16", name: "numIconVertices"}, {
                type: "Uint16",
                name: "numVerticalIconVertices"
            }, {type: "Uint16", name: "useRuntimeCollisionCircles"}, {
                type: "Uint32",
                name: "crossTileID"
            }, {type: "Float32", components: 2, name: "textOffset"}, {
                type: "Float32",
                name: "collisionCircleDiameter"
            }]), ea([{type: "Float32", name: "offsetX"}]), ea([{type: "Int16", name: "x"}, {
                type: "Int16",
                name: "y"
            }, {type: "Int16", name: "tileUnitDistanceFromAnchor"}]);
            const Gc = 128;

            function qc(e, t) {
                const {expression: n} = t;
                if ("constant" === n.kind) return {kind: "constant", layoutSize: n.evaluate(new Yo(e + 1))};
                if ("source" === n.kind) return {kind: "source"};
                {
                    const {zoomStops: t, interpolationType: i} = n;
                    let r = 0;
                    for (; r < t.length && t[r] <= e;) r++;
                    r = Math.max(0, r - 1);
                    let o = r;
                    for (; o < t.length && t[o] < e + 1;) o++;
                    o = Math.min(t.length - 1, o);
                    const a = t[r], s = t[o];
                    return "composite" === n.kind ? {
                        kind: "composite",
                        minZoom: a,
                        maxZoom: s,
                        interpolationType: i
                    } : {
                        kind: "camera",
                        minZoom: a,
                        maxZoom: s,
                        minSize: n.evaluate(new Yo(a)),
                        maxSize: n.evaluate(new Yo(s)),
                        interpolationType: i
                    }
                }
            }

            function Zc(e, {uSize: t, uSizeT: n}, {lowerSize: i, upperSize: r}) {
                return "source" === e.kind ? i / Gc : "composite" === e.kind ? On(i / Gc, r / Gc, n) : t
            }

            function $c(e, t) {
                let n = 0, i = 0;
                if ("constant" === e.kind) i = e.layoutSize; else if ("source" !== e.kind) {
                    const {interpolationType: r, minZoom: o, maxZoom: a} = e,
                        s = r ? $(Kn.interpolationFactor(r, t, o, a), 0, 1) : 0;
                    "camera" === e.kind ? i = On(e.minSize, e.maxSize, s) : n = s
                }
                return {uSizeT: n, uSize: i}
            }

            var Xc = Object.freeze({
                __proto__: null,
                getSizeData: qc,
                evaluateSizeForFeature: Zc,
                evaluateSizeForZoom: $c,
                SIZE_PACK_FACTOR: Gc
            });

            function Jc(e, t, n) {
                return e.sections.forEach(e => {
                    e.text = function (e, t, n) {
                        const i = t.layout.get("text-transform").evaluate(n, {});
                        return "uppercase" === i ? e = e.toLocaleUpperCase() : "lowercase" === i && (e = e.toLocaleLowerCase()), Ro.applyArabicShaping && (e = Ro.applyArabicShaping(e)), e
                    }(e.text, t, n)
                }), e
            }

            const Kc = {
                "!": "",
                "#": "",
                $: "",
                "%": "",
                "&": "",
                "(": "",
                ")": "",
                "*": "",
                "+": "",
                ",": "",
                "-": "",
                ".": "",
                "/": "",
                ":": "",
                ";": "",
                "<": "",
                "=": "",
                ">": "",
                "?": "",
                "@": "",
                "[": "",
                "\\": "",
                "]": "",
                "^": "",
                _: "",
                "`": "",
                "{": "",
                "|": "",
                "}": "",
                "~": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": ""
            };

            function Qc(e) {
                return "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e
            }

            function eu(e) {
                return "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e || "" === e
            }

            var tu = function (e, t, n, i, r) {
                var o, a, s = 8 * r - i - 1, l = (1 << s) - 1, c = l >> 1, u = -7, d = n ? r - 1 : 0, h = n ? -1 : 1,
                    p = e[t + d];
                for (d += h, o = p & (1 << -u) - 1, p >>= -u, u += s; u > 0; o = 256 * o + e[t + d], d += h, u -= 8) ;
                for (a = o & (1 << -u) - 1, o >>= -u, u += i; u > 0; a = 256 * a + e[t + d], d += h, u -= 8) ;
                if (0 === o) o = 1 - c; else {
                    if (o === l) return a ? NaN : 1 / 0 * (p ? -1 : 1);
                    a += Math.pow(2, i), o -= c
                }
                return (p ? -1 : 1) * a * Math.pow(2, o - i)
            }, nu = function (e, t, n, i, r, o) {
                var a, s, l, c = 8 * o - r - 1, u = (1 << c) - 1, d = u >> 1,
                    h = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = i ? 0 : o - 1, f = i ? 1 : -1,
                    m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t += a + d >= 1 ? h / l : h * Math.pow(2, 1 - d)) * l >= 2 && (a++, l /= 2), a + d >= u ? (s = 0, a = u) : a + d >= 1 ? (s = (t * l - 1) * Math.pow(2, r), a += d) : (s = t * Math.pow(2, d - 1) * Math.pow(2, r), a = 0)); r >= 8; e[n + p] = 255 & s, p += f, s /= 256, r -= 8) ;
                for (a = a << r | s, c += r; c > 0; e[n + p] = 255 & a, p += f, a /= 256, c -= 8) ;
                e[n + p - f] |= 128 * m
            }, iu = ru;

            function ru(e) {
                this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length
            }

            ru.Varint = 0, ru.Fixed64 = 1, ru.Bytes = 2, ru.Fixed32 = 5;
            var ou = 4294967296, au = 1 / ou, su = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");

            function lu(e) {
                return e.type === ru.Bytes ? e.readVarint() + e.pos : e.pos + 1
            }

            function cu(e, t, n) {
                return n ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0)
            }

            function uu(e, t, n) {
                var i = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
                n.realloc(i);
                for (var r = n.pos - 1; r >= e; r--) n.buf[r + i] = n.buf[r]
            }

            function du(e, t) {
                for (var n = 0; n < e.length; n++) t.writeVarint(e[n])
            }

            function hu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeSVarint(e[n])
            }

            function pu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeFloat(e[n])
            }

            function fu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeDouble(e[n])
            }

            function mu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeBoolean(e[n])
            }

            function _u(e, t) {
                for (var n = 0; n < e.length; n++) t.writeFixed32(e[n])
            }

            function gu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeSFixed32(e[n])
            }

            function yu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeFixed64(e[n])
            }

            function vu(e, t) {
                for (var n = 0; n < e.length; n++) t.writeSFixed64(e[n])
            }

            function xu(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3]
            }

            function bu(e, t, n) {
                e[n] = t, e[n + 1] = t >>> 8, e[n + 2] = t >>> 16, e[n + 3] = t >>> 24
            }

            function wu(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24)
            }

            function Mu(e, t, n) {
                t.glyphs = [], 1 === e && n.readMessage(Tu, t)
            }

            function Tu(e, t, n) {
                if (3 === e) {
                    const {id: e, bitmap: i, width: r, height: o, left: a, top: s, advance: l} = n.readMessage(ku, {});
                    t.glyphs.push({
                        id: e,
                        bitmap: new ml({width: r + 6, height: o + 6}, i),
                        metrics: {width: r, height: o, left: a, top: s, advance: l}
                    })
                } else 4 === e ? t.ascender = n.readSVarint() : 5 === e && (t.descender = n.readSVarint())
            }

            function ku(e, t, n) {
                1 === e ? t.id = n.readVarint() : 2 === e ? t.bitmap = n.readBytes() : 3 === e ? t.width = n.readVarint() : 4 === e ? t.height = n.readVarint() : 5 === e ? t.left = n.readSVarint() : 6 === e ? t.top = n.readSVarint() : 7 === e && (t.advance = n.readVarint())
            }

            function Su(e) {
                let t = 0, n = 0;
                for (const i of e) t += i.w * i.h, n = Math.max(n, i.w);
                e.sort((e, t) => t.h - e.h);
                const i = [{x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / .95)), n), h: 1 / 0}];
                let r = 0, o = 0;
                for (const t of e) for (let e = i.length - 1; e >= 0; e--) {
                    const n = i[e];
                    if (!(t.w > n.w || t.h > n.h)) {
                        if (t.x = n.x, t.y = n.y, o = Math.max(o, t.y + t.h), r = Math.max(r, t.x + t.w), t.w === n.w && t.h === n.h) {
                            const t = i.pop();
                            e < i.length && (i[e] = t)
                        } else t.h === n.h ? (n.x += t.w, n.w -= t.w) : t.w === n.w ? (n.y += t.h, n.h -= t.h) : (i.push({
                            x: n.x + t.w,
                            y: n.y,
                            w: n.w - t.w,
                            h: t.h
                        }), n.y += t.h, n.h -= t.h);
                        break
                    }
                }
                return {w: r, h: o, fill: t / (r * o) || 0}
            }

            ru.prototype = {
                destroy: function () {
                    this.buf = null
                }, readFields: function (e, t, n) {
                    for (n = n || this.length; this.pos < n;) {
                        var i = this.readVarint(), r = i >> 3, o = this.pos;
                        this.type = 7 & i, e(r, t, this), this.pos === o && this.skip(i)
                    }
                    return t
                }, readMessage: function (e, t) {
                    return this.readFields(e, t, this.readVarint() + this.pos)
                }, readFixed32: function () {
                    var e = xu(this.buf, this.pos);
                    return this.pos += 4, e
                }, readSFixed32: function () {
                    var e = wu(this.buf, this.pos);
                    return this.pos += 4, e
                }, readFixed64: function () {
                    var e = xu(this.buf, this.pos) + xu(this.buf, this.pos + 4) * ou;
                    return this.pos += 8, e
                }, readSFixed64: function () {
                    var e = xu(this.buf, this.pos) + wu(this.buf, this.pos + 4) * ou;
                    return this.pos += 8, e
                }, readFloat: function () {
                    var e = tu(this.buf, this.pos, !0, 23, 4);
                    return this.pos += 4, e
                }, readDouble: function () {
                    var e = tu(this.buf, this.pos, !0, 52, 8);
                    return this.pos += 8, e
                }, readVarint: function (e) {
                    var t, n, i = this.buf;
                    return t = 127 & (n = i[this.pos++]), n < 128 ? t : (t |= (127 & (n = i[this.pos++])) << 7, n < 128 ? t : (t |= (127 & (n = i[this.pos++])) << 14, n < 128 ? t : (t |= (127 & (n = i[this.pos++])) << 21, n < 128 ? t : function (e, t, n) {
                        var i, r, o = n.buf;
                        if (i = (112 & (r = o[n.pos++])) >> 4, r < 128) return cu(e, i, t);
                        if (i |= (127 & (r = o[n.pos++])) << 3, r < 128) return cu(e, i, t);
                        if (i |= (127 & (r = o[n.pos++])) << 10, r < 128) return cu(e, i, t);
                        if (i |= (127 & (r = o[n.pos++])) << 17, r < 128) return cu(e, i, t);
                        if (i |= (127 & (r = o[n.pos++])) << 24, r < 128) return cu(e, i, t);
                        if (i |= (1 & (r = o[n.pos++])) << 31, r < 128) return cu(e, i, t);
                        throw new Error("Expected varint not more than 10 bytes")
                    }(t |= (15 & (n = i[this.pos])) << 28, e, this))))
                }, readVarint64: function () {
                    return this.readVarint(!0)
                }, readSVarint: function () {
                    var e = this.readVarint();
                    return e % 2 == 1 ? (e + 1) / -2 : e / 2
                }, readBoolean: function () {
                    return Boolean(this.readVarint())
                }, readString: function () {
                    var e = this.readVarint() + this.pos, t = this.pos;
                    return this.pos = e, e - t >= 12 && su ? function (e, t, n) {
                        return su.decode(e.subarray(t, n))
                    }(this.buf, t, e) : function (e, t, n) {
                        for (var i = "", r = t; r < n;) {
                            var o, a, s, l = e[r], c = null, u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                            if (r + u > n) break;
                            1 === u ? l < 128 && (c = l) : 2 === u ? 128 == (192 & (o = e[r + 1])) && (c = (31 & l) << 6 | 63 & o) <= 127 && (c = null) : 3 === u ? (a = e[r + 2], 128 == (192 & (o = e[r + 1])) && 128 == (192 & a) && ((c = (15 & l) << 12 | (63 & o) << 6 | 63 & a) <= 2047 || c >= 55296 && c <= 57343) && (c = null)) : 4 === u && (a = e[r + 2], s = e[r + 3], 128 == (192 & (o = e[r + 1])) && 128 == (192 & a) && 128 == (192 & s) && ((c = (15 & l) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) <= 65535 || c >= 1114112) && (c = null)), null === c ? (c = 65533, u = 1) : c > 65535 && (c -= 65536, i += String.fromCharCode(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), i += String.fromCharCode(c), r += u
                        }
                        return i
                    }(this.buf, t, e)
                }, readBytes: function () {
                    var e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e);
                    return this.pos = e, t
                }, readPackedVarint: function (e, t) {
                    if (this.type !== ru.Bytes) return e.push(this.readVarint(t));
                    var n = lu(this);
                    for (e = e || []; this.pos < n;) e.push(this.readVarint(t));
                    return e
                }, readPackedSVarint: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readSVarint());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readSVarint());
                    return e
                }, readPackedBoolean: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readBoolean());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readBoolean());
                    return e
                }, readPackedFloat: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readFloat());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readFloat());
                    return e
                }, readPackedDouble: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readDouble());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readDouble());
                    return e
                }, readPackedFixed32: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readFixed32());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readFixed32());
                    return e
                }, readPackedSFixed32: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readSFixed32());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readSFixed32());
                    return e
                }, readPackedFixed64: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readFixed64());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readFixed64());
                    return e
                }, readPackedSFixed64: function (e) {
                    if (this.type !== ru.Bytes) return e.push(this.readSFixed64());
                    var t = lu(this);
                    for (e = e || []; this.pos < t;) e.push(this.readSFixed64());
                    return e
                }, skip: function (e) {
                    var t = 7 & e;
                    if (t === ru.Varint) for (; this.buf[this.pos++] > 127;) ; else if (t === ru.Bytes) this.pos = this.readVarint() + this.pos; else if (t === ru.Fixed32) this.pos += 4; else {
                        if (t !== ru.Fixed64) throw new Error("Unimplemented type: " + t);
                        this.pos += 8
                    }
                }, writeTag: function (e, t) {
                    this.writeVarint(e << 3 | t)
                }, realloc: function (e) {
                    for (var t = this.length || 16; t < this.pos + e;) t *= 2;
                    if (t !== this.length) {
                        var n = new Uint8Array(t);
                        n.set(this.buf), this.buf = n, this.length = t
                    }
                }, finish: function () {
                    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
                }, writeFixed32: function (e) {
                    this.realloc(4), bu(this.buf, e, this.pos), this.pos += 4
                }, writeSFixed32: function (e) {
                    this.realloc(4), bu(this.buf, e, this.pos), this.pos += 4
                }, writeFixed64: function (e) {
                    this.realloc(8), bu(this.buf, -1 & e, this.pos), bu(this.buf, Math.floor(e * au), this.pos + 4), this.pos += 8
                }, writeSFixed64: function (e) {
                    this.realloc(8), bu(this.buf, -1 & e, this.pos), bu(this.buf, Math.floor(e * au), this.pos + 4), this.pos += 8
                }, writeVarint: function (e) {
                    (e = +e || 0) > 268435455 || e < 0 ? function (e, t) {
                        var n, i;
                        if (e >= 0 ? (n = e % 4294967296 | 0, i = e / 4294967296 | 0) : (i = ~(-e / 4294967296), 4294967295 ^ (n = ~(-e % 4294967296)) ? n = n + 1 | 0 : (n = 0, i = i + 1 | 0)), e >= 0x10000000000000000 || e < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
                        t.realloc(10), function (e, t, n) {
                            n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, n.buf[n.pos] = 127 & (e >>>= 7)
                        }(n, 0, t), function (e, t) {
                            var n = (7 & e) << 4;
                            t.buf[t.pos++] |= n | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e)))))
                        }(i, t)
                    }(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127))))
                }, writeSVarint: function (e) {
                    this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e)
                }, writeBoolean: function (e) {
                    this.writeVarint(Boolean(e))
                }, writeString: function (e) {
                    e = String(e), this.realloc(4 * e.length), this.pos++;
                    var t = this.pos;
                    this.pos = function (e, t, n) {
                        for (var i, r, o = 0; o < t.length; o++) {
                            if ((i = t.charCodeAt(o)) > 55295 && i < 57344) {
                                if (!r) {
                                    i > 56319 || o + 1 === t.length ? (e[n++] = 239, e[n++] = 191, e[n++] = 189) : r = i;
                                    continue
                                }
                                if (i < 56320) {
                                    e[n++] = 239, e[n++] = 191, e[n++] = 189, r = i;
                                    continue
                                }
                                i = r - 55296 << 10 | i - 56320 | 65536, r = null
                            } else r && (e[n++] = 239, e[n++] = 191, e[n++] = 189, r = null);
                            i < 128 ? e[n++] = i : (i < 2048 ? e[n++] = i >> 6 | 192 : (i < 65536 ? e[n++] = i >> 12 | 224 : (e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128), e[n++] = i >> 6 & 63 | 128), e[n++] = 63 & i | 128)
                        }
                        return n
                    }(this.buf, e, this.pos);
                    var n = this.pos - t;
                    n >= 128 && uu(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n
                }, writeFloat: function (e) {
                    this.realloc(4), nu(this.buf, e, this.pos, !0, 23, 4), this.pos += 4
                }, writeDouble: function (e) {
                    this.realloc(8), nu(this.buf, e, this.pos, !0, 52, 8), this.pos += 8
                }, writeBytes: function (e) {
                    var t = e.length;
                    this.writeVarint(t), this.realloc(t);
                    for (var n = 0; n < t; n++) this.buf[this.pos++] = e[n]
                }, writeRawMessage: function (e, t) {
                    this.pos++;
                    var n = this.pos;
                    e(t, this);
                    var i = this.pos - n;
                    i >= 128 && uu(n, i, this), this.pos = n - 1, this.writeVarint(i), this.pos += i
                }, writeMessage: function (e, t, n) {
                    this.writeTag(e, ru.Bytes), this.writeRawMessage(t, n)
                }, writePackedVarint: function (e, t) {
                    t.length && this.writeMessage(e, du, t)
                }, writePackedSVarint: function (e, t) {
                    t.length && this.writeMessage(e, hu, t)
                }, writePackedBoolean: function (e, t) {
                    t.length && this.writeMessage(e, mu, t)
                }, writePackedFloat: function (e, t) {
                    t.length && this.writeMessage(e, pu, t)
                }, writePackedDouble: function (e, t) {
                    t.length && this.writeMessage(e, fu, t)
                }, writePackedFixed32: function (e, t) {
                    t.length && this.writeMessage(e, _u, t)
                }, writePackedSFixed32: function (e, t) {
                    t.length && this.writeMessage(e, gu, t)
                }, writePackedFixed64: function (e, t) {
                    t.length && this.writeMessage(e, yu, t)
                }, writePackedSFixed64: function (e, t) {
                    t.length && this.writeMessage(e, vu, t)
                }, writeBytesField: function (e, t) {
                    this.writeTag(e, ru.Bytes), this.writeBytes(t)
                }, writeFixed32Field: function (e, t) {
                    this.writeTag(e, ru.Fixed32), this.writeFixed32(t)
                }, writeSFixed32Field: function (e, t) {
                    this.writeTag(e, ru.Fixed32), this.writeSFixed32(t)
                }, writeFixed64Field: function (e, t) {
                    this.writeTag(e, ru.Fixed64), this.writeFixed64(t)
                }, writeSFixed64Field: function (e, t) {
                    this.writeTag(e, ru.Fixed64), this.writeSFixed64(t)
                }, writeVarintField: function (e, t) {
                    this.writeTag(e, ru.Varint), this.writeVarint(t)
                }, writeSVarintField: function (e, t) {
                    this.writeTag(e, ru.Varint), this.writeSVarint(t)
                }, writeStringField: function (e, t) {
                    this.writeTag(e, ru.Bytes), this.writeString(t)
                }, writeFloatField: function (e, t) {
                    this.writeTag(e, ru.Fixed32), this.writeFloat(t)
                }, writeDoubleField: function (e, t) {
                    this.writeTag(e, ru.Fixed64), this.writeDouble(t)
                }, writeBooleanField: function (e, t) {
                    this.writeVarintField(e, Boolean(t))
                }
            };

            class Du {
                constructor(e, {pixelRatio: t, version: n, stretchX: i, stretchY: r, content: o}) {
                    this.paddedRect = e, this.pixelRatio = t, this.stretchX = i, this.stretchY = r, this.content = o, this.version = n
                }

                get tl() {
                    return [this.paddedRect.x + 1, this.paddedRect.y + 1]
                }

                get br() {
                    return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
                }

                get displaySize() {
                    return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
                }
            }

            class Lu {
                constructor(e, t) {
                    const n = {}, i = {};
                    this.haveRenderCallbacks = [];
                    const r = [];
                    this.addImages(e, n, r), this.addImages(t, i, r);
                    const {w: o, h: a} = Su(r), s = new _l({width: o || 1, height: a || 1});
                    for (const t in e) {
                        const i = e[t], r = n[t].paddedRect;
                        _l.copy(i.data, s, {x: 0, y: 0}, {x: r.x + 1, y: r.y + 1}, i.data)
                    }
                    for (const e in t) {
                        const n = t[e], r = i[e].paddedRect, o = r.x + 1, a = r.y + 1, l = n.data.width,
                            c = n.data.height;
                        _l.copy(n.data, s, {x: 0, y: 0}, {x: o, y: a}, n.data), _l.copy(n.data, s, {
                            x: 0,
                            y: c - 1
                        }, {x: o, y: a - 1}, {width: l, height: 1}), _l.copy(n.data, s, {x: 0, y: 0}, {
                            x: o,
                            y: a + c
                        }, {width: l, height: 1}), _l.copy(n.data, s, {x: l - 1, y: 0}, {x: o - 1, y: a}, {
                            width: 1,
                            height: c
                        }), _l.copy(n.data, s, {x: 0, y: 0}, {x: o + l, y: a}, {width: 1, height: c})
                    }
                    this.image = s, this.iconPositions = n, this.patternPositions = i
                }

                addImages(e, t, n) {
                    for (const i in e) {
                        const r = e[i], o = {x: 0, y: 0, w: r.data.width + 2, h: r.data.height + 2};
                        n.push(o), t[i] = new Du(o, r), r.hasRenderCallback && this.haveRenderCallbacks.push(i)
                    }
                }

                patchUpdatedImages(e, t) {
                    e.dispatchRenderCallbacks(this.haveRenderCallbacks);
                    for (const n in e.updatedImages) this.patchUpdatedImage(this.iconPositions[n], e.getImage(n), t), this.patchUpdatedImage(this.patternPositions[n], e.getImage(n), t)
                }

                patchUpdatedImage(e, t, n) {
                    if (!e || !t) return;
                    if (e.version === t.version) return;
                    e.version = t.version;
                    const [i, r] = e.tl;
                    n.update(t.data, void 0, {x: i, y: r})
                }
            }

            Yr("ImagePosition", Du), Yr("ImageAtlas", Lu);
            const Eu = {horizontal: 1, vertical: 2, horizontalOnly: 3};

            class Cu {
                constructor() {
                    this.scale = 1, this.fontStack = "", this.imageName = null
                }

                static forText(e, t) {
                    const n = new Cu;
                    return n.scale = e || 1, n.fontStack = t, n
                }

                static forImage(e) {
                    const t = new Cu;
                    return t.imageName = e, t
                }
            }

            class Au {
                constructor() {
                    this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
                }

                static fromFeature(e, t) {
                    const n = new Au;
                    for (let i = 0; i < e.sections.length; i++) {
                        const r = e.sections[i];
                        r.image ? n.addImageSection(r) : n.addTextSection(r, t)
                    }
                    return n
                }

                length() {
                    return this.text.length
                }

                getSection(e) {
                    return this.sections[this.sectionIndex[e]]
                }

                getSections() {
                    return this.sections
                }

                getSectionIndex(e) {
                    return this.sectionIndex[e]
                }

                getCharCode(e) {
                    return this.text.charCodeAt(e)
                }

                verticalizePunctuation(e) {
                    this.text = function (e, t) {
                        let n = "";
                        for (let i = 0; i < e.length; i++) {
                            const r = e.charCodeAt(i + 1) || null, o = e.charCodeAt(i - 1) || null;
                            n += !t && (r && vo(r) && !Kc[e[i + 1]] || o && vo(o) && !Kc[e[i - 1]]) || !Kc[e[i]] ? e[i] : Kc[e[i]]
                        }
                        return n
                    }(this.text, e)
                }

                trim() {
                    let e = 0;
                    for (let t = 0; t < this.text.length && Pu[this.text.charCodeAt(t)]; t++) e++;
                    let t = this.text.length;
                    for (let n = this.text.length - 1; n >= 0 && n >= e && Pu[this.text.charCodeAt(n)]; n--) t--;
                    this.text = this.text.substring(e, t), this.sectionIndex = this.sectionIndex.slice(e, t)
                }

                substring(e, t) {
                    const n = new Au;
                    return n.text = this.text.substring(e, t), n.sectionIndex = this.sectionIndex.slice(e, t), n.sections = this.sections, n
                }

                toString() {
                    return this.text
                }

                getMaxScale() {
                    return this.sectionIndex.reduce((e, t) => Math.max(e, this.sections[t].scale), 0)
                }

                addTextSection(e, t) {
                    this.text += e.text, this.sections.push(Cu.forText(e.scale, e.fontStack || t));
                    const n = this.sections.length - 1;
                    for (let t = 0; t < e.text.length; ++t) this.sectionIndex.push(n)
                }

                addImageSection(e) {
                    const t = e.image ? e.image.name : "";
                    if (0 === t.length) return void he("Can't add FormattedSection with an empty image.");
                    const n = this.getNextImageSectionCharCode();
                    n ? (this.text += String.fromCharCode(n), this.sections.push(Cu.forImage(t)), this.sectionIndex.push(this.sections.length - 1)) : he("Reached maximum number of images 6401")
                }

                getNextImageSectionCharCode() {
                    return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
                }
            }

            function Iu(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m) {
                const _ = Au.fromFeature(e, r);
                let g;
                d === Eu.vertical && _.verticalizePunctuation(h);
                const {processBidirectionalText: y, processStyledBidirectionalText: v} = Ro;
                if (y && 1 === _.sections.length) {
                    g = [];
                    const e = y(_.toString(), Bu(_, c, o, t, i, p, f));
                    for (const t of e) {
                        const e = new Au;
                        e.text = t, e.sections = _.sections;
                        for (let n = 0; n < t.length; n++) e.sectionIndex.push(0);
                        g.push(e)
                    }
                } else if (v) {
                    g = [];
                    const e = v(_.text, _.sectionIndex, Bu(_, c, o, t, i, p, f));
                    for (const t of e) {
                        const e = new Au;
                        e.text = t[0], e.sectionIndex = t[1], e.sections = _.sections, g.push(e)
                    }
                } else g = function (e, t) {
                    const n = [], i = e.text;
                    let r = 0;
                    for (const i of t) n.push(e.substring(r, i)), r = i;
                    return r < i.length && n.push(e.substring(r, i.length)), n
                }(_, Bu(_, c, o, t, i, p, f));
                const x = [], b = {
                    positionedLines: x,
                    text: _.toString(),
                    top: u[1],
                    bottom: u[1],
                    left: u[0],
                    right: u[0],
                    writingMode: d,
                    iconsInText: !1,
                    verticalizable: !1,
                    hasBaseline: !1
                };
                return function (e, t, n, i, r, o, a, s, l, c, u, d) {
                    let h = 0, p = 0, f = 0;
                    const m = "right" === s ? 1 : "left" === s ? 0 : .5;
                    let _ = !1;
                    for (const e of r) {
                        const n = e.getSections();
                        for (const e of n) {
                            if (e.imageName) continue;
                            const n = t[e.fontStack];
                            if (n && (_ = void 0 !== n.ascender && void 0 !== n.descender, !_)) break
                        }
                        if (!_) break
                    }
                    let g = 0;
                    for (const a of r) {
                        a.trim();
                        const r = a.getMaxScale(), s = 24 * (r - 1), v = {positionedGlyphs: [], lineOffset: 0};
                        e.positionedLines[g] = v;
                        const x = v.positionedGlyphs;
                        let b = 0;
                        if (!a.length()) {
                            p += o, ++g;
                            continue
                        }
                        let w = 0, M = 0;
                        for (let o = 0; o < a.length(); o++) {
                            const s = a.getSection(o), f = a.getSectionIndex(o), m = a.getCharCode(o);
                            let g = s.scale, v = null, T = null, k = null, S = 24, D = 0;
                            const L = !(l === Eu.horizontal || !u && !yo(m) || u && (Pu[m] || (y = m, Hr(y) || Nr(y) || Ur(y) || lo(y) || po(y))));
                            if (s.imageName) {
                                const t = i[s.imageName];
                                if (!t) continue;
                                k = s.imageName, e.iconsInText = e.iconsInText || !0, T = t.paddedRect;
                                const n = t.displaySize;
                                g = 24 * g / d, v = {
                                    width: n[0],
                                    height: n[1],
                                    left: 1,
                                    top: -3,
                                    advance: L ? n[1] : n[0],
                                    localGlyph: !1
                                }, D = _ ? -v.height * g : 24 * r - 17 - n[1] * g, S = v.advance;
                                const o = (L ? n[0] : n[1]) * g - 24 * r;
                                o > 0 && o > b && (b = o)
                            } else {
                                const e = n[s.fontStack];
                                if (!e) continue;
                                e[m] && (T = e[m]);
                                const i = t[s.fontStack];
                                if (!i) continue;
                                const o = i.glyphs[m];
                                if (!o) continue;
                                if (v = o.metrics, S = 8203 !== m ? 24 : 0, _) {
                                    const e = void 0 !== i.ascender ? Math.abs(i.ascender) : 0,
                                        t = void 0 !== i.descender ? Math.abs(i.descender) : 0, n = (e + t) * g;
                                    w < n && (w = n, M = (e - t) / 2 * g), D = -e * g
                                } else D = 24 * (r - g) - 17
                            }
                            L ? (e.verticalizable = !0, x.push({
                                glyph: m,
                                imageName: k,
                                x: h,
                                y: p + D,
                                vertical: L,
                                scale: g,
                                localGlyph: v.localGlyph,
                                fontStack: s.fontStack,
                                sectionIndex: f,
                                metrics: v,
                                rect: T
                            }), h += S * g + c) : (x.push({
                                glyph: m,
                                imageName: k,
                                x: h,
                                y: p + D,
                                vertical: L,
                                scale: g,
                                localGlyph: v.localGlyph,
                                fontStack: s.fontStack,
                                sectionIndex: f,
                                metrics: v,
                                rect: T
                            }), h += v.advance * g + c)
                        }
                        0 !== x.length && (f = Math.max(h - c, f), _ ? Hu(x, m, b, M, o * r / 2) : Hu(x, m, b, 0, o / 2)), h = 0;
                        const T = o * r + b;
                        v.lineOffset = Math.max(b, s), p += T, ++g
                    }
                    var y;
                    const v = p, {horizontalAlign: x, verticalAlign: b} = ju(a);
                    (function (e, t, n, i, r, o) {
                        const a = (t - n) * r, s = -o * i;
                        for (const t of e) for (const e of t.positionedGlyphs) e.x += a, e.y += s
                    })(e.positionedLines, m, x, b, f, v), e.top += -b * v, e.bottom = e.top + v, e.left += -x * f, e.right = e.left + f, e.hasBaseline = _
                }(b, t, n, i, g, a, s, l, d, c, h, m), !function (e) {
                    for (const t of e) if (0 !== t.positionedGlyphs.length) return !1;
                    return !0
                }(x) && b
            }

            const Pu = {9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0}, Ru = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0
            };

            function Yu(e, t, n, i, r, o) {
                if (t.imageName) {
                    const e = i[t.imageName];
                    return e ? e.displaySize[0] * t.scale * 24 / o + r : 0
                }
                {
                    const i = n[t.fontStack], o = i && i.glyphs[e];
                    return o ? o.metrics.advance * t.scale + r : 0
                }
            }

            function zu(e, t, n, i) {
                const r = Math.pow(e - t, 2);
                return i ? e < t ? r / 2 : 2 * r : r + Math.abs(n) * n
            }

            function Ou(e, t, n) {
                let i = 0;
                return 10 === e && (i -= 1e4), n && (i += 150), 40 !== e && 65288 !== e || (i += 50), 41 !== t && 65289 !== t || (i += 50), i
            }

            function Fu(e, t, n, i, r, o) {
                let a = null, s = zu(t, n, r, o);
                for (const e of i) {
                    const i = zu(t - e.x, n, r, o) + e.badness;
                    i <= s && (a = e, s = i)
                }
                return {index: e, x: t, priorBreak: a, badness: s}
            }

            function Bu(e, t, n, i, r, o, a) {
                if ("point" !== o) return [];
                if (!e) return [];
                const s = [], l = function (e, t, n, i, r, o) {
                    let a = 0;
                    for (let n = 0; n < e.length(); n++) {
                        const s = e.getSection(n);
                        a += Yu(e.getCharCode(n), s, i, r, t, o)
                    }
                    return a / Math.max(1, Math.ceil(a / n))
                }(e, t, n, i, r, a), c = e.text.indexOf("") >= 0;
                let u = 0;
                for (let n = 0; n < e.length(); n++) {
                    const o = e.getSection(n), h = e.getCharCode(n);
                    if (Pu[h] || (u += Yu(h, o, i, r, t, a)), n < e.length() - 1) {
                        const t = !((d = h) < 11904 || !(Jr(d) || Xr(d) || uo(d) || so(d) || to(d) || Wr(d) || Kr(d) || qr(d) || no(d) || io(d) || eo(d) || fo(d) || Zr(d) || Gr(d) || Vr(d) || Qr(d) || $r(d) || co(d) || oo(d) || ro(d)));
                        (Ru[h] || t || o.imageName) && s.push(Fu(n + 1, u, l, s, Ou(h, e.getCharCode(n + 1), t && c), !1))
                    }
                }
                var d;
                return function e(t) {
                    return t ? e(t.priorBreak).concat(t.index) : []
                }(Fu(e.length(), u, l, s, 0, !0))
            }

            function ju(e) {
                let t = .5, n = .5;
                switch (e) {
                    case"right":
                    case"top-right":
                    case"bottom-right":
                        t = 1;
                        break;
                    case"left":
                    case"top-left":
                    case"bottom-left":
                        t = 0
                }
                switch (e) {
                    case"bottom":
                    case"bottom-right":
                    case"bottom-left":
                        n = 1;
                        break;
                    case"top":
                    case"top-right":
                    case"top-left":
                        n = 0
                }
                return {horizontalAlign: t, verticalAlign: n}
            }

            function Hu(e, t, n, i, r) {
                if (!(t || n || i || r)) return;
                const o = e.length - 1, a = e[o], s = (a.x + a.metrics.advance * a.scale) * t;
                for (let t = 0; t <= o; t++) e[t].x -= s, e[t].y += n + i + r
            }

            function Nu(e, t, n) {
                const {horizontalAlign: i, verticalAlign: r} = ju(n), o = t[0] - e.displaySize[0] * i,
                    a = t[1] - e.displaySize[1] * r;
                return {image: e, top: a, bottom: a + e.displaySize[1], left: o, right: o + e.displaySize[0]}
            }

            function Uu(e, t, n, i, r, o) {
                const a = e.image;
                let s;
                if (a.content) {
                    const e = a.content, t = a.pixelRatio || 1;
                    s = [e[0] / t, e[1] / t, a.displaySize[0] - e[2] / t, a.displaySize[1] - e[3] / t]
                }
                const l = t.left * o, c = t.right * o;
                let u, d, h, p;
                "width" === n || "both" === n ? (p = r[0] + l - i[3], d = r[0] + c + i[1]) : (p = r[0] + (l + c - a.displaySize[0]) / 2, d = p + a.displaySize[0]);
                const f = t.top * o, m = t.bottom * o;
                return "height" === n || "both" === n ? (u = r[1] + f - i[0], h = r[1] + m + i[2]) : (u = r[1] + (f + m - a.displaySize[1]) / 2, h = u + a.displaySize[1]), {
                    image: a,
                    top: u,
                    right: d,
                    bottom: h,
                    left: p,
                    collisionPadding: s
                }
            }

            class Wu extends r {
                constructor(e, t, n, i, r) {
                    super(e, t), this.angle = i, this.z = n, void 0 !== r && (this.segment = r)
                }

                clone() {
                    return new Wu(this.x, this.y, this.z, this.angle, this.segment)
                }
            }

            function Vu(e, t, n, i, r) {
                if (void 0 === t.segment) return !0;
                let o = t, a = t.segment + 1, s = 0;
                for (; s > -n / 2;) {
                    if (a--, a < 0) return !1;
                    s -= e[a].dist(o), o = e[a]
                }
                s += e[a].dist(e[a + 1]), a++;
                const l = [];
                let c = 0;
                for (; s < n / 2;) {
                    const t = e[a], n = e[a + 1];
                    if (!n) return !1;
                    let o = e[a - 1].angleTo(t) - t.angleTo(n);
                    for (o = Math.abs((o + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                        distance: s,
                        angleDelta: o
                    }), c += o; s - l[0].distance > i;) c -= l.shift().angleDelta;
                    if (c > r) return !1;
                    a++, s += t.dist(n)
                }
                return !0
            }

            function Gu(e) {
                let t = 0;
                for (let n = 0; n < e.length - 1; n++) t += e[n].dist(e[n + 1]);
                return t
            }

            function qu(e, t, n) {
                return e ? .6 * t * n : 0
            }

            function Zu(e, t) {
                return Math.max(e ? e.right - e.left : 0, t ? t.right - t.left : 0)
            }

            function $u(e, t, n, i, r, o) {
                const a = qu(n, r, o), s = Zu(n, i) * o;
                let l = 0;
                const c = Gu(e) / 2;
                for (let n = 0; n < e.length - 1; n++) {
                    const i = e[n], r = e[n + 1], o = i.dist(r);
                    if (l + o > c) {
                        const u = (c - l) / o, d = On(i.x, r.x, u), h = On(i.y, r.y, u),
                            p = new Wu(d, h, 0, r.angleTo(i), n);
                        return !a || Vu(e, p, s, a, t) ? p : void 0
                    }
                    l += o
                }
            }

            function Xu(e, t, n, i, r, o, a, s, l) {
                const c = qu(i, o, a), u = Zu(i, r), d = u * a,
                    h = 0 === e[0].x || e[0].x === l || 0 === e[0].y || e[0].y === l;
                return t - d < t / 4 && (t = d + t / 4), function e(t, n, i, r, o, a, s, l, c) {
                    const u = a / 2, d = Gu(t);
                    let h = 0, p = n - i, f = [];
                    for (let e = 0; e < t.length - 1; e++) {
                        const n = t[e], s = t[e + 1], l = n.dist(s), m = s.angleTo(n);
                        for (; p + i < h + l;) {
                            p += i;
                            const _ = (p - h) / l, g = On(n.x, s.x, _), y = On(n.y, s.y, _);
                            if (g >= 0 && g < c && y >= 0 && y < c && p - u >= 0 && p + u <= d) {
                                const n = new Wu(g, y, 0, m, e);
                                n._round(), r && !Vu(t, n, a, r, o) || f.push(n)
                            }
                        }
                        h += l
                    }
                    return l || f.length || s || (f = e(t, h / 2, i, r, o, a, s, !0, c)), f
                }(e, h ? t / 2 * s % t : (u / 2 + 2 * o) * a * s % t, t, c, n, d, h, !1, l)
            }

            function Ju(e, t, n, i, o) {
                const a = [];
                for (let s = 0; s < e.length; s++) {
                    const l = e[s];
                    let c;
                    for (let e = 0; e < l.length - 1; e++) {
                        let s = l[e], u = l[e + 1];
                        s.x < t && u.x < t || (s.x < t ? s = new r(t, s.y + (t - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x < t && (u = new r(t, s.y + (t - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y < n && u.y < n || (s.y < n ? s = new r(s.x + (n - s.y) / (u.y - s.y) * (u.x - s.x), n)._round() : u.y < n && (u = new r(s.x + (n - s.y) / (u.y - s.y) * (u.x - s.x), n)._round()), s.x >= i && u.x >= i || (s.x >= i ? s = new r(i, s.y + (i - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x >= i && (u = new r(i, s.y + (i - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y >= o && u.y >= o || (s.y >= o ? s = new r(s.x + (o - s.y) / (u.y - s.y) * (u.x - s.x), o)._round() : u.y >= o && (u = new r(s.x + (o - s.y) / (u.y - s.y) * (u.x - s.x), o)._round()), c && s.equals(c[c.length - 1]) || (c = [s], a.push(c)), c.push(u)))))
                    }
                }
                return a
            }

            Yr("Anchor", Wu);
            const Ku = 1e20;

            function Qu(e, t, n, i, r, o, a, s, l) {
                for (let c = t; c < t + i; c++) ed(e, n * o + c, o, r, a, s, l);
                for (let c = n; c < n + r; c++) ed(e, c * o + t, 1, i, a, s, l)
            }

            function ed(e, t, n, i, r, o, a) {
                o[0] = 0, a[0] = -Ku, a[1] = Ku, r[0] = e[t];
                for (let s = 1, l = 0, c = 0; s < i; s++) {
                    r[s] = e[t + s * n];
                    const i = s * s;
                    do {
                        const e = o[l];
                        c = (r[s] - r[e] + i - e * e) / (s - e) / 2
                    } while (c <= a[l] && --l > -1);
                    l++, o[l] = s, a[l] = c, a[l + 1] = Ku
                }
                for (let s = 0, l = 0; s < i; s++) {
                    for (; a[l + 1] < s;) l++;
                    const i = o[l], c = s - i;
                    e[t + s * n] = r[i] + c * c
                }
            }

            const td = {none: 0, ideographs: 1, all: 2};

            class nd {
                constructor(e, t, n) {
                    this.requestManager = e, this.localGlyphMode = t, this.localFontFamily = n, this.entries = {}, this.localGlyphs = {
                        200: {},
                        400: {},
                        500: {},
                        900: {}
                    }
                }

                setURL(e) {
                    this.url = e
                }

                getGlyphs(e, t) {
                    const n = [];
                    for (const t in e) for (const i of e[t]) n.push({stack: t, id: i});
                    K(n, ({stack: e, id: t}, n) => {
                        let i = this.entries[e];
                        i || (i = this.entries[e] = {
                            glyphs: {},
                            requests: {},
                            ranges: {},
                            ascender: void 0,
                            descender: void 0
                        });
                        let r = i.glyphs[t];
                        if (void 0 !== r) return void n(null, {stack: e, id: t, glyph: r});
                        if (r = this._tinySDF(i, e, t), r) return i.glyphs[t] = r, void n(null, {
                            stack: e,
                            id: t,
                            glyph: r
                        });
                        const o = Math.floor(t / 256);
                        if (256 * o > 65535) return void n(new Error("glyphs > 65535 not supported"));
                        if (i.ranges[o]) return void n(null, {stack: e, id: t, glyph: r});
                        let a = i.requests[o];
                        a || (a = i.requests[o] = [], nd.loadGlyphRange(e, o, this.url, this.requestManager, (e, t) => {
                            if (t) {
                                i.ascender = t.ascender, i.descender = t.descender;
                                for (const e in t.glyphs) this._doesCharSupportLocalGlyph(+e) || (i.glyphs[+e] = t.glyphs[+e]);
                                i.ranges[o] = !0
                            }
                            for (const n of a) n(e, t);
                            delete i.requests[o]
                        })), a.push((i, r) => {
                            i ? n(i) : r && n(null, {stack: e, id: t, glyph: r.glyphs[t] || null})
                        })
                    }, (e, n) => {
                        if (e) t(e); else if (n) {
                            const e = {};
                            for (const {
                                stack: t,
                                id: i,
                                glyph: r
                            } of n) void 0 === e[t] && (e[t] = {}), void 0 === e[t].glyphs && (e[t].glyphs = {}), e[t].glyphs[i] = r && {
                                id: r.id,
                                bitmap: r.bitmap.clone(),
                                metrics: r.metrics
                            }, e[t].ascender = this.entries[t].ascender, e[t].descender = this.entries[t].descender;
                            t(null, e)
                        }
                    })
                }

                _doesCharSupportLocalGlyph(e) {
                    return this.localGlyphMode !== td.none && (this.localGlyphMode === td.all ? !!this.localFontFamily : !!this.localFontFamily && (io(e) || ao(e) || Zr(e) || $r(e)) || qr(e))
                }

                _tinySDF(e, t, n) {
                    const i = this.localFontFamily;
                    if (!i || !this._doesCharSupportLocalGlyph(n)) return;
                    let r = e.tinySDF;
                    if (!r) {
                        let n = "400";
                        /bold/i.test(t) ? n = "900" : /medium/i.test(t) ? n = "500" : /light/i.test(t) && (n = "200"), r = e.tinySDF = new nd.TinySDF({
                            fontFamily: i,
                            fontWeight: n,
                            fontSize: 48,
                            buffer: 6,
                            radius: 16
                        }), r.fontWeight = n
                    }
                    if (this.localGlyphs[r.fontWeight][n]) return this.localGlyphs[r.fontWeight][n];
                    const o = String.fromCharCode(n), {
                        data: a,
                        width: s,
                        height: l,
                        glyphWidth: c,
                        glyphHeight: u,
                        glyphLeft: d,
                        glyphTop: h,
                        glyphAdvance: p
                    } = r.draw(o);
                    return this.localGlyphs[r.fontWeight][n] = {
                        id: n,
                        bitmap: new ml({width: s, height: l}, a),
                        metrics: {
                            width: c / 2,
                            height: u / 2,
                            left: d / 2,
                            top: h / 2 - 27,
                            advance: p / 2,
                            localGlyph: !0
                        }
                    }
                }
            }

            function id(e, t, n, i) {
                const o = [], a = e.image, s = a.pixelRatio, l = a.paddedRect.w - 2, c = a.paddedRect.h - 2,
                    u = e.right - e.left, d = e.bottom - e.top, h = a.stretchX || [[0, l]], p = a.stretchY || [[0, c]],
                    f = (e, t) => e + t[1] - t[0], m = h.reduce(f, 0), _ = p.reduce(f, 0), g = l - m, y = c - _;
                let v = 0, x = m, b = 0, w = _, M = 0, T = g, k = 0, S = y;
                if (a.content && i) {
                    const e = a.content;
                    v = rd(h, 0, e[0]), b = rd(p, 0, e[1]), x = rd(h, e[0], e[2]), w = rd(p, e[1], e[3]), M = e[0] - v, k = e[1] - b, T = e[2] - e[0] - x, S = e[3] - e[1] - w
                }
                const D = (i, o, l, c) => {
                    const h = ad(i.stretch - v, x, u, e.left), p = sd(i.fixed - M, T, i.stretch, m),
                        f = ad(o.stretch - b, w, d, e.top), g = sd(o.fixed - k, S, o.stretch, _),
                        y = ad(l.stretch - v, x, u, e.left), D = sd(l.fixed - M, T, l.stretch, m),
                        L = ad(c.stretch - b, w, d, e.top), E = sd(c.fixed - k, S, c.stretch, _), C = new r(h, f),
                        A = new r(y, f), I = new r(y, L), P = new r(h, L), R = new r(p / s, g / s),
                        Y = new r(D / s, E / s), z = t * Math.PI / 180;
                    if (z) {
                        const e = Math.sin(z), t = Math.cos(z), n = [t, -e, e, t];
                        C._matMult(n), A._matMult(n), P._matMult(n), I._matMult(n)
                    }
                    const O = i.stretch + i.fixed, F = o.stretch + o.fixed;
                    return {
                        tl: C,
                        tr: A,
                        bl: P,
                        br: I,
                        tex: {
                            x: a.paddedRect.x + 1 + O,
                            y: a.paddedRect.y + 1 + F,
                            w: l.stretch + l.fixed - O,
                            h: c.stretch + c.fixed - F
                        },
                        writingMode: void 0,
                        glyphOffset: [0, 0],
                        sectionIndex: 0,
                        pixelOffsetTL: R,
                        pixelOffsetBR: Y,
                        minFontScaleX: T / s / u,
                        minFontScaleY: S / s / d,
                        isSDF: n
                    }
                };
                if (i && (a.stretchX || a.stretchY)) {
                    const e = od(h, g, m), t = od(p, y, _);
                    for (let n = 0; n < e.length - 1; n++) {
                        const i = e[n], r = e[n + 1];
                        for (let e = 0; e < t.length - 1; e++) o.push(D(i, t[e], r, t[e + 1]))
                    }
                } else o.push(D({fixed: 0, stretch: -1}, {fixed: 0, stretch: -1}, {fixed: 0, stretch: l + 1}, {
                    fixed: 0,
                    stretch: c + 1
                }));
                return o
            }

            function rd(e, t, n) {
                let i = 0;
                for (const r of e) i += Math.max(t, Math.min(n, r[1])) - Math.max(t, Math.min(n, r[0]));
                return i
            }

            function od(e, t, n) {
                const i = [{fixed: -1, stretch: 0}];
                for (const [t, n] of e) {
                    const e = i[i.length - 1];
                    i.push({fixed: t - e.stretch, stretch: e.stretch}), i.push({
                        fixed: t - e.stretch,
                        stretch: e.stretch + (n - t)
                    })
                }
                return i.push({fixed: t + 1, stretch: n}), i
            }

            function ad(e, t, n, i) {
                return e / t * n + i
            }

            function sd(e, t, n, i) {
                return e - t * n / i
            }

            function ld(e, t, n, i) {
                const r = t + e.positionedLines[i].lineOffset;
                return 0 === i ? n + r / 2 : n + (r + (t + e.positionedLines[i - 1].lineOffset)) / 2
            }

            nd.loadGlyphRange = function (e, t, n, i, r) {
                const o = 256 * t, a = o + 255,
                    s = i.transformRequest(i.normalizeGlyphsURL(n).replace("{fontstack}", e).replace("{range}", `${o}-${a}`), nt.Glyphs);
                at(s, (e, t) => {
                    if (e) r(e); else if (t) {
                        const e = {}, n = function (e) {
                            return new iu(e).readFields(Mu, {})
                        }(t);
                        for (const t of n.glyphs) e[t.id] = t;
                        r(null, {glyphs: e, ascender: n.ascender, descender: n.descender})
                    }
                })
            }, nd.TinySDF = class {
                constructor({
                                fontSize: e = 24,
                                buffer: t = 3,
                                radius: n = 8,
                                cutoff: i = .25,
                                fontFamily: r = "sans-serif",
                                fontWeight: o = "normal",
                                fontStyle: a = "normal"
                            }) {
                    this.buffer = t, this.cutoff = i, this.radius = n;
                    const s = this.size = e + 4 * t, l = this._createCanvas(s),
                        c = this.ctx = l.getContext("2d", {willReadFrequently: !0});
                    c.font = `${a} ${o} ${e}px ${r}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(s * s), this.gridInner = new Float64Array(s * s), this.f = new Float64Array(s), this.z = new Float64Array(s + 1), this.v = new Uint16Array(s)
                }

                _createCanvas(e) {
                    const t = document.createElement("canvas");
                    return t.width = t.height = e, t
                }

                draw(e) {
                    const {
                            width: t,
                            actualBoundingBoxAscent: n,
                            actualBoundingBoxDescent: i,
                            actualBoundingBoxLeft: r,
                            actualBoundingBoxRight: o
                        } = this.ctx.measureText(e), a = Math.floor(n),
                        s = Math.min(this.size - this.buffer, Math.ceil(o - r)),
                        l = Math.min(this.size - this.buffer, Math.ceil(n) + Math.ceil(i)), c = s + 2 * this.buffer,
                        u = l + 2 * this.buffer, d = c * u, h = new Uint8ClampedArray(d), p = {
                            data: h,
                            width: c,
                            height: u,
                            glyphWidth: s,
                            glyphHeight: l,
                            glyphTop: a,
                            glyphLeft: 0,
                            glyphAdvance: t
                        };
                    if (0 === s || 0 === l) return p;
                    const {ctx: f, buffer: m, gridInner: _, gridOuter: g} = this;
                    f.clearRect(m, m, s, l), f.fillText(e, m, m + a + 1);
                    const y = f.getImageData(m, m, s, l);
                    g.fill(Ku, 0, d), _.fill(0, 0, d);
                    for (let e = 0; e < l; e++) for (let t = 0; t < s; t++) {
                        const n = y.data[4 * (e * s + t) + 3] / 255;
                        if (0 === n) continue;
                        const i = (e + m) * c + t + m;
                        if (1 === n) g[i] = 0, _[i] = Ku; else {
                            const e = .5 - n;
                            g[i] = e > 0 ? e * e : 0, _[i] = e < 0 ? e * e : 0
                        }
                    }
                    Qu(g, 0, 0, c, u, c, this.f, this.v, this.z), Qu(_, m, m, s, l, c, this.f, this.v, this.z);
                    for (let e = 0; e < d; e++) {
                        const t = Math.sqrt(g[e]) - Math.sqrt(_[e]);
                        h[e] = Math.round(255 - 255 * (t / this.radius + this.cutoff))
                    }
                    return p
                }
            };

            class cd {
                constructor(e = [], t = ud) {
                    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let e = (this.length >> 1) - 1; e >= 0; e--) this._down(e)
                }

                push(e) {
                    this.data.push(e), this.length++, this._up(this.length - 1)
                }

                pop() {
                    if (0 === this.length) return;
                    const e = this.data[0], t = this.data.pop();
                    return this.length--, this.length > 0 && (this.data[0] = t, this._down(0)), e
                }

                peek() {
                    return this.data[0]
                }

                _up(e) {
                    const {data: t, compare: n} = this, i = t[e];
                    for (; e > 0;) {
                        const r = e - 1 >> 1, o = t[r];
                        if (n(i, o) >= 0) break;
                        t[e] = o, e = r
                    }
                    t[e] = i
                }

                _down(e) {
                    const {data: t, compare: n} = this, i = this.length >> 1, r = t[e];
                    for (; e < i;) {
                        let i = 1 + (e << 1), o = t[i];
                        const a = i + 1;
                        if (a < this.length && n(t[a], o) < 0 && (i = a, o = t[a]), n(o, r) >= 0) break;
                        t[e] = o, e = i
                    }
                    t[e] = r
                }
            }

            function ud(e, t) {
                return e < t ? -1 : e > t ? 1 : 0
            }

            function dd(e, t = 1, n = !1) {
                let i = 1 / 0, o = 1 / 0, a = -1 / 0, s = -1 / 0;
                const l = e[0];
                for (let e = 0; e < l.length; e++) {
                    const t = l[e];
                    (!e || t.x < i) && (i = t.x), (!e || t.y < o) && (o = t.y), (!e || t.x > a) && (a = t.x), (!e || t.y > s) && (s = t.y)
                }
                const c = Math.min(a - i, s - o);
                let u = c / 2;
                const d = new cd([], hd);
                if (0 === c) return new r(i, o);
                for (let t = i; t < a; t += c) for (let n = o; n < s; n += c) d.push(new pd(t + u, n + u, u, e));
                let h = function (e) {
                    let t = 0, n = 0, i = 0;
                    const r = e[0];
                    for (let e = 0, o = r.length, a = o - 1; e < o; a = e++) {
                        const o = r[e], s = r[a], l = o.x * s.y - s.x * o.y;
                        n += (o.x + s.x) * l, i += (o.y + s.y) * l, t += 3 * l
                    }
                    return new pd(n / t, i / t, 0, e)
                }(e), p = d.length;
                for (; d.length;) {
                    const i = d.pop();
                    (i.d > h.d || !h.d) && (h = i, n && console.log("found best %d after %d probes", Math.round(1e4 * i.d) / 1e4, p)), i.max - h.d <= t || (u = i.h / 2, d.push(new pd(i.p.x - u, i.p.y - u, u, e)), d.push(new pd(i.p.x + u, i.p.y - u, u, e)), d.push(new pd(i.p.x - u, i.p.y + u, u, e)), d.push(new pd(i.p.x + u, i.p.y + u, u, e)), p += 4)
                }
                return n && (console.log("num probes: " + p), console.log("best distance: " + h.d)), h.p
            }

            function hd(e, t) {
                return t.max - e.max
            }

            function pd(e, t, n, i) {
                this.p = new r(e, t), this.h = n, this.d = function (e, t) {
                    let n = !1, i = 1 / 0;
                    for (let r = 0; r < t.length; r++) {
                        const o = t[r];
                        for (let t = 0, r = o.length, a = r - 1; t < r; a = t++) {
                            const r = o[t], s = o[a];
                            r.y > e.y != s.y > e.y && e.x < (s.x - r.x) * (e.y - r.y) / (s.y - r.y) + r.x && (n = !n), i = Math.min(i, qs(e, r, s))
                        }
                    }
                    return (n ? 1 : -1) * Math.sqrt(i)
                }(this.p, i), this.max = this.d + this.h * Math.SQRT2
            }

            const fd = Number.POSITIVE_INFINITY, md = Math.sqrt(2);

            function _d(e, t) {
                return t[1] !== fd ? function (e, t, n) {
                    let i = 0, r = 0;
                    switch (t = Math.abs(t), n = Math.abs(n), e) {
                        case"top-right":
                        case"top-left":
                        case"top":
                            r = n - 7;
                            break;
                        case"bottom-right":
                        case"bottom-left":
                        case"bottom":
                            r = 7 - n
                    }
                    switch (e) {
                        case"top-right":
                        case"bottom-right":
                        case"right":
                            i = -t;
                            break;
                        case"top-left":
                        case"bottom-left":
                        case"left":
                            i = t
                    }
                    return [i, r]
                }(e, t[0], t[1]) : function (e, t) {
                    let n = 0, i = 0;
                    t < 0 && (t = 0);
                    const r = t / md;
                    switch (e) {
                        case"top-right":
                        case"top-left":
                            i = r - 7;
                            break;
                        case"bottom-right":
                        case"bottom-left":
                            i = 7 - r;
                            break;
                        case"bottom":
                            i = 7 - t;
                            break;
                        case"top":
                            i = t - 7
                    }
                    switch (e) {
                        case"top-right":
                        case"bottom-right":
                            n = -r;
                            break;
                        case"top-left":
                        case"bottom-left":
                            n = r;
                            break;
                        case"left":
                            n = t;
                            break;
                        case"right":
                            n = -t
                    }
                    return [n, i]
                }(e, t[0])
            }

            function gd(e, t, n, i, r, o, a, s, l, c) {
                e.createArrays(), e.tilePixelRatio = gs / (512 * e.overscaling), e.compareText = {}, e.iconsNeedLinear = !1;
                const u = e.layers[0].layout, d = e.layers[0]._unevaluatedLayout._values, h = {};
                if ("composite" === e.textSizeData.kind) {
                    const {minZoom: t, maxZoom: n} = e.textSizeData;
                    h.compositeTextSizes = [d["text-size"].possiblyEvaluate(new Yo(t), s), d["text-size"].possiblyEvaluate(new Yo(n), s)]
                }
                if ("composite" === e.iconSizeData.kind) {
                    const {minZoom: t, maxZoom: n} = e.iconSizeData;
                    h.compositeIconSizes = [d["icon-size"].possiblyEvaluate(new Yo(t), s), d["icon-size"].possiblyEvaluate(new Yo(n), s)]
                }
                h.layoutTextSize = d["text-size"].possiblyEvaluate(new Yo(l + 1), s), h.layoutIconSize = d["icon-size"].possiblyEvaluate(new Yo(l + 1), s), h.textMaxSize = d["text-size"].possiblyEvaluate(new Yo(18), s);
                const p = "map" === u.get("text-rotation-alignment") && "point" !== u.get("symbol-placement"),
                    f = u.get("text-size");
                for (const o of e.features) {
                    const l = u.get("text-font").evaluate(o, {}, s).join(","), d = f.evaluate(o, {}, s),
                        m = h.layoutTextSize.evaluate(o, {}, s),
                        _ = (h.layoutIconSize.evaluate(o, {}, s), {horizontal: {}, vertical: void 0}), g = o.text;
                    let y, v = [0, 0];
                    if (g) {
                        const i = g.toString(), a = 24 * u.get("text-letter-spacing").evaluate(o, {}, s),
                            c = 24 * u.get("text-line-height").evaluate(o, {}, s), h = _o(i) ? a : 0,
                            f = u.get("text-anchor").evaluate(o, {}, s), y = u.get("text-variable-anchor");
                        if (!y) {
                            const e = u.get("text-radial-offset").evaluate(o, {}, s);
                            v = e ? _d(f, [24 * e, fd]) : u.get("text-offset").evaluate(o, {}, s).map(e => 24 * e)
                        }
                        let x = p ? "center" : u.get("text-justify").evaluate(o, {}, s);
                        const b = u.get("symbol-placement"), w = "point" === b,
                            M = "point" === b ? 24 * u.get("text-max-width").evaluate(o, {}, s) : 0, T = o => {
                                e.allowVerticalPlacement && mo(i) && (_.vertical = Iu(g, t, n, r, l, M, c, f, o, h, v, Eu.vertical, !0, b, m, d))
                            };
                        if (!p && y) {
                            const e = "auto" === x ? y.map(e => yd(e)) : [x];
                            let i = !1;
                            for (let o = 0; o < e.length; o++) {
                                const a = e[o];
                                if (!_.horizontal[a]) if (i) _.horizontal[a] = _.horizontal[0]; else {
                                    const e = Iu(g, t, n, r, l, M, c, "center", a, h, v, Eu.horizontal, !1, b, m, d);
                                    e && (_.horizontal[a] = e, i = 1 === e.positionedLines.length)
                                }
                            }
                            T("left")
                        } else {
                            if ("auto" === x && (x = yd(f)), w || u.get("text-writing-mode").indexOf("horizontal") >= 0 || !mo(i)) {
                                const e = Iu(g, t, n, r, l, M, c, f, x, h, v, Eu.horizontal, !1, b, m, d);
                                e && (_.horizontal[x] = e)
                            }
                            T("point" === b ? "left" : x)
                        }
                    }
                    let x = !1;
                    if (o.icon && o.icon.name) {
                        const t = i[o.icon.name];
                        t && (y = Nu(r[o.icon.name], u.get("icon-offset").evaluate(o, {}, s), u.get("icon-anchor").evaluate(o, {}, s)), x = t.sdf, void 0 === e.sdfIcons ? e.sdfIcons = t.sdf : e.sdfIcons !== t.sdf && he("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t.pixelRatio !== e.pixelRatio || 0 !== u.get("icon-rotate").constantOr(1)) && (e.iconsNeedLinear = !0))
                    }
                    const b = wd(_.horizontal) || _.vertical;
                    e.iconsInText || (e.iconsInText = !!b && b.iconsInText), (b || y) && vd(e, o, _, y, i, h, m, 0, v, x, a, s, c)
                }
                o && e.generateCollisionDebugBuffers(l, e.collisionBoxArray)
            }

            function yd(e) {
                switch (e) {
                    case"right":
                    case"top-right":
                    case"bottom-right":
                        return "right";
                    case"left":
                    case"top-left":
                    case"bottom-left":
                        return "left"
                }
                return "center"
            }

            function vd(e, t, n, i, r, o, a, s, l, c, u, d, h) {
                let p = o.textMaxSize.evaluate(t, {}, d);
                void 0 === p && (p = a);
                const f = e.layers[0].layout, m = f.get("icon-offset").evaluate(t, {}, d),
                    _ = wd(n.horizontal) || n.vertical, g = a / 24, y = e.tilePixelRatio * p / 24,
                    v = e.tilePixelRatio * f.get("symbol-spacing"), x = f.get("text-padding") * e.tilePixelRatio,
                    b = f.get("icon-padding") * e.tilePixelRatio, w = U(f.get("text-max-angle")),
                    M = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"),
                    T = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"),
                    k = f.get("symbol-placement"), S = v / 2, D = f.get("icon-text-fit");
                let L;
                i && "none" !== D && (e.allowVerticalPlacement && n.vertical && (L = Uu(i, n.vertical, D, f.get("icon-text-fit-padding"), m, g)), _ && (i = Uu(i, _, D, f.get("icon-text-fit-padding"), m, g)));
                const E = (a, s, p) => {
                    if (s.x < 0 || s.x >= gs || s.y < 0 || s.y >= gs) return;
                    const {x: f, y: _, z: g} = h.projectTilePoint(s.x, s.y, p), y = new Wu(f, _, g, 0, void 0);
                    !function (e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g, y, v, x, b, w, M, T) {
                        const k = e.addToLineVertexArray(t, i);
                        let S, D, L, E, C, A, I, P = 0, R = 0, Y = 0, z = 0, O = -1, F = -1;
                        const B = {};
                        let j = Ha(""), H = 0, N = 0;
                        if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [H, N] = l.layout.get("text-offset").evaluate(x, {}, T).map(e => 24 * e) : (H = 24 * l.layout.get("text-radial-offset").evaluate(x, {}, T), N = fd), e.allowVerticalPlacement && r.vertical) {
                            const e = r.vertical;
                            if (f) A = Td(e), s && (I = Td(s)); else {
                                const i = l.layout.get("text-rotate").evaluate(x, {}, T) + 90;
                                L = Md(c, n, t, u, d, h, e, p, i, m), s && (E = Md(c, n, t, u, d, h, s, g, i))
                            }
                        }
                        if (o) {
                            const i = l.layout.get("icon-rotate").evaluate(x, {}, T),
                                r = "none" !== l.layout.get("icon-text-fit"), a = id(o, i, w, r),
                                p = s ? id(s, i, w, r) : void 0;
                            D = Md(c, n, t, u, d, h, o, g, i), P = 4 * a.length;
                            const f = e.iconSizeData;
                            let m = null;
                            "source" === f.kind ? (m = [Gc * l.layout.get("icon-size").evaluate(x, {}, T)], m[0] > xd && he(e.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".')) : "composite" === f.kind && (m = [Gc * b.compositeIconSizes[0].evaluate(x, {}, T), Gc * b.compositeIconSizes[1].evaluate(x, {}, T)], (m[0] > xd || m[1] > xd) && he(e.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".')), e.addSymbols(e.icon, a, m, v, y, x, !1, n, t, k.lineStartIndex, k.lineLength, -1, M, T), O = e.icon.placedSymbolArray.length - 1, p && (R = 4 * p.length, e.addSymbols(e.icon, p, m, v, y, x, Eu.vertical, n, t, k.lineStartIndex, k.lineLength, -1, M, T), F = e.icon.placedSymbolArray.length - 1)
                        }
                        for (const i in r.horizontal) {
                            const o = r.horizontal[i];
                            S || (j = Ha(o.text), f ? C = Td(o) : S = Md(c, n, t, u, d, h, o, p, l.layout.get("text-rotate").evaluate(x, {}, T), m));
                            const s = 1 === o.positionedLines.length;
                            if (Y += bd(e, n, t, o, a, l, f, x, m, k, r.vertical ? Eu.horizontal : Eu.horizontalOnly, s ? Object.keys(r.horizontal) : [i], B, O, b, M, T), s) break
                        }
                        r.vertical && (z += bd(e, n, t, r.vertical, a, l, f, x, m, k, Eu.vertical, ["vertical"], B, F, b, M, T));
                        let U = -1;
                        const W = (e, t) => e ? Math.max(e, t) : t;
                        U = W(C, U), U = W(A, U), U = W(I, U);
                        const V = U > -1 ? 1 : 0;
                        e.glyphOffsetArray.length >= Pd.MAX_GLYPHS && he("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== x.sortKey && e.addToSortKeyRanges(e.symbolInstances.length, x.sortKey), e.symbolInstances.emplaceBack(n.x, n.y, n.z, t.x, t.y, B.right >= 0 ? B.right : -1, B.center >= 0 ? B.center : -1, B.left >= 0 ? B.left : -1, B.vertical >= 0 ? B.vertical : -1, O, F, j, void 0 !== S ? S : e.collisionBoxArray.length, void 0 !== S ? S + 1 : e.collisionBoxArray.length, void 0 !== L ? L : e.collisionBoxArray.length, void 0 !== L ? L + 1 : e.collisionBoxArray.length, void 0 !== D ? D : e.collisionBoxArray.length, void 0 !== D ? D + 1 : e.collisionBoxArray.length, E || e.collisionBoxArray.length, E ? E + 1 : e.collisionBoxArray.length, u, Y, z, P, R, V, 0, H, N, U)
                    }(e, s, y, a, n, i, r, L, e.layers[0], e.collisionBoxArray, t.index, t.sourceLayerIndex, e.index, x, M, l, 0, b, T, m, t, o, c, u, d)
                };
                if ("line" === k) for (const r of Ju(t.geometry, 0, 0, gs, gs)) {
                    const t = Xu(r, v, w, n.vertical || _, i, 24, y, e.overscaling, gs);
                    for (const n of t) {
                        const t = _;
                        t && kd(e, t.text, S, n) || E(r, n, d)
                    }
                } else if ("line-center" === k) {
                    for (const e of t.geometry) if (e.length > 1) {
                        const t = $u(e, w, n.vertical || _, i, 24, y);
                        t && E(e, t, d)
                    }
                } else if ("Polygon" === t.type) for (const e of Ql(t.geometry, 0)) {
                    const t = dd(e, 16);
                    E(e[0], new Wu(t.x, t.y, 0, 0, void 0), d)
                } else if ("LineString" === t.type) for (const e of t.geometry) E(e, new Wu(e[0].x, e[0].y, 0, 0, void 0), d); else if ("Point" === t.type) for (const e of t.geometry) for (const t of e) E([t], new Wu(t.x, t.y, 0, 0, void 0), d)
            }

            const xd = 32640;

            function bd(e, t, n, i, o, a, s, l, c, u, d, h, p, f, m, _, g) {
                const y = function (e, t, n, i, o, a, s, l) {
                    const c = [];
                    if (0 === t.positionedLines.length) return c;
                    const u = i.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180, d = function (e) {
                        const t = e[0], n = e[1], i = t * n;
                        return i > 0 ? [t, -n] : i < 0 ? [-t, n] : 0 === t ? [n, t] : [n, -t]
                    }(n);
                    let h = Math.abs(t.top - t.bottom);
                    for (const e of t.positionedLines) h -= e.lineOffset;
                    const p = t.positionedLines.length, f = h / p;
                    let m = t.top - n[1];
                    for (let e = 0; e < p; ++e) {
                        const i = t.positionedLines[e];
                        m = ld(t, f, m, e);
                        for (const e of i.positionedGlyphs) {
                            if (!e.rect) continue;
                            const i = e.rect || {};
                            let a = 4, h = !0, p = 1, f = 0;
                            if (e.imageName) {
                                const t = s[e.imageName];
                                if (!t) continue;
                                if (t.sdf) {
                                    he("SDF images are not supported in formatted text and will be ignored.");
                                    continue
                                }
                                h = !1, p = t.pixelRatio, a = 1 / p
                            }
                            const _ = (o || l) && e.vertical, g = e.metrics.advance * e.scale / 2, y = e.metrics,
                                v = e.rect;
                            if (null === v) continue;
                            l && t.verticalizable && (f = e.imageName ? g - e.metrics.width * e.scale / 2 : 0);
                            const x = o ? [e.x + g, e.y] : [0, 0];
                            let b = [0, 0], w = [0, 0], M = !1;
                            o || (_ ? (w = [e.x + g + d[0], e.y + d[1] - f], M = !0) : b = [e.x + g + n[0], e.y + n[1] - f]);
                            const T = v.w * e.scale / (p * (e.localGlyph ? 2 : 1)),
                                k = v.h * e.scale / (p * (e.localGlyph ? 2 : 1));
                            let S, D, L, E;
                            if (_) {
                                const t = e.y - m, n = new r(-g, g - t), i = -Math.PI / 2, o = new r(...w);
                                S = new r(-g + b[0], b[1]), S._rotateAround(i, n)._add(o), S.x += -t + g, S.y -= (y.left - a) * e.scale;
                                const s = e.imageName ? y.advance * e.scale : 24 * e.scale,
                                    l = String.fromCharCode(e.glyph);
                                Qc(l) ? S.x += (1 - a) * e.scale : eu(l) ? S.x += s - y.height * e.scale + (-a - 1) * e.scale : S.x += e.imageName || y.width + 2 * a === v.w && y.height + 2 * a === v.h ? (s - k) / 2 : (s - (y.height + 2 * a) * e.scale) / 2, D = new r(S.x, S.y - T), L = new r(S.x + k, S.y), E = new r(S.x + k, S.y - T)
                            } else {
                                const t = (y.left - a) * e.scale - g + b[0], n = (-y.top - a) * e.scale + b[1],
                                    i = t + T, o = n + k;
                                S = new r(t, n), D = new r(i, n), L = new r(t, o), E = new r(i, o)
                            }
                            if (u) {
                                let e;
                                e = o ? new r(0, 0) : M ? new r(d[0], d[1]) : new r(n[0], n[1]), S._rotateAround(u, e), D._rotateAround(u, e), L._rotateAround(u, e), E._rotateAround(u, e)
                            }
                            const C = new r(0, 0), A = new r(0, 0);
                            c.push({
                                tl: S,
                                tr: D,
                                bl: L,
                                br: E,
                                tex: i,
                                writingMode: t.writingMode,
                                glyphOffset: x,
                                sectionIndex: e.sectionIndex,
                                isSDF: h,
                                pixelOffsetTL: C,
                                pixelOffsetBR: A,
                                minFontScaleX: 0,
                                minFontScaleY: 0
                            })
                        }
                    }
                    return c
                }(0, i, c, a, s, l, o, e.allowVerticalPlacement), v = e.textSizeData;
                let x = null;
                "source" === v.kind ? (x = [Gc * a.layout.get("text-size").evaluate(l, {}, g)], x[0] > xd && he(e.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".')) : "composite" === v.kind && (x = [Gc * m.compositeTextSizes[0].evaluate(l, {}, g), Gc * m.compositeTextSizes[1].evaluate(l, {}, g)], (x[0] > xd || x[1] > xd) && he(e.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".')), e.addSymbols(e.text, y, x, c, s, l, d, t, n, u.lineStartIndex, u.lineLength, f, _, g);
                for (const t of h) p[t] = e.text.placedSymbolArray.length - 1;
                return 4 * y.length
            }

            function wd(e) {
                for (const t in e) return e[t];
                return null
            }

            function Md(e, t, n, i, o, a, s, l, c, u) {
                let d = s.top, h = s.bottom, p = s.left, f = s.right;
                const m = s.collisionPadding;
                if (m && (p -= m[0], d -= m[1], f += m[2], h += m[3]), c) {
                    const e = new r(p, d), t = new r(f, d), n = new r(p, h), i = new r(f, h), o = U(c);
                    let a = new r(0, 0);
                    u && (a = new r(u[0], u[1])), e._rotateAround(o, a), t._rotateAround(o, a), n._rotateAround(o, a), i._rotateAround(o, a), p = Math.min(e.x, t.x, n.x, i.x), f = Math.max(e.x, t.x, n.x, i.x), d = Math.min(e.y, t.y, n.y, i.y), h = Math.max(e.y, t.y, n.y, i.y)
                }
                return e.emplaceBack(t.x, t.y, t.z, n.x, n.y, p, d, f, h, l, i, o, a), e.length - 1
            }

            function Td(e) {
                e.collisionPadding && (e.top -= e.collisionPadding[1], e.bottom += e.collisionPadding[3]);
                const t = e.bottom - e.top;
                return t > 0 ? Math.max(10, t) : null
            }

            function kd(e, t, n, i) {
                const r = e.compareText;
                if (t in r) {
                    const e = r[t];
                    for (let t = e.length - 1; t >= 0; t--) if (i.dist(e[t]) < n) return !0
                } else r[t] = [];
                return r[t].push(i), !1
            }

            const Sd = gc.VectorTileFeature.types,
                Dd = [{name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0}];

            function Ld(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m) {
                const _ = u ? Math.min(xd, Math.round(u[0])) : 0, g = u ? Math.min(xd, Math.round(u[1])) : 0;
                e.emplaceBack(t, n, Math.round(32 * a), Math.round(32 * s), l, c, (_ << 1) + (d ? 1 : 0), g, 16 * h, 16 * p, 256 * f, 256 * m, i, r, o, 0)
            }

            function Ed(e, t, n) {
                e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n)
            }

            function Cd(e) {
                for (const t of e.sections) if (wo(t.text)) return !0;
                return !1
            }

            class Ad {
                constructor(e) {
                    this.layoutVertexArray = new la, this.indexArray = new fa, this.programConfigurations = e, this.segments = new _s, this.dynamicLayoutVertexArray = new oa, this.opacityVertexArray = new ca, this.placedSymbolArray = new La
                }

                isEmpty() {
                    return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length
                }

                upload(e, t, n, i) {
                    this.isEmpty() || (n && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, jc.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Hc.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Dd, !0), this.opacityVertexBuffer.itemSize = 1), (n || i) && this.programConfigurations.upload(e))
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
                }
            }

            Yr("SymbolBuffers", Ad);

            class Id {
                constructor(e, t, n) {
                    this.layoutVertexArray = new e, this.layoutAttributes = t, this.indexArray = new n, this.segments = new _s, this.collisionVertexArray = new pa, this.collisionVertexArrayExt = new oa
                }

                upload(e) {
                    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Nc.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, Uc.members, !0)
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy())
                }
            }

            Yr("CollisionBuffers", Id);

            class Pd {
                constructor(e) {
                    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = u([]), this.placementViewportMatrix = u([]);
                    const t = this.layers[0]._unevaluatedLayout._values;
                    this.textSizeData = qc(this.zoom, t["text-size"]), this.iconSizeData = qc(this.zoom, t["icon-size"]);
                    const n = this.layers[0].layout, i = n.get("symbol-sort-key"), r = n.get("symbol-z-order");
                    this.canOverlap = n.get("text-allow-overlap") || n.get("icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== r && void 0 !== i.constantOr(1), this.sortFeaturesByY = ("viewport-y" === r || "auto" === r && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n.get("text-writing-mode").map(e => Eu[e]), this.stateDependentLayerIds = this.layers.filter(e => e.isStateDependent()).map(e => e.id), this.sourceID = e.sourceID
                }

                createArrays() {
                    this.text = new Ad(new as(this.layers, this.zoom, e => /^text/.test(e))), this.icon = new Ad(new as(this.layers, this.zoom, e => /^icon/.test(e))), this.glyphOffsetArray = new Aa, this.lineVertexArray = new Ia, this.symbolInstances = new Ca
                }

                calculateGlyphDependencies(e, t, n, i, r) {
                    for (let n = 0; n < e.length; n++) if (t[e.charCodeAt(n)] = !0, i && r) {
                        const i = Kc[e.charAt(n)];
                        i && (t[i.charCodeAt(0)] = !0)
                    }
                }

                populate(e, t, n, i) {
                    const r = this.layers[0], o = r.layout, a = o.get("text-font"), s = o.get("text-field"),
                        l = o.get("icon-image"),
                        c = ("constant" !== s.value.kind || s.value.value instanceof Zt && !s.value.value.isEmpty() || s.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0),
                        u = "constant" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0,
                        d = o.get("symbol-sort-key");
                    if (this.features = [], !c && !u) return;
                    const h = t.iconDependencies, p = t.glyphDependencies, f = t.availableImages, m = new Yo(this.zoom);
                    for (const {feature: t, id: s, index: l, sourceLayerIndex: _} of e) {
                        const e = r._featureFilter.needGeometry, g = Os(t, e);
                        if (!r._featureFilter.filter(m, g, n)) continue;
                        let y, v;
                        if (e || (g.geometry = zs(t, n, i)), c) {
                            const e = r.getValueAndResolveTokens("text-field", g, n, f), t = Zt.factory(e);
                            Cd(t) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Io() || this.hasRTLText && Ro.isParsed()) && (y = Jc(t, r, g))
                        }
                        if (u) {
                            const e = r.getValueAndResolveTokens("icon-image", g, n, f);
                            v = e instanceof $t ? e : $t.fromString(e)
                        }
                        if (!y && !v) continue;
                        const x = this.sortFeaturesByKey ? d.evaluate(g, {}, n) : void 0;
                        if (this.features.push({
                            id: s,
                            text: y,
                            icon: v,
                            index: l,
                            sourceLayerIndex: _,
                            geometry: g.geometry,
                            properties: t.properties,
                            type: Sd[t.type],
                            sortKey: x
                        }), v && (h[v.name] = !0), y) {
                            const e = a.evaluate(g, {}, n).join(","),
                                t = "map" === o.get("text-rotation-alignment") && "point" !== o.get("symbol-placement");
                            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Eu.vertical) >= 0;
                            for (const n of y.sections) if (n.image) h[n.image.name] = !0; else {
                                const i = mo(y.toString()), r = n.fontStack || e, o = p[r] = p[r] || {};
                                this.calculateGlyphDependencies(n.text, o, t, this.allowVerticalPlacement, i)
                            }
                        }
                    }
                    "line" === o.get("symbol-placement") && (this.features = function (e) {
                        const t = {}, n = {}, i = [];
                        let r = 0;

                        function o(t) {
                            i.push(e[t]), r++
                        }

                        function a(e, t, r) {
                            const o = n[e];
                            return delete n[e], n[t] = o, i[o].geometry[0].pop(), i[o].geometry[0] = i[o].geometry[0].concat(r[0]), o
                        }

                        function s(e, n, r) {
                            const o = t[n];
                            return delete t[n], t[e] = o, i[o].geometry[0].shift(), i[o].geometry[0] = r[0].concat(i[o].geometry[0]), o
                        }

                        function l(e, t, n) {
                            const i = n ? t[0][t[0].length - 1] : t[0][0];
                            return `${e}:${i.x}:${i.y}`
                        }

                        for (let c = 0; c < e.length; c++) {
                            const u = e[c], d = u.geometry, h = u.text ? u.text.toString() : null;
                            if (!h) {
                                o(c);
                                continue
                            }
                            const p = l(h, d), f = l(h, d, !0);
                            if (p in n && f in t && n[p] !== t[f]) {
                                const e = s(p, f, d), r = a(p, f, i[e].geometry);
                                delete t[p], delete n[f], n[l(h, i[r].geometry, !0)] = r, i[e].geometry = null
                            } else p in n ? a(p, f, d) : f in t ? s(p, f, d) : (o(c), t[p] = r - 1, n[f] = r - 1)
                        }
                        return i.filter(e => e.geometry)
                    }(this.features)), this.sortFeaturesByKey && this.features.sort((e, t) => e.sortKey - t.sortKey)
                }

                update(e, t, n, i) {
                    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, n, i), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, n, i))
                }

                isEmpty() {
                    return 0 === this.symbolInstances.length && !this.hasRTLText
                }

                uploadPending() {
                    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                }

                upload(e) {
                    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
                }

                destroyDebugData() {
                    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
                }

                destroy() {
                    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
                }

                addToLineVertexArray(e, t) {
                    const n = this.lineVertexArray.length;
                    if (void 0 !== e.segment) {
                        let n = e.dist(t[e.segment + 1]), i = e.dist(t[e.segment]);
                        const r = {};
                        for (let i = e.segment + 1; i < t.length; i++) r[i] = {
                            x: t[i].x,
                            y: t[i].y,
                            tileUnitDistanceFromAnchor: n
                        }, i < t.length - 1 && (n += t[i + 1].dist(t[i]));
                        for (let n = e.segment || 0; n >= 0; n--) r[n] = {
                            x: t[n].x,
                            y: t[n].y,
                            tileUnitDistanceFromAnchor: i
                        }, n > 0 && (i += t[n - 1].dist(t[n]));
                        for (let e = 0; e < t.length; e++) {
                            const t = r[e];
                            this.lineVertexArray.emplaceBack(t.x, t.y, t.tileUnitDistanceFromAnchor)
                        }
                    }
                    return {lineStartIndex: n, lineLength: this.lineVertexArray.length - n}
                }

                addSymbols(e, t, n, i, r, o, a, s, l, c, u, d, h, p) {
                    const f = e.indexArray, m = e.layoutVertexArray,
                        _ = e.segments.prepareSegment(4 * t.length, m, f, this.canOverlap ? o.sortKey : void 0),
                        g = this.glyphOffsetArray.length, y = _.vertexLength,
                        v = this.allowVerticalPlacement && a === Eu.vertical ? Math.PI / 2 : 0,
                        x = o.text && o.text.sections;
                    for (let i = 0; i < t.length; i++) {
                        const {
                            tl: r,
                            tr: a,
                            bl: c,
                            br: u,
                            tex: d,
                            pixelOffsetTL: g,
                            pixelOffsetBR: y,
                            minFontScaleX: b,
                            minFontScaleY: w,
                            glyphOffset: M,
                            isSDF: T,
                            sectionIndex: k
                        } = t[i], S = _.vertexLength, D = M[1];
                        Ld(m, s.x, s.y, s.z, l.x, l.y, r.x, D + r.y, d.x, d.y, n, T, g.x, g.y, b, w), Ld(m, s.x, s.y, s.z, l.x, l.y, a.x, D + a.y, d.x + d.w, d.y, n, T, y.x, g.y, b, w), Ld(m, s.x, s.y, s.z, l.x, l.y, c.x, D + c.y, d.x, d.y + d.h, n, T, g.x, y.y, b, w), Ld(m, s.x, s.y, s.z, l.x, l.y, u.x, D + u.y, d.x + d.w, d.y + d.h, n, T, y.x, y.y, b, w), Ed(e.dynamicLayoutVertexArray, s, v), f.emplaceBack(S, S + 1, S + 2), f.emplaceBack(S + 1, S + 2, S + 3), _.vertexLength += 4, _.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(M[0]), i !== t.length - 1 && k === t[i + 1].sectionIndex || e.programConfigurations.populatePaintArrays(m.length, o, o.index, {}, h, p, x && x[k])
                    }
                    e.placedSymbolArray.emplaceBack(s.x, s.y, s.z, l.x, l.y, g, this.glyphOffsetArray.length - g, y, c, u, l.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], a, 0, !1, 0, d, 0)
                }

                _commitLayoutVertex(e, t, n, i, r, o, a) {
                    e.emplaceBack(t, n, i, r, o, Math.round(a.x), Math.round(a.y))
                }

                _addCollisionDebugVertices(e, t, n, i, o, a, s) {
                    const l = n.segments.prepareSegment(4, n.layoutVertexArray, n.indexArray), c = l.vertexLength,
                        u = s.tileAnchorX, d = s.tileAnchorY;
                    for (let e = 0; e < 4; e++) n.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                    n.collisionVertexArrayExt.emplaceBack(t, -e.padding, -e.padding), n.collisionVertexArrayExt.emplaceBack(t, e.padding, -e.padding), n.collisionVertexArrayExt.emplaceBack(t, e.padding, e.padding), n.collisionVertexArrayExt.emplaceBack(t, -e.padding, e.padding), this._commitLayoutVertex(n.layoutVertexArray, i, o, a, u, d, new r(e.x1, e.y1)), this._commitLayoutVertex(n.layoutVertexArray, i, o, a, u, d, new r(e.x2, e.y1)), this._commitLayoutVertex(n.layoutVertexArray, i, o, a, u, d, new r(e.x2, e.y2)), this._commitLayoutVertex(n.layoutVertexArray, i, o, a, u, d, new r(e.x1, e.y2)), l.vertexLength += 4;
                    const h = n.indexArray;
                    h.emplaceBack(c, c + 1), h.emplaceBack(c + 1, c + 2), h.emplaceBack(c + 2, c + 3), h.emplaceBack(c + 3, c), l.primitiveLength += 4
                }

                _addTextDebugCollisionBoxes(e, t, n, i, r, o) {
                    for (let a = i; a < r; a++) {
                        const i = n.get(a), r = this.getSymbolInstanceTextSize(e, o, t, a);
                        this._addCollisionDebugVertices(i, r, this.textCollisionBox, i.projectedAnchorX, i.projectedAnchorY, i.projectedAnchorZ, o)
                    }
                }

                _addIconDebugCollisionBoxes(e, t, n, i, r, o) {
                    for (let a = i; a < r; a++) {
                        const i = n.get(a), r = this.getSymbolInstanceIconSize(e, t, a);
                        this._addCollisionDebugVertices(i, r, this.iconCollisionBox, i.projectedAnchorX, i.projectedAnchorY, i.projectedAnchorZ, o)
                    }
                }

                generateCollisionDebugBuffers(e, t) {
                    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Id(da, Wc.members, ba), this.iconCollisionBox = new Id(da, Wc.members, ba);
                    const n = $c(this.iconSizeData, e), i = $c(this.textSizeData, e);
                    for (let r = 0; r < this.symbolInstances.length; r++) {
                        const o = this.symbolInstances.get(r);
                        this._addTextDebugCollisionBoxes(i, e, t, o.textBoxStartIndex, o.textBoxEndIndex, o), this._addTextDebugCollisionBoxes(i, e, t, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o), this._addIconDebugCollisionBoxes(n, e, t, o.iconBoxStartIndex, o.iconBoxEndIndex, o), this._addIconDebugCollisionBoxes(n, e, t, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o)
                    }
                }

                getSymbolInstanceTextSize(e, t, n, i) {
                    const r = this.text.placedSymbolArray.get(t.rightJustifiedTextSymbolIndex >= 0 ? t.rightJustifiedTextSymbolIndex : t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.leftJustifiedTextSymbolIndex >= 0 ? t.leftJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex >= 0 ? t.verticalPlacedTextSymbolIndex : i),
                        o = Zc(this.textSizeData, e, r) / 24;
                    return this.tilePixelRatio * o
                }

                getSymbolInstanceIconSize(e, t, n) {
                    const i = this.icon.placedSymbolArray.get(n), r = Zc(this.iconSizeData, e, i);
                    return this.tilePixelRatio * r
                }

                _commitDebugCollisionVertexUpdate(e, t, n) {
                    e.emplaceBack(t, -n, -n), e.emplaceBack(t, n, -n), e.emplaceBack(t, n, n), e.emplaceBack(t, -n, n)
                }

                _updateTextDebugCollisionBoxes(e, t, n, i, r, o) {
                    for (let a = i; a < r; a++) {
                        const i = n.get(a), r = this.getSymbolInstanceTextSize(e, o, t, a);
                        this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, r, i.padding)
                    }
                }

                _updateIconDebugCollisionBoxes(e, t, n, i, r) {
                    for (let o = i; o < r; o++) {
                        const i = n.get(o), r = this.getSymbolInstanceIconSize(e, t, o);
                        this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, r, i.padding)
                    }
                }

                updateCollisionDebugBuffers(e, t) {
                    if (!this.hasDebugData()) return;
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                    const n = $c(this.iconSizeData, e), i = $c(this.textSizeData, e);
                    for (let r = 0; r < this.symbolInstances.length; r++) {
                        const o = this.symbolInstances.get(r);
                        this._updateTextDebugCollisionBoxes(i, e, t, o.textBoxStartIndex, o.textBoxEndIndex, o), this._updateTextDebugCollisionBoxes(i, e, t, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o), this._updateIconDebugCollisionBoxes(n, e, t, o.iconBoxStartIndex, o.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(n, e, t, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex)
                    }
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
                }

                _deserializeCollisionBoxesForSymbol(e, t, n, i, r, o, a, s, l) {
                    const c = {};
                    for (let i = t; i < n; i++) {
                        const t = e.get(i);
                        c.textBox = {
                            x1: t.x1,
                            y1: t.y1,
                            x2: t.x2,
                            y2: t.y2,
                            padding: t.padding,
                            projectedAnchorX: t.projectedAnchorX,
                            projectedAnchorY: t.projectedAnchorY,
                            projectedAnchorZ: t.projectedAnchorZ,
                            tileAnchorX: t.tileAnchorX,
                            tileAnchorY: t.tileAnchorY
                        }, c.textFeatureIndex = t.featureIndex;
                        break
                    }
                    for (let t = i; t < r; t++) {
                        const n = e.get(t);
                        c.verticalTextBox = {
                            x1: n.x1,
                            y1: n.y1,
                            x2: n.x2,
                            y2: n.y2,
                            padding: n.padding,
                            projectedAnchorX: n.projectedAnchorX,
                            projectedAnchorY: n.projectedAnchorY,
                            projectedAnchorZ: n.projectedAnchorZ,
                            tileAnchorX: n.tileAnchorX,
                            tileAnchorY: n.tileAnchorY
                        }, c.verticalTextFeatureIndex = n.featureIndex;
                        break
                    }
                    for (let t = o; t < a; t++) {
                        const n = e.get(t);
                        c.iconBox = {
                            x1: n.x1,
                            y1: n.y1,
                            x2: n.x2,
                            y2: n.y2,
                            padding: n.padding,
                            projectedAnchorX: n.projectedAnchorX,
                            projectedAnchorY: n.projectedAnchorY,
                            projectedAnchorZ: n.projectedAnchorZ,
                            tileAnchorX: n.tileAnchorX,
                            tileAnchorY: n.tileAnchorY
                        }, c.iconFeatureIndex = n.featureIndex;
                        break
                    }
                    for (let t = s; t < l; t++) {
                        const n = e.get(t);
                        c.verticalIconBox = {
                            x1: n.x1,
                            y1: n.y1,
                            x2: n.x2,
                            y2: n.y2,
                            padding: n.padding,
                            projectedAnchorX: n.projectedAnchorX,
                            projectedAnchorY: n.projectedAnchorY,
                            projectedAnchorZ: n.projectedAnchorZ,
                            tileAnchorX: n.tileAnchorX,
                            tileAnchorY: n.tileAnchorY
                        }, c.verticalIconFeatureIndex = n.featureIndex;
                        break
                    }
                    return c
                }

                deserializeCollisionBoxes(e) {
                    this.collisionArrays = [];
                    for (let t = 0; t < this.symbolInstances.length; t++) {
                        const n = this.symbolInstances.get(t);
                        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex))
                    }
                }

                hasTextData() {
                    return this.text.segments.get().length > 0
                }

                hasIconData() {
                    return this.icon.segments.get().length > 0
                }

                hasDebugData() {
                    return this.textCollisionBox && this.iconCollisionBox
                }

                hasTextCollisionBoxData() {
                    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                }

                hasIconCollisionBoxData() {
                    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                }

                addIndicesForPlacedSymbol(e, t) {
                    const n = e.placedSymbolArray.get(t), i = n.vertexStartIndex + 4 * n.numGlyphs;
                    for (let t = n.vertexStartIndex; t < i; t += 4) e.indexArray.emplaceBack(t, t + 1, t + 2), e.indexArray.emplaceBack(t + 1, t + 2, t + 3)
                }

                getSortedSymbolIndexes(e) {
                    if (this.sortedAngle === e && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                    const t = Math.sin(e), n = Math.cos(e), i = [], r = [], o = [];
                    for (let e = 0; e < this.symbolInstances.length; ++e) {
                        o.push(e);
                        const a = this.symbolInstances.get(e);
                        i.push(0 | Math.round(t * a.tileAnchorX + n * a.tileAnchorY)), r.push(a.featureIndex)
                    }
                    return o.sort((e, t) => i[e] - i[t] || r[t] - r[e]), o
                }

                addToSortKeyRanges(e, t) {
                    const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                    n && n.sortKey === t ? n.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({
                        sortKey: t,
                        symbolInstanceStart: e,
                        symbolInstanceEnd: e + 1
                    })
                }

                sortFeatures(e) {
                    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                        for (const e of this.symbolInstanceIndexes) {
                            const t = this.symbolInstances.get(e);
                            this.featureSortOrder.push(t.featureIndex), [t.rightJustifiedTextSymbolIndex, t.centerJustifiedTextSymbolIndex, t.leftJustifiedTextSymbolIndex].forEach((e, t, n) => {
                                e >= 0 && n.indexOf(e) === t && this.addIndicesForPlacedSymbol(this.text, e)
                            }), t.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, t.verticalPlacedTextSymbolIndex), t.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t.placedIconSymbolIndex), t.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t.verticalPlacedIconSymbolIndex)
                        }
                        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                    }
                }
            }

            Yr("SymbolBucket", Pd, {omit: ["layers", "collisionBoxArray", "features", "compareText"]}), Pd.MAX_GLYPHS = 65535, Pd.addDynamicAttributes = Ed;
            const Rd = new $o({
                "symbol-placement": new Wo(vt.layout_symbol["symbol-placement"]),
                "symbol-spacing": new Wo(vt.layout_symbol["symbol-spacing"]),
                "symbol-avoid-edges": new Wo(vt.layout_symbol["symbol-avoid-edges"]),
                "symbol-sort-key": new Vo(vt.layout_symbol["symbol-sort-key"]),
                "symbol-z-order": new Wo(vt.layout_symbol["symbol-z-order"]),
                "icon-allow-overlap": new Wo(vt.layout_symbol["icon-allow-overlap"]),
                "icon-ignore-placement": new Wo(vt.layout_symbol["icon-ignore-placement"]),
                "icon-optional": new Wo(vt.layout_symbol["icon-optional"]),
                "icon-rotation-alignment": new Wo(vt.layout_symbol["icon-rotation-alignment"]),
                "icon-size": new Vo(vt.layout_symbol["icon-size"]),
                "icon-text-fit": new Wo(vt.layout_symbol["icon-text-fit"]),
                "icon-text-fit-padding": new Wo(vt.layout_symbol["icon-text-fit-padding"]),
                "icon-image": new Vo(vt.layout_symbol["icon-image"]),
                "icon-rotate": new Vo(vt.layout_symbol["icon-rotate"]),
                "icon-padding": new Wo(vt.layout_symbol["icon-padding"]),
                "icon-keep-upright": new Wo(vt.layout_symbol["icon-keep-upright"]),
                "icon-offset": new Vo(vt.layout_symbol["icon-offset"]),
                "icon-anchor": new Vo(vt.layout_symbol["icon-anchor"]),
                "icon-pitch-alignment": new Wo(vt.layout_symbol["icon-pitch-alignment"]),
                "text-pitch-alignment": new Wo(vt.layout_symbol["text-pitch-alignment"]),
                "text-rotation-alignment": new Wo(vt.layout_symbol["text-rotation-alignment"]),
                "text-field": new Vo(vt.layout_symbol["text-field"]),
                "text-font": new Vo(vt.layout_symbol["text-font"]),
                "text-size": new Vo(vt.layout_symbol["text-size"]),
                "text-max-width": new Vo(vt.layout_symbol["text-max-width"]),
                "text-line-height": new Vo(vt.layout_symbol["text-line-height"]),
                "text-letter-spacing": new Vo(vt.layout_symbol["text-letter-spacing"]),
                "text-justify": new Vo(vt.layout_symbol["text-justify"]),
                "text-radial-offset": new Vo(vt.layout_symbol["text-radial-offset"]),
                "text-variable-anchor": new Wo(vt.layout_symbol["text-variable-anchor"]),
                "text-anchor": new Vo(vt.layout_symbol["text-anchor"]),
                "text-max-angle": new Wo(vt.layout_symbol["text-max-angle"]),
                "text-writing-mode": new Wo(vt.layout_symbol["text-writing-mode"]),
                "text-rotate": new Vo(vt.layout_symbol["text-rotate"]),
                "text-padding": new Wo(vt.layout_symbol["text-padding"]),
                "text-keep-upright": new Wo(vt.layout_symbol["text-keep-upright"]),
                "text-transform": new Vo(vt.layout_symbol["text-transform"]),
                "text-offset": new Vo(vt.layout_symbol["text-offset"]),
                "text-allow-overlap": new Wo(vt.layout_symbol["text-allow-overlap"]),
                "text-ignore-placement": new Wo(vt.layout_symbol["text-ignore-placement"]),
                "text-optional": new Wo(vt.layout_symbol["text-optional"])
            });
            var Yd = {
                paint: new $o({
                    "icon-opacity": new Vo(vt.paint_symbol["icon-opacity"]),
                    "icon-color": new Vo(vt.paint_symbol["icon-color"]),
                    "icon-halo-color": new Vo(vt.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new Vo(vt.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new Vo(vt.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new Wo(vt.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new Wo(vt.paint_symbol["icon-translate-anchor"]),
                    "text-opacity": new Vo(vt.paint_symbol["text-opacity"]),
                    "text-color": new Vo(vt.paint_symbol["text-color"], {
                        runtimeType: At,
                        getOverride: e => e.textColor,
                        hasOverride: e => !!e.textColor
                    }),
                    "text-halo-color": new Vo(vt.paint_symbol["text-halo-color"]),
                    "text-halo-width": new Vo(vt.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new Vo(vt.paint_symbol["text-halo-blur"]),
                    "text-translate": new Wo(vt.paint_symbol["text-translate"]),
                    "text-translate-anchor": new Wo(vt.paint_symbol["text-translate-anchor"])
                }), layout: Rd
            };

            class zd {
                constructor(e) {
                    this.type = e.property.overrides ? e.property.overrides.runtimeType : Dt, this.defaultValue = e
                }

                evaluate(e) {
                    if (e.formattedSection) {
                        const t = this.defaultValue.property.overrides;
                        if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection)
                    }
                    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default
                }

                eachChild(e) {
                    this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return null
                }
            }

            Yr("FormatSectionOverride", zd, {omit: ["defaultValue"]});

            class Od extends ps {
                constructor(e) {
                    super(e, Yd)
                }

                recalculate(e, t) {
                    super.recalculate(e, t), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                    const n = this.layout.get("text-writing-mode");
                    if (n) {
                        const e = [];
                        for (const t of n) e.indexOf(t) < 0 && e.push(t);
                        this.layout._values["text-writing-mode"] = e
                    } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                    this._setPaintOverrides()
                }

                getValueAndResolveTokens(e, t, n, i) {
                    const r = this.layout.get(e).evaluate(t, {}, n, i), o = this._unevaluatedLayout._values[e];
                    return o.isDataDriven() || Fi(o.value) || !r ? r : function (e, t) {
                        return t.replace(/{([^{}]+)}/g, (t, n) => n in e ? String(e[n]) : "")
                    }(t.properties, r)
                }

                createBucket(e) {
                    return new Pd(e)
                }

                queryRadius() {
                    return 0
                }

                queryIntersectsFeature() {
                    return !1
                }

                _setPaintOverrides() {
                    for (const e of Yd.paint.overridableProperties) {
                        if (!Od.hasPaintOverride(this.layout, e)) continue;
                        const t = this.paint.get(e), n = new zd(t), i = new Oi(n, t.property.specification);
                        let r = null;
                        r = "constant" === t.value.kind || "source" === t.value.kind ? new ji("source", i) : new Hi("composite", i, t.value.zoomStops, t.value._interpolationType), this.paint._values[e] = new No(t.property, r, t.parameters)
                    }
                }

                _handleOverridablePaintPropertyUpdate(e, t, n) {
                    return !(!this.layout || t.isDataDriven() || n.isDataDriven()) && Od.hasPaintOverride(this.layout, e)
                }

                static hasPaintOverride(e, t) {
                    const n = e.get("text-field"), i = Yd.paint.properties[t];
                    let r = !1;
                    const o = e => {
                        for (const t of e) if (i.overrides && i.overrides.hasOverride(t)) return void (r = !0)
                    };
                    if ("constant" === n.value.kind && n.value.value instanceof Zt) o(n.value.value.sections); else if ("source" === n.value.kind) {
                        const e = t => {
                            r || (t instanceof en && Kt(t.value) === Yt ? o(t.value.sections) : t instanceof on ? o(t.sections) : t.eachChild(e))
                        }, t = n.value;
                        t._styleExpression && e(t._styleExpression.expression)
                    }
                    return r
                }

                getProgramConfiguration(e) {
                    return new os(this, e)
                }
            }

            var Fd = {
                paint: new $o({
                    "background-color": new Wo(vt.paint_background["background-color"]),
                    "background-pattern": new qo(vt.paint_background["background-pattern"]),
                    "background-opacity": new Wo(vt.paint_background["background-opacity"])
                })
            }, Bd = {
                paint: new $o({
                    "raster-opacity": new Wo(vt.paint_raster["raster-opacity"]),
                    "raster-hue-rotate": new Wo(vt.paint_raster["raster-hue-rotate"]),
                    "raster-brightness-min": new Wo(vt.paint_raster["raster-brightness-min"]),
                    "raster-brightness-max": new Wo(vt.paint_raster["raster-brightness-max"]),
                    "raster-saturation": new Wo(vt.paint_raster["raster-saturation"]),
                    "raster-contrast": new Wo(vt.paint_raster["raster-contrast"]),
                    "raster-resampling": new Wo(vt.paint_raster["raster-resampling"]),
                    "raster-fade-duration": new Wo(vt.paint_raster["raster-fade-duration"])
                })
            };

            class jd extends ps {
                constructor(e) {
                    super(e, {}), this.implementation = e
                }

                is3D() {
                    return "3d" === this.implementation.renderingMode
                }

                hasOffscreenPass() {
                    return void 0 !== this.implementation.prerender
                }

                recalculate() {
                }

                updateTransitions() {
                }

                hasTransition() {
                }

                serialize() {
                }

                onAdd(e) {
                    this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl)
                }

                onRemove(e) {
                    this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl)
                }
            }

            var Hd = {
                paint: new $o({
                    "sky-type": new Wo(vt.paint_sky["sky-type"]),
                    "sky-atmosphere-sun": new Wo(vt.paint_sky["sky-atmosphere-sun"]),
                    "sky-atmosphere-sun-intensity": new Wo(vt.paint_sky["sky-atmosphere-sun-intensity"]),
                    "sky-gradient-center": new Wo(vt.paint_sky["sky-gradient-center"]),
                    "sky-gradient-radius": new Wo(vt.paint_sky["sky-gradient-radius"]),
                    "sky-gradient": new Zo(vt.paint_sky["sky-gradient"]),
                    "sky-atmosphere-halo-color": new Wo(vt.paint_sky["sky-atmosphere-halo-color"]),
                    "sky-atmosphere-color": new Wo(vt.paint_sky["sky-atmosphere-color"]),
                    "sky-opacity": new Wo(vt.paint_sky["sky-opacity"])
                })
            };

            function Nd(e, t, n) {
                const i = x(0, 0, 1), r = F(O());
                return function (e, t, n) {
                    n *= .5;
                    var i = t[0], r = t[1], o = t[2], a = t[3], s = Math.sin(n), l = Math.cos(n);
                    e[0] = i * l - o * s, e[1] = r * l + a * s, e[2] = o * l + i * s, e[3] = a * l - r * s
                }(r, r, n ? -U(e) + Math.PI : U(e)), B(r, r, -U(t)), A(i, i, r), D(i, i)
            }

            const Ud = {
                circle: class extends ps {
                    constructor(e) {
                        super(e, il)
                    }

                    createBucket(e) {
                        return new Bs(e)
                    }

                    queryRadius(e) {
                        const t = e;
                        return Ks("circle-radius", this, t) + Ks("circle-stroke-width", this, t) + Qs(this.paint.get("circle-translate"))
                    }

                    queryIntersectsFeature(e, t, n, i, r, o, a, s) {
                        const l = tl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, e.pixelToTileUnitsFactor),
                            c = this.paint.get("circle-radius").evaluate(t, n) + this.paint.get("circle-stroke-width").evaluate(t, n);
                        return al(e, i, o, a, s, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, c)
                    }

                    getProgramIds() {
                        return ["circle"]
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }
                }, heatmap: class extends ps {
                    createBucket(e) {
                        return new dl(e)
                    }

                    constructor(e) {
                        super(e, gl), this._updateColorRamp()
                    }

                    _handleSpecialPaintPropertyUpdate(e) {
                        "heatmap-color" === e && this._updateColorRamp()
                    }

                    _updateColorRamp() {
                        this.colorRamp = yl({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }), this.colorRampTexture = null
                    }

                    resize() {
                        this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null)
                    }

                    queryRadius(e) {
                        return Ks("heatmap-radius", this, e)
                    }

                    queryIntersectsFeature(e, t, n, i, o, a, s, l) {
                        const c = this.paint.get("heatmap-radius").evaluate(t, n);
                        return al(e, i, a, s, l, !0, !0, new r(0, 0), c)
                    }

                    hasOffscreenPass() {
                        return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility
                    }

                    getProgramIds() {
                        return ["heatmap", "heatmapTexture"]
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }
                }, hillshade: class extends ps {
                    constructor(e) {
                        super(e, vl)
                    }

                    hasOffscreenPass() {
                        return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility
                    }

                    getProgramIds() {
                        return ["hillshade", "hillshadePrepare"]
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }
                }, fill: class extends ps {
                    constructor(e) {
                        super(e, oc)
                    }

                    getProgramIds() {
                        const e = this.paint.get("fill-pattern"), t = e && e.constantOr(1),
                            n = [t ? "fillPattern" : "fill"];
                        return this.paint.get("fill-antialias") && n.push(t && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), n
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }

                    recalculate(e, t) {
                        super.recalculate(e, t);
                        const n = this.paint._values["fill-outline-color"];
                        "constant" === n.value.kind && void 0 === n.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }

                    createBucket(e) {
                        return new ic(e)
                    }

                    queryRadius() {
                        return Qs(this.paint.get("fill-translate"))
                    }

                    queryIntersectsFeature(e, t, n, i, r, o) {
                        return !e.queryGeometry.isAboveHorizon && Ns(el(e.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, e.pixelToTileUnitsFactor), i)
                    }

                    isTileClipped() {
                        return !0
                    }
                }, "fill-extrusion": class extends ps {
                    constructor(e) {
                        super(e, Tc)
                    }

                    createBucket(e) {
                        return new wc(e)
                    }

                    queryRadius() {
                        return Qs(this.paint.get("fill-extrusion-translate"))
                    }

                    is3D() {
                        return !0
                    }

                    getProgramIds() {
                        return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }

                    queryIntersectsFeature(e, t, n, i, o, a, s, l, c) {
                        const u = tl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, e.pixelToTileUnitsFactor),
                            d = this.paint.get("fill-extrusion-height").evaluate(t, n),
                            h = this.paint.get("fill-extrusion-base").evaluate(t, n), p = [0, 0], f = l && a.elevation,
                            m = a.elevation ? a.elevation.exaggeration() : 1;
                        if (f) {
                            const t = e.tile.getBucket(this).centroidVertexArray, n = c + 1;
                            if (n < t.length) {
                                const e = t.get(n);
                                p[0] = e.a_centroid_pos0, p[1] = e.a_centroid_pos1
                            }
                        }
                        if (0 === p[0] && 1 === p[1]) return !1;
                        const _ = function (e, t, n, i, o, a, s, l, c) {
                            return a ? function (e, t, n, i, r, o, a, s, l) {
                                const c = [], u = [], d = [0, 0, 0, 1];
                                for (const h of e) {
                                    const e = [], p = [];
                                    for (const c of h) {
                                        const u = c.x + i.x, h = c.y + i.y, f = Lc(u, h, t, n, o, a, s, l);
                                        d[0] = u, d[1] = h, d[2] = f.base, d[3] = 1, z(d, d, r), d[3] = Math.max(d[3], 1e-5);
                                        const m = Dc([d[0] / d[3], d[1] / d[3], d[2] / d[3]]);
                                        d[0] = u, d[1] = h, d[2] = f.top, d[3] = 1, z(d, d, r), d[3] = Math.max(d[3], 1e-5);
                                        const _ = Dc([d[0] / d[3], d[1] / d[3], d[2] / d[3]]);
                                        e.push(m), p.push(_)
                                    }
                                    c.push(e), u.push(p)
                                }
                                return [c, u]
                            }(e, t, n, i, o, a, s, l, c) : function (e, t, n, i, o) {
                                const a = [], s = [], l = o[8] * t, c = o[9] * t, u = o[10] * t, d = o[11] * t,
                                    h = o[8] * n, p = o[9] * n, f = o[10] * n, m = o[11] * n;
                                for (const t of e) {
                                    const e = [], n = [];
                                    for (const a of t) {
                                        const t = a.x + i.x, s = a.y + i.y, _ = o[0] * t + o[4] * s + o[12],
                                            g = o[1] * t + o[5] * s + o[13], y = o[2] * t + o[6] * s + o[14],
                                            v = o[3] * t + o[7] * s + o[15], x = _ + l, b = g + c, w = y + u,
                                            M = Math.max(v + d, 1e-5), T = _ + h, k = g + p, S = y + f,
                                            D = Math.max(v + m, 1e-5), L = new r(x / M, b / M);
                                        L.z = w / M, e.push(L);
                                        const E = new r(T / D, k / D);
                                        E.z = S / D, n.push(E)
                                    }
                                    a.push(e), s.push(n)
                                }
                                return [a, s]
                            }(e, t, n, i, o)
                        }(i, h, d, u, s, f ? l : null, p, m, a.center.lat), g = e.queryGeometry;
                        return function (e, t, n) {
                            let i = 1 / 0;
                            Ns(n, t) && (i = Sc(n, t[0]));
                            for (let r = 0; r < t.length; r++) {
                                const o = t[r], a = e[r];
                                for (let e = 0; e < o.length - 1; e++) {
                                    const t = o[e], r = [t, o[e + 1], a[e + 1], a[e], t];
                                    js(n, r) && (i = Math.min(i, Sc(n, r)))
                                }
                            }
                            return i !== 1 / 0 && i
                        }(_[0], _[1], g.isPointQuery() ? g.screenBounds : g.screenGeometry)
                    }
                }, line: class extends ps {
                    constructor(e) {
                        super(e, Oc), this.gradientVersion = 0
                    }

                    _handleSpecialPaintPropertyUpdate(e) {
                        if ("line-gradient" === e) {
                            const e = this._transitionablePaint._values["line-gradient"].value.expression;
                            this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof zn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }

                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }

                    recalculate(e, t) {
                        super.recalculate(e, t), this.paint._values["line-floorwidth"] = Fc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e)
                    }

                    createBucket(e) {
                        return new Yc(e)
                    }

                    getProgramIds() {
                        return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                    }

                    getProgramConfiguration(e) {
                        return new os(this, e)
                    }

                    queryRadius(e) {
                        const t = e, n = Bc(Ks("line-width", this, t), Ks("line-gap-width", this, t)),
                            i = Ks("line-offset", this, t);
                        return n / 2 + Math.abs(i) + Qs(this.paint.get("line-translate"))
                    }

                    queryIntersectsFeature(e, t, n, i, o, a) {
                        if (e.queryGeometry.isAboveHorizon) return !1;
                        const s = el(e.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, e.pixelToTileUnitsFactor),
                            l = e.pixelToTileUnitsFactor / 2 * Bc(this.paint.get("line-width").evaluate(t, n), this.paint.get("line-gap-width").evaluate(t, n)),
                            c = this.paint.get("line-offset").evaluate(t, n);
                        return c && (i = function (e, t) {
                            const n = [], i = new r(0, 0);
                            for (let r = 0; r < e.length; r++) {
                                const o = e[r], a = [];
                                for (let e = 0; e < o.length; e++) {
                                    const n = o[e - 1], r = o[e], s = o[e + 1],
                                        l = 0 === e ? i : r.sub(n)._unit()._perp(),
                                        c = e === o.length - 1 ? i : s.sub(r)._unit()._perp(), u = l._add(c)._unit();
                                    u._mult(1 / (u.x * c.x + u.y * c.y)), a.push(u._mult(t)._add(r))
                                }
                                n.push(a)
                            }
                            return n
                        }(i, c * e.pixelToTileUnitsFactor)), function (e, t, n) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (e.length >= 3) for (let t = 0; t < r.length; t++) if ($s(e, r[t])) return !0;
                                if (Us(e, r, n)) return !0
                            }
                            return !1
                        }(s, i, l)
                    }

                    isTileClipped() {
                        return !0
                    }
                }, symbol: Od, background: class extends ps {
                    constructor(e) {
                        super(e, Fd)
                    }

                    getProgramIds() {
                        return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                    }
                }, raster: class extends ps {
                    constructor(e) {
                        super(e, Bd)
                    }

                    getProgramIds() {
                        return ["raster"]
                    }
                }, sky: class extends ps {
                    constructor(e) {
                        super(e, Hd), this._updateColorRamp()
                    }

                    _handleSpecialPaintPropertyUpdate(e) {
                        "sky-gradient" === e ? this._updateColorRamp() : "sky-atmosphere-sun" !== e && "sky-atmosphere-halo-color" !== e && "sky-atmosphere-color" !== e && "sky-atmosphere-sun-intensity" !== e || (this._skyboxInvalidated = !0)
                    }

                    _updateColorRamp() {
                        this.colorRamp = yl({
                            expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                            evaluationKey: "skyRadialProgress"
                        }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null)
                    }

                    needsSkyboxCapture(e) {
                        if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                        if (!this.paint.get("sky-atmosphere-sun")) {
                            const t = e.style.light.properties.get("position");
                            return this._lightPosition.azimuthal !== t.azimuthal || this._lightPosition.polar !== t.polar
                        }
                    }

                    getCenter(e, t) {
                        const n = this.paint.get("sky-type");
                        if ("atmosphere" === n) {
                            const n = this.paint.get("sky-atmosphere-sun"), i = !n, r = e.style.light,
                                o = r.properties.get("position");
                            return i && "viewport" === r.properties.get("anchor") && he("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), i ? Nd(o.azimuthal, 90 - o.polar, t) : Nd(n[0], 90 - n[1], t)
                        }
                        if ("gradient" === n) {
                            const e = this.paint.get("sky-gradient-center");
                            return Nd(e[0], 90 - e[1], t)
                        }
                    }

                    is3D() {
                        return !1
                    }

                    isSky() {
                        return !0
                    }

                    markSkyboxValid(e) {
                        this._skyboxInvalidated = !1, this._lightPosition = e.style.light.properties.get("position")
                    }

                    hasOffscreenPass() {
                        return !0
                    }

                    getProgramIds() {
                        const e = this.paint.get("sky-type");
                        return "atmosphere" === e ? ["skyboxCapture", "skybox"] : "gradient" === e ? ["skyboxGradient"] : null
                    }
                }
            }, {HTMLImageElement: Wd, HTMLCanvasElement: Vd, HTMLVideoElement: Gd, ImageData: qd, ImageBitmap: Zd} = a;

            class $d {
                constructor(e, t, n, i) {
                    this.context = e, this.format = n, this.texture = e.gl.createTexture(), this.update(t, i)
                }

                update(e, t, n) {
                    const {width: i, height: r} = e, {context: o} = this, {gl: a} = o;
                    if (a.bindTexture(a.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!t || !1 !== t.premultiply)), n || this.size && this.size[0] === i && this.size[1] === r) {
                        const {x: t, y: o} = n || {x: 0, y: 0};
                        e instanceof Wd || e instanceof Vd || e instanceof Gd || e instanceof qd || Zd && e instanceof Zd ? a.texSubImage2D(a.TEXTURE_2D, 0, t, o, a.RGBA, a.UNSIGNED_BYTE, e) : a.texSubImage2D(a.TEXTURE_2D, 0, t, o, i, r, a.RGBA, a.UNSIGNED_BYTE, e.data)
                    } else this.size = [i, r], e instanceof Wd || e instanceof Vd || e instanceof Gd || e instanceof qd || Zd && e instanceof Zd ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, e) : a.texImage2D(a.TEXTURE_2D, 0, this.format, i, r, 0, this.format, a.UNSIGNED_BYTE, e.data);
                    this.useMipmap = Boolean(t && t.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && a.generateMipmap(a.TEXTURE_2D)
                }

                bind(e, t) {
                    const {context: n} = this, {gl: i} = n;
                    i.bindTexture(i.TEXTURE_2D, this.texture), e !== this.filter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap ? e === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_NEAREST : e), this.filter = e), t !== this.wrap && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, t), this.wrap = t)
                }

                isSizePowerOfTwo() {
                    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                }

                destroy() {
                    const {gl: e} = this.context;
                    e.deleteTexture(this.texture), this.texture = null
                }
            }

            class Xd {
                constructor(e, t) {
                    this.width = e, this.height = t, this.nextRow = 0, this.image = new ml({
                        width: e,
                        height: t
                    }), this.positions = {}, this.uploaded = !1
                }

                getDash(e, t) {
                    const n = this.getKey(e, t);
                    return this.positions[n]
                }

                trim() {
                    const e = this.width, t = this.height = re(this.nextRow);
                    this.image.resize({width: e, height: t})
                }

                getKey(e, t) {
                    return e.join(",") + t
                }

                getDashRanges(e, t, n) {
                    const i = [];
                    let r = e.length % 2 == 1 ? -e[e.length - 1] * n : 0, o = e[0] * n, a = !0;
                    i.push({left: r, right: o, isDash: a, zeroLength: 0 === e[0]});
                    let s = e[0];
                    for (let t = 1; t < e.length; t++) {
                        a = !a;
                        const l = e[t];
                        r = s * n, s += l, o = s * n, i.push({left: r, right: o, isDash: a, zeroLength: 0 === l})
                    }
                    return i
                }

                addRoundDash(e, t, n) {
                    const i = t / 2;
                    for (let t = -n; t <= n; t++) {
                        const r = this.width * (this.nextRow + n + t);
                        let o = 0, a = e[o];
                        for (let s = 0; s < this.width; s++) {
                            s / a.right > 1 && (a = e[++o]);
                            const l = Math.abs(s - a.left), c = Math.abs(s - a.right), u = Math.min(l, c);
                            let d;
                            const h = t / n * (i + 1);
                            if (a.isDash) {
                                const e = i - Math.abs(h);
                                d = Math.sqrt(u * u + e * e)
                            } else d = i - Math.sqrt(u * u + h * h);
                            this.image.data[r + s] = Math.max(0, Math.min(255, d + 128))
                        }
                    }
                }

                addRegularDash(e, t) {
                    for (let t = e.length - 1; t >= 0; --t) {
                        const n = e[t], i = e[t + 1];
                        n.zeroLength ? e.splice(t, 1) : i && i.isDash === n.isDash && (i.left = n.left, e.splice(t, 1))
                    }
                    const n = e[0], i = e[e.length - 1];
                    n.isDash === i.isDash && (n.left = i.left - this.width, i.right = n.right + this.width);
                    const r = this.width * this.nextRow;
                    let o = 0, a = e[o];
                    for (let n = 0; n < this.width; n++) {
                        n / a.right > 1 && (a = e[++o]);
                        const i = Math.abs(n - a.left), s = Math.abs(n - a.right), l = Math.min(i, s);
                        this.image.data[r + n] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + t + 128))
                    }
                }

                addDash(e, t) {
                    const n = this.getKey(e, t);
                    if (this.positions[n]) return this.positions[n];
                    const i = "round" === t, r = i ? 7 : 0, o = 2 * r + 1;
                    if (this.nextRow + o > this.height) return he("LineAtlas out of space"), null;
                    0 === e.length && e.push(1);
                    let a = 0;
                    for (let t = 0; t < e.length; t++) e[t] < 0 && (he("Negative value is found in line dasharray, replacing values with 0"), e[t] = 0), a += e[t];
                    if (0 !== a) {
                        const n = this.width / a, o = this.getDashRanges(e, this.width, n);
                        i ? this.addRoundDash(o, n, r) : this.addRegularDash(o, "square" === t ? .5 * n : 0)
                    }
                    const s = this.nextRow + r;
                    this.nextRow += o;
                    const l = {tl: [s, r], br: [a, 0]};
                    return this.positions[n] = l, l
                }
            }

            Yr("LineAtlas", Xd);

            class Jd {
                constructor(e) {
                    this._callback = e, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
                        this._triggered = !1, this._callback()
                    })
                }

                trigger() {
                    this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
                        this._triggered = !1, this._callback()
                    }, 0))
                }

                remove() {
                    delete this._channel, this._callback = () => {
                    }
                }
            }

            const Kd = a.performance;

            function Qd(e) {
                const t = e ? e.url.toString() : void 0;
                return Kd.getEntriesByName(t)
            }

            class eh {
                constructor() {
                    this.tasks = {}, this.taskQueue = [], ae(["process"], this), this.invoker = new Jd(this.process), this.nextId = 0
                }

                add(e, t) {
                    const n = this.nextId++, i = function ({type: e, isSymbolTile: t, zoom: n}) {
                        return n = n || 0, "message" === e ? 0 : "maybePrepare" !== e || t ? "parseTile" !== e || t ? "parseTile" === e && t ? 300 - n : "maybePrepare" === e && t ? 400 - n : 500 : 200 - n : 100 - n
                    }(t);
                    if (0 === i) {
                        me();
                        try {
                            e()
                        } finally {
                        }
                        return {
                            cancel: () => {
                            }
                        }
                    }
                    return this.tasks[n] = {
                        fn: e,
                        metadata: t,
                        priority: i,
                        id: n
                    }, this.taskQueue.push(n), this.invoker.trigger(), {
                        cancel: () => {
                            delete this.tasks[n]
                        }
                    }
                }

                process() {
                    me();
                    try {
                        if (this.taskQueue = this.taskQueue.filter(e => !!this.tasks[e]), !this.taskQueue.length) return;
                        const e = this.pick();
                        if (null === e) return;
                        const t = this.tasks[e];
                        if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !t) return;
                        t.fn()
                    } finally {
                    }
                }

                pick() {
                    let e = null, t = 1 / 0;
                    for (let n = 0; n < this.taskQueue.length; n++) {
                        const i = this.tasks[this.taskQueue[n]];
                        i.priority < t && (t = i.priority, e = n)
                    }
                    if (null === e) return null;
                    const n = this.taskQueue[e];
                    return this.taskQueue.splice(e, 1), n
                }

                remove() {
                    this.invoker.remove()
                }
            }

            function th(e, t, n) {
                var i = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
                return [e * i - 2 * Math.PI * 6378137 / 2, t * i - 2 * Math.PI * 6378137 / 2]
            }

            class nh {
                constructor(e, t, n) {
                    this.z = e, this.x = t, this.y = n, this.key = oh(0, e, e, t, n)
                }

                equals(e) {
                    return this.z === e.z && this.x === e.x && this.y === e.y
                }

                url(e, t) {
                    const n = function (e, t, n) {
                        var i = th(256 * e, 256 * (t = Math.pow(2, n) - t - 1), n),
                            r = th(256 * (e + 1), 256 * (t + 1), n);
                        return i[0] + "," + i[1] + "," + r[0] + "," + r[1]
                    }(this.x, this.y, this.z), i = function (e, t, n) {
                        let i, r = "";
                        for (let o = e; o > 0; o--) i = 1 << o - 1, r += (t & i ? 1 : 0) + (n & i ? 2 : 0);
                        return r
                    }(this.z, this.x, this.y);
                    return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === t ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", i).replace("{bbox-epsg-3857}", n)
                }

                toString() {
                    return `${this.z}/${this.x}/${this.y}`
                }
            }

            class ih {
                constructor(e, t) {
                    this.wrap = e, this.canonical = t, this.key = oh(e, t.z, t.z, t.x, t.y)
                }
            }

            class rh {
                constructor(e, t, n, i, r) {
                    this.overscaledZ = e, this.wrap = t, this.canonical = new nh(n, +i, +r), this.key = 0 === t && e === n ? this.canonical.key : oh(t, e, n, i, r)
                }

                equals(e) {
                    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical)
                }

                scaledTo(e) {
                    const t = this.canonical.z - e;
                    return e > this.canonical.z ? new rh(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new rh(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t)
                }

                calculateScaledKey(e, t = !0) {
                    if (this.overscaledZ === e && t) return this.key;
                    if (e > this.canonical.z) return oh(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y);
                    {
                        const n = this.canonical.z - e;
                        return oh(this.wrap * +t, e, e, this.canonical.x >> n, this.canonical.y >> n)
                    }
                }

                isChildOf(e) {
                    if (e.wrap !== this.wrap) return !1;
                    const t = this.canonical.z - e.canonical.z;
                    return 0 === e.overscaledZ || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t
                }

                children(e) {
                    if (this.overscaledZ >= e) return [new rh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
                    const t = this.canonical.z + 1, n = 2 * this.canonical.x, i = 2 * this.canonical.y;
                    return [new rh(t, this.wrap, t, n, i), new rh(t, this.wrap, t, n + 1, i), new rh(t, this.wrap, t, n, i + 1), new rh(t, this.wrap, t, n + 1, i + 1)]
                }

                isLessThan(e) {
                    return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y))
                }

                wrapped() {
                    return new rh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
                }

                unwrapTo(e) {
                    return new rh(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y)
                }

                overscaleFactor() {
                    return Math.pow(2, this.overscaledZ - this.canonical.z)
                }

                toUnwrapped() {
                    return new ih(this.wrap, this.canonical)
                }

                toString() {
                    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                }
            }

            function oh(e, t, n, i, r) {
                const o = 1 << Math.min(n, 22);
                let a = o * (r % o) + i % o;
                return e && n < 22 && (a += o * o * ((e < 0 ? -2 * e - 1 : 2 * e) % (1 << 2 * (22 - n)))), 16 * (32 * a + n) + (t - n)
            }

            Yr("CanonicalTileID", nh), Yr("OverscaledTileID", rh, {omit: ["projMatrix"]});

            class ah {
                constructor(e, t, n) {
                    this.func = e, this.mask = t, this.range = n
                }
            }

            ah.ReadOnly = !1, ah.ReadWrite = !0, ah.disabled = new ah(519, ah.ReadOnly, [0, 1]);

            class sh {
                constructor(e, t, n, i, r, o) {
                    this.test = e, this.ref = t, this.mask = n, this.fail = i, this.depthFail = r, this.pass = o
                }
            }

            sh.disabled = new sh({func: 519, mask: 0}, 0, 0, 7680, 7680, 7680);

            class lh {
                constructor(e, t, n) {
                    this.blendFunction = e, this.blendColor = t, this.mask = n
                }
            }

            lh.Replace = [1, 0], lh.disabled = new lh(lh.Replace, Vt.transparent, [!1, !1, !1, !1]), lh.unblended = new lh(lh.Replace, Vt.transparent, [!0, !0, !0, !0]), lh.alphaBlended = new lh([1, 771], Vt.transparent, [!0, !0, !0, !0]);

            class ch {
                constructor(e, t, n) {
                    this.enable = e, this.mode = t, this.frontFace = n
                }
            }

            ch.disabled = new ch(!1, 1029, 2305), ch.backCCW = new ch(!0, 1029, 2305), ch.backCW = new ch(!0, 1029, 2304), ch.frontCW = new ch(!0, 1028, 2304), ch.frontCCW = new ch(!0, 1028, 2305);

            class uh {
                constructor(e) {
                    this._stringToNumber = {}, this._numberToString = [];
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        this._stringToNumber[n] = t, this._numberToString[t] = n
                    }
                }

                encode(e) {
                    return this._stringToNumber[e]
                }

                decode(e) {
                    return this._numberToString[e]
                }
            }

            class dh {
                constructor(e, t, n, i, r) {
                    this.type = "Feature", this._vectorTileFeature = e, e._z = t, e._x = n, e._y = i, this.properties = e.properties, this.id = r
                }

                get geometry() {
                    return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
                }

                set geometry(e) {
                    this._geometry = e
                }

                toJSON() {
                    const e = {geometry: this.geometry};
                    for (const t in this) "_geometry" !== t && "_vectorTileFeature" !== t && (e[t] = this[t]);
                    return e
                }
            }

            class hh {
                constructor() {
                    this.state = {}, this.stateChanges = {}, this.deletedStates = {}
                }

                updateState(e, t, n) {
                    const i = String(t);
                    if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][i] = this.stateChanges[e][i] || {}, ee(this.stateChanges[e][i], n), null === this.deletedStates[e]) {
                        this.deletedStates[e] = {};
                        for (const t in this.state[e]) t !== i && (this.deletedStates[e][t] = null)
                    } else if (this.deletedStates[e] && null === this.deletedStates[e][i]) {
                        this.deletedStates[e][i] = {};
                        for (const t in this.state[e][i]) n[t] || (this.deletedStates[e][i][t] = null)
                    } else for (const t in n) this.deletedStates[e] && this.deletedStates[e][i] && null === this.deletedStates[e][i][t] && delete this.deletedStates[e][i][t]
                }

                removeFeatureState(e, t, n) {
                    if (null === this.deletedStates[e]) return;
                    const i = String(t);
                    if (this.deletedStates[e] = this.deletedStates[e] || {}, n && void 0 !== t) null !== this.deletedStates[e][i] && (this.deletedStates[e][i] = this.deletedStates[e][i] || {}, this.deletedStates[e][i][n] = null); else if (void 0 !== t) if (this.stateChanges[e] && this.stateChanges[e][i]) for (n in this.deletedStates[e][i] = {}, this.stateChanges[e][i]) this.deletedStates[e][i][n] = null; else this.deletedStates[e][i] = null; else this.deletedStates[e] = null
                }

                getState(e, t) {
                    const n = String(t), i = ee({}, (this.state[e] || {})[n], (this.stateChanges[e] || {})[n]);
                    if (null === this.deletedStates[e]) return {};
                    if (this.deletedStates[e]) {
                        const n = this.deletedStates[e][t];
                        if (null === n) return {};
                        for (const e in n) delete i[e]
                    }
                    return i
                }

                initializeTileState(e, t) {
                    e.setFeatureState(this.state, t)
                }

                coalesceChanges(e, t) {
                    const n = {};
                    for (const e in this.stateChanges) {
                        this.state[e] = this.state[e] || {};
                        const t = {};
                        for (const n in this.stateChanges[e]) this.state[e][n] || (this.state[e][n] = {}), ee(this.state[e][n], this.stateChanges[e][n]), t[n] = this.state[e][n];
                        n[e] = t
                    }
                    for (const e in this.deletedStates) {
                        this.state[e] = this.state[e] || {};
                        const t = {};
                        if (null === this.deletedStates[e]) for (const n in this.state[e]) t[n] = {}, this.state[e][n] = {}; else for (const n in this.deletedStates[e]) {
                            if (null === this.deletedStates[e][n]) this.state[e][n] = {}; else for (const t of Object.keys(this.deletedStates[e][n])) delete this.state[e][n][t];
                            t[n] = this.state[e][n]
                        }
                        n[e] = n[e] || {}, ee(n[e], t)
                    }
                    if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(n).length) for (const i in e) e[i].setFeatureState(n, t)
                }
            }

            class ph {
                constructor(e) {
                    this.size = e, this.minimums = [], this.maximums = [], this.leaves = []
                }

                getElevation(e, t) {
                    const n = this.toIdx(e, t);
                    return {min: this.minimums[n], max: this.maximums[n]}
                }

                isLeaf(e, t) {
                    return this.leaves[this.toIdx(e, t)]
                }

                toIdx(e, t) {
                    return t * this.size + e
                }
            }

            function fh(e, t, n, i) {
                let r = 0, o = Number.MAX_VALUE;
                for (let a = 0; a < 3; a++) if (Math.abs(i[a]) < 1e-15) {
                    if (n[a] < e[a] || n[a] > t[a]) return null
                } else {
                    const s = 1 / i[a];
                    let l = (e[a] - n[a]) * s, c = (t[a] - n[a]) * s;
                    if (l > c) {
                        const e = l;
                        l = c, c = e
                    }
                    if (l > r && (r = l), c < o && (o = c), r > o) return null
                }
                return r
            }

            function mh(e, t, n, i, r, o, a, s, l, c, u) {
                const d = i - e, h = r - t, p = o - n, f = a - e, m = s - t, _ = l - n, g = u[1] * _ - u[2] * m,
                    y = u[2] * f - u[0] * _, v = u[0] * m - u[1] * f, x = d * g + h * y + p * v;
                if (Math.abs(x) < 1e-15) return null;
                const b = 1 / x, w = c[0] - e, M = c[1] - t, T = c[2] - n, k = (w * g + M * y + T * v) * b;
                if (k < 0 || k > 1) return null;
                const S = M * p - T * h, D = T * d - w * p, L = w * h - M * d, E = (u[0] * S + u[1] * D + u[2] * L) * b;
                return E < 0 || k + E > 1 ? null : (f * S + m * D + _ * L) * b
            }

            function _h(e, t, n) {
                return (e - t) / (n - t)
            }

            function gh(e, t, n, i, r, o, a, s, l) {
                const c = 1 << n, u = o - i, d = a - r, h = (e + 1) / c * u + i, p = (t + 0) / c * d + r,
                    f = (t + 1) / c * d + r;
                s[0] = (e + 0) / c * u + i, s[1] = p, l[0] = h, l[1] = f
            }

            class yh {
                constructor(e) {
                    if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
                    const t = function (e) {
                        const t = Math.ceil(Math.log2(e.dim / 8)), n = [];
                        let i = Math.ceil(Math.pow(2, t));
                        const r = 1 / i, o = (e, t, n, i, r) => {
                            const o = i ? 1 : 0, a = (e + 1) * n - o, s = t * n, l = (t + 1) * n - o;
                            r[0] = e * n, r[1] = s, r[2] = a, r[3] = l
                        };
                        let a = new ph(i);
                        const s = [];
                        for (let t = 0; t < i * i; t++) {
                            o(t % i, Math.floor(t / i), r, !1, s);
                            const n = xh(s[0], s[1], e), l = xh(s[2], s[1], e), c = xh(s[2], s[3], e),
                                u = xh(s[0], s[3], e);
                            a.minimums.push(Math.min(n, l, c, u)), a.maximums.push(Math.max(n, l, c, u)), a.leaves.push(1)
                        }
                        for (n.push(a), i /= 2; i >= 1; i /= 2) {
                            const e = n[n.length - 1];
                            a = new ph(i);
                            for (let t = 0; t < i * i; t++) {
                                o(t % i, Math.floor(t / i), 2, !0, s);
                                const n = e.getElevation(s[0], s[1]), r = e.getElevation(s[2], s[1]),
                                    l = e.getElevation(s[2], s[3]), c = e.getElevation(s[0], s[3]),
                                    u = e.isLeaf(s[0], s[1]), d = e.isLeaf(s[2], s[1]), h = e.isLeaf(s[2], s[3]),
                                    p = e.isLeaf(s[0], s[3]), f = Math.min(n.min, r.min, l.min, c.min),
                                    m = Math.max(n.max, r.max, l.max, c.max), _ = u && d && h && p;
                                a.maximums.push(m), a.minimums.push(f), a.leaves.push(m - f <= 5 && _ ? 1 : 0)
                            }
                            n.push(a)
                        }
                        return n
                    }(this.dem), n = t.length - 1, i = t[n];
                    this._addNode(i.minimums[0], i.maximums[0], i.leaves[0]), this._construct(t, 0, 0, n, 0)
                }

                raycastRoot(e, t, n, i, r, o, a = 1) {
                    return fh([e, t, -100], [n, i, this.maximums[0] * a], r, o)
                }

                raycast(e, t, n, i, r, o, a = 1) {
                    if (!this.nodeCount) return null;
                    const s = this.raycastRoot(e, t, n, i, r, o, a);
                    if (null == s) return null;
                    const l = [], c = [], u = [], d = [], h = [{idx: 0, t: s, nodex: 0, nodey: 0, depth: 0}];
                    for (; h.length > 0;) {
                        const {idx: s, t: p, nodex: f, nodey: m, depth: _} = h.pop();
                        if (this.leaves[s]) {
                            gh(f, m, _, e, t, n, i, u, d);
                            const s = 1 << _, l = (f + 0) / s, c = (f + 1) / s, h = (m + 0) / s, g = (m + 1) / s,
                                y = xh(l, h, this.dem) * a, v = xh(c, h, this.dem) * a, x = xh(c, g, this.dem) * a,
                                b = xh(l, g, this.dem) * a, w = mh(u[0], u[1], y, d[0], u[1], v, d[0], d[1], x, r, o),
                                M = mh(d[0], d[1], x, u[0], d[1], b, u[0], u[1], y, r, o),
                                T = Math.min(null !== w ? w : Number.MAX_VALUE, null !== M ? M : Number.MAX_VALUE);
                            if (T !== Number.MAX_VALUE) return T;
                            {
                                const e = S([], r, o, p);
                                if (vh(y, v, b, x, _h(e[0], u[0], d[0]), _h(e[1], u[1], d[1])) >= e[2]) return p
                            }
                            continue
                        }
                        let g = 0;
                        for (let h = 0; h < this._siblingOffset.length; h++) {
                            gh((f << 1) + this._siblingOffset[h][0], (m << 1) + this._siblingOffset[h][1], _ + 1, e, t, n, i, u, d), u[2] = -100, d[2] = this.maximums[this.childOffsets[s] + h] * a;
                            const p = fh(u, d, r, o);
                            if (null != p) {
                                const e = p;
                                l[h] = e;
                                let t = !1;
                                for (let n = 0; n < g && !t; n++) e >= l[c[n]] && (c.splice(n, 0, h), t = !0);
                                t || (c[g] = h), g++
                            }
                        }
                        for (let e = 0; e < g; e++) {
                            const t = c[e];
                            h.push({
                                idx: this.childOffsets[s] + t,
                                t: l[t],
                                nodex: (f << 1) + this._siblingOffset[t][0],
                                nodey: (m << 1) + this._siblingOffset[t][1],
                                depth: _ + 1
                            })
                        }
                    }
                    return null
                }

                _addNode(e, t, n) {
                    return this.minimums.push(e), this.maximums.push(t), this.leaves.push(n), this.childOffsets.push(0), this.nodeCount++
                }

                _construct(e, t, n, i, r) {
                    if (1 === e[i].isLeaf(t, n)) return;
                    this.childOffsets[r] || (this.childOffsets[r] = this.nodeCount);
                    const o = i - 1, a = e[o];
                    let s, l = 0;
                    for (let e = 0; e < this._siblingOffset.length; e++) {
                        const i = 2 * t + this._siblingOffset[e][0], r = 2 * n + this._siblingOffset[e][1],
                            o = a.getElevation(i, r), c = a.isLeaf(i, r), u = this._addNode(o.min, o.max, c);
                        c && (l |= 1 << e), s || (s = u)
                    }
                    for (let i = 0; i < this._siblingOffset.length; i++) l & 1 << i || this._construct(e, 2 * t + this._siblingOffset[i][0], 2 * n + this._siblingOffset[i][1], o, s + i)
                }
            }

            function vh(e, t, n, i, r, o) {
                return On(On(e, n, o), On(t, i, o), r)
            }

            function xh(e, t, n) {
                const i = n.dim, r = $(e * i - .5, 0, i - 1), o = $(t * i - .5, 0, i - 1), a = Math.floor(r),
                    s = Math.floor(o), l = Math.min(a + 1, i - 1), c = Math.min(s + 1, i - 1);
                return vh(n.get(a, s), n.get(l, s), n.get(a, c), n.get(l, c), r - a, o - s)
            }

            const bh = {mapbox: [6553.6, 25.6, .1, 1e4], terrarium: [256, 1, 1 / 256, 32768]};

            class wh {
                get tree() {
                    return this._tree || this._buildQuadTree(), this._tree
                }

                constructor(e, t, n, i = !1, r = !1) {
                    if (this.uid = e, t.height !== t.width) throw new RangeError("DEM tiles must be square");
                    if (n && "mapbox" !== n && "terrarium" !== n) return he(`"${n}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                    this.stride = t.height;
                    const o = this.dim = t.height - 2;
                    if (this.data = new Uint32Array(t.data.buffer), this.encoding = n || "mapbox", this.borderReady = i, !i) {
                        for (let e = 0; e < o; e++) this.data[this._idx(-1, e)] = this.data[this._idx(0, e)], this.data[this._idx(o, e)] = this.data[this._idx(o - 1, e)], this.data[this._idx(e, -1)] = this.data[this._idx(e, 0)], this.data[this._idx(e, o)] = this.data[this._idx(e, o - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o, -1)] = this.data[this._idx(o - 1, 0)], this.data[this._idx(-1, o)] = this.data[this._idx(0, o - 1)], this.data[this._idx(o, o)] = this.data[this._idx(o - 1, o - 1)], r && this._buildQuadTree()
                    }
                }

                _buildQuadTree() {
                    this._tree = new yh(this)
                }

                get(e, t, n = !1) {
                    const i = new Uint8Array(this.data.buffer);
                    n && (e = $(e, -1, this.dim), t = $(t, -1, this.dim));
                    const r = 4 * this._idx(e, t);
                    return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(i[r], i[r + 1], i[r + 2])
                }

                static getUnpackVector(e) {
                    return bh[e]
                }

                get unpackVector() {
                    return bh[this.encoding]
                }

                _idx(e, t) {
                    if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                    return (t + 1) * this.stride + (e + 1)
                }

                _unpackMapbox(e, t, n) {
                    return (256 * e * 256 + 256 * t + n) / 10 - 1e4
                }

                _unpackTerrarium(e, t, n) {
                    return 256 * e + t + n / 256 - 32768
                }

                static pack(e, t) {
                    const n = [0, 0, 0, 0], i = wh.getUnpackVector(t);
                    let r = Math.floor((e + i[3]) / i[2]);
                    return n[2] = r % 256, r = Math.floor(r / 256), n[1] = r % 256, r = Math.floor(r / 256), n[0] = r, n
                }

                getPixels() {
                    return new _l({width: this.stride, height: this.stride}, new Uint8Array(this.data.buffer))
                }

                backfillBorder(e, t, n) {
                    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
                    let i = t * this.dim, r = t * this.dim + this.dim, o = n * this.dim, a = n * this.dim + this.dim;
                    switch (t) {
                        case-1:
                            i = r - 1;
                            break;
                        case 1:
                            r = i + 1
                    }
                    switch (n) {
                        case-1:
                            o = a - 1;
                            break;
                        case 1:
                            a = o + 1
                    }
                    const s = -t * this.dim, l = -n * this.dim;
                    for (let t = o; t < a; t++) for (let n = i; n < r; n++) this.data[this._idx(n, t)] = e.data[this._idx(n + s, t + l)]
                }

                onDeserialize() {
                    this._tree && (this._tree.dem = this)
                }
            }

            Yr("DEMData", wh), Yr("DemMinMaxQuadTree", yh, {omit: ["dem"]});

            class Mh {
                constructor(e, t) {
                    this.max = e, this.onRemove = t, this.reset()
                }

                reset() {
                    for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
                    return this.data = {}, this.order = [], this
                }

                add(e, t, n) {
                    const i = e.wrapped().key;
                    void 0 === this.data[i] && (this.data[i] = []);
                    const r = {value: t, timeout: void 0};
                    if (void 0 !== n && (r.timeout = setTimeout(() => {
                        this.remove(e, r)
                    }, n)), this.data[i].push(r), this.order.push(i), this.order.length > this.max) {
                        const e = this._getAndRemoveByKey(this.order[0]);
                        e && this.onRemove(e)
                    }
                    return this
                }

                has(e) {
                    return e.wrapped().key in this.data
                }

                getAndRemove(e) {
                    return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
                }

                _getAndRemoveByKey(e) {
                    const t = this.data[e].shift();
                    return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value
                }

                getByKey(e) {
                    const t = this.data[e];
                    return t ? t[0].value : null
                }

                get(e) {
                    return this.has(e) ? this.data[e.wrapped().key][0].value : null
                }

                remove(e, t) {
                    if (!this.has(e)) return this;
                    const n = e.wrapped().key, i = void 0 === t ? 0 : this.data[n].indexOf(t), r = this.data[n][i];
                    return this.data[n].splice(i, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[n].length && delete this.data[n], this.onRemove(r.value), this.order.splice(this.order.indexOf(n), 1), this
                }

                setMaxSize(e) {
                    for (this.max = e; this.order.length > this.max;) {
                        const e = this._getAndRemoveByKey(this.order[0]);
                        e && this.onRemove(e)
                    }
                    return this
                }

                filter(e) {
                    const t = [];
                    for (const n in this.data) for (const i of this.data[n]) e(i.value) || t.push(i);
                    for (const e of t) this.remove(e.value.tileID, e)
                }
            }

            class Th extends yt {
                constructor(e, t, n) {
                    super(), this.id = e, this._onlySymbols = n, t.on("data", e => {
                        "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform))
                    }), t.on("error", () => {
                        this._sourceErrored = !0
                    }), this._source = t, this._tiles = {}, this._cache = new Mh(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = null, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new hh
                }

                onAdd(e) {
                    this.map = e, this._minTileCacheSize = e ? e._minTileCacheSize : null, this._maxTileCacheSize = e ? e._maxTileCacheSize : null
                }

                loaded() {
                    if (this._sourceErrored) return !0;
                    if (!this._sourceLoaded) return !1;
                    if (!this._source.loaded()) return !1;
                    for (const e in this._tiles) {
                        const t = this._tiles[e];
                        if ("loaded" !== t.state && "errored" !== t.state) return !1
                    }
                    return !0
                }

                getSource() {
                    return this._source
                }

                pause() {
                    this._paused = !0
                }

                resume() {
                    if (!this._paused) return;
                    const e = this._shouldReloadOnResume;
                    this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform)
                }

                _loadTile(e, t) {
                    return e.isSymbolTile = this._onlySymbols, this._source.loadTile(e, t)
                }

                _unloadTile(e) {
                    if (this._source.unloadTile) return this._source.unloadTile(e, () => {
                    })
                }

                _abortTile(e) {
                    if (this._source.abortTile) return this._source.abortTile(e, () => {
                    })
                }

                serialize() {
                    return this._source.serialize()
                }

                prepare(e) {
                    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                    for (const t in this._tiles) {
                        const n = this._tiles[t];
                        n.upload(e), n.prepare(this.map.style.imageManager)
                    }
                }

                getIds() {
                    return Q(this._tiles).map(e => e.tileID).sort(kh).map(e => e.key)
                }

                getRenderableIds(e) {
                    const t = [];
                    for (const n in this._tiles) this._isIdRenderable(+n, e) && t.push(this._tiles[n]);
                    return e ? t.sort((e, t) => {
                        const n = e.tileID, i = t.tileID,
                            o = new r(n.canonical.x, n.canonical.y)._rotate(this.transform.angle),
                            a = new r(i.canonical.x, i.canonical.y)._rotate(this.transform.angle);
                        return n.overscaledZ - i.overscaledZ || a.y - o.y || a.x - o.x
                    }).map(e => e.tileID.key) : t.map(e => e.tileID).sort(kh).map(e => e.key)
                }

                hasRenderableParent(e) {
                    const t = this.findLoadedParent(e, 0);
                    return !!t && this._isIdRenderable(t.tileID.key)
                }

                _isIdRenderable(e, t) {
                    return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade())
                }

                reload() {
                    if (this._paused) this._shouldReloadOnResume = !0; else {
                        this._cache.reset();
                        for (const e in this._tiles) "errored" !== this._tiles[e].state && this._reloadTile(+e, "reloading")
                    }
                }

                _reloadTile(e, t) {
                    const n = this._tiles[e];
                    n && ("loading" !== n.state && (n.state = t), this._loadTile(n, this._tileLoaded.bind(this, n, e, t)))
                }

                _tileLoaded(e, t, n, i) {
                    if (i) if (e.state = "errored", 404 !== i.status) this._source.fire(new gt(i, {tile: e})); else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const e = this.map.painter.terrain;
                        this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id)
                    } else this.update(this.transform); else e.timeAdded = Me.now(), "expired" === n && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(t, e), "raster-dem" === this._source.type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new _t("data", {
                        dataType: "source",
                        tile: e,
                        coord: e.tileID,
                        sourceCacheId: this.id
                    }))
                }

                _backfillDEM(e) {
                    const t = this.getRenderableIds();
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        if (e.neighboringTiles && e.neighboringTiles[r]) {
                            const t = this.getTileByID(r);
                            n(e, t), n(t, e)
                        }
                    }

                    function n(e, t) {
                        if (!e.dem || e.dem.borderReady) return;
                        e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;
                        let n = t.tileID.canonical.x - e.tileID.canonical.x;
                        const i = t.tileID.canonical.y - e.tileID.canonical.y, r = Math.pow(2, e.tileID.canonical.z),
                            o = t.tileID.key;
                        0 === n && 0 === i || Math.abs(i) > 1 || (Math.abs(n) > 1 && (1 === Math.abs(n + r) ? n += r : 1 === Math.abs(n - r) && (n -= r)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, n, i), e.neighboringTiles && e.neighboringTiles[o] && (e.neighboringTiles[o].backfilled = !0)))
                    }
                }

                getTile(e) {
                    return this.getTileByID(e.key)
                }

                getTileByID(e) {
                    return this._tiles[e]
                }

                _retainLoadedChildren(e, t, n, i) {
                    for (const r in this._tiles) {
                        let o = this._tiles[r];
                        if (i[r] || !o.hasData() || o.tileID.overscaledZ <= t || o.tileID.overscaledZ > n) continue;
                        let a = o.tileID;
                        for (; o && o.tileID.overscaledZ > t + 1;) {
                            const e = o.tileID.scaledTo(o.tileID.overscaledZ - 1);
                            o = this._tiles[e.key], o && o.hasData() && (a = e)
                        }
                        let s = a;
                        for (; s.overscaledZ > t;) if (s = s.scaledTo(s.overscaledZ - 1), e[s.key]) {
                            i[a.key] = a;
                            break
                        }
                    }
                }

                findLoadedParent(e, t) {
                    if (e.key in this._loadedParentTiles) {
                        const n = this._loadedParentTiles[e.key];
                        return n && n.tileID.overscaledZ >= t ? n : null
                    }
                    for (let n = e.overscaledZ - 1; n >= t; n--) {
                        const t = e.scaledTo(n), i = this._getLoadedTile(t);
                        if (i) return i
                    }
                }

                _getLoadedTile(e) {
                    const t = this._tiles[e.key];
                    return t && t.hasData() ? t : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key)
                }

                updateCacheSize(e, t) {
                    t = t || this._source.tileSize;
                    const n = Math.ceil(e.width / t) + 1, i = Math.ceil(e.height / t) + 1, r = Math.floor(n * i * 5),
                        o = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r) : r,
                        a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;
                    this._cache.setMaxSize(a)
                }

                handleWrapJump(e) {
                    const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);
                    if (this._prevLng = e, t) {
                        const e = {};
                        for (const n in this._tiles) {
                            const i = this._tiles[n];
                            i.tileID = i.tileID.unwrapTo(i.tileID.wrap + t), e[i.tileID.key] = i
                        }
                        this._tiles = e;
                        for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
                        for (const e in this._tiles) this._setTileReloadTimer(+e, this._tiles[e])
                    }
                }

                update(e, t, n) {
                    if (this.transform = e, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                    if (this.usedForTerrain && !n) return;
                    let i;
                    this.updateCacheSize(e, t), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(e => new rh(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y)) : (i = e.coveringTiles({
                        tileSize: t || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !n,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    }), this._source.hasTile && (i = i.filter(e => this._source.hasTile(e)))) : i = [];
                    const r = this._updateRetainedTiles(i);
                    if (Sh(this._source.type) && 0 !== i.length) {
                        const e = {}, t = {}, n = Object.keys(r);
                        for (const i of n) {
                            const n = r[i], o = this._tiles[i];
                            if (!o || o.fadeEndTime && o.fadeEndTime <= Me.now()) continue;
                            const a = this.findLoadedParent(n, Math.max(n.overscaledZ - Th.maxOverzooming, this._source.minzoom));
                            a && (this._addTile(a.tileID), e[a.tileID.key] = a.tileID), t[i] = n
                        }
                        const o = i[i.length - 1].overscaledZ;
                        for (const e in this._tiles) {
                            const n = this._tiles[e];
                            if (r[e] || !n.hasData()) continue;
                            let i = n.tileID;
                            for (; i.overscaledZ > o;) {
                                i = i.scaledTo(i.overscaledZ - 1);
                                const o = this._tiles[i.key];
                                if (o && o.hasData() && t[i.key]) {
                                    r[e] = n.tileID;
                                    break
                                }
                            }
                        }
                        for (const t in e) r[t] || (this._coveredTiles[t] = !0, r[t] = e[t])
                    }
                    for (const e in r) this._tiles[e].clearFadeHold();
                    const o = function (e, t) {
                        const n = [];
                        for (const i in e) i in t || n.push(i);
                        return n
                    }(this._tiles, r);
                    for (const e of o) {
                        const t = this._tiles[e];
                        t.hasSymbolBuckets && !t.holdingForFade() ? t.setHoldDuration(this.map._fadeDuration) : t.hasSymbolBuckets && !t.symbolFadeFinished() || this._removeTile(+e)
                    }
                    this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
                }

                releaseSymbolFadeTiles() {
                    for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e)
                }

                _updateRetainedTiles(e) {
                    const t = {};
                    if (0 === e.length) return t;
                    const n = {}, i = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0), r = e[0].overscaledZ,
                        o = Math.max(r - Th.maxOverzooming, this._source.minzoom),
                        a = Math.max(r + Th.maxUnderzooming, this._source.minzoom), s = {};
                    for (const n of e) {
                        const e = this._addTile(n);
                        t[n.key] = n, e.hasData() || i < this._source.maxzoom && (s[n.key] = n)
                    }
                    this._retainLoadedChildren(s, i, a, t);
                    for (const i of e) {
                        let e = this._tiles[i.key];
                        if (e.hasData()) continue;
                        if (i.canonical.z >= this._source.maxzoom) {
                            const e = i.children(this._source.maxzoom)[0], n = this.getTile(e);
                            if (n && n.hasData()) {
                                t[e.key] = e;
                                continue
                            }
                        } else {
                            const e = i.children(this._source.maxzoom);
                            if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue
                        }
                        let r = e.wasRequested();
                        for (let a = i.overscaledZ - 1; a >= o; --a) {
                            const o = i.scaledTo(a);
                            if (n[o.key]) break;
                            if (n[o.key] = !0, e = this.getTile(o), !e && r && (e = this._addTile(o)), e && (t[o.key] = o, r = e.wasRequested(), e.hasData())) break
                        }
                    }
                    return t
                }

                _updateLoadedParentTileCache() {
                    this._loadedParentTiles = {};
                    for (const e in this._tiles) {
                        const t = [];
                        let n, i = this._tiles[e].tileID;
                        for (; i.overscaledZ > 0;) {
                            if (i.key in this._loadedParentTiles) {
                                n = this._loadedParentTiles[i.key];
                                break
                            }
                            t.push(i.key);
                            const e = i.scaledTo(i.overscaledZ - 1);
                            if (n = this._getLoadedTile(e), n) break;
                            i = e
                        }
                        for (const e of t) this._loadedParentTiles[e] = n
                    }
                }

                _addTile(e) {
                    let t = this._tiles[e.key];
                    if (t) return t;
                    t = this._cache.getAndRemove(e), t && (this._setTileReloadTimer(e.key, t), t.tileID = e, this._state.initializeTileState(t, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t)));
                    const n = Boolean(t);
                    if (!n) {
                        const n = this.map ? this.map.painter : null,
                            i = "raster" === this._source.type || "raster-dem" === this._source.type;
                        t = new Bh(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, n, i), this._loadTile(t, this._tileLoaded.bind(this, t, e.key, t.state))
                    }
                    return t ? (t.uses++, this._tiles[e.key] = t, n || this._source.fire(new _t("dataloading", {
                        tile: t,
                        coord: t.tileID,
                        dataType: "source"
                    })), t) : null
                }

                _setTileReloadTimer(e, t) {
                    e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
                    const n = t.getExpiryTimeout();
                    n && (this._timers[e] = setTimeout(() => {
                        this._reloadTile(e, "expired"), delete this._timers[e]
                    }, n))
                }

                _removeTile(e) {
                    const t = this._tiles[e];
                    t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && "reloading" !== t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))))
                }

                clearTiles() {
                    this._shouldReloadOnResume = !1, this._paused = !1;
                    for (const e in this._tiles) this._removeTile(+e);
                    this._source._clear && this._source._clear(), this._cache.reset()
                }

                tilesIn(e, t, n) {
                    const i = [], r = this.transform;
                    if (!r) return i;
                    for (const o in this._tiles) {
                        const a = this._tiles[o];
                        if (n && a.clearQueryDebugViz(), a.holdingForFade()) continue;
                        const s = e.containsTile(a, r, t);
                        s && i.push(s)
                    }
                    return i
                }

                getVisibleCoordinates(e) {
                    const t = this.getRenderableIds(e).map(e => this._tiles[e].tileID);
                    for (const e of t) e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped());
                    return t
                }

                hasTransition() {
                    if (this._source.hasTransition()) return !0;
                    if (Sh(this._source.type)) for (const e in this._tiles) {
                        const t = this._tiles[e];
                        if (void 0 !== t.fadeEndTime && t.fadeEndTime >= Me.now()) return !0
                    }
                    return !1
                }

                setFeatureState(e, t, n) {
                    this._state.updateState(e = e || "_geojsonTileLayer", t, n)
                }

                removeFeatureState(e, t, n) {
                    this._state.removeFeatureState(e = e || "_geojsonTileLayer", t, n)
                }

                getFeatureState(e, t) {
                    return this._state.getState(e = e || "_geojsonTileLayer", t)
                }

                setDependencies(e, t, n) {
                    const i = this._tiles[e];
                    i && i.setDependencies(t, n)
                }

                reloadTilesForDependencies(e, t) {
                    for (const n in this._tiles) this._tiles[n].hasDependency(e, t) && this._reloadTile(+n, "reloading");
                    this._cache.filter(n => !n.hasDependency(e, t))
                }

                _preloadTiles(e, t) {
                    const n = new Map, i = Array.isArray(e) ? e : [e], r = this.map.painter.terrain,
                        o = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;
                    for (const e of i) {
                        const t = e.coveringTiles({
                            tileSize: o,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom && !this.usedForTerrain,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain
                        });
                        for (const e of t) n.set(e.key, e);
                        this.usedForTerrain && e.updateElevation(!1)
                    }
                    const a = Array.from(n.values()),
                        s = "raster" === this._source.type || "raster-dem" === this._source.type;
                    K(a, (e, t) => {
                        const n = new Bh(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, s);
                        this._loadTile(n, e => {
                            "raster-dem" === this._source.type && n.dem && this._backfillDEM(n), t(e, n)
                        })
                    }, t)
                }
            }

            function kh(e, t) {
                const n = Math.abs(2 * e.wrap) - +(e.wrap < 0), i = Math.abs(2 * t.wrap) - +(t.wrap < 0);
                return e.overscaledZ - t.overscaledZ || i - n || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x
            }

            function Sh(e) {
                return "raster" === e || "image" === e || "video" === e
            }

            Th.maxOverzooming = 10, Th.maxUnderzooming = 3;

            class Dh {
                constructor(e, t, n) {
                    this._demTile = e, this._dem = this._demTile.dem, this._scale = t, this._offset = n
                }

                static create(e, t, n) {
                    const i = n || e.findDEMTileFor(t);
                    if (!i || !i.dem) return;
                    const r = i.dem, o = i.tileID, a = 1 << t.canonical.z - o.canonical.z;
                    return new Dh(i, i.tileSize / gs / a, [(t.canonical.x / a - o.canonical.x) * r.dim, (t.canonical.y / a - o.canonical.y) * r.dim])
                }

                tileCoordToPixel(e, t) {
                    const n = t * this._scale + this._offset[1], i = Math.floor(e * this._scale + this._offset[0]),
                        o = Math.floor(n);
                    return new r(i, o)
                }

                getElevationAt(e, t, n, i) {
                    const r = e * this._scale + this._offset[0], o = t * this._scale + this._offset[1],
                        a = Math.floor(r), s = Math.floor(o), l = this._dem;
                    return i = !!i, n ? On(On(l.get(a, s, i), l.get(a, s + 1, i), o - s), On(l.get(a + 1, s, i), l.get(a + 1, s + 1, i), o - s), r - a) : l.get(a, s, i)
                }

                getElevationAtPixel(e, t, n) {
                    return this._dem.get(e, t, !!n)
                }

                getMeterToDEM(e) {
                    return (1 << this._demTile.tileID.canonical.z) * ks(1, e) * this._dem.stride
                }
            }

            class Lh {
                constructor(e, t) {
                    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Cr(gs, 16, 0), this.featureIndexArray = new Ra, this.promoteId = t
                }

                insert(e, t, n, i, r, o = 0) {
                    const a = this.featureIndexArray.length;
                    this.featureIndexArray.emplaceBack(n, i, r, o);
                    const s = this.grid;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e];
                            i[0] = Math.min(i[0], t.x), i[1] = Math.min(i[1], t.y), i[2] = Math.max(i[2], t.x), i[3] = Math.max(i[3], t.y)
                        }
                        i[0] < gs && i[1] < gs && i[2] >= 0 && i[3] >= 0 && s.insert(a, i[0], i[1], i[2], i[3])
                    }
                }

                loadVTLayers() {
                    if (!this.vtLayers) {
                        this.vtLayers = new gc.VectorTile(new iu(this.rawTileData)).layers, this.sourceLayerCoder = new uh(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                        for (const e in this.vtLayers) this.vtFeatures[e] = []
                    }
                    return this.vtLayers
                }

                query(e, t, n, i) {
                    this.loadVTLayers();
                    const r = e.params || {}, o = Ji(r.filter), a = e.tileResult, s = e.transform,
                        l = a.bufferedTilespaceBounds,
                        c = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (e, t, n, i) => Xs(a.bufferedTilespaceGeometry, e, t, n, i));
                    c.sort(Ch);
                    let u = null;
                    s.elevation && c.length > 0 && (u = Dh.create(s.elevation, this.tileID));
                    const d = {};
                    let h;
                    for (let s = 0; s < c.length; s++) {
                        const l = c[s];
                        if (l === h) continue;
                        h = l;
                        const p = this.featureIndexArray.get(l);
                        let f = null;
                        this.loadMatchingFeature(d, p, o, r.layers, r.availableImages, t, n, i, (t, n, i, r = 0) => (f || (f = zs(t, this.tileID.canonical, e.tileTransform)), n.queryIntersectsFeature(a, t, i, f, this.z, e.transform, e.pixelPosMatrix, u, r)))
                    }
                    return d
                }

                loadMatchingFeature(e, t, n, i, r, o, a, s, l) {
                    const {featureIndex: c, bucketIndex: u, sourceLayerIndex: d, layoutVertexArrayOffset: h} = t,
                        p = this.bucketLayerIDs[u];
                    if (i && !function (e, t) {
                        for (let n = 0; n < e.length; n++) if (t.indexOf(e[n]) >= 0) return !0;
                        return !1
                    }(i, p)) return;
                    const f = this.sourceLayerCoder.decode(d), m = this.vtLayers[f].feature(c);
                    if (n.needGeometry) {
                        const e = Os(m, !0);
                        if (!n.filter(new Yo(this.tileID.overscaledZ), e, this.tileID.canonical)) return
                    } else if (!n.filter(new Yo(this.tileID.overscaledZ), m)) return;
                    const _ = this.getId(m, f);
                    for (let t = 0; t < p.length; t++) {
                        const n = p[t];
                        if (i && i.indexOf(n) < 0) continue;
                        const u = o[n];
                        if (!u) continue;
                        let d = {};
                        void 0 !== _ && s && (d = s.getState(u.sourceLayer || "_geojsonTileLayer", _));
                        const f = ee({}, a[n]);
                        f.paint = Eh(f.paint, u.paint, m, d, r), f.layout = Eh(f.layout, u.layout, m, d, r);
                        const g = !l || l(m, u, d, h);
                        if (!g) continue;
                        const y = new dh(m, this.z, this.x, this.y, _);
                        y.layer = f;
                        let v = e[n];
                        void 0 === v && (v = e[n] = []), v.push({featureIndex: c, feature: y, intersectionZ: g})
                    }
                }

                lookupSymbolFeatures(e, t, n, i, r, o, a, s) {
                    const l = {};
                    this.loadVTLayers();
                    const c = Ji(r);
                    for (const r of e) this.loadMatchingFeature(l, {
                        bucketIndex: n,
                        sourceLayerIndex: i,
                        featureIndex: r,
                        layoutVertexArrayOffset: 0
                    }, c, o, a, s, t);
                    return l
                }

                loadFeature(e) {
                    const {featureIndex: t, sourceLayerIndex: n} = e;
                    this.loadVTLayers();
                    const i = this.sourceLayerCoder.decode(n), r = this.vtFeatures[i];
                    if (r[t]) return r[t];
                    const o = this.vtLayers[i].feature(t);
                    return r[t] = o, o
                }

                hasLayer(e) {
                    for (const t of this.bucketLayerIDs) for (const n of t) if (e === n) return !0;
                    return !1
                }

                getId(e, t) {
                    let n = e.id;
                    return this.promoteId && (n = e.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[t]], "boolean" == typeof n && (n = Number(n))), n
                }
            }

            function Eh(e, t, n, i, r) {
                return le(e, (e, o) => {
                    const a = t instanceof Uo ? t.get(o) : null;
                    return a && a.evaluate ? a.evaluate(n, i, r) : a
                })
            }

            function Ch(e, t) {
                return t - e
            }

            Yr("FeatureIndex", Lh, {omit: ["rawTileData", "sourceLayerCoder"]});
            var Ah = ea([{name: "a_pos", type: "Int16", components: 2}]);
            const Ih = new Uint16Array(8184);
            for (let e = 0; e < 2046; e++) {
                let t = e + 2, n = 0, i = 0, r = 0, o = 0, a = 0, s = 0;
                for (1 & t ? r = o = a = 32 : n = i = s = 32; (t >>= 1) > 1;) {
                    const e = n + r >> 1, l = i + o >> 1;
                    1 & t ? (r = n, o = i, n = a, i = s) : (n = r, i = o, r = a, o = s), a = e, s = l
                }
                const l = 4 * e;
                Ih[l + 0] = n, Ih[l + 1] = i, Ih[l + 2] = r, Ih[l + 3] = o
            }
            const Ph = new Uint16Array(2178), Rh = new Uint8Array(1089), Yh = new Uint16Array(1089);

            function zh(e) {
                return 0 === e ? -.03125 : 32 === e ? .03125 : 0
            }

            var Oh = ea([{name: "a_pos", type: "Int16", components: 2}, {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }]);
            const Fh = {
                type: 2,
                extent: gs,
                loadGeometry: () => [[new r(0, 0), new r(8193, 0), new r(8193, 8193), new r(0, 8193), new r(0, 0)]]
            };

            class Bh {
                constructor(e, t, n, i, r) {
                    this.tileID = e, this.uid = ne(), this.uses = 0, this.tileSize = t, this.tileZoom = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r, this.expiredRequestCount = 0, this.state = "loading", i && i.transform && (this.projection = i.transform.projection)
                }

                registerFadeDuration(e) {
                    const t = e + this.timeAdded;
                    t < Me.now() || this.fadeEndTime && t < this.fadeEndTime || (this.fadeEndTime = t)
                }

                wasRequested() {
                    return "errored" === this.state || "loaded" === this.state || "reloading" === this.state
                }

                get tileTransform() {
                    return this._tileTransform || (this._tileTransform = np(this.tileID.canonical, this.projection)), this._tileTransform
                }

                loadVectorData(e, t, n) {
                    if (this.unloadVectorData(), this.state = "loaded", e) {
                        e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (e, t) {
                            const n = {};
                            if (!t) return n;
                            for (const i of e) {
                                const e = i.layerIds.map(e => t.getLayer(e)).filter(Boolean);
                                if (0 !== e.length) {
                                    i.layers = e, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map(t => e.filter(e => e.id === t)[0]));
                                    for (const t of e) n[t.id] = i
                                }
                            }
                            return n
                        }(e.buckets, t.style), this.hasSymbolBuckets = !1;
                        for (const e in this.buckets) {
                            const t = this.buckets[e];
                            if (t instanceof Pd) {
                                if (this.hasSymbolBuckets = !0, !n) break;
                                t.justReloaded = !0
                            }
                        }
                        if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e in this.buckets) {
                            const t = this.buckets[e];
                            if (t instanceof Pd && t.hasRTLText) {
                                this.hasRTLText = !0, Ro.isLoading() || Ro.isLoaded() || "deferred" !== Io() || Po();
                                break
                            }
                        }
                        this.queryPadding = 0;
                        for (const e in this.buckets) {
                            const n = this.buckets[e];
                            this.queryPadding = Math.max(this.queryPadding, t.style.getLayer(e).queryRadius(n))
                        }
                        e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), e.lineAtlas && (this.lineAtlas = e.lineAtlas)
                    } else this.collisionBoxArray = new Sa
                }

                unloadVectorData() {
                    if (this.hasData()) {
                        for (const e in this.buckets) this.buckets[e].destroy();
                        this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugIndexBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this.globeGridBuffer && (this.globeGridBuffer.destroy(), this.globeGridBuffer = null), this.globePoleBuffer && (this.globePoleBuffer.destroy(), this.globePoleBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded"
                    }
                }

                getBucket(e) {
                    return this.buckets[e.id]
                }

                upload(e) {
                    for (const t in this.buckets) {
                        const n = this.buckets[t];
                        n.uploadPending() && n.upload(e)
                    }
                    const t = e.gl;
                    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new $d(e, this.imageAtlas.image, t.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new $d(e, this.glyphAtlasImage, t.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new $d(e, this.lineAtlas.image, t.ALPHA), this.lineAtlas.uploaded = !0)
                }

                prepare(e) {
                    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
                }

                queryRenderedFeatures(e, t, n, i, r, o, a, s) {
                    return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                        tileResult: i,
                        pixelPosMatrix: a,
                        transform: o,
                        params: r,
                        tileTransform: this.tileTransform
                    }, e, t, n) : {}
                }

                querySourceFeatures(e, t) {
                    const n = this.latestFeatureIndex;
                    if (!n || !n.rawTileData) return;
                    const i = n.loadVTLayers(), r = t ? t.sourceLayer : "", o = i._geojsonTileLayer || i[r];
                    if (!o) return;
                    const a = Ji(t && t.filter), {z: s, x: l, y: c} = this.tileID.canonical, u = {z: s, x: l, y: c};
                    for (let t = 0; t < o.length; t++) {
                        const i = o.feature(t);
                        if (a.needGeometry) {
                            const e = Os(i, !0);
                            if (!a.filter(new Yo(this.tileID.overscaledZ), e, this.tileID.canonical)) continue
                        } else if (!a.filter(new Yo(this.tileID.overscaledZ), i)) continue;
                        const d = n.getId(i, r), h = new dh(i, s, l, c, d);
                        h.tile = u, e.push(h)
                    }
                }

                hasData() {
                    return "loaded" === this.state || "reloading" === this.state || "expired" === this.state
                }

                patternsLoaded() {
                    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                }

                setExpiryData(e) {
                    const t = this.expirationTime;
                    if (e.cacheControl) {
                        const t = _e(e.cacheControl);
                        t["max-age"] && (this.expirationTime = Date.now() + 1e3 * t["max-age"])
                    } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
                    if (this.expirationTime) {
                        const e = Date.now();
                        let n = !1;
                        if (this.expirationTime > e) n = !1; else if (t) if (this.expirationTime < t) n = !0; else {
                            const i = this.expirationTime - t;
                            i ? this.expirationTime = e + Math.max(i, 3e4) : n = !0
                        } else n = !0;
                        n ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
                    }
                }

                getExpiryTimeout() {
                    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1)
                }

                setFeatureState(e, t) {
                    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e).length || !t) return;
                    const n = this.latestFeatureIndex.loadVTLayers(), i = t.style.listImages();
                    for (const r in this.buckets) {
                        if (!t.style.hasLayer(r)) continue;
                        const o = this.buckets[r], a = o.layers[0].sourceLayer || "_geojsonTileLayer", s = n[a],
                            l = e[a];
                        if (!s || !l || 0 === Object.keys(l).length) continue;
                        if (o.update(l, s, i, this.imageAtlas && this.imageAtlas.patternPositions || {}), o instanceof Yc || o instanceof ic) {
                            const e = t.style._getSourceCache(o.layers[0].source);
                            t._terrain && t._terrain.enabled && e && o.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(e.id, this.tileID)
                        }
                        const c = t && t.style && t.style.getLayer(r);
                        c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(o)))
                    }
                }

                holdingForFade() {
                    return void 0 !== this.symbolFadeHoldUntil
                }

                symbolFadeFinished() {
                    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Me.now()
                }

                clearFadeHold() {
                    this.symbolFadeHoldUntil = void 0
                }

                setHoldDuration(e) {
                    this.symbolFadeHoldUntil = Me.now() + e
                }

                setDependencies(e, t) {
                    const n = {};
                    for (const e of t) n[e] = !0;
                    this.dependencies[e] = n
                }

                hasDependency(e, t) {
                    for (const n of e) {
                        const e = this.dependencies[n];
                        if (e) for (const n of t) if (e[n]) return !0
                    }
                    return !1
                }

                clearQueryDebugViz() {
                }

                _makeDebugTileBoundsBuffers(e, t) {
                    if (!t || "mercator" === t.name || this._tileDebugBuffer) return;
                    const n = zs(Fh, this.tileID.canonical, this.tileTransform)[0], i = new na, r = new wa;
                    for (let e = 0; e < n.length; e++) {
                        const {x: t, y: o} = n[e];
                        i.emplaceBack(t, o), r.emplaceBack(e)
                    }
                    r.emplaceBack(0), this._tileDebugIndexBuffer = e.createIndexBuffer(r), this._tileDebugBuffer = e.createVertexBuffer(i, Oh.members), this._tileDebugSegments = _s.simpleSegment(0, 0, i.length, r.length)
                }

                _makeTileBoundsBuffers(e, t) {
                    if (this._tileBoundsBuffer || !t || "mercator" === t.name) return;
                    const n = zs(Fh, this.tileID.canonical, this.tileTransform)[0];
                    let i, r;
                    if (this.isRaster) {
                        const e = function (e, t) {
                            const n = np(e, t), i = Math.pow(2, e.z);
                            for (let r = 0; r < 33; r++) for (let o = 0; o < 33; o++) {
                                const a = Ss((e.x + (o + zh(o)) / 32) / i), s = Ds((e.y + (r + zh(r)) / 32) / i),
                                    l = t.project(a, s), c = 33 * r + o;
                                Ph[2 * c + 0] = Math.round((l.x * n.scale - n.x) * gs), Ph[2 * c + 1] = Math.round((l.y * n.scale - n.y) * gs)
                            }
                            Rh.fill(0), Yh.fill(0);
                            for (let e = 2045; e >= 0; e--) {
                                const t = 4 * e, n = Ih[t + 0], i = Ih[t + 1], r = Ih[t + 2], o = Ih[t + 3],
                                    a = n + r >> 1, s = i + o >> 1, l = a + s - i, c = s + n - a, u = 33 * i + n,
                                    d = 33 * o + r, h = 33 * s + a,
                                    p = Math.hypot((Ph[2 * u + 0] + Ph[2 * d + 0]) / 2 - Ph[2 * h + 0], (Ph[2 * u + 1] + Ph[2 * d + 1]) / 2 - Ph[2 * h + 1]) >= 16;
                                if (Rh[h] = Rh[h] || (p ? 1 : 0), e < 1022) {
                                    const e = 33 * (i + c >> 1) + (n + l >> 1), t = 33 * (o + c >> 1) + (r + l >> 1);
                                    Rh[h] = Rh[h] || Rh[e] || Rh[t]
                                }
                            }
                            const r = new ia, o = new fa;
                            let a = 0;

                            function s(e, t) {
                                const n = 33 * t + e;
                                return 0 === Yh[n] && (r.emplaceBack(Ph[2 * n + 0], Ph[2 * n + 1], e * gs / 32, t * gs / 32), Yh[n] = ++a), Yh[n] - 1
                            }

                            function l(e, t, n, i, r, a) {
                                const c = e + n >> 1, u = t + i >> 1;
                                if (Math.abs(e - r) + Math.abs(t - a) > 1 && Rh[33 * u + c]) l(r, a, e, t, c, u), l(n, i, r, a, c, u); else {
                                    const l = s(e, t), c = s(n, i), u = s(r, a);
                                    o.emplaceBack(l, c, u)
                                }
                            }

                            return l(0, 0, 32, 32, 32, 0), l(32, 32, 0, 0, 0, 32), {vertices: r, indices: o}
                        }(this.tileID.canonical, t);
                        i = e.vertices, r = e.indices
                    } else {
                        i = new ia, r = new fa;
                        for (const {x: e, y: t} of n) i.emplaceBack(e, t, 0, 0);
                        const e = wl(i.int16, void 0, 4);
                        for (let t = 0; t < e.length; t += 3) r.emplaceBack(e[t], e[t + 1], e[t + 2])
                    }
                    this._tileBoundsBuffer = e.createVertexBuffer(i, Oh.members), this._tileBoundsIndexBuffer = e.createIndexBuffer(r), this._tileBoundsSegments = _s.simpleSegment(0, 0, i.length, r.length)
                }
            }

            const jh = ea([{type: "Float32", name: "a_globe_pos", components: 3}, {
                    type: "Float32",
                    name: "a_merc_pos",
                    components: 2
                }, {type: "Float32", name: "a_uv", components: 2}]),
                Hh = ea([{type: "Float32", name: "a_pos", components: 3}, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }]), {members: Nh} = jh;

            function Uh(e, t) {
                const n = e.fovAboveCenter, i = e.elevation ? e.elevation.getMinElevationBelowMSL() * t : 0,
                    r = (e._camera.position[2] * e.worldSize - i) / Math.cos(e._pitch),
                    o = Math.sin(n) * r / Math.sin(Math.max(Math.PI / 2 - e._pitch - n, .01)),
                    a = Math.sin(e._pitch) * o + r;
                return Math.min(1.01 * a, r * (1 / e._horizonShift))
            }

            const Wh = gs / Math.PI / 2, Vh = -Wh, Gh = Wh,
                qh = [new ol([Vh, Vh, Vh], [Gh, Gh, Gh]), new ol([Vh, Vh, Vh], [0, 0, Gh]), new ol([0, Vh, Vh], [Gh, 0, Gh]), new ol([Vh, 0, Vh], [0, Gh, Gh]), new ol([0, 0, Vh], [Gh, Gh, Gh])];

            function Zh(e) {
                if (e.z <= 1) return qh[e.z + 2 * e.y + e.x];
                const [t, n] = $h(e), i = [Jh(t[0], t[1]), Jh(t[0], n[1]), Jh(n[0], t[1]), Jh(n[0], n[1])],
                    r = [Gh, Gh, Gh], o = [Vh, Vh, Vh];
                for (const e of i) r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.min(r[2], e[2]), o[0] = Math.max(o[0], e[0]), o[1] = Math.max(o[1], e[1]), o[2] = Math.max(o[2], e[2]);
                return new ol(r, o)
            }

            function $h(e) {
                const t = Math.pow(2, e.z), n = e.x / t, i = (e.x + 1) / t, r = (e.y + 1) / t;
                return [[Ds(e.y / t), Ss(n)], [Ds(r), Ss(i)]]
            }

            function Xh(e, t, n, i) {
                return n = U(n), i || (i = Wh), [e * Math.sin(n) * i, -t * i, e * Math.cos(n) * i]
            }

            function Jh(e, t, n) {
                return Xh(Math.cos(U(e)), Math.sin(U(e)), t, n)
            }

            function Kh(e) {
                return 16383 / Math.max(...P([], e.max, e.min))
            }

            function Qh(e) {
                const t = u(new Float64Array(16)), n = 1 / Kh(e);
                return h(t, t, e.min), p(t, t, [n, n, n]), t
            }

            function ep(e, t, n) {
                const i = t / (2 * Math.PI), r = function (e) {
                    const t = gs / (2 * Math.PI);
                    return e / (2 * Math.PI) / t
                }(t);
                if (!n) {
                    const i = $(e.center.lat, -85.051129, Es);
                    n = [Ms(e.center.lng) * t, Ts(i) * t]
                }
                const o = u(new Float64Array(16));
                return h(o, o, [n[0], n[1], -i]), p(o, o, [r, r, r]), f(o, o, U(-e._center.lat)), m(o, o, U(-e._center.lng)), o
            }

            class tp {
                constructor(e) {
                    const t = this._createGridIndices();
                    this.gridIndexBuffer = e.createIndexBuffer(t, !0), this.gridSegments = _s.simpleSegment(0, 0, 4225, 8192);
                    const n = this._createPoleTriangleIndices();
                    this.poleIndexBuffer = e.createIndexBuffer(n, !0), this.poleSegments = _s.simpleSegment(0, 0, 66, 64);
                    const i = new va;
                    i.emplaceBack(-1, 1, 1, 0, 0, 0, 0), i.emplaceBack(1, 1, 1, 0, 0, 1, 0), i.emplaceBack(1, -1, 1, 0, 0, 1, 1), i.emplaceBack(-1, -1, 1, 0, 0, 0, 1);
                    const r = new fa;
                    r.emplaceBack(0, 1, 2), r.emplaceBack(2, 3, 0), this.atmosphereVertexBuffer = e.createVertexBuffer(i, Hh.members), this.atmosphereIndexBuffer = e.createIndexBuffer(r), this.atmosphereSegments = _s.simpleSegment(0, 0, 4, 2)
                }

                destroy() {
                    this.poleIndexBuffer.destroy(), this.gridIndexBuffer.destroy(), this.poleSegments.destroy(), this.gridSegments.destroy(), this.atmosphereVertexBuffer.destroy(), this.atmosphereIndexBuffer.destroy(), this.atmosphereSegments.destroy(), this.wireframeIndexBuffer && (this.wireframeIndexBuffer.destroy(), this.wireframeSegments.destroy())
                }

                static createPoleTriangleVertices(e, t, n) {
                    const i = new va, r = t / Math.PI / 2;
                    i.emplaceBack(0, -r, 0, 0, 0, .5, n ? 0 : 1);
                    const o = 360 / e, a = Math.cos(U(85)), s = Math.sin(U(85));
                    for (let e = 0; e <= 64; e++) {
                        const t = e / 64, c = Xh(a, s, 0 * (1 - (l = t)) + o * l, r);
                        i.emplaceBack(c[0], c[1], c[2], 0, 0, t, n ? 0 : 1)
                    }
                    var l;
                    return i
                }

                _createPoleTriangleIndices() {
                    const e = new fa;
                    for (let t = 0; t <= 64; t++) e.emplaceBack(0, t + 1, t + 2);
                    return e
                }

                static createGridVertices(e) {
                    const t = Math.pow(2, e.z), n = (e, t, n) => e * (1 - n) + t * n, [i, r] = $h(e), o = new va,
                        a = function (e) {
                            const t = u(new Float64Array(16)), n = Kh(e);
                            var i, r;
                            return p(t, t, [n, n, n]), h(t, t, ((i = [])[0] = -(r = e.min)[0], i[1] = -r[1], i[2] = -r[2], i)), t
                        }(Zh(e));
                    o.reserve(4096);
                    for (let s = 0; s < 65; s++) {
                        const l = n(i[0], r[0], s / 64), c = Ts(l), u = c * t - e.y, d = Math.sin(U(l)),
                            h = Math.cos(U(l));
                        for (let e = 0; e < 65; e++) {
                            const t = e / 64, s = n(i[1], r[1], t), l = Xh(h, d, s);
                            C(l, l, a);
                            const p = Ms(s);
                            o.emplaceBack(l[0], l[1], l[2], p, c, t, u)
                        }
                    }
                    return o
                }

                _createGridIndices() {
                    const e = new fa, t = (t, n) => {
                        const i = 65 * n + t;
                        e.emplaceBack(i + 1, i, i + 65), e.emplaceBack(i + 65, i + 65 + 1, i + 1)
                    };
                    for (let e = 0; e < 64; e++) for (let n = 0; n < 64; n++) t(n, e);
                    return e
                }

                getWirefameBuffer(e) {
                    if (!this.wireframeSegments) {
                        const t = this._createWireframeGrid();
                        this.wireframeIndexBuffer = e.createIndexBuffer(t), this.wireframeSegments = _s.simpleSegment(0, 0, 4096, t.length)
                    }
                    return [this.wireframeIndexBuffer, this.wireframeSegments]
                }

                _createWireframeGrid() {
                    const e = new ba, t = (t, n) => {
                        const i = 65 * n + t;
                        e.emplaceBack(i, i + 1), e.emplaceBack(i, i + 65), e.emplaceBack(i, i + 65 + 1)
                    };
                    for (let e = 0; e < 64; e++) for (let n = 0; n < 64; n++) t(n, e);
                    return e
                }
            }

            function np(e, t) {
                if (!t.isReprojectedInTileSpace) return {
                    scale: 1 << e.z,
                    x: e.x,
                    y: e.y,
                    x2: e.x + 1,
                    y2: e.y + 1,
                    projection: t
                };
                const n = Math.pow(2, -e.z), i = e.x * n, r = (e.x + 1) * n, o = e.y * n, a = (e.y + 1) * n, s = Ss(i),
                    l = Ss(r), c = Ds(o), u = Ds(a), d = t.project(s, c), h = t.project(l, c), p = t.project(l, u),
                    f = t.project(s, u);
                let m = Math.min(d.x, h.x, p.x, f.x), _ = Math.min(d.y, h.y, p.y, f.y),
                    g = Math.max(d.x, h.x, p.x, f.x), y = Math.max(d.y, h.y, p.y, f.y);
                const v = n / 16;

                function x(e, n, i, r, o, a) {
                    const s = (i + o) / 2, l = (r + a) / 2, c = t.project(Ss(s), Ds(l)),
                        u = Math.max(0, m - c.x, _ - c.y, c.x - g, c.y - y);
                    m = Math.min(m, c.x), g = Math.max(g, c.x), _ = Math.min(_, c.y), y = Math.max(y, c.y), u > v && (x(e, c, i, r, s, l), x(c, n, s, l, o, a))
                }

                x(d, h, i, o, r, o), x(h, p, r, o, r, a), x(p, f, r, a, i, a), x(f, d, i, a, i, o), m -= v, _ -= v, g += v, y += v;
                const b = 1 / Math.max(g - m, y - _);
                return {scale: b, x: m * b, y: _ * b, x2: g * b, y2: y * b, projection: t}
            }

            class ip {
                constructor(e) {
                    const t = {}, n = [];
                    for (const i in e) {
                        const r = e[i], o = t[i] = {};
                        for (const e in r.glyphs) {
                            const t = r.glyphs[+e];
                            if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue;
                            const i = t.metrics.localGlyph ? 2 : 1,
                                a = {x: 0, y: 0, w: t.bitmap.width + 2 * i, h: t.bitmap.height + 2 * i};
                            n.push(a), o[e] = a
                        }
                    }
                    const {w: i, h: r} = Su(n), o = new ml({width: i || 1, height: r || 1});
                    for (const n in e) {
                        const i = e[n];
                        for (const e in i.glyphs) {
                            const r = i.glyphs[+e];
                            if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;
                            const a = t[n][e], s = r.metrics.localGlyph ? 2 : 1;
                            ml.copy(r.bitmap, o, {x: 0, y: 0}, {x: a.x + s, y: a.y + s}, r.bitmap)
                        }
                    }
                    this.image = o, this.positions = t
                }
            }

            Yr("GlyphAtlas", ip);

            class rp {
                constructor(e) {
                    this.tileID = new rh(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.tileZoom = e.tileZoom, this.uid = e.uid, this.zoom = e.zoom, this.canonical = e.tileID.canonical, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId, this.enableTerrain = !!e.enableTerrain, this.isSymbolTile = e.isSymbolTile, this.tileTransform = np(e.tileID.canonical, e.projection), this.projection = e.projection
                }

                parse(e, t, n, i, r) {
                    this.status = "parsing", this.data = e, this.collisionBoxArray = new Sa;
                    const o = new uh(Object.keys(e.layers).sort()), a = new Lh(this.tileID, this.promoteId);
                    a.bucketLayerIDs = [];
                    const s = {}, l = new Xd(256, 256), c = {
                        featureIndex: a,
                        iconDependencies: {},
                        patternDependencies: {},
                        glyphDependencies: {},
                        lineAtlas: l,
                        availableImages: n
                    }, u = t.familiesBySource[this.source];
                    for (const t in u) {
                        const i = e.layers[t];
                        if (!i) continue;
                        let r = !1, l = !1;
                        for (const e of u[t]) "symbol" === e[0].type ? r = !0 : l = !0;
                        if (!0 === this.isSymbolTile && !r) continue;
                        if (!1 === this.isSymbolTile && !l) continue;
                        1 === i.version && he(`Vector tile source "${this.source}" layer "${t}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                        const d = o.encode(t), h = [];
                        for (let e = 0; e < i.length; e++) {
                            const n = i.feature(e), r = a.getId(n, t);
                            h.push({feature: n, id: r, index: e, sourceLayerIndex: d})
                        }
                        for (const e of u[t]) {
                            const t = e[0];
                            void 0 !== this.isSymbolTile && "symbol" === t.type !== this.isSymbolTile || t.minzoom && this.zoom < Math.floor(t.minzoom) || t.maxzoom && this.zoom >= t.maxzoom || "none" !== t.visibility && (op(e, this.zoom, n), (s[t.id] = t.createBucket({
                                index: a.bucketLayerIDs.length,
                                layers: e,
                                zoom: this.zoom,
                                canonical: this.canonical,
                                pixelRatio: this.pixelRatio,
                                overscaling: this.overscaling,
                                collisionBoxArray: this.collisionBoxArray,
                                sourceLayerIndex: d,
                                sourceID: this.source,
                                enableTerrain: this.enableTerrain,
                                availableImages: n
                            })).populate(h, c, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(e.map(e => e.id)))
                        }
                    }
                    let d, h, p, f;
                    l.trim();
                    const m = {type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom},
                        _ = le(c.glyphDependencies, e => Object.keys(e).map(Number));
                    Object.keys(_).length ? i.send("getGlyphs", {uid: this.uid, stacks: _}, (e, t) => {
                        d || (d = e, h = t, v.call(this))
                    }, void 0, !1, m) : h = {};
                    const g = Object.keys(c.iconDependencies);
                    g.length ? i.send("getImages", {
                        icons: g,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons"
                    }, (e, t) => {
                        d || (d = e, p = t, v.call(this))
                    }, void 0, !1, m) : p = {};
                    const y = Object.keys(c.patternDependencies);

                    function v() {
                        if (d) return r(d);
                        if (h && p && f) {
                            const e = new ip(h), t = new Lu(p, f);
                            for (const i in s) {
                                const r = s[i];
                                r instanceof Pd ? (op(r.layers, this.zoom, n), gd(r, h, e.positions, p, t.iconPositions, this.showCollisionBoxes, n, this.tileID.canonical, this.tileZoom, this.projection), r.projection = this.projection.name) : r.hasPattern && (r instanceof Yc || r instanceof ic || r instanceof wc) && (op(r.layers, this.zoom, n), r.addFeatures(c, this.tileID.canonical, t.patternPositions, n))
                            }
                            this.status = "done", r(null, {
                                buckets: Q(s).filter(e => !e.isEmpty()),
                                featureIndex: a,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: e.image,
                                lineAtlas: l,
                                imageAtlas: t,
                                glyphMap: this.returnDependencies ? h : null,
                                iconMap: this.returnDependencies ? p : null,
                                glyphPositions: this.returnDependencies ? e.positions : null
                            })
                        }
                    }

                    y.length ? i.send("getImages", {
                        icons: y,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns"
                    }, (e, t) => {
                        d || (d = e, f = t, v.call(this))
                    }, void 0, !1, m) : f = {}, v.call(this)
                }
            }

            function op(e, t, n) {
                const i = new Yo(t);
                for (const t of e) t.recalculate(i, n)
            }

            class ap {
                constructor(e) {
                    this.entries = {}, this.scheduler = e
                }

                request(e, t, n, i) {
                    const r = this.entries[e] = this.entries[e] || {callbacks: []};
                    if (r.result) {
                        const [e, n] = r.result;
                        return this.scheduler ? this.scheduler.add(() => {
                            i(e, n)
                        }, t) : i(e, n), () => {
                        }
                    }
                    return r.callbacks.push(i), r.cancel || (r.cancel = n((n, i) => {
                        r.result = [n, i];
                        for (const e of r.callbacks) this.scheduler ? this.scheduler.add(() => {
                            e(n, i)
                        }, t) : e(n, i);
                        setTimeout(() => delete this.entries[e], 3e3)
                    })), () => {
                        r.result || (r.callbacks = r.callbacks.filter(e => e !== i), r.callbacks.length || (r.cancel(), delete this.entries[e]))
                    }
                }
            }

            function sp(e, t, n) {
                const i = JSON.stringify(e.request);
                return e.data && (this.deduped.entries[i] = {result: [null, e.data]}), this.deduped.request(i, {
                    type: "parseTile",
                    isSymbolTile: e.isSymbolTile,
                    zoom: e.tileZoom
                }, t => {
                    const i = at(e.request, (e, i, r, o) => {
                        e ? t(e) : i && t(null, {
                            vectorTile: n ? void 0 : new gc.VectorTile(new iu(i)),
                            rawData: i,
                            cacheControl: r,
                            expires: o
                        })
                    });
                    return () => {
                        i.cancel(), t()
                    }
                }, t)
            }

            const lp = u(new Float64Array(16));

            class cp {
                constructor(e, t) {
                    this._tr = e, this._worldSize = t
                }

                createInversionMatrix() {
                    return lp
                }

                createTileMatrix(e) {
                    let t, n, i;
                    const r = e.canonical, o = u(new Float64Array(16)), a = this._tr.projection;
                    if (a.isReprojectedInTileSpace) {
                        const s = np(r, a);
                        t = 1, n = s.x + e.wrap * s.scale, i = s.y, p(o, o, [t / s.scale, t / s.scale, this._tr.pixelsPerMeter / this._worldSize])
                    } else t = this._worldSize / this._tr.zoomScale(r.z), n = (r.x + Math.pow(2, r.z) * e.wrap) * t, i = r.y * t;
                    return h(o, o, [n, i, 0]), p(o, o, [t / gs, t / gs, 1]), o
                }

                pointCoordinate(e, t, n) {
                    const i = this._tr.horizonLineFromTop(!1), o = new r(e, Math.max(i, t));
                    return this._tr.rayIntersectionCoordinate(this._tr.pointRayIntersection(o, n))
                }

                upVector() {
                    return [0, 0, 1]
                }

                upVectorScale() {
                    return 1
                }
            }

            var up = {
                name: "albers",
                range: [4, 7],
                center: [-96, 37.5],
                parallels: [29.5, 45.5],
                zAxisUnit: "meters",
                conic: !0,
                isReprojectedInTileSpace: !0,
                unsupportedLayers: ["custom"],
                initializeConstants() {
                    if (this.constants && j(this.parallels, this.constants.parallels)) return;
                    const e = Math.sin(U(this.parallels[0])), t = (e + Math.sin(U(this.parallels[1]))) / 2,
                        n = 1 + e * (2 * t - e), i = Math.sqrt(n) / t;
                    this.constants = {n: t, c: n, r0: i, parallels: this.parallels}
                },
                project(e, t) {
                    this.initializeConstants();
                    const n = U(e - this.center[0]), i = U(t), {n: r, c: o, r0: a} = this.constants,
                        s = Math.sqrt(o - 2 * r * Math.sin(i)) / r;
                    return {x: s * Math.sin(n * r), y: s * Math.cos(n * r) - a, z: 0}
                },
                unproject(e, t) {
                    this.initializeConstants();
                    const {n: n, c: i, r0: r} = this.constants, o = r + t;
                    let a = Math.atan2(e, Math.abs(o)) * Math.sign(o);
                    o * n < 0 && (a -= Math.PI * Math.sign(e) * Math.sign(o));
                    const s = U(this.center[0]) * n;
                    a = J(a, -Math.PI - s, Math.PI - s);
                    const l = W(a / n) + this.center[0],
                        c = Math.asin($((i - (e * e + o * o) * n * n) / (2 * n), -1, 1)), u = $(W(c), -85.051129, Es);
                    return new xs(l, u)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            };
            const dp = 1.340264, hp = -.081106, pp = 893e-6, fp = .003796, mp = Math.sqrt(3) / 2;
            var _p = {
                name: "equalEarth",
                center: [0, 0],
                range: [3.5, 7],
                zAxisUnit: "meters",
                isReprojectedInTileSpace: !0,
                unsupportedLayers: ["custom"],
                project(e, t) {
                    t = t / 180 * Math.PI, e = e / 180 * Math.PI;
                    const n = Math.asin(mp * Math.sin(t)), i = n * n, r = i * i * i;
                    return {
                        x: .5 * (e * Math.cos(n) / (mp * (dp + 3 * hp * i + r * (7 * pp + 9 * fp * i))) / Math.PI + .5),
                        y: 1 - .5 * (n * (dp + hp * i + r * (pp + fp * i)) / Math.PI + 1),
                        z: 0
                    }
                },
                unproject(e, t) {
                    e = (2 * e - .5) * Math.PI;
                    let n = t = (2 * (1 - t) - 1) * Math.PI, i = n * n, r = i * i * i;
                    for (let e, o, a, s = 0; s < 12 && (o = n * (dp + hp * i + r * (pp + fp * i)) - t, a = dp + 3 * hp * i + r * (7 * pp + 9 * fp * i), e = o / a, n = $(n - e, -Math.PI / 3, Math.PI / 3), i = n * n, r = i * i * i, !(Math.abs(e) < 1e-12)); ++s) ;
                    const o = mp * e * (dp + 3 * hp * i + r * (7 * pp + 9 * fp * i)) / Math.cos(n),
                        a = Math.asin(Math.sin(n) / mp), s = $(180 * o / Math.PI, -180, 180),
                        l = $(180 * a / Math.PI, -85.051129, Es);
                    return new xs(s, l)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            }, gp = {
                name: "equirectangular",
                supportsWorldCopies: !0,
                center: [0, 0],
                range: [3.5, 7],
                zAxisUnit: "meters",
                wrap: !0,
                isReprojectedInTileSpace: !0,
                unsupportedLayers: ["custom"],
                project: (e, t) => ({x: .5 + e / 360, y: .5 - t / 360, z: 0}),
                unproject(e, t) {
                    const n = 360 * (e - .5), i = $(360 * (.5 - t), -85.051129, Es);
                    return new xs(n, i)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            };
            const yp = Math.PI / 2;

            function vp(e) {
                return Math.tan((yp + e) / 2)
            }

            var xp = {
                name: "lambertConformalConic",
                range: [3.5, 7],
                zAxisUnit: "meters",
                center: [0, 30],
                parallels: [30, 30],
                conic: !0,
                isReprojectedInTileSpace: !0,
                unsupportedLayers: ["custom"],
                initializeConstants() {
                    if (this.constants && j(this.parallels, this.constants.parallels)) return;
                    const e = U(this.parallels[0]), t = U(this.parallels[1]), n = Math.cos(e),
                        i = e === t ? Math.sin(e) : Math.log(n / Math.cos(t)) / Math.log(vp(t) / vp(e)),
                        r = n * Math.pow(vp(e), i) / i;
                    this.constants = {n: i, f: r, parallels: this.parallels}
                },
                project(e, t) {
                    this.initializeConstants(), t = U(t), e = U(e - this.center[0]);
                    const n = 1e-6, {n: i, f: r} = this.constants;
                    r > 0 ? t < -yp + n && (t = -yp + n) : t > yp - n && (t = yp - n);
                    const o = r / Math.pow(vp(t), i), a = o * Math.sin(i * e), s = r - o * Math.cos(i * e);
                    return {x: .5 * (a / Math.PI + .5), y: 1 - .5 * (s / Math.PI + .5), z: 0}
                },
                unproject(e, t) {
                    this.initializeConstants(), e = (2 * e - .5) * Math.PI, t = (2 * (1 - t) - .5) * Math.PI;
                    const {n: n, f: i} = this.constants, r = i - t, o = Math.sign(r),
                        a = Math.sign(n) * Math.sqrt(e * e + r * r);
                    let s = Math.atan2(e, Math.abs(r)) * o;
                    r * n < 0 && (s -= Math.PI * Math.sign(e) * o);
                    const l = $(W(s / n) + this.center[0], -180, 180),
                        c = $(W(2 * Math.atan(Math.pow(i / a, 1 / n)) - yp), -85.051129, Es);
                    return new xs(l, c)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            }, bp = {
                name: "mercator",
                wrap: !0,
                requiresDraping: !1,
                supportsWorldCopies: !0,
                supportsTerrain: !0,
                supportsFog: !0,
                supportsFreeCamera: !0,
                zAxisUnit: "meters",
                center: [0, 0],
                project: (e, t) => ({x: Ms(e), y: Ts(t), z: 0}),
                unproject(e, t) {
                    const n = Ss(e), i = Ds(t);
                    return new xs(n, i)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            };
            const wp = U(Es);
            var Mp = {
                name: "naturalEarth",
                center: [0, 0],
                range: [3.5, 7],
                isReprojectedInTileSpace: !0,
                zAxisUnit: "meters",
                unsupportedLayers: ["custom"],
                project(e, t) {
                    const n = (t = U(t)) * t, i = n * n;
                    return {
                        x: .5 * ((e = U(e)) * (.8707 - .131979 * n + i * (i * (.003971 * n - .001529 * i) - .013791)) / Math.PI + .5),
                        y: 1 - .5 * (t * (1.007226 + n * (.015085 + i * (.028874 * n - .044475 - .005916 * i))) / Math.PI + 1),
                        z: 0
                    }
                },
                unproject(e, t) {
                    e = (2 * e - .5) * Math.PI;
                    let n = t = (2 * (1 - t) - 1) * Math.PI, i = 25, r = 0, o = n * n;
                    do {
                        o = n * n;
                        const e = o * o;
                        r = (n * (1.007226 + o * (.015085 + e * (.028874 * o - .044475 - .005916 * e))) - t) / (1.007226 + o * (.045255 + e * (.259866 * o - .311325 - .005916 * 11 * e))), n = $(n - r, -wp, wp)
                    } while (Math.abs(r) > 1e-6 && --i > 0);
                    o = n * n;
                    const a = $(W(e / (.8707 + o * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979))), -180, 180),
                        s = W(n);
                    return new xs(a, s)
                },
                projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                pixelsPerMeter: (e, t) => ks(1, e) * t,
                farthestPixelDistance(e) {
                    return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                },
                createTileTransform: (e, t) => new cp(e, t)
            };
            const Tp = U(Es), kp = {
                albers: up,
                equalEarth: _p,
                equirectangular: gp,
                lambertConformalConic: xp,
                mercator: bp,
                naturalEarth: Mp,
                winkelTripel: {
                    name: "winkelTripel",
                    center: [0, 0],
                    range: [3.5, 7],
                    zAxisUnit: "meters",
                    isReprojectedInTileSpace: !0,
                    unsupportedLayers: ["custom"],
                    project(e, t) {
                        t = U(t), e = U(e);
                        const n = Math.cos(t), i = 2 / Math.PI, r = Math.acos(n * Math.cos(e / 2)), o = Math.sin(r) / r,
                            a = .5 * (e * i + 2 * n * Math.sin(e / 2) / o) || 0, s = .5 * (t + Math.sin(t) / o) || 0;
                        return {x: .5 * (a / Math.PI + .5), y: 1 - .5 * (s / Math.PI + 1), z: 0}
                    },
                    unproject(e, t) {
                        let n = e = (2 * e - .5) * Math.PI, i = t = (2 * (1 - t) - 1) * Math.PI, r = 25;
                        const o = 1e-6;
                        let a = 0, s = 0;
                        do {
                            const r = Math.cos(i), o = Math.sin(i), l = 2 * o * r, c = o * o, u = r * r,
                                d = Math.cos(n / 2), h = Math.sin(n / 2), p = 2 * d * h, f = h * h, m = 1 - u * d * d,
                                _ = m ? 1 / m : 0, g = m ? Math.acos(r * d) * Math.sqrt(1 / m) : 0,
                                y = .5 * (2 * g * r * h + 2 * n / Math.PI) - e, v = .5 * (g * o + i) - t,
                                x = .5 * _ * (u * f + g * r * d * c) + 1 / Math.PI, b = _ * (p * l / 4 - g * o * h),
                                w = .125 * _ * (l * h - g * o * u * p), M = .5 * _ * (c * d + g * f * r) + .5,
                                T = b * w - M * x;
                            a = (v * b - y * M) / T, s = (y * w - v * x) / T, n = $(n - a, -Math.PI, Math.PI), i = $(i - s, -Tp, Tp)
                        } while ((Math.abs(a) > o || Math.abs(s) > o) && --r > 0);
                        return new xs(W(n), W(i))
                    },
                    projectTilePoint: (e, t) => ({x: e, y: t, z: 0}),
                    locationPoint: (e, t) => e._coordinatePoint(e.locationCoordinate(t), !1),
                    pixelsPerMeter: (e, t) => ks(1, e) * t,
                    farthestPixelDistance(e) {
                        return Uh(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                    },
                    createTileTransform: (e, t) => new cp(e, t)
                }
            };
            e.ARRAY_TYPE = l, e.AUTH_ERR_MSG = Pe, e.Aabb = ol, e.Actor = class {
                constructor(e, t, n) {
                    this.target = e, this.parent = t, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, ae(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = me() ? e : a, this.scheduler = new eh
                }

                send(e, t, n, i, r = !1, o) {
                    const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                    n && (n.metadata = o, this.callbacks[a] = n);
                    const s = be(this.globalScope) ? void 0 : [];
                    return this.target.postMessage({
                        id: a,
                        type: e,
                        hasCallback: !!n,
                        targetMapId: i,
                        mustQueue: r,
                        sourceMapId: this.mapId,
                        data: Fr(t, s)
                    }, s), {
                        cancel: () => {
                            n && delete this.callbacks[a], this.target.postMessage({
                                id: a,
                                type: "<cancel>",
                                targetMapId: i,
                                sourceMapId: this.mapId
                            })
                        }
                    }
                }

                receive(e) {
                    const t = e.data, n = t.id;
                    if (n && (!t.targetMapId || this.mapId === t.targetMapId)) if ("<cancel>" === t.type) {
                        const e = this.cancelCallbacks[n];
                        delete this.cancelCallbacks[n], e && e.cancel()
                    } else if (t.mustQueue || me()) {
                        const e = this.callbacks[n];
                        this.cancelCallbacks[n] = this.scheduler.add(() => this.processTask(n, t), e && e.metadata || {type: "message"})
                    } else this.processTask(n, t)
                }

                processTask(e, t) {
                    if ("<response>" === t.type) {
                        const n = this.callbacks[e];
                        delete this.callbacks[e], n && (t.error ? n(Br(t.error)) : n(null, Br(t.data)))
                    } else {
                        const n = be(this.globalScope) ? void 0 : [], i = t.hasCallback ? (t, i) => {
                            delete this.cancelCallbacks[e], this.target.postMessage({
                                id: e,
                                type: "<response>",
                                sourceMapId: this.mapId,
                                error: t ? Fr(t) : null,
                                data: Fr(i, n)
                            }, n)
                        } : e => {
                        }, r = Br(t.data);
                        if (this.parent[t.type]) this.parent[t.type](t.sourceMapId, r, i); else if (this.parent.getWorkerSource) {
                            const e = t.type.split(".");
                            this.parent.getWorkerSource(t.sourceMapId, e[0], r.source)[e[1]](r, i)
                        } else i(new Error("Could not find function " + t.type))
                    }
                }

                remove() {
                    this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1)
                }
            }, e.CanonicalTileID = nh, e.Color = Vt, e.ColorMode = lh, e.CullFaceMode = ch, e.DEMData = wh, e.DataConstantProperty = Wo, e.DedupedRequest = ap, e.DepthMode = ah, e.EXTENT = gs, e.Elevation = class {
                getAtPointOrZero(e, t = 0) {
                    return this.getAtPoint(e, t) || 0
                }

                getAtPoint(e, t, n = !0) {
                    null == t && (t = null);
                    const i = this._source();
                    if (!i) return t;
                    if (e.y < 0 || e.y > 1) return t;
                    const r = i.getSource().maxzoom, o = 1 << r, a = Math.floor(e.x), s = e.x - a,
                        l = new rh(r, a, r, Math.floor(s * o), Math.floor(e.y * o)), c = this.findDEMTileFor(l);
                    if (!c || !c.dem) return t;
                    const u = c.dem, d = 1 << c.tileID.canonical.z, h = (s * d - c.tileID.canonical.x) * u.dim,
                        p = (e.y * d - c.tileID.canonical.y) * u.dim, f = Math.floor(h), m = Math.floor(p);
                    return (n ? this.exaggeration() : 1) * On(On(u.get(f, m), u.get(f, m + 1), p - m), On(u.get(f + 1, m), u.get(f + 1, m + 1), p - m), h - f)
                }

                getAtTileOffset(e, t, n) {
                    const i = 1 << e.canonical.z;
                    return this.getAtPointOrZero(new Cs(e.wrap + (e.canonical.x + t / gs) / i, (e.canonical.y + n / gs) / i))
                }

                getAtTileOffsetFunc(e, t) {
                    return n => {
                        const i = this.getAtTileOffset(e, n.x, n.y), r = t.upVector(e.canonical, n.x, n.y);
                        return k(r, r, i * t.upVectorScale(e.canonical)), r
                    }
                }

                getForTilePoints(e, t, n, i) {
                    const r = Dh.create(this, e, i);
                    return !!r && (t.forEach(e => {
                        e[2] = this.exaggeration() * r.getElevationAt(e[0], e[1], n)
                    }), !0)
                }

                getMinMaxForTile(e) {
                    const t = this.findDEMTileFor(e);
                    if (!t || !t.dem) return null;
                    const n = t.dem.tree, i = t.tileID, r = 1 << e.canonical.z - i.canonical.z;
                    let o = e.canonical.x / r - i.canonical.x, a = e.canonical.y / r - i.canonical.y, s = 0;
                    for (let t = 0; t < e.canonical.z - i.canonical.z && !n.leaves[s]; t++) {
                        o *= 2, a *= 2;
                        const e = 2 * Math.floor(a) + Math.floor(o);
                        s = n.childOffsets[s] + e, o %= 1, a %= 1
                    }
                    return {min: this.exaggeration() * n.minimums[s], max: this.exaggeration() * n.maximums[s]}
                }

                getMinElevationBelowMSL() {
                    throw new Error("Pure virtual method called.")
                }

                raycast(e, t, n) {
                    throw new Error("Pure virtual method called.")
                }

                pointCoordinate(e) {
                    throw new Error("Pure virtual method called.")
                }

                _source() {
                    throw new Error("Pure virtual method called.")
                }

                exaggeration() {
                    throw new Error("Pure virtual method called.")
                }

                findDEMTileFor(e) {
                    throw new Error("Pure virtual method called.")
                }

                get visibleDemTiles() {
                    throw new Error("Getter must be implemented in subclass.")
                }
            }, e.ErrorEvent = gt, e.EvaluationParameters = Yo, e.Event = _t, e.Evented = yt, e.Frustum = rl, e.GLOBE_ZOOM_THRESHOLD_MAX = 6, e.GlobeSharedBuffers = tp, e.GlyphManager = nd, e.ImagePosition = Du, e.LineAtlas = Xd, e.LngLat = xs, e.LngLatBounds = ys, e.LocalGlyphMode = td, e.MAX_MERCATOR_LATITUDE = Es, e.MercatorCoordinate = Cs, e.ONE_EM = 24, e.OverscaledTileID = rh, e.Properties = $o, e.RGBAImage = _l, e.Ray = class {
                constructor(e, t) {
                    this.pos = e, this.dir = t
                }

                intersectsPlane(e, t, n) {
                    const i = L(t, this.dir);
                    if (Math.abs(i) < 1e-6) return !1;
                    const r = ((e[0] - this.pos[0]) * t[0] + (e[1] - this.pos[1]) * t[1] + (e[2] - this.pos[2]) * t[2]) / i;
                    return n[0] = this.pos[0] + this.dir[0] * r, n[1] = this.pos[1] + this.dir[1] * r, n[2] = this.pos[2] + this.dir[2] * r, !0
                }

                closestPointOnSphere(e, t, n) {
                    if (function (e, t) {
                        var n = e[0], i = e[1], r = e[2], o = t[0], a = t[1], l = t[2];
                        return Math.abs(n - o) <= s * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - a) <= s * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - l) <= s * Math.max(1, Math.abs(r), Math.abs(l))
                    }(this.pos, e) || 0 === t) return n[0] = n[1] = n[2] = 0, !1;
                    const [i, r, o] = this.dir, a = this.pos[0] - e[0], l = this.pos[1] - e[1], c = this.pos[2] - e[2],
                        u = i * i + r * r + o * o, d = 2 * (a * i + l * r + c * o),
                        h = d * d - 4 * u * (a * a + l * l + c * c - t * t);
                    if (h < 0) {
                        const e = Math.max(-d / 2, 0), s = a + i * e, u = l + r * e, h = c + o * e,
                            p = Math.hypot(s, u, h);
                        return n[0] = s * t / p, n[1] = u * t / p, n[2] = h * t / p, !1
                    }
                    {
                        const e = (-d - Math.sqrt(h)) / (2 * u);
                        if (e < 0) {
                            const e = Math.hypot(a, l, c);
                            return n[0] = a * t / e, n[1] = l * t / e, n[2] = c * t / e, !1
                        }
                        return n[0] = a + i * e, n[1] = l + r * e, n[2] = c + o * e, !0
                    }
                }
            }, e.RequestManager = class {
                constructor(e, t, n) {
                    this._transformRequestFn = e, this._customAccessToken = t, this._silenceAuthErrors = !!n, this._createSkuToken()
                }

                _createSkuToken() {
                    const e = function () {
                        let e = "";
                        for (let t = 0; t < 10; t++) e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                        return {token: ["1", Ie, e].join(""), tokenExpiresAt: Date.now() + 432e5}
                    }();
                    this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt
                }

                _isSkuTokenExpired() {
                    return Date.now() > this._skuTokenExpiresAt
                }

                transformRequest(e, t) {
                    return this._transformRequestFn && this._transformRequestFn(e, t) || {url: e}
                }

                normalizeStyleURL(e, t) {
                    if (!Re(e)) return e;
                    const n = Oe(e);
                    return n.path = "/styles/v1" + n.path, this._makeAPIURL(n, this._customAccessToken || t)
                }

                normalizeGlyphsURL(e, t) {
                    if (!Re(e)) return e;
                    const n = Oe(e);
                    return n.path = "/fonts/v1" + n.path, this._makeAPIURL(n, this._customAccessToken || t)
                }

                normalizeSourceURL(e, t) {
                    if (!Re(e)) return e;
                    const n = Oe(e);
                    return n.path = `/v4/${n.authority}.json`, n.params.push("secure"), this._makeAPIURL(n, this._customAccessToken || t)
                }

                normalizeSpriteURL(e, t, n, i) {
                    const r = Oe(e);
                    return Re(e) ? (r.path = `/styles/v1${r.path}/sprite${t}${n}`, this._makeAPIURL(r, this._customAccessToken || i)) : (r.path += `${t}${n}`, Fe(r))
                }

                normalizeTileURL(e, t, n) {
                    if (this._isSkuTokenExpired() && this._createSkuToken(), e && !Re(e)) return e;
                    const i = Oe(e);
                    i.path = i.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${t || n && "raster" !== i.authority && 512 === n ? "@2x" : ""}${Se.supported ? ".webp" : "$1"}`), "raster" === i.authority ? i.path = `/${ke.RASTER_URL_PREFIX}${i.path}` : (i.path = i.path.replace(/^.+\/v4\//, "/"), i.path = `/${ke.TILE_URL_VERSION}${i.path}`);
                    const r = this._customAccessToken || function (e) {
                        for (const t of e) {
                            const e = t.match(/^access_token=(.*)$/);
                            if (e) return e[1]
                        }
                        return null
                    }(i.params) || ke.ACCESS_TOKEN;
                    return ke.REQUIRE_ACCESS_TOKEN && r && this._skuToken && i.params.push("sku=" + this._skuToken), this._makeAPIURL(i, r)
                }

                canonicalizeTileURL(e, t) {
                    const n = Oe(e);
                    if (!n.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !n.path.match(/\.[\w]+$/)) return e;
                    let i = "mapbox://";
                    n.path.match(/^\/raster\/v1\//) ? i += "raster/" + n.path.replace(`/${ke.RASTER_URL_PREFIX}/`, "") : i += "tiles/" + n.path.replace(`/${ke.TILE_URL_VERSION}/`, "");
                    let r = n.params;
                    return t && (r = r.filter(e => !e.match(/^access_token=/))), r.length && (i += "?" + r.join("&")), i
                }

                canonicalizeTileset(e, t) {
                    const n = !!t && Re(t), i = [];
                    for (const t of e.tiles || []) Ye(t) ? i.push(this.canonicalizeTileURL(t, n)) : i.push(t);
                    return i
                }

                _makeAPIURL(e, t) {
                    const n = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",
                        i = Oe(ke.API_URL);
                    if (e.protocol = i.protocol, e.authority = i.authority, "http" === e.protocol) {
                        const t = e.params.indexOf("secure");
                        t >= 0 && e.params.splice(t, 1)
                    }
                    if ("/" !== i.path && (e.path = `${i.path}${e.path}`), !ke.REQUIRE_ACCESS_TOKEN) return Fe(e);
                    if (t = t || ke.ACCESS_TOKEN, !this._silenceAuthErrors) {
                        if (!t) throw new Error("An API access token is required to use Mapbox GL. " + n);
                        if ("s" === t[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + n)
                    }
                    return e.params = e.params.filter(e => -1 === e.indexOf("access_token")), e.params.push("access_token=" + (t || "")), Fe(e)
                }
            }, e.ResourceType = nt, e.SegmentVector = _s, e.SourceCache = Th, e.StencilMode = sh, e.StructArrayLayout1ui2 = wa, e.StructArrayLayout2f1f2i16 = ha, e.StructArrayLayout2i4 = na, e.StructArrayLayout2ui4 = ba, e.StructArrayLayout3f12 = oa, e.StructArrayLayout3ui6 = fa, e.StructArrayLayout4i8 = ia, e.Texture = $d, e.Tile = Bh, e.Transitionable = Fo, e.Uniform1f = qa, e.Uniform1i = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = 0
                }

                set(e) {
                    this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e))
                }
            }, e.Uniform2f = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = [0, 0]
                }

                set(e) {
                    e[0] === this.current[0] && e[1] === this.current[1] || (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]))
                }
            }, e.Uniform3f = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = [0, 0, 0]
                }

                set(e) {
                    e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] || (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]))
                }
            }, e.Uniform4f = Za, e.UniformColor = $a, e.UniformMatrix2f = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = Ka
                }

                set(e) {
                    for (let t = 0; t < 4; t++) if (e[t] !== this.current[t]) {
                        this.current = e, this.gl.uniformMatrix2fv(this.location, !1, e);
                        break
                    }
                }
            }, e.UniformMatrix3f = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = Ja
                }

                set(e) {
                    for (let t = 0; t < 9; t++) if (e[t] !== this.current[t]) {
                        this.current = e, this.gl.uniformMatrix3fv(this.location, !1, e);
                        break
                    }
                }
            }, e.UniformMatrix4f = class extends Ga {
                constructor(e, t) {
                    super(e, t), this.current = Xa
                }

                set(e) {
                    if (e[12] !== this.current[12] || e[0] !== this.current[0]) return this.current = e, void this.gl.uniformMatrix4fv(this.location, !1, e);
                    for (let t = 1; t < 16; t++) if (e[t] !== this.current[t]) {
                        this.current = e, this.gl.uniformMatrix4fv(this.location, !1, e);
                        break
                    }
                }
            }, e.UnwrappedTileID = ih, e.ValidationError = xt, e.VectorTileWorkerSource = class extends yt {
                constructor(e, t, n, i, r) {
                    super(), this.actor = e, this.layerIndex = t, this.availableImages = n, this.loadVectorData = r || sp, this.loading = {}, this.loaded = {}, this.deduped = new ap(e.scheduler), this.isSpriteLoaded = i, this.scheduler = e.scheduler
                }

                loadTile(e, t) {
                    const n = e.uid, i = e && e.request, r = i && i.collectResourceTiming,
                        o = this.loading[n] = new rp(e);
                    o.abort = this.loadVectorData(e, (a, s) => {
                        const l = !this.loading[n];
                        if (delete this.loading[n], l || a || !s) return o.status = "done", l || (this.loaded[n] = o), t(a);
                        const c = s.rawData, u = {};
                        s.expires && (u.expires = s.expires), s.cacheControl && (u.cacheControl = s.cacheControl), o.vectorTile = s.vectorTile || new gc.VectorTile(new iu(c));
                        const d = () => {
                            o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, (e, n) => {
                                if (e || !n) return t(e);
                                const o = {};
                                if (r) {
                                    const e = Qd(i);
                                    e.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(e)))
                                }
                                t(null, ee({rawTileData: c.slice(0)}, n, u, o))
                            })
                        };
                        this.isSpriteLoaded ? d() : this.once("isSpriteLoaded", () => {
                            this.scheduler ? this.scheduler.add(d, {
                                type: "parseTile",
                                isSymbolTile: e.isSymbolTile,
                                zoom: e.tileZoom
                            }) : d()
                        }), this.loaded = this.loaded || {}, this.loaded[n] = o
                    })
                }

                reloadTile(e, t) {
                    const n = this.loaded, i = e.uid, r = this;
                    if (n && n[i]) {
                        const o = n[i];
                        o.showCollisionBoxes = e.showCollisionBoxes, o.enableTerrain = !!e.enableTerrain, o.projection = e.projection;
                        const a = (e, n) => {
                            const i = o.reloadCallback;
                            i && (delete o.reloadCallback, o.parse(o.vectorTile, r.layerIndex, this.availableImages, r.actor, i)), t(e, n)
                        };
                        "parsing" === o.status ? o.reloadCallback = a : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a())
                    }
                }

                abortTile(e, t) {
                    const n = e.uid, i = this.loading[n];
                    i && (i.abort && i.abort(), delete this.loading[n]), t()
                }

                removeTile(e, t) {
                    const n = this.loaded, i = e.uid;
                    n && n[i] && delete n[i], t()
                }
            }, e.WritingMode = Eu, e.ZoomHistory = jr, e.add = b, e.addDynamicAttributes = Ed, e.adjoint = function (e, t) {
                var n = t[0], i = t[1], r = t[2], o = t[3], a = t[4], s = t[5], l = t[6], c = t[7], u = t[8];
                return e[0] = a * u - s * c, e[1] = r * c - i * u, e[2] = i * s - r * a, e[3] = s * l - o * u, e[4] = n * u - r * l, e[5] = r * o - n * s, e[6] = o * c - a * l, e[7] = i * l - n * c, e[8] = n * a - i * o, e
            }, e.asyncAll = K, e.bezier = q, e.bindAll = ae, e.boundsAttributes = Oh, e.bufferConvexPolygon = function (e, t) {
                const n = [];
                for (let i = 0; i < e.length; i++) {
                    const r = J(i - 1, -1, e.length - 1), o = J(i + 1, -1, e.length - 1), a = e[i], s = e[o],
                        l = e[r].sub(a).unit(), c = s.sub(a).unit(), u = c.angleWithSep(l.x, l.y),
                        d = l.add(c).unit().mult(-1 * t / Math.sin(u / 2));
                    n.push(a.add(d))
                }
                return n
            }, e.cacheEntryPossiblyAdded = function (e) {
                tt++, tt > Ke && (e.getActor().send("enforceCacheSizeLimit", Je), tt = 0)
            }, e.calculateGlobeMatrix = ep, e.calculateGlobeMercatorMatrix = function (e) {
                const t = e.worldSize, n = $(e.center.lat, -85.051129, Es), i = new r(Ms(e.center.lng) * t, Ts(n) * t),
                    o = ks(1, e.center.lat) * t, a = e.pixelsPerMeter, s = t / (o / e.pixelsPerMeter),
                    l = u(new Float64Array(16));
                return h(l, l, [i.x, i.y, 0]), p(l, l, [s, s, a]), l
            }, e.clamp = $, e.clearTileCache = function (e) {
                const t = a.caches.delete(Ze);
                e && t.catch(e).then(() => e())
            }, e.clipLine = Ju, e.clone = function (e) {
                var t = new l(16);
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
            }, e.clone$1 = ue, e.collisionCircleLayout = Vc, e.config = ke, e.conjugate = function (e, t) {
                return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
            }, e.create = function () {
                var e = new l(16);
                return l != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
            }, e.create$1 = c, e.createExpression = Bi, e.createLayout = ea, e.createStyleLayer = function (e) {
                return "custom" === e.type ? new jd(e) : new Ud[e.type](e)
            }, e.cross = E, e.degToRad = U, e.div = function (e, t, n) {
                return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e
            }, e.dot = L, e.ease = Z, e.easeCubicInOut = G, e.emitValidationErrors = Er, e.endsWith = se, e.enforceCacheSizeLimit = function (e) {
                Qe(), $e && $e.then(t => {
                    t.keys().then(n => {
                        for (let i = 0; i < n.length - e; i++) t.delete(n[i])
                    })
                })
            }, e.evaluateSizeForFeature = Zc, e.evaluateSizeForZoom = $c, e.evaluateVariableOffset = _d, e.evented = Ao, e.exactEquals = function (e, t) {
                return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
            },e.exactEquals$1 = function (e, t) {
                return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
            },e.exported = Me,e.exported$1 = Se,e.extend = ee,e.extend$1 = wt,e.filterObject = ce,e.fromMat4 = function (e, t) {
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e
            },e.fromQuat = function (e, t) {
                var n = t[0], i = t[1], r = t[2], o = t[3], a = n + n, s = i + i, l = r + r, c = n * a, u = i * a,
                    d = i * s, h = r * a, p = r * s, f = r * l, m = o * a, _ = o * s, g = o * l;
                return e[0] = 1 - d - f, e[1] = u + g, e[2] = h - _, e[3] = 0, e[4] = u - g, e[5] = 1 - c - f, e[6] = p + m, e[7] = 0, e[8] = h + _, e[9] = p - m, e[10] = 1 - c - d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            },e.fromRotation = function (e, t) {
                var n = Math.sin(t), i = Math.cos(t);
                return e[0] = i, e[1] = n, e[2] = 0, e[3] = -n, e[4] = i, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
            },e.fromScaling = function (e, t) {
                return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
            },e.furthestTileCorner = function (e) {
                const t = Math.round((e + 45 + 360) % 360 / 90) % 4;
                return V[t]
            },e.getAABBPointSquareDist = function (e, t, n) {
                let i = 0;
                for (let r = 0; r < 2; ++r) {
                    const o = n ? n[r] : 0;
                    e[r] > o && (i += (e[r] - o) * (e[r] - o)), t[r] < o && (i += (o - t[r]) * (o - t[r]))
                }
                return i
            },e.getAnchorAlignment = ju,e.getAnchorJustification = yd,e.getBounds = function (e) {
                let t = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0;
                for (const r of e) t = Math.min(t, r.x), n = Math.min(n, r.y), i = Math.max(i, r.x), o = Math.max(o, r.y);
                return {min: new r(t, n), max: new r(i, o)}
            },e.getColumn = function (e, t) {
                return [e[4 * t], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]]
            },e.getImage = pt,e.getJSON = function (e, t) {
                return ot(ee(e, {type: "json"}), t)
            },e.getMapSessionAPI = Ge,e.getPerformanceMeasurement = Qd,e.getProjection = function (e) {
                const t = kp[e.name];
                if (!t) throw new Error("Invalid projection name: " + e.name);
                return t.conic ? function (e, t) {
                    if (t.parallels && Math.abs(t.parallels[0] + t.parallels[1]) < .01) {
                        let n = function (e) {
                            const t = Math.max(.01, Math.cos(U(e))), n = 1 / (2 * Math.max(Math.PI * t, 1 / t));
                            return {
                                wrap: !0, supportsWorldCopies: !0, unsupportedLayers: ["custom"], project(e, i) {
                                    const r = U(e) * t, o = Math.sin(U(i)) / t;
                                    return {x: r * n + .5, y: -o * n + .5, z: 0}
                                }, unproject(e, i) {
                                    const r = -(i - .5) / n, o = $(W((e - .5) / n) / t, -180, 180),
                                        a = Math.asin($(r * t, -1, 1)), s = $(W(a), -85.051129, Es);
                                    return new xs(o, s)
                                }
                            }
                        }(t.parallels[0]);
                        if ("lambertConformalConic" === t.name) {
                            const {project: e, unproject: t} = kp.mercator;
                            n = {wrap: !0, supportsWorldCopies: !0, project: e, unproject: t}
                        }
                        return ee({}, e, t, n)
                    }
                    return ee({}, e, t)
                }(t, e) : t
            },e.getRTLTextPluginStatus = Io,e.getReferrer = rt,e.getTilePoint = function (e, {x: t, y: n}, i = 0) {
                return new r(((t - i) * e.scale - e.x) * gs, (n * e.scale - e.y) * gs)
            },e.getTileVec3 = function (e, t, n = 0) {
                return x(((t.x - n) * e.scale - e.x) * gs, (t.y * e.scale - e.y) * gs, Ls(t.z, t.y))
            },e.getVideo = function (e, t) {
                const n = a.document.createElement("video");
                n.muted = !0, n.onloadstart = function () {
                    t(null, n)
                };
                for (let t = 0; t < e.length; t++) {
                    const i = a.document.createElement("source");
                    ct(e[t]) || (n.crossOrigin = "Anonymous"), i.src = e[t], n.appendChild(i)
                }
                return {
                    cancel: () => {
                    }
                }
            },e.globeBuffersForTileMesh = function (e, t, n, i) {
                const r = e.context, o = e.transform;
                let a = t.globeGridBuffer, s = t.globePoleBuffer;
                if (!a) {
                    const e = tp.createGridVertices(n.canonical);
                    a = t.globeGridBuffer = r.createVertexBuffer(e, Nh, !1)
                }
                if (!s) {
                    const e = tp.createPoleTriangleVertices(i, o.tileSize * i, 0 === n.canonical.y);
                    s = t.globePoleBuffer = r.createVertexBuffer(e, Nh, !1)
                }
                return [a, s]
            },e.globeDenormalizeECEF = Qh,e.globeMatrixForTile = function (e, t) {
                const n = Qh(Zh(e)),
                    i = ((r = new Float64Array(16))[0] = (o = t)[0], r[1] = o[1], r[2] = o[2], r[3] = o[3], r[4] = o[4], r[5] = o[5], r[6] = o[6], r[7] = o[7], r[8] = o[8], r[9] = o[9], r[10] = o[10], r[11] = o[11], r[12] = o[12], r[13] = o[13], r[14] = o[14], r[15] = o[15], r);
                var r, o;
                return _(i, i, n), i
            },e.globePoleMatrixForTile = function (e, t, n) {
                const i = u(new Float64Array(16)), r = Math.pow(2, e.z), o = (e.x - r / 2) / r * Math.PI * 2,
                    a = n.point, s = n.worldSize / (n.tileSize * r);
                return h(i, i, [a.x, a.y, -n.worldSize / Math.PI / 2]), p(i, i, [s, s, s]), f(i, i, U(-n._center.lat)), m(i, i, U(-n._center.lng)), m(i, i, o), t && p(i, i, [1, -1, 1]), i
            },e.globeTileBounds = Zh,e.globeToMercatorTransition = function (e) {
                return X(5, 6, e)
            },e.identity = u,e.identity$1 = F,e.invert = function (e, t) {
                var n = t[0], i = t[1], r = t[2], o = t[3], a = t[4], s = t[5], l = t[6], c = t[7], u = t[8], d = t[9],
                    h = t[10], p = t[11], f = t[12], m = t[13], _ = t[14], g = t[15], y = n * s - i * a,
                    v = n * l - r * a, x = n * c - o * a, b = i * l - r * s, w = i * c - o * s, M = r * c - o * l,
                    T = u * m - d * f, k = u * _ - h * f, S = u * g - p * f, D = d * _ - h * m, L = d * g - p * m,
                    E = h * g - p * _, C = y * E - v * L + x * D + b * S - w * k + M * T;
                return C ? (e[0] = (s * E - l * L + c * D) * (C = 1 / C), e[1] = (r * L - i * E - o * D) * C, e[2] = (m * M - _ * w + g * b) * C, e[3] = (h * w - d * M - p * b) * C, e[4] = (l * S - a * E - c * k) * C, e[5] = (n * E - r * S + o * k) * C, e[6] = (_ * x - f * M - g * v) * C, e[7] = (u * M - h * x + p * v) * C, e[8] = (a * L - s * S + c * T) * C, e[9] = (i * S - n * L - o * T) * C, e[10] = (f * w - m * x + g * y) * C, e[11] = (d * x - u * w - p * y) * C, e[12] = (s * k - a * D - l * T) * C, e[13] = (n * D - i * k + r * T) * C, e[14] = (m * v - f * b - _ * y) * C, e[15] = (u * b - d * v + h * y) * C, e) : null
            },e.isMapAuthenticated = function (e) {
                return qe.has(e)
            },e.isMapboxURL = Re,e.isSafariWithAntialiasingBug = function (e) {
                const t = e.navigator ? e.navigator.userAgent : null;
                return !!be(e) && t && (t.match("Version/15.4") || t.match("Version/15.5") || t.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
            },e.latFromMercatorY = Ds,e.len = Y,e.length = v,e.length$1 = function (e) {
                return Math.hypot(e[0], e[1], e[2], e[3])
            },e.loadVectorTile = sp,e.makeRequest = ot,e.mercatorXfromLng = Ms,e.mercatorYfromLat = Ts,e.mercatorZfromAltitude = ks,e.mul = _,e.mul$1 = R,e.multiply = function (e, t, n) {
                var i = t[0], r = t[1], o = t[2], a = t[3], s = t[4], l = t[5], c = t[6], u = t[7], d = t[8], h = n[0],
                    p = n[1], f = n[2], m = n[3], _ = n[4], g = n[5], y = n[6], v = n[7], x = n[8];
                return e[0] = h * i + p * a + f * c, e[1] = h * r + p * s + f * u, e[2] = h * o + p * l + f * d, e[3] = m * i + _ * a + g * c, e[4] = m * r + _ * s + g * u, e[5] = m * o + _ * l + g * d, e[6] = y * i + v * a + x * c, e[7] = y * r + v * s + x * u, e[8] = y * o + v * l + x * d, e
            },e.multiply$1 = d,e.multiply$2 = M,e.nextPowerOfTwo = re,e.normalize = D,e.normalize$1 = function (e, t) {
                var n = t[0], i = t[1], r = t[2], o = t[3], a = n * n + i * i + r * r + o * o;
                return a > 0 && (a = 1 / Math.sqrt(a)), e[0] = n * a, e[1] = i * a, e[2] = r * a, e[3] = o * a, e
            },e.number = On,e.ortho = function (e, t, n, i, r, o, a) {
                var s = 1 / (t - n), l = 1 / (i - r), c = 1 / (o - a);
                return e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + n) * s, e[13] = (r + i) * l, e[14] = (a + o) * c, e[15] = 1, e
            },e.pbf = iu,e.perspective = function (e, t, n, i, r) {
                var o, a = 1 / Math.tan(t / 2);
                return e[0] = a / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, null != r && r !== 1 / 0 ? (e[10] = (r + i) * (o = 1 / (i - r)), e[14] = 2 * r * i * o) : (e[10] = -1, e[14] = -2 * i), e
            },e.pick = function (e, t) {
                const n = {};
                for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    r in e && (n[r] = e[r])
                }
                return n
            },e.plugin = Ro,e.pointGeometry = r,e.polygonIntersectsBox = Xs,e.polygonIntersectsPolygon = js,e.polygonizeBounds = function (e, t, n = 0, i = !0) {
                const o = new r(n, n), a = e.sub(o), s = t.add(o), l = [a, new r(s.x, a.y), s, new r(a.x, s.y)];
                return i && l.push(a), l
            },e.posAttributes = Ah,e.postMapLoadEvent = We,e.postTurnstileEvent = Ne,e.potpack = Su,e.prevPowerOfTwo = function (e) {
                return e <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },e.radToDeg = W,e.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],e.registerForPluginStateChange = function (e) {
                return e({pluginStatus: Do, pluginURL: Lo}), Ao.on("pluginStateChange", e), e
            },e.removeAuthState = function (e) {
                qe.delete(e)
            },e.renderColorRamp = yl,e.rotateX = f,e.rotateX$1 = B,e.rotateY = m,e.rotateZ = function (e, t, n) {
                var i = Math.sin(n), r = Math.cos(n), o = t[0], a = t[1], s = t[2], l = t[3], c = t[4], u = t[5],
                    d = t[6], h = t[7];
                return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * r + c * i, e[1] = a * r + u * i, e[2] = s * r + d * i, e[3] = l * r + h * i, e[4] = c * r - o * i, e[5] = u * r - a * i, e[6] = d * r - s * i, e[7] = h * r - l * i, e
            },e.rotateZ$1 = function (e, t, n) {
                n *= .5;
                var i = t[0], r = t[1], o = t[2], a = t[3], s = Math.sin(n), l = Math.cos(n);
                return e[0] = i * l + r * s, e[1] = r * l - i * s, e[2] = o * l + a * s, e[3] = a * l - o * s, e
            },e.scale = p,e.scale$1 = function (e, t, n) {
                return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
            },e.scale$2 = k,e.scaleAndAdd = S,e.setCacheLimits = function (e, t) {
                Je = e, Ke = t
            },e.setColumn = function (e, t, n) {
                e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3]
            },e.setRTLTextPlugin = function (e, t, n = !1) {
                if (Do === Mo || Do === To || Do === ko) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                Lo = Me.resolveURL(e), Do = Mo, So = t, Co(), n || Po()
            },e.smoothstep = X,e.spec = vt,e.storeAuthState = function (e, t) {
                t ? qe.add(e) : qe.delete(e)
            },e.sub = P,e.subtract = w,e.symbolSize = Xc,e.tileAABB = function (e, t, n, i, r, o, a, s, l) {
                if ("globe" === l.name) {
                    const a = Zh(new ih(o, new nh(n, i, r)).canonical).getCorners(), s = Number.MAX_VALUE,
                        l = [-s, -s, -s], h = [s, s, s], p = ep(e, t);
                    for (let e = 0; e < a.length; e++) C(a[e], a[e], p), u = h, d = a[e], (c = h)[0] = Math.min(u[0], d[0]), c[1] = Math.min(u[1], d[1]), c[2] = Math.min(u[2], d[2]), T(l, l, a[e]);
                    return new ol(h, l)
                }
                var c, u, d;
                const h = np({z: n, x: i, y: r}, l);
                return new ol([(o + h.x / h.scale) * t, t * (h.y / h.scale), a], [(o + h.x2 / h.scale) * t, t * (h.y2 / h.scale), s])
            },e.tileTransform = np,e.transformMat3 = function (e, t, n) {
                var i = t[0], r = t[1], o = t[2];
                return e[0] = i * n[0] + r * n[3] + o * n[6], e[1] = i * n[1] + r * n[4] + o * n[7], e[2] = i * n[2] + r * n[5] + o * n[8], e
            },e.transformMat4 = C,e.transformMat4$1 = z,e.transformQuat = A,e.translate = h,e.transpose = function (e, t) {
                if (e === t) {
                    var n = t[1], i = t[2], r = t[5];
                    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = i, e[7] = r
                } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
                return e
            },e.triggerPluginCompletionEvent = Eo,e.uniqueId = ne,e.validateCustomStyleLayer = function (e) {
                const t = [], n = e.id;
                return void 0 === n && t.push({message: `layers.${n}: missing required property "id"`}), void 0 === e.render && t.push({message: `layers.${n}: missing required method "render"`}), e.renderingMode && "2d" !== e.renderingMode && "3d" !== e.renderingMode && t.push({message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`}), t
            },e.validateFog = Sr,e.validateLight = kr,e.validateStyle = Tr,e.values = Q,e.vectorTile = gc,e.version = t,e.warnOnce = he,e.window = a,e.wrap = J
        })), i(0, (function (e) {
            function t(e) {
                const n = typeof e;
                if ("number" === n || "boolean" === n || "string" === n || null == e) return JSON.stringify(e);
                if (Array.isArray(e)) {
                    let n = "[";
                    for (const i of e) n += t(i) + ",";
                    return n + "]"
                }
                const i = Object.keys(e).sort();
                let r = "{";
                for (let n = 0; n < i.length; n++) r += `${JSON.stringify(i[n])}:${t(e[i[n]])},`;
                return r + "}"
            }

            function n(n) {
                let i = "";
                for (const r of e.refProperties) i += "/" + t(n[r]);
                return i
            }

            class i {
                constructor(e) {
                    this.keyCache = {}, e && this.replace(e)
                }

                replace(e) {
                    this._layerConfigs = {}, this._layers = {}, this.update(e, [])
                }

                update(t, i) {
                    for (const n of t) this._layerConfigs[n.id] = n, (this._layers[n.id] = e.createStyleLayer(n)).compileFilter(), this.keyCache[n.id] && delete this.keyCache[n.id];
                    for (const e of i) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
                    this.familiesBySource = {};
                    const r = function (e, t) {
                        const i = {};
                        for (let r = 0; r < e.length; r++) {
                            const o = t && t[e[r].id] || n(e[r]);
                            t && (t[e[r].id] = o);
                            let a = i[o];
                            a || (a = i[o] = []), a.push(e[r])
                        }
                        const r = [];
                        for (const e in i) r.push(i[e]);
                        return r
                    }(e.values(this._layerConfigs), this.keyCache);
                    for (const e of r) {
                        const t = e.map(e => this._layers[e.id]), n = t[0];
                        if ("none" === n.visibility) continue;
                        const i = n.source || "";
                        let r = this.familiesBySource[i];
                        r || (r = this.familiesBySource[i] = {});
                        const o = n.sourceLayer || "_geojsonTileLayer";
                        let a = r[o];
                        a || (a = r[o] = []), a.push(t)
                    }
                }
            }

            const {ImageBitmap: r} = e.window;

            class o {
                loadTile(t, n) {
                    const {uid: i, encoding: o, rawImageData: a, padding: s, buildQuadTree: l} = t,
                        c = r && a instanceof r ? this.getImageData(a, s) : a;
                    n(null, new e.DEMData(i, c, o, s < 1, l))
                }

                getImageData(t, n) {
                    this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);
                    const i = this.offscreenCanvasContext.getImageData(-n, -n, t.width + 2 * n, t.height + 2 * n);
                    return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({
                        width: i.width,
                        height: i.height
                    }, i.data)
                }
            }

            var a = function e(t, n) {
                var i, r = t && t.type;
                if ("FeatureCollection" === r) for (i = 0; i < t.features.length; i++) e(t.features[i], n); else if ("GeometryCollection" === r) for (i = 0; i < t.geometries.length; i++) e(t.geometries[i], n); else if ("Feature" === r) e(t.geometry, n); else if ("Polygon" === r) s(t.coordinates, n); else if ("MultiPolygon" === r) for (i = 0; i < t.coordinates.length; i++) s(t.coordinates[i], n);
                return t
            };

            function s(e, t) {
                if (0 !== e.length) {
                    l(e[0], t);
                    for (var n = 1; n < e.length; n++) l(e[n], !t)
                }
            }

            function l(e, t) {
                for (var n = 0, i = 0, r = 0, o = e.length, a = o - 1; r < o; a = r++) {
                    var s = (e[r][0] - e[a][0]) * (e[a][1] + e[r][1]), l = n + s;
                    i += Math.abs(n) >= Math.abs(s) ? n - l + s : s - l + n, n = l
                }
                n + i >= 0 != !!t && e.reverse()
            }

            const c = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;

            class u {
                constructor(t) {
                    this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10))
                }

                loadGeometry() {
                    if (1 === this._feature.type) {
                        const t = [];
                        for (const n of this._feature.geometry) t.push([new e.pointGeometry(n[0], n[1])]);
                        return t
                    }
                    {
                        const t = [];
                        for (const n of this._feature.geometry) {
                            const i = [];
                            for (const t of n) i.push(new e.pointGeometry(t[0], t[1]));
                            t.push(i)
                        }
                        return t
                    }
                }

                toGeoJSON(e, t, n) {
                    return c.call(this, e, t, n)
                }
            }

            class d {
                constructor(t) {
                    this.layers = {_geojsonTileLayer: this}, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t
                }

                feature(e) {
                    return new u(this._features[e])
                }
            }

            var h = e.vectorTile.VectorTileFeature, p = f;

            function f(e, t) {
                this.options = t || {}, this.features = e, this.length = e.length
            }

            function m(e, t) {
                this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096
            }

            f.prototype.feature = function (e) {
                return new m(this.features[e], this.options.extent)
            }, m.prototype.loadGeometry = function () {
                var t = this.rawGeometry;
                this.geometry = [];
                for (var n = 0; n < t.length; n++) {
                    for (var i = t[n], r = [], o = 0; o < i.length; o++) r.push(new e.pointGeometry(i[o][0], i[o][1]));
                    this.geometry.push(r)
                }
                return this.geometry
            }, m.prototype.bbox = function () {
                this.geometry || this.loadGeometry();
                for (var e = this.geometry, t = 1 / 0, n = -1 / 0, i = 1 / 0, r = -1 / 0, o = 0; o < e.length; o++) for (var a = e[o], s = 0; s < a.length; s++) {
                    var l = a[s];
                    t = Math.min(t, l.x), n = Math.max(n, l.x), i = Math.min(i, l.y), r = Math.max(r, l.y)
                }
                return [t, i, n, r]
            }, m.prototype.toGeoJSON = h.prototype.toGeoJSON;
            var _ = y, g = p;

            function y(t) {
                var n = new e.pbf;
                return function (e, t) {
                    for (var n in e.layers) t.writeMessage(3, v, e.layers[n])
                }(t, n), n.finish()
            }

            function v(e, t) {
                var n;
                t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);
                var i = {keys: [], values: [], keycache: {}, valuecache: {}};
                for (n = 0; n < e.length; n++) i.feature = e.feature(n), t.writeMessage(2, x, i);
                var r = i.keys;
                for (n = 0; n < r.length; n++) t.writeStringField(3, r[n]);
                var o = i.values;
                for (n = 0; n < o.length; n++) t.writeMessage(4, k, o[n])
            }

            function x(e, t) {
                var n = e.feature;
                void 0 !== n.id && t.writeVarintField(1, n.id), t.writeMessage(2, b, e), t.writeVarintField(3, n.type), t.writeMessage(4, T, n)
            }

            function b(e, t) {
                var n = e.feature, i = e.keys, r = e.values, o = e.keycache, a = e.valuecache;
                for (var s in n.properties) {
                    var l = n.properties[s], c = o[s];
                    if (null !== l) {
                        void 0 === c && (i.push(s), o[s] = c = i.length - 1), t.writeVarint(c);
                        var u = typeof l;
                        "string" !== u && "boolean" !== u && "number" !== u && (l = JSON.stringify(l));
                        var d = u + ":" + l, h = a[d];
                        void 0 === h && (r.push(l), a[d] = h = r.length - 1), t.writeVarint(h)
                    }
                }
            }

            function w(e, t) {
                return (t << 3) + (7 & e)
            }

            function M(e) {
                return e << 1 ^ e >> 31
            }

            function T(e, t) {
                for (var n = e.loadGeometry(), i = e.type, r = 0, o = 0, a = n.length, s = 0; s < a; s++) {
                    var l = n[s], c = 1;
                    1 === i && (c = l.length), t.writeVarint(w(1, c));
                    for (var u = 3 === i ? l.length - 1 : l.length, d = 0; d < u; d++) {
                        1 === d && 1 !== i && t.writeVarint(w(2, u - 1));
                        var h = l[d].x - r, p = l[d].y - o;
                        t.writeVarint(M(h)), t.writeVarint(M(p)), r += h, o += p
                    }
                    3 === i && t.writeVarint(w(7, 1))
                }
            }

            function k(e, t) {
                var n = typeof e;
                "string" === n ? t.writeStringField(1, e) : "boolean" === n ? t.writeBooleanField(7, e) : "number" === n && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e))
            }

            function S(e, t, n, i, r, o) {
                if (r - i <= n) return;
                const a = i + r >> 1;
                (function e(t, n, i, r, o, a) {
                    for (; o > r;) {
                        if (o - r > 600) {
                            const s = o - r + 1, l = i - r + 1, c = Math.log(s), u = .5 * Math.exp(2 * c / 3),
                                d = .5 * Math.sqrt(c * u * (s - u) / s) * (l - s / 2 < 0 ? -1 : 1);
                            e(t, n, i, Math.max(r, Math.floor(i - l * u / s + d)), Math.min(o, Math.floor(i + (s - l) * u / s + d)), a)
                        }
                        const s = n[2 * i + a];
                        let l = r, c = o;
                        for (D(t, n, r, i), n[2 * o + a] > s && D(t, n, r, o); l < c;) {
                            for (D(t, n, l, c), l++, c--; n[2 * l + a] < s;) l++;
                            for (; n[2 * c + a] > s;) c--
                        }
                        n[2 * r + a] === s ? D(t, n, r, c) : (c++, D(t, n, c, o)), c <= i && (r = c + 1), i <= c && (o = c - 1)
                    }
                })(e, t, a, i, r, o % 2), S(e, t, n, i, a - 1, o + 1), S(e, t, n, a + 1, r, o + 1)
            }

            function D(e, t, n, i) {
                L(e, n, i), L(t, 2 * n, 2 * i), L(t, 2 * n + 1, 2 * i + 1)
            }

            function L(e, t, n) {
                const i = e[t];
                e[t] = e[n], e[n] = i
            }

            function E(e, t, n, i) {
                const r = e - n, o = t - i;
                return r * r + o * o
            }

            _.fromVectorTileJs = y, _.fromGeojsonVt = function (e, t) {
                t = t || {};
                var n = {};
                for (var i in e) n[i] = new p(e[i].features, t), n[i].name = i, n[i].version = t.version, n[i].extent = t.extent;
                return y({layers: n})
            }, _.GeoJSONWrapper = g;
            const C = e => e[0], A = e => e[1];

            class I {
                constructor(e, t = C, n = A, i = 64, r = Float64Array) {
                    this.nodeSize = i, this.points = e;
                    const o = e.length < 65536 ? Uint16Array : Uint32Array, a = this.ids = new o(e.length),
                        s = this.coords = new r(2 * e.length);
                    for (let i = 0; i < e.length; i++) a[i] = i, s[2 * i] = t(e[i]), s[2 * i + 1] = n(e[i]);
                    S(a, s, i, 0, a.length - 1, 0)
                }

                range(e, t, n, i) {
                    return function (e, t, n, i, r, o, a) {
                        const s = [0, e.length - 1, 0], l = [];
                        let c, u;
                        for (; s.length;) {
                            const d = s.pop(), h = s.pop(), p = s.pop();
                            if (h - p <= a) {
                                for (let a = p; a <= h; a++) c = t[2 * a], u = t[2 * a + 1], c >= n && c <= r && u >= i && u <= o && l.push(e[a]);
                                continue
                            }
                            const f = Math.floor((p + h) / 2);
                            c = t[2 * f], u = t[2 * f + 1], c >= n && c <= r && u >= i && u <= o && l.push(e[f]);
                            const m = (d + 1) % 2;
                            (0 === d ? n <= c : i <= u) && (s.push(p), s.push(f - 1), s.push(m)), (0 === d ? r >= c : o >= u) && (s.push(f + 1), s.push(h), s.push(m))
                        }
                        return l
                    }(this.ids, this.coords, e, t, n, i, this.nodeSize)
                }

                within(e, t, n) {
                    return function (e, t, n, i, r, o) {
                        const a = [0, e.length - 1, 0], s = [], l = r * r;
                        for (; a.length;) {
                            const c = a.pop(), u = a.pop(), d = a.pop();
                            if (u - d <= o) {
                                for (let r = d; r <= u; r++) E(t[2 * r], t[2 * r + 1], n, i) <= l && s.push(e[r]);
                                continue
                            }
                            const h = Math.floor((d + u) / 2), p = t[2 * h], f = t[2 * h + 1];
                            E(p, f, n, i) <= l && s.push(e[h]);
                            const m = (c + 1) % 2;
                            (0 === c ? n - r <= p : i - r <= f) && (a.push(d), a.push(h - 1), a.push(m)), (0 === c ? n + r >= p : i + r >= f) && (a.push(h + 1), a.push(u), a.push(m))
                        }
                        return s
                    }(this.ids, this.coords, e, t, n, this.nodeSize)
                }
            }

            const P = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: e => e
            }, R = Math.fround || (Y = new Float32Array(1), e => (Y[0] = +e, Y[0]));
            var Y;

            class z {
                constructor(e) {
                    this.options = W(Object.create(P), e), this.trees = new Array(this.options.maxZoom + 1)
                }

                load(e) {
                    const {log: t, minZoom: n, maxZoom: i, nodeSize: r} = this.options;
                    t && console.time("total time");
                    const o = `prepare ${e.length} points`;
                    t && console.time(o), this.points = e;
                    let a = [];
                    for (let t = 0; t < e.length; t++) e[t].geometry && a.push(F(e[t], t));
                    this.trees[i + 1] = new I(a, V, G, r, Float32Array), t && console.timeEnd(o);
                    for (let e = i; e >= n; e--) {
                        const n = +Date.now();
                        a = this._cluster(a, e), this.trees[e] = new I(a, V, G, r, Float32Array), t && console.log("z%d: %d clusters in %dms", e, a.length, +Date.now() - n)
                    }
                    return t && console.timeEnd("total time"), this
                }

                getClusters(e, t) {
                    let n = ((e[0] + 180) % 360 + 360) % 360 - 180;
                    const i = Math.max(-90, Math.min(90, e[1]));
                    let r = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                    const o = Math.max(-90, Math.min(90, e[3]));
                    if (e[2] - e[0] >= 360) n = -180, r = 180; else if (n > r) {
                        const e = this.getClusters([n, i, 180, o], t), a = this.getClusters([-180, i, r, o], t);
                        return e.concat(a)
                    }
                    const a = this.trees[this._limitZoom(t)], s = a.range(H(n), N(o), H(r), N(i)), l = [];
                    for (const e of s) {
                        const t = a.points[e];
                        l.push(t.numPoints ? B(t) : this.points[t.index])
                    }
                    return l
                }

                getChildren(e) {
                    const t = this._getOriginId(e), n = this._getOriginZoom(e), i = "No cluster with the specified id.",
                        r = this.trees[n];
                    if (!r) throw new Error(i);
                    const o = r.points[t];
                    if (!o) throw new Error(i);
                    const a = this.options.radius / (this.options.extent * Math.pow(2, n - 1)),
                        s = r.within(o.x, o.y, a), l = [];
                    for (const t of s) {
                        const n = r.points[t];
                        n.parentId === e && l.push(n.numPoints ? B(n) : this.points[n.index])
                    }
                    if (0 === l.length) throw new Error(i);
                    return l
                }

                getLeaves(e, t, n) {
                    const i = [];
                    return this._appendLeaves(i, e, t = t || 10, n = n || 0, 0), i
                }

                getTile(e, t, n) {
                    const i = this.trees[this._limitZoom(e)], r = Math.pow(2, e), {extent: o, radius: a} = this.options,
                        s = a / o, l = (n - s) / r, c = (n + 1 + s) / r, u = {features: []};
                    return this._addTileFeatures(i.range((t - s) / r, l, (t + 1 + s) / r, c), i.points, t, n, r, u), 0 === t && this._addTileFeatures(i.range(1 - s / r, l, 1, c), i.points, r, n, r, u), t === r - 1 && this._addTileFeatures(i.range(0, l, s / r, c), i.points, -1, n, r, u), u.features.length ? u : null
                }

                getClusterExpansionZoom(e) {
                    let t = this._getOriginZoom(e) - 1;
                    for (; t <= this.options.maxZoom;) {
                        const n = this.getChildren(e);
                        if (t++, 1 !== n.length) break;
                        e = n[0].properties.cluster_id
                    }
                    return t
                }

                _appendLeaves(e, t, n, i, r) {
                    const o = this.getChildren(t);
                    for (const t of o) {
                        const o = t.properties;
                        if (o && o.cluster ? r + o.point_count <= i ? r += o.point_count : r = this._appendLeaves(e, o.cluster_id, n, i, r) : r < i ? r++ : e.push(t), e.length === n) break
                    }
                    return r
                }

                _addTileFeatures(e, t, n, i, r, o) {
                    for (const a of e) {
                        const e = t[a], s = e.numPoints;
                        let l, c, u;
                        if (s) l = j(e), c = e.x, u = e.y; else {
                            const t = this.points[e.index];
                            l = t.properties, c = H(t.geometry.coordinates[0]), u = N(t.geometry.coordinates[1])
                        }
                        const d = {
                            type: 1,
                            geometry: [[Math.round(this.options.extent * (c * r - n)), Math.round(this.options.extent * (u * r - i))]],
                            tags: l
                        };
                        let h;
                        s ? h = e.id : this.options.generateId ? h = e.index : this.points[e.index].id && (h = this.points[e.index].id), void 0 !== h && (d.id = h), o.features.push(d)
                    }
                }

                _limitZoom(e) {
                    return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1))
                }

                _cluster(e, t) {
                    const n = [], {radius: i, extent: r, reduce: o, minPoints: a} = this.options,
                        s = i / (r * Math.pow(2, t));
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i];
                        if (r.zoom <= t) continue;
                        r.zoom = t;
                        const l = this.trees[t + 1], c = l.within(r.x, r.y, s), u = r.numPoints || 1;
                        let d = u;
                        for (const e of c) {
                            const n = l.points[e];
                            n.zoom > t && (d += n.numPoints || 1)
                        }
                        if (d > u && d >= a) {
                            let e = r.x * u, a = r.y * u, s = o && u > 1 ? this._map(r, !0) : null;
                            const h = (i << 5) + (t + 1) + this.points.length;
                            for (const n of c) {
                                const i = l.points[n];
                                if (i.zoom <= t) continue;
                                i.zoom = t;
                                const c = i.numPoints || 1;
                                e += i.x * c, a += i.y * c, i.parentId = h, o && (s || (s = this._map(r, !0)), o(s, this._map(i)))
                            }
                            r.parentId = h, n.push(O(e / d, a / d, h, d, s))
                        } else if (n.push(r), d > 1) for (const e of c) {
                            const i = l.points[e];
                            i.zoom <= t || (i.zoom = t, n.push(i))
                        }
                    }
                    return n
                }

                _getOriginId(e) {
                    return e - this.points.length >> 5
                }

                _getOriginZoom(e) {
                    return (e - this.points.length) % 32
                }

                _map(e, t) {
                    if (e.numPoints) return t ? W({}, e.properties) : e.properties;
                    const n = this.points[e.index].properties, i = this.options.map(n);
                    return t && i === n ? W({}, i) : i
                }
            }

            function O(e, t, n, i, r) {
                return {x: R(e), y: R(t), zoom: 1 / 0, id: n, parentId: -1, numPoints: i, properties: r}
            }

            function F(e, t) {
                const [n, i] = e.geometry.coordinates;
                return {x: R(H(n)), y: R(N(i)), zoom: 1 / 0, index: t, parentId: -1}
            }

            function B(e) {
                return {
                    type: "Feature",
                    id: e.id,
                    properties: j(e),
                    geometry: {type: "Point", coordinates: [(t = e.x, 360 * (t - .5)), U(e.y)]}
                };
                var t
            }

            function j(e) {
                const t = e.numPoints,
                    n = t >= 1e4 ? Math.round(t / 1e3) + "k" : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;
                return W(W({}, e.properties), {
                    cluster: !0,
                    cluster_id: e.id,
                    point_count: t,
                    point_count_abbreviated: n
                })
            }

            function H(e) {
                return e / 360 + .5
            }

            function N(e) {
                const t = Math.sin(e * Math.PI / 180), n = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
                return n < 0 ? 0 : n > 1 ? 1 : n
            }

            function U(e) {
                const t = (180 - 360 * e) * Math.PI / 180;
                return 360 * Math.atan(Math.exp(t)) / Math.PI - 90
            }

            function W(e, t) {
                for (const n in t) e[n] = t[n];
                return e
            }

            function V(e) {
                return e.x
            }

            function G(e) {
                return e.y
            }

            function q(e, t, n, i, r, o) {
                var a = r - n, s = o - i;
                if (0 !== a || 0 !== s) {
                    var l = ((e - n) * a + (t - i) * s) / (a * a + s * s);
                    l > 1 ? (n = r, i = o) : l > 0 && (n += a * l, i += s * l)
                }
                return (a = e - n) * a + (s = t - i) * s
            }

            function Z(e, t, n, i) {
                var r = {
                    id: void 0 === e ? null : e,
                    type: t,
                    geometry: n,
                    tags: i,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                };
                return function (e) {
                    var t = e.geometry, n = e.type;
                    if ("Point" === n || "MultiPoint" === n || "LineString" === n) $(e, t); else if ("Polygon" === n || "MultiLineString" === n) for (var i = 0; i < t.length; i++) $(e, t[i]); else if ("MultiPolygon" === n) for (i = 0; i < t.length; i++) for (var r = 0; r < t[i].length; r++) $(e, t[i][r])
                }(r), r
            }

            function $(e, t) {
                for (var n = 0; n < t.length; n += 3) e.minX = Math.min(e.minX, t[n]), e.minY = Math.min(e.minY, t[n + 1]), e.maxX = Math.max(e.maxX, t[n]), e.maxY = Math.max(e.maxY, t[n + 1])
            }

            function X(e, t, n, i) {
                if (t.geometry) {
                    var r = t.geometry.coordinates, o = t.geometry.type,
                        a = Math.pow(n.tolerance / ((1 << n.maxZoom) * n.extent), 2), s = [], l = t.id;
                    if (n.promoteId ? l = t.properties[n.promoteId] : n.generateId && (l = i || 0), "Point" === o) J(r, s); else if ("MultiPoint" === o) for (var c = 0; c < r.length; c++) J(r[c], s); else if ("LineString" === o) K(r, s, a, !1); else if ("MultiLineString" === o) {
                        if (n.lineMetrics) {
                            for (c = 0; c < r.length; c++) K(r[c], s = [], a, !1), e.push(Z(l, "LineString", s, t.properties));
                            return
                        }
                        Q(r, s, a, !1)
                    } else if ("Polygon" === o) Q(r, s, a, !0); else {
                        if ("MultiPolygon" !== o) {
                            if ("GeometryCollection" === o) {
                                for (c = 0; c < t.geometry.geometries.length; c++) X(e, {
                                    id: l,
                                    geometry: t.geometry.geometries[c],
                                    properties: t.properties
                                }, n, i);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (c = 0; c < r.length; c++) {
                            var u = [];
                            Q(r[c], u, a, !0), s.push(u)
                        }
                    }
                    e.push(Z(l, o, s, t.properties))
                }
            }

            function J(e, t) {
                t.push(ee(e[0])), t.push(te(e[1])), t.push(0)
            }

            function K(e, t, n, i) {
                for (var r, o, a = 0, s = 0; s < e.length; s++) {
                    var l = ee(e[s][0]), c = te(e[s][1]);
                    t.push(l), t.push(c), t.push(0), s > 0 && (a += i ? (r * c - l * o) / 2 : Math.sqrt(Math.pow(l - r, 2) + Math.pow(c - o, 2))), r = l, o = c
                }
                var u = t.length - 3;
                t[2] = 1, function e(t, n, i, r) {
                    for (var o, a = r, s = i - n >> 1, l = i - n, c = t[n], u = t[n + 1], d = t[i], h = t[i + 1], p = n + 3; p < i; p += 3) {
                        var f = q(t[p], t[p + 1], c, u, d, h);
                        if (f > a) o = p, a = f; else if (f === a) {
                            var m = Math.abs(p - s);
                            m < l && (o = p, l = m)
                        }
                    }
                    a > r && (o - n > 3 && e(t, n, o, r), t[o + 2] = a, i - o > 3 && e(t, o, i, r))
                }(t, 0, u, n), t[u + 2] = 1, t.size = Math.abs(a), t.start = 0, t.end = t.size
            }

            function Q(e, t, n, i) {
                for (var r = 0; r < e.length; r++) {
                    var o = [];
                    K(e[r], o, n, i), t.push(o)
                }
            }

            function ee(e) {
                return e / 360 + .5
            }

            function te(e) {
                var t = Math.sin(e * Math.PI / 180), n = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
                return n < 0 ? 0 : n > 1 ? 1 : n
            }

            function ne(e, t, n, i, r, o, a, s) {
                if (i /= t, o >= (n /= t) && a < i) return e;
                if (a < n || o >= i) return null;
                for (var l = [], c = 0; c < e.length; c++) {
                    var u = e[c], d = u.geometry, h = u.type, p = 0 === r ? u.minX : u.minY,
                        f = 0 === r ? u.maxX : u.maxY;
                    if (p >= n && f < i) l.push(u); else if (!(f < n || p >= i)) {
                        var m = [];
                        if ("Point" === h || "MultiPoint" === h) ie(d, m, n, i, r); else if ("LineString" === h) re(d, m, n, i, r, !1, s.lineMetrics); else if ("MultiLineString" === h) ae(d, m, n, i, r, !1); else if ("Polygon" === h) ae(d, m, n, i, r, !0); else if ("MultiPolygon" === h) for (var _ = 0; _ < d.length; _++) {
                            var g = [];
                            ae(d[_], g, n, i, r, !0), g.length && m.push(g)
                        }
                        if (m.length) {
                            if (s.lineMetrics && "LineString" === h) {
                                for (_ = 0; _ < m.length; _++) l.push(Z(u.id, h, m[_], u.tags));
                                continue
                            }
                            "LineString" !== h && "MultiLineString" !== h || (1 === m.length ? (h = "LineString", m = m[0]) : h = "MultiLineString"), "Point" !== h && "MultiPoint" !== h || (h = 3 === m.length ? "Point" : "MultiPoint"), l.push(Z(u.id, h, m, u.tags))
                        }
                    }
                }
                return l.length ? l : null
            }

            function ie(e, t, n, i, r) {
                for (var o = 0; o < e.length; o += 3) {
                    var a = e[o + r];
                    a >= n && a <= i && (t.push(e[o]), t.push(e[o + 1]), t.push(e[o + 2]))
                }
            }

            function re(e, t, n, i, r, o, a) {
                for (var s, l, c = oe(e), u = 0 === r ? le : ce, d = e.start, h = 0; h < e.length - 3; h += 3) {
                    var p = e[h], f = e[h + 1], m = e[h + 2], _ = e[h + 3], g = e[h + 4], y = 0 === r ? p : f,
                        v = 0 === r ? _ : g, x = !1;
                    a && (s = Math.sqrt(Math.pow(p - _, 2) + Math.pow(f - g, 2))), y < n ? v > n && (l = u(c, p, f, _, g, n), a && (c.start = d + s * l)) : y > i ? v < i && (l = u(c, p, f, _, g, i), a && (c.start = d + s * l)) : se(c, p, f, m), v < n && y >= n && (l = u(c, p, f, _, g, n), x = !0), v > i && y <= i && (l = u(c, p, f, _, g, i), x = !0), !o && x && (a && (c.end = d + s * l), t.push(c), c = oe(e)), a && (d += s)
                }
                var b = e.length - 3;
                p = e[b], f = e[b + 1], m = e[b + 2], (y = 0 === r ? p : f) >= n && y <= i && se(c, p, f, m), b = c.length - 3, o && b >= 3 && (c[b] !== c[0] || c[b + 1] !== c[1]) && se(c, c[0], c[1], c[2]), c.length && t.push(c)
            }

            function oe(e) {
                var t = [];
                return t.size = e.size, t.start = e.start, t.end = e.end, t
            }

            function ae(e, t, n, i, r, o) {
                for (var a = 0; a < e.length; a++) re(e[a], t, n, i, r, o, !1)
            }

            function se(e, t, n, i) {
                e.push(t), e.push(n), e.push(i)
            }

            function le(e, t, n, i, r, o) {
                var a = (o - t) / (i - t);
                return e.push(o), e.push(n + (r - n) * a), e.push(1), a
            }

            function ce(e, t, n, i, r, o) {
                var a = (o - n) / (r - n);
                return e.push(t + (i - t) * a), e.push(o), e.push(1), a
            }

            function ue(e, t) {
                for (var n = [], i = 0; i < e.length; i++) {
                    var r, o = e[i], a = o.type;
                    if ("Point" === a || "MultiPoint" === a || "LineString" === a) r = de(o.geometry, t); else if ("MultiLineString" === a || "Polygon" === a) {
                        r = [];
                        for (var s = 0; s < o.geometry.length; s++) r.push(de(o.geometry[s], t))
                    } else if ("MultiPolygon" === a) for (r = [], s = 0; s < o.geometry.length; s++) {
                        for (var l = [], c = 0; c < o.geometry[s].length; c++) l.push(de(o.geometry[s][c], t));
                        r.push(l)
                    }
                    n.push(Z(o.id, a, r, o.tags))
                }
                return n
            }

            function de(e, t) {
                var n = [];
                n.size = e.size, void 0 !== e.start && (n.start = e.start, n.end = e.end);
                for (var i = 0; i < e.length; i += 3) n.push(e[i] + t, e[i + 1], e[i + 2]);
                return n
            }

            function he(e, t) {
                if (e.transformed) return e;
                var n, i, r, o = 1 << e.z, a = e.x, s = e.y;
                for (n = 0; n < e.features.length; n++) {
                    var l = e.features[n], c = l.geometry, u = l.type;
                    if (l.geometry = [], 1 === u) for (i = 0; i < c.length; i += 2) l.geometry.push(pe(c[i], c[i + 1], t, o, a, s)); else for (i = 0; i < c.length; i++) {
                        var d = [];
                        for (r = 0; r < c[i].length; r += 2) d.push(pe(c[i][r], c[i][r + 1], t, o, a, s));
                        l.geometry.push(d)
                    }
                }
                return e.transformed = !0, e
            }

            function pe(e, t, n, i, r, o) {
                return [Math.round(n * (e * i - r)), Math.round(n * (t * i - o))]
            }

            function fe(e, t, n, i, r) {
                for (var o = t === r.maxZoom ? 0 : r.tolerance / ((1 << t) * r.extent), a = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: 0,
                    source: null,
                    x: n,
                    y: i,
                    z: t,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0
                }, s = 0; s < e.length; s++) {
                    a.numFeatures++, me(a, e[s], o, r);
                    var l = e[s].minX, c = e[s].minY, u = e[s].maxX, d = e[s].maxY;
                    l < a.minX && (a.minX = l), c < a.minY && (a.minY = c), u > a.maxX && (a.maxX = u), d > a.maxY && (a.maxY = d)
                }
                return a
            }

            function me(e, t, n, i) {
                var r = t.geometry, o = t.type, a = [];
                if ("Point" === o || "MultiPoint" === o) for (var s = 0; s < r.length; s += 3) a.push(r[s]), a.push(r[s + 1]), e.numPoints++, e.numSimplified++; else if ("LineString" === o) _e(a, r, e, n, !1, !1); else if ("MultiLineString" === o || "Polygon" === o) for (s = 0; s < r.length; s++) _e(a, r[s], e, n, "Polygon" === o, 0 === s); else if ("MultiPolygon" === o) for (var l = 0; l < r.length; l++) {
                    var c = r[l];
                    for (s = 0; s < c.length; s++) _e(a, c[s], e, n, !0, 0 === s)
                }
                if (a.length) {
                    var u = t.tags || null;
                    if ("LineString" === o && i.lineMetrics) {
                        for (var d in u = {}, t.tags) u[d] = t.tags[d];
                        u.mapbox_clip_start = r.start / r.size, u.mapbox_clip_end = r.end / r.size
                    }
                    var h = {
                        geometry: a,
                        type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1,
                        tags: u
                    };
                    null !== t.id && (h.id = t.id), e.features.push(h)
                }
            }

            function _e(e, t, n, i, r, o) {
                var a = i * i;
                if (i > 0 && t.size < (r ? a : i)) n.numPoints += t.length / 3; else {
                    for (var s = [], l = 0; l < t.length; l += 3) (0 === i || t[l + 2] > a) && (n.numSimplified++, s.push(t[l]), s.push(t[l + 1])), n.numPoints++;
                    r && function (e, t) {
                        for (var n = 0, i = 0, r = e.length, o = r - 2; i < r; o = i, i += 2) n += (e[i] - e[o]) * (e[i + 1] + e[o + 1]);
                        if (n > 0 === t) for (i = 0, r = e.length; i < r / 2; i += 2) {
                            var a = e[i], s = e[i + 1];
                            e[i] = e[r - 2 - i], e[i + 1] = e[r - 1 - i], e[r - 2 - i] = a, e[r - 1 - i] = s
                        }
                    }(s, o), e.push(s)
                }
            }

            function ge(e, t) {
                var n = (t = this.options = function (e, t) {
                    for (var n in t) e[n] = t[n];
                    return e
                }(Object.create(this.options), t)).debug;
                if (n && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");
                var i = function (e, t) {
                    var n = [];
                    if ("FeatureCollection" === e.type) for (var i = 0; i < e.features.length; i++) X(n, e.features[i], t, i); else X(n, "Feature" === e.type ? e : {geometry: e}, t);
                    return n
                }(e, t);
                this.tiles = {}, this.tileCoords = [], n && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i = function (e, t) {
                    var n = t.buffer / t.extent, i = e, r = ne(e, 1, -1 - n, n, 0, -1, 2, t),
                        o = ne(e, 1, 1 - n, 2 + n, 0, -1, 2, t);
                    return (r || o) && (i = ne(e, 1, -n, 1 + n, 0, -1, 2, t) || [], r && (i = ue(r, 1).concat(i)), o && (i = i.concat(ue(o, -1)))), i
                }(i, t)).length && this.splitTile(i, 0, 0, 0), n && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
            }

            function ye(e, t, n) {
                return 32 * ((1 << e) * n + t) + e
            }

            function ve(e, t) {
                const n = e.tileID.canonical;
                if (!this._geoJSONIndex) return t(null, null);
                const i = this._geoJSONIndex.getTile(n.z, n.x, n.y);
                if (!i) return t(null, null);
                const r = new d(i.features);
                let o = _(r);
                0 === o.byteOffset && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)), t(null, {
                    vectorTile: r,
                    rawData: o.buffer
                })
            }

            ge.prototype.options = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0
            }, ge.prototype.splitTile = function (e, t, n, i, r, o, a) {
                for (var s = [e, t, n, i], l = this.options, c = l.debug; s.length;) {
                    i = s.pop(), n = s.pop(), t = s.pop(), e = s.pop();
                    var u = 1 << t, d = ye(t, n, i), h = this.tiles[d];
                    if (!h && (c > 1 && console.time("creation"), h = this.tiles[d] = fe(e, t, n, i, l), this.tileCoords.push({
                        z: t,
                        x: n,
                        y: i
                    }), c)) {
                        c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, n, i, h.numFeatures, h.numPoints, h.numSimplified), console.timeEnd("creation"));
                        var p = "z" + t;
                        this.stats[p] = (this.stats[p] || 0) + 1, this.total++
                    }
                    if (h.source = e, r) {
                        if (t === l.maxZoom || t === r) continue;
                        var f = 1 << r - t;
                        if (n !== Math.floor(o / f) || i !== Math.floor(a / f)) continue
                    } else if (t === l.indexMaxZoom || h.numPoints <= l.indexMaxPoints) continue;
                    if (h.source = null, 0 !== e.length) {
                        c > 1 && console.time("clipping");
                        var m, _, g, y, v, x, b = .5 * l.buffer / l.extent, w = .5 - b, M = .5 + b, T = 1 + b;
                        m = _ = g = y = null, v = ne(e, u, n - b, n + M, 0, h.minX, h.maxX, l), x = ne(e, u, n + w, n + T, 0, h.minX, h.maxX, l), e = null, v && (m = ne(v, u, i - b, i + M, 1, h.minY, h.maxY, l), _ = ne(v, u, i + w, i + T, 1, h.minY, h.maxY, l), v = null), x && (g = ne(x, u, i - b, i + M, 1, h.minY, h.maxY, l), y = ne(x, u, i + w, i + T, 1, h.minY, h.maxY, l), x = null), c > 1 && console.timeEnd("clipping"), s.push(m || [], t + 1, 2 * n, 2 * i), s.push(_ || [], t + 1, 2 * n, 2 * i + 1), s.push(g || [], t + 1, 2 * n + 1, 2 * i), s.push(y || [], t + 1, 2 * n + 1, 2 * i + 1)
                    }
                }
            }, ge.prototype.getTile = function (e, t, n) {
                var i = this.options, r = i.extent, o = i.debug;
                if (e < 0 || e > 24) return null;
                var a = 1 << e, s = ye(e, t = (t % a + a) % a, n);
                if (this.tiles[s]) return he(this.tiles[s], r);
                o > 1 && console.log("drilling down to z%d-%d-%d", e, t, n);
                for (var l, c = e, u = t, d = n; !l && c > 0;) c--, u = Math.floor(u / 2), d = Math.floor(d / 2), l = this.tiles[ye(c, u, d)];
                return l && l.source ? (o > 1 && console.log("found parent tile z%d-%d-%d", c, u, d), o > 1 && console.time("drilling down"), this.splitTile(l.source, c, u, d, e, t, n), o > 1 && console.timeEnd("drilling down"), this.tiles[s] ? he(this.tiles[s], r) : null) : null
            };

            class xe extends e.VectorTileWorkerSource {
                constructor(e, t, n, i, r) {
                    super(e, t, n, i, ve), r && (this.loadGeoJSON = r)
                }

                loadData(t, n) {
                    const i = t && t.request, r = i && i.collectResourceTiming;
                    this.loadGeoJSON(t, (o, s) => {
                        if (o || !s) return n(o);
                        if ("object" != typeof s) return n(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                        {
                            a(s, !0);
                            try {
                                if (t.filter) {
                                    const n = e.createExpression(t.filter, {
                                        type: "boolean",
                                        "property-type": "data-driven",
                                        overridable: !1,
                                        transition: !1
                                    });
                                    if ("error" === n.result) throw new Error(n.value.map(e => `${e.key}: ${e.message}`).join(", "));
                                    const i = s.features.filter(e => n.value.evaluate({zoom: 0}, e));
                                    s = {type: "FeatureCollection", features: i}
                                }
                                this._geoJSONIndex = t.cluster ? new z(function ({
                                                                                     superclusterOptions: t,
                                                                                     clusterProperties: n
                                                                                 }) {
                                    if (!n || !t) return t;
                                    const i = {}, r = {}, o = {accumulated: null, zoom: 0}, a = {properties: null},
                                        s = Object.keys(n);
                                    for (const t of s) {
                                        const [o, a] = n[t], s = e.createExpression(a),
                                            l = e.createExpression("string" == typeof o ? [o, ["accumulated"], ["get", t]] : o);
                                        i[t] = s.value, r[t] = l.value
                                    }
                                    return t.map = e => {
                                        a.properties = e;
                                        const t = {};
                                        for (const e of s) t[e] = i[e].evaluate(o, a);
                                        return t
                                    }, t.reduce = (e, t) => {
                                        a.properties = t;
                                        for (const t of s) o.accumulated = e[t], e[t] = r[t].evaluate(o, a)
                                    }, t
                                }(t)).load(s.features) : function (e, t) {
                                    return new ge(e, t)
                                }(s, t.geojsonVtOptions)
                            } catch (o) {
                                return n(o)
                            }
                            this.loaded = {};
                            const l = {};
                            if (r) {
                                const n = e.getPerformanceMeasurement(i);
                                n && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(n)))
                            }
                            n(null, l)
                        }
                    })
                }

                reloadTile(e, t) {
                    const n = this.loaded;
                    return n && n[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t)
                }

                loadGeoJSON(t, n) {
                    if (t.request) e.getJSON(t.request, n); else {
                        if ("string" != typeof t.data) return n(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                        try {
                            return n(null, JSON.parse(t.data))
                        } catch (e) {
                            return n(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`))
                        }
                    }
                }

                getClusterExpansionZoom(e, t) {
                    try {
                        t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId))
                    } catch (e) {
                        t(e)
                    }
                }

                getClusterChildren(e, t) {
                    try {
                        t(null, this._geoJSONIndex.getChildren(e.clusterId))
                    } catch (e) {
                        t(e)
                    }
                }

                getClusterLeaves(e, t) {
                    try {
                        t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset))
                    } catch (e) {
                        t(e)
                    }
                }
            }

            class be {
                constructor(t) {
                    this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({name: "mercator"}), this.workerSourceTypes = {
                        vector: e.VectorTileWorkerSource,
                        geojson: xe
                    }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {
                        if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
                        this.workerSourceTypes[e] = t
                    }, this.self.registerRTLTextPlugin = t => {
                        if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
                        e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText
                    }
                }

                clearCaches(e, t, n) {
                    delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], n()
                }

                checkIfReady(e, t, n) {
                    n()
                }

                setReferrer(e, t) {
                    this.referrer = t
                }

                spriteLoaded(t, n) {
                    this.isSpriteLoaded[t] = n;
                    for (const i in this.workerSources[t]) {
                        const r = this.workerSources[t][i];
                        for (const t in r) r[t] instanceof e.VectorTileWorkerSource && (r[t].isSpriteLoaded = n, r[t].fire(new e.Event("isSpriteLoaded")))
                    }
                }

                setImages(e, t, n) {
                    this.availableImages[e] = t;
                    for (const n in this.workerSources[e]) {
                        const i = this.workerSources[e][n];
                        for (const e in i) i[e].availableImages = t
                    }
                    n()
                }

                enableTerrain(e, t, n) {
                    this.terrain = t, n()
                }

                setProjection(t, n) {
                    this.projections[t] = e.getProjection(n)
                }

                setLayers(e, t, n) {
                    this.getLayerIndex(e).replace(t), n()
                }

                updateLayers(e, t, n) {
                    this.getLayerIndex(e).update(t.layers, t.removedIds), n()
                }

                loadTile(t, n, i) {
                    const r = this.enableTerrain ? e.extend({enableTerrain: this.terrain}, n) : n;
                    r.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, n.type, n.source).loadTile(r, i)
                }

                loadDEMTile(t, n, i) {
                    const r = this.enableTerrain ? e.extend({buildQuadTree: this.terrain}, n) : n;
                    this.getDEMWorkerSource(t, n.source).loadTile(r, i)
                }

                reloadTile(t, n, i) {
                    const r = this.enableTerrain ? e.extend({enableTerrain: this.terrain}, n) : n;
                    r.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, n.type, n.source).reloadTile(r, i)
                }

                abortTile(e, t, n) {
                    this.getWorkerSource(e, t.type, t.source).abortTile(t, n)
                }

                removeTile(e, t, n) {
                    this.getWorkerSource(e, t.type, t.source).removeTile(t, n)
                }

                removeSource(e, t, n) {
                    if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;
                    const i = this.workerSources[e][t.type][t.source];
                    delete this.workerSources[e][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, n) : n()
                }

                loadWorkerSource(e, t, n) {
                    try {
                        this.self.importScripts(t.url), n()
                    } catch (e) {
                        n(e.toString())
                    }
                }

                syncRTLPluginState(t, n, i) {
                    try {
                        e.plugin.setState(n);
                        const t = e.plugin.getPluginURL();
                        if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {
                            this.self.importScripts(t);
                            const n = e.plugin.isParsed();
                            i(n ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + t), n)
                        }
                    } catch (e) {
                        i(e.toString())
                    }
                }

                getAvailableImages(e) {
                    let t = this.availableImages[e];
                    return t || (t = []), t
                }

                getLayerIndex(e) {
                    let t = this.layerIndexes[e];
                    return t || (t = this.layerIndexes[e] = new i), t
                }

                getWorkerSource(e, t, n) {
                    return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][n] || (this.workerSources[e][t][n] = new this.workerSourceTypes[t]({
                        send: (t, n, i, r, o, a) => {
                            this.actor.send(t, n, i, e, o, a)
                        }, scheduler: this.actor.scheduler
                    }, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e])), this.workerSources[e][t][n]
                }

                getDEMWorkerSource(e, t) {
                    return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new o), this.demWorkerSources[e][t]
                }

                enforceCacheSizeLimit(t, n) {
                    e.enforceCacheSizeLimit(n)
                }

                getWorkerPerformanceMetrics(e, t, n) {
                    n(void 0, void 0)
                }
            }

            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new be(self)), be
        })), i(0, (function (e) {
            var t = n;

            function n(e) {
                return !function (e) {
                    return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {
                        if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                        var e, t, n = new Blob([""], {type: "text/javascript"}), i = URL.createObjectURL(n);
                        try {
                            t = new Worker(i), e = !0
                        } catch (t) {
                            e = !1
                        }
                        return t && t.terminate(), URL.revokeObjectURL(i), e
                    }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {
                        var e = document.createElement("canvas");
                        e.width = e.height = 1;
                        var t = e.getContext("2d");
                        if (!t) return !1;
                        var n = t.getImageData(0, 0, 1, 1);
                        return n && n.width === e.width
                    }() ? (void 0 === i[t = e && e.failIfMajorPerformanceCaveat] && (i[t] = function (e) {
                        var t, i = function (e) {
                            var t = document.createElement("canvas"), i = Object.create(n.webGLContextAttributes);
                            return i.failIfMajorPerformanceCaveat = e, t.getContext("webgl", i) || t.getContext("experimental-webgl", i)
                        }(e);
                        if (!i) return !1;
                        try {
                            t = i.createShader(i.VERTEX_SHADER)
                        } catch (e) {
                            return !1
                        }
                        return !(!t || i.isContextLost()) && (i.shaderSource(t, "void main() {}"), i.compileShader(t), !0 === i.getShaderParameter(t, i.COMPILE_STATUS))
                    }(t)), i[t] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
                    var t
                }(e)
            }

            var i = {};

            function r(e, t) {
                var n = t[0], i = t[1], r = t[2], o = t[3], a = n * o - r * i;
                return a ? (e[0] = o * (a = 1 / a), e[1] = -i * a, e[2] = -r * a, e[3] = n * a, e) : null
            }

            function o(e, t) {
                if (Array.isArray(e)) {
                    if (!Array.isArray(t) || e.length !== t.length) return !1;
                    for (let n = 0; n < e.length; n++) if (!o(e[n], t[n])) return !1;
                    return !0
                }
                if ("object" == typeof e && null !== e && null !== t) {
                    if ("object" != typeof t) return !1;
                    if (Object.keys(e).length !== Object.keys(t).length) return !1;
                    for (const n in e) if (!o(e[n], t[n])) return !1;
                    return !0
                }
                return e === t
            }

            n.webGLContextAttributes = {antialias: !1, alpha: !0, stencil: !0, depth: !0};
            const a = {
                    create: function (t, n, i) {
                        const r = e.window.document.createElement(t);
                        return void 0 !== n && (r.className = n), i && i.appendChild(r), r
                    }, createSVG: function (t, n, i) {
                        const r = e.window.document.createElementNS("http://www.w3.org/2000/svg", t);
                        for (const e of Object.keys(n)) r.setAttributeNS(null, e, n[e]);
                        return i && i.appendChild(r), r
                    }
                }, s = e.window.document && e.window.document.documentElement.style,
                l = s && void 0 !== s.userSelect ? "userSelect" : "WebkitUserSelect";
            let c;
            a.disableDrag = function () {
                s && l && (c = s[l], s[l] = "none")
            }, a.enableDrag = function () {
                s && l && (s[l] = c)
            };
            const u = function (t) {
                t.preventDefault(), t.stopPropagation(), e.window.removeEventListener("click", u, !0)
            };

            function d(t, n, i) {
                const r = t.offsetWidth === n.width ? 1 : t.offsetWidth / n.width;
                return new e.pointGeometry((i.clientX - n.left) * r, (i.clientY - n.top) * r)
            }

            function h(e) {
                const {userImage: t} = e;
                return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0)
            }

            a.suppressClick = function () {
                e.window.addEventListener("click", u, !0), e.window.setTimeout(() => {
                    e.window.removeEventListener("click", u, !0)
                }, 0)
            }, a.mousePos = function (e, t) {
                const n = e.getBoundingClientRect();
                return d(e, n, t)
            }, a.touchPos = function (e, t) {
                const n = e.getBoundingClientRect(), i = [];
                for (let r = 0; r < t.length; r++) i.push(d(e, n, t[r]));
                return i
            }, a.mouseButton = function (t) {
                return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t.button
            };

            class p extends e.Evented {
                constructor() {
                    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({
                        width: 1,
                        height: 1
                    }), this.dirty = !0
                }

                isLoaded() {
                    return this.loaded
                }

                setLoaded(e) {
                    if (this.loaded !== e && (this.loaded = e, e)) {
                        for (const {ids: e, callback: t} of this.requestors) this._notify(e, t);
                        this.requestors = []
                    }
                }

                getImage(e) {
                    return this.images[e]
                }

                addImage(e, t) {
                    this._validate(e, t) && (this.images[e] = t)
                }

                _validate(t, n) {
                    let i = !0;
                    return this._validateStretch(n.stretchX, n.data && n.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), i = !1), this._validateStretch(n.stretchY, n.data && n.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), i = !1), this._validateContent(n.content, n) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), i = !1), i
                }

                _validateStretch(e, t) {
                    if (!e) return !0;
                    let n = 0;
                    for (const i of e) {
                        if (i[0] < n || i[1] < i[0] || t < i[1]) return !1;
                        n = i[1]
                    }
                    return !0
                }

                _validateContent(e, t) {
                    return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]))
                }

                updateImage(e, t) {
                    t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0
                }

                removeImage(e) {
                    const t = this.images[e];
                    delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove()
                }

                listImages() {
                    return Object.keys(this.images)
                }

                getImages(e, t) {
                    let n = !0;
                    if (!this.isLoaded()) for (const t of e) this.images[t] || (n = !1);
                    this.isLoaded() || n ? this._notify(e, t) : this.requestors.push({ids: e, callback: t})
                }

                _notify(t, n) {
                    const i = {};
                    for (const n of t) {
                        this.images[n] || this.fire(new e.Event("styleimagemissing", {id: n}));
                        const t = this.images[n];
                        t ? i[n] = {
                            data: t.data.clone(),
                            pixelRatio: t.pixelRatio,
                            sdf: t.sdf,
                            version: t.version,
                            stretchX: t.stretchX,
                            stretchY: t.stretchY,
                            content: t.content,
                            hasRenderCallback: Boolean(t.userImage && t.userImage.render)
                        } : e.warnOnce(`Image "${n}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                    }
                    n(null, i)
                }

                getPixelSize() {
                    const {width: e, height: t} = this.atlasImage;
                    return {width: e, height: t}
                }

                getPattern(t) {
                    const n = this.patterns[t], i = this.getImage(t);
                    if (!i) return null;
                    if (n && n.position.version === i.version) return n.position;
                    if (n) n.position.version = i.version; else {
                        const n = {w: i.data.width + 2, h: i.data.height + 2, x: 0, y: 0},
                            r = new e.ImagePosition(n, i);
                        this.patterns[t] = {bin: n, position: r}
                    }
                    return this._updatePatternAtlas(), this.patterns[t].position
                }

                bind(t) {
                    const n = t.gl;
                    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE)
                }

                _updatePatternAtlas() {
                    const t = [];
                    for (const e in this.patterns) t.push(this.patterns[e].bin);
                    const {w: n, h: i} = e.potpack(t), r = this.atlasImage;
                    r.resize({width: n || 1, height: i || 1});
                    for (const t in this.patterns) {
                        const {bin: n} = this.patterns[t], i = n.x + 1, o = n.y + 1, a = this.images[t].data,
                            s = a.width, l = a.height;
                        e.RGBAImage.copy(a, r, {x: 0, y: 0}, {x: i, y: o}, {
                            width: s,
                            height: l
                        }), e.RGBAImage.copy(a, r, {x: 0, y: l - 1}, {x: i, y: o - 1}, {
                            width: s,
                            height: 1
                        }), e.RGBAImage.copy(a, r, {x: 0, y: 0}, {x: i, y: o + l}, {
                            width: s,
                            height: 1
                        }), e.RGBAImage.copy(a, r, {x: s - 1, y: 0}, {x: i - 1, y: o}, {
                            width: 1,
                            height: l
                        }), e.RGBAImage.copy(a, r, {x: 0, y: 0}, {x: i + s, y: o}, {width: 1, height: l})
                    }
                    this.dirty = !0
                }

                beginFrame() {
                    this.callbackDispatchedThisFrame = {}
                }

                dispatchRenderCallbacks(e) {
                    for (const t of e) {
                        if (this.callbackDispatchedThisFrame[t]) continue;
                        this.callbackDispatchedThisFrame[t] = !0;
                        const e = this.images[t];
                        h(e) && this.updateImage(t, e)
                    }
                }
            }

            const f = new e.Properties({
                anchor: new e.DataConstantProperty(e.spec.light.anchor),
                position: new class {
                    constructor() {
                        this.specification = e.spec.light.position
                    }

                    possiblyEvaluate(t, n) {
                        return function ([t, n, i]) {
                            const r = e.degToRad(n + 90), o = e.degToRad(i);
                            return {
                                x: t * Math.cos(r) * Math.sin(o),
                                y: t * Math.sin(r) * Math.sin(o),
                                z: t * Math.cos(o),
                                azimuthal: n,
                                polar: i
                            }
                        }(t.expression.evaluate(n))
                    }

                    interpolate(t, n, i) {
                        return {
                            x: e.number(t.x, n.x, i),
                            y: e.number(t.y, n.y, i),
                            z: e.number(t.z, n.z, i),
                            azimuthal: e.number(t.azimuthal, n.azimuthal, i),
                            polar: e.number(t.polar, n.polar, i)
                        }
                    }
                },
                color: new e.DataConstantProperty(e.spec.light.color),
                intensity: new e.DataConstantProperty(e.spec.light.intensity)
            }), m = "-transition";

            class _ extends e.Evented {
                constructor(t) {
                    super(), this._transitionable = new e.Transitionable(f), this.setLight(t), this._transitioning = this._transitionable.untransitioned()
                }

                getLight() {
                    return this._transitionable.serialize()
                }

                setLight(t, n = {}) {
                    if (!this._validate(e.validateLight, t, n)) for (const n in t) {
                        const i = t[n];
                        e.endsWith(n, m) ? this._transitionable.setTransition(n.slice(0, -m.length), i) : this._transitionable.setValue(n, i)
                    }
                }

                updateTransitions(e) {
                    this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(e) {
                    this.properties = this._transitioning.possiblyEvaluate(e)
                }

                _validate(t, n, i) {
                    return (!i || !1 !== i.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
                        value: n,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: e.spec
                    })))
                }
            }

            const g = new e.Properties({
                source: new e.DataConstantProperty(e.spec.terrain.source),
                exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration)
            }), y = "-transition";

            class v extends e.Evented {
                constructor(t, n) {
                    super(), this._transitionable = new e.Transitionable(g), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = n
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(t) {
                    for (const n in t) {
                        const i = t[n];
                        e.endsWith(n, y) ? this._transitionable.setTransition(n.slice(0, -y.length), i) : this._transitionable.setValue(n, i)
                    }
                }

                updateTransitions(e) {
                    this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(e) {
                    this.properties = this._transitioning.possiblyEvaluate(e)
                }
            }

            function x(t, n, i, r) {
                const o = e.smoothstep(45, 65, i), [a, s] = b(t, r), l = e.length(n);
                let c = 1 - Math.min(1, Math.exp((l - a) / (s - a) * -6));
                return c *= c * c, c = Math.min(1, 1.00747 * c), c * o * t.alpha
            }

            function b(e, t) {
                const n = .5 / Math.tan(.5 * t);
                return [e.range[0] + n, e.range[1] + n]
            }

            const w = new e.Properties({
                range: new e.DataConstantProperty(e.spec.fog.range),
                color: new e.DataConstantProperty(e.spec.fog.color),
                "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"])
            }), M = "-transition";

            class T extends e.Evented {
                constructor(t, n) {
                    super(), this._transitionable = new e.Transitionable(w), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = n
                }

                get state() {
                    return {
                        range: this.properties.get("range"),
                        horizonBlend: this.properties.get("horizon-blend"),
                        alpha: this.properties.get("color").a
                    }
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(t, n = {}) {
                    if (!this._validate(e.validateFog, t, n)) for (const n in t) {
                        const i = t[n];
                        e.endsWith(n, M) ? this._transitionable.setTransition(n.slice(0, -M.length), i) : this._transitionable.setValue(n, i)
                    }
                }

                getOpacity(t) {
                    if (!this._transform.projection.supportsFog) return 0;
                    const n = this.properties && this.properties.get("color") || 1;
                    return e.smoothstep(45, 65, t) * n.a
                }

                getOpacityAtLatLng(t, n) {
                    return this._transform.projection.supportsFog ? function (t, n, i) {
                        const r = e.MercatorCoordinate.fromLngLat(n),
                            o = i.elevation ? i.elevation.getAtPointOrZero(r) : 0, a = [r.x, r.y, o];
                        return e.transformMat4(a, a, i.mercatorFogMatrix), x(t, a, i.pitch, i._fov)
                    }(this.state, t, n) : 0
                }

                getFovAdjustedRange(e) {
                    return this._transform.projection.supportsFog ? b(this.state, e) : [0, 1]
                }

                updateTransitions(e) {
                    this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(e) {
                    this.properties = this._transitioning.possiblyEvaluate(e)
                }

                _validate(t, n, i) {
                    return (!i || !1 !== i.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
                        value: n,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: e.spec
                    })))
                }
            }

            class k {
                constructor(t, n) {
                    this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
                    const i = this.workerPool.acquire(this.id);
                    for (let e = 0; e < i.length; e++) {
                        const t = new k.Actor(i[e], n, this.id);
                        t.name = "Worker " + e, this.actors.push(t)
                    }
                    this.ready = !1, this.broadcast("checkIfReady", null, () => {
                        this.ready = !0
                    })
                }

                broadcast(t, n, i) {
                    e.asyncAll(this.actors, (e, i) => {
                        e.send(t, n, i)
                    }, i = i || function () {
                    })
                }

                getActor() {
                    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
                }

                remove() {
                    this.actors.forEach(e => {
                        e.remove()
                    }), this.actors = [], this.workerPool.release(this.id)
                }
            }

            function S(t, n, i) {
                return n * (e.EXTENT / (t.tileSize * Math.pow(2, i - t.tileID.overscaledZ)))
            }

            k.Actor = e.Actor;

            class D {
                constructor(e, t, n) {
                    this.context = e;
                    const i = e.gl;
                    this.buffer = i.createBuffer(), this.dynamicDraw = Boolean(n), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer
                }

                bind() {
                    this.context.bindElementBuffer.set(this.buffer)
                }

                updateData(e) {
                    const t = this.context.gl;
                    this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
                }

                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }

            const L = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT"
            };

            class E {
                constructor(e, t, n, i) {
                    this.length = t.length, this.attributes = n, this.itemSize = t.bytesPerElement, this.dynamicDraw = i, this.context = e;
                    const r = e.gl;
                    this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer
                }

                bind() {
                    this.context.bindVertexBuffer.set(this.buffer)
                }

                updateData(e) {
                    const t = this.context.gl;
                    this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer)
                }

                enableAttributes(e, t) {
                    for (let n = 0; n < this.attributes.length; n++) {
                        const i = t.attributes[this.attributes[n].name];
                        void 0 !== i && e.enableVertexAttribArray(i)
                    }
                }

                setVertexAttribPointers(e, t, n) {
                    for (let i = 0; i < this.attributes.length; i++) {
                        const r = this.attributes[i], o = t.attributes[r.name];
                        void 0 !== o && e.vertexAttribPointer(o, r.components, e[L[r.type]], !1, this.itemSize, r.offset + this.itemSize * (n || 0))
                    }
                }

                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }

            class C {
                constructor(e) {
                    this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
                }

                get() {
                    return this.current
                }

                set(e) {
                }

                getDefault() {
                    return this.default
                }

                setDefault() {
                    this.set(this.default)
                }
            }

            class A extends C {
                getDefault() {
                    return e.Color.transparent
                }

                set(e) {
                    const t = this.current;
                    (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
                }
            }

            class I extends C {
                getDefault() {
                    return 1
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
                }
            }

            class P extends C {
                getDefault() {
                    return 0
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
                }
            }

            class R extends C {
                getDefault() {
                    return [!0, !0, !0, !0]
                }

                set(e) {
                    const t = this.current;
                    (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
                }
            }

            class Y extends C {
                getDefault() {
                    return !0
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
                }
            }

            class z extends C {
                getDefault() {
                    return 255
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
                }
            }

            class O extends C {
                getDefault() {
                    return {func: this.gl.ALWAYS, ref: 0, mask: 255}
                }

                set(e) {
                    const t = this.current;
                    (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
                }
            }

            class F extends C {
                getDefault() {
                    const e = this.gl;
                    return [e.KEEP, e.KEEP, e.KEEP]
                }

                set(e) {
                    const t = this.current;
                    (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
                }
            }

            class B extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1
                }
            }

            class j extends C {
                getDefault() {
                    return [0, 1]
                }

                set(e) {
                    const t = this.current;
                    (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
                }
            }

            class H extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1
                }
            }

            class N extends C {
                getDefault() {
                    return this.gl.LESS
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
                }
            }

            class U extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1
                }
            }

            class W extends C {
                getDefault() {
                    const e = this.gl;
                    return [e.ONE, e.ZERO]
                }

                set(e) {
                    const t = this.current;
                    (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
                }
            }

            class V extends C {
                getDefault() {
                    return e.Color.transparent
                }

                set(e) {
                    const t = this.current;
                    (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
                }
            }

            class G extends C {
                getDefault() {
                    return this.gl.FUNC_ADD
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
                }
            }

            class q extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1
                }
            }

            class Z extends C {
                getDefault() {
                    return this.gl.BACK
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
                }
            }

            class $ extends C {
                getDefault() {
                    return this.gl.CCW
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
                }
            }

            class X extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
                }
            }

            class J extends C {
                getDefault() {
                    return this.gl.TEXTURE0
                }

                set(e) {
                    (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
                }
            }

            class K extends C {
                getDefault() {
                    const e = this.gl;
                    return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
                }

                set(e) {
                    const t = this.current;
                    (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
                }
            }

            class Q extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1
                }
            }

            class ee extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1
                }
            }

            class te extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1
                }
            }

            class ne extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
                }
            }

            class ie extends C {
                getDefault() {
                    return null
                }

                set(e) {
                    const t = this.gl;
                    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
                }
            }

            class re extends C {
                constructor(e) {
                    super(e), this.vao = e.extVertexArrayObject
                }

                getDefault() {
                    return null
                }

                set(e) {
                    this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1)
                }
            }

            class oe extends C {
                getDefault() {
                    return 4
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
                }
            }

            class ae extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
                }
            }

            class se extends C {
                getDefault() {
                    return !1
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    const t = this.gl;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
                }
            }

            class le extends C {
                constructor(e, t) {
                    super(e), this.context = e, this.parent = t
                }

                getDefault() {
                    return null
                }
            }

            class ce extends le {
                setDirty() {
                    this.dirty = !0
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const t = this.gl;
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
                }
            }

            class ue extends le {
                attachment() {
                    return this.gl.DEPTH_ATTACHMENT
                }

                set(e) {
                    if (e === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const t = this.gl;
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1
                }
            }

            class de extends ue {
                attachment() {
                    return this.gl.DEPTH_STENCIL_ATTACHMENT
                }
            }

            class he {
                constructor(e, t, n, i) {
                    this.context = e, this.width = t, this.height = n;
                    const r = this.framebuffer = e.gl.createFramebuffer();
                    this.colorAttachment = new ce(e, r), i && (this.depthAttachment = new ue(e, r))
                }

                destroy() {
                    const e = this.context.gl, t = this.colorAttachment.get();
                    if (t && e.deleteTexture(t), this.depthAttachment) {
                        const t = this.depthAttachment.get();
                        t && e.deleteRenderbuffer(t)
                    }
                    e.deleteFramebuffer(this.framebuffer)
                }
            }

            class pe {
                constructor(e) {
                    this.gl = e, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new A(this), this.clearDepth = new I(this), this.clearStencil = new P(this), this.colorMask = new R(this), this.depthMask = new Y(this), this.stencilMask = new z(this), this.stencilFunc = new O(this), this.stencilOp = new F(this), this.stencilTest = new B(this), this.depthRange = new j(this), this.depthTest = new H(this), this.depthFunc = new N(this), this.blend = new U(this), this.blendFunc = new W(this), this.blendColor = new V(this), this.blendEquation = new G(this), this.cullFace = new q(this), this.cullFaceSide = new Z(this), this.frontFace = new $(this), this.program = new X(this), this.activeTexture = new J(this), this.viewport = new K(this), this.bindFramebuffer = new Q(this), this.bindRenderbuffer = new ee(this), this.bindTexture = new te(this), this.bindVertexBuffer = new ne(this), this.bindElementBuffer = new ie(this), this.bindVertexArrayOES = this.extVertexArrayObject && new re(this), this.pixelStoreUnpack = new oe(this), this.pixelStoreUnpackPremultiplyAlpha = new ae(this), this.pixelStoreUnpackFlipY = new se(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extTextureHalfFloat = e.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)
                }

                setDefault() {
                    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
                }

                setDirty() {
                    this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
                }

                createIndexBuffer(e, t) {
                    return new D(this, e, t)
                }

                createVertexBuffer(e, t, n) {
                    return new E(this, e, t, n)
                }

                createRenderbuffer(e, t, n) {
                    const i = this.gl, r = i.createRenderbuffer();
                    return this.bindRenderbuffer.set(r), i.renderbufferStorage(i.RENDERBUFFER, e, t, n), this.bindRenderbuffer.set(null), r
                }

                createFramebuffer(e, t, n) {
                    return new he(this, e, t, n)
                }

                clear({color: e, depth: t, stencil: n}) {
                    const i = this.gl;
                    let r = 0;
                    e && (r |= i.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= i.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== n && (r |= i.STENCIL_BUFFER_BIT, this.clearStencil.set(n), this.stencilMask.set(255)), i.clear(r)
                }

                setCullFace(e) {
                    !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
                }

                setDepthMode(e) {
                    e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
                }

                setStencilMode(e) {
                    e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
                        func: e.test.func,
                        ref: e.ref,
                        mask: e.test.mask
                    })) : this.stencilTest.set(!1)
                }

                setColorMode(t) {
                    o(t.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask)
                }

                unbindVAO() {
                    this.extVertexArrayObject && this.bindVertexArrayOES.set(null)
                }
            }

            class fe {
                constructor(e, t, n, i) {
                    this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = n, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map(e => i.pointCoordinate3D(e)), this.cameraGeometry = this.bufferedCameraGeometry(0)
                }

                static createFromScreenPoints(t, n) {
                    let i, r;
                    if (t instanceof e.pointGeometry || "number" == typeof t[0]) {
                        const o = e.pointGeometry.convert(t);
                        i = [e.pointGeometry.convert(t)], r = n.isPointAboveHorizon(o)
                    } else {
                        const o = e.pointGeometry.convert(t[0]), a = e.pointGeometry.convert(t[1]);
                        i = [o, a], r = e.polygonizeBounds(o, a).every(e => n.isPointAboveHorizon(e))
                    }
                    return new fe(i, n.getCameraPoint(), r, n)
                }

                isPointQuery() {
                    return 1 === this.screenBounds.length
                }

                bufferedScreenGeometry(t) {
                    return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t)
                }

                bufferedCameraGeometry(t) {
                    const n = this.screenBounds[0],
                        i = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
                        r = e.polygonizeBounds(n, i, 0, !1);
                    return this.cameraPoint.y > i.y && (this.cameraPoint.x > n.x && this.cameraPoint.x < i.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= i.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= n.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t)
                }

                containsTile(t, n, i) {
                    const r = t.queryPadding + 1, o = t.tileID.wrap,
                        a = i ? this._bufferedCameraMercator(r, n).map(n => e.getTilePoint(t.tileTransform, n, o)) : this._bufferedScreenMercator(r, n).map(n => e.getTilePoint(t.tileTransform, n, o)),
                        s = this.screenGeometryMercator.map(n => e.getTileVec3(t.tileTransform, n, o)),
                        l = s.map(t => new e.pointGeometry(t[0], t[1])),
                        c = n.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),
                        u = e.getTileVec3(t.tileTransform, c, o), d = s.map(t => {
                            const n = e.sub(t, t, u);
                            return e.normalize(n, n), new e.Ray(u, n)
                        }), h = S(t, 1, n.zoom);
                    if (e.polygonIntersectsBox(a, 0, 0, e.EXTENT, e.EXTENT)) return {
                        queryGeometry: this,
                        tilespaceGeometry: l,
                        tilespaceRays: d,
                        bufferedTilespaceGeometry: a,
                        bufferedTilespaceBounds: (p = e.getBounds(a), p.min.x = e.clamp(p.min.x, 0, e.EXTENT), p.min.y = e.clamp(p.min.y, 0, e.EXTENT), p.max.x = e.clamp(p.max.x, 0, e.EXTENT), p.max.y = e.clamp(p.max.y, 0, e.EXTENT), p),
                        tile: t,
                        tileID: t.tileID,
                        pixelToTileUnitsFactor: h
                    };
                    var p
                }

                _bufferedScreenMercator(e, t) {
                    const n = me(e);
                    if (this._screenRaycastCache[n]) return this._screenRaycastCache[n];
                    {
                        const i = this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e));
                        return this._screenRaycastCache[n] = i, i
                    }
                }

                _bufferedCameraMercator(e, t) {
                    const n = me(e);
                    if (this._cameraRaycastCache[n]) return this._cameraRaycastCache[n];
                    {
                        const i = this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e));
                        return this._cameraRaycastCache[n] = i, i
                    }
                }
            }

            function me(e) {
                return 100 * e | 0
            }

            function _e(t, n, i) {
                const r = function (r, o) {
                    if (r) return i(r);
                    if (o) {
                        const r = e.pick(e.extend(o, t), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                        o.vector_layers && (r.vectorLayers = o.vector_layers, r.vectorLayerIds = r.vectorLayers.map(e => e.id)), r.tiles = n.canonicalizeTileset(r, t.url), i(null, r)
                    }
                };
                return t.url ? e.getJSON(n.transformRequest(n.normalizeSourceURL(t.url), e.ResourceType.Source), r) : e.exported.frame(() => r(null, t))
            }

            class ge {
                constructor(t, n, i) {
                    this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = n || 0, this.maxzoom = i || 24
                }

                validateBounds(e) {
                    return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
                }

                contains(t) {
                    const n = Math.pow(2, t.z), i = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * n),
                        r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * n),
                        o = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * n),
                        a = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * n);
                    return t.x >= i && t.x < o && t.y >= r && t.y < a
                }
            }

            class ye extends e.Evented {
                constructor(t, n, i, r) {
                    super(), this.id = t, this.dispatcher = i, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.extend({type: "raster"}, n), e.extend(this, e.pick(n, ["url", "scheme", "tileSize"]))
                }

                load() {
                    this._loaded = !1, this.fire(new e.Event("dataloading", {dataType: "source"})), this._tileJSONRequest = _e(this._options, this.map._requestManager, (t, n) => {
                        this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new ge(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles), this.fire(new e.Event("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.Event("data", {dataType: "source", sourceDataType: "content"})))
                    })
                }

                loaded() {
                    return this._loaded
                }

                onAdd(e) {
                    this.map = e, this.load()
                }

                onRemove() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null)
                }

                serialize() {
                    return e.extend({}, this._options)
                }

                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical)
                }

                loadTile(t, n) {
                    const i = e.exported.devicePixelRatio >= 2,
                        r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), i, this.tileSize);
                    t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (i, r, o, a) => {
                        if (delete t.request, t.aborted) t.state = "unloaded", n(null); else if (i) t.state = "errored", n(i); else if (r) {
                            this.map._refreshExpiredTiles && t.setExpiryData({cacheControl: o, expires: a});
                            const i = this.map.painter.context, s = i.gl;
                            t.texture = this.map.painter.getTileTexture(r.width), t.texture ? t.texture.update(r, {useMipmap: !0}) : (t.texture = new e.Texture(i, r, s.RGBA, {useMipmap: !0}), t.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), i.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, i.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i.extTextureFilterAnisotropicMax)), t.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), n(null)
                        }
                    })
                }

                abortTile(e, t) {
                    e.request && (e.request.cancel(), delete e.request), t()
                }

                unloadTile(e, t) {
                    e.texture && this.map.painter.saveTileTexture(e.texture), t()
                }

                hasTransition() {
                    return !1
                }
            }

            let ve;

            function xe(t, n, i, r, o, a, s, l) {
                const c = [t, i, o, n, r, a, 1, 1, 1], u = [s, l, 1],
                    d = e.adjoint([], c), [h, p, f] = e.transformMat3(u, u, e.transpose(d, d));
                return e.multiply(c, [h, 0, 0, 0, p, 0, 0, 0, f], c)
            }

            class be extends e.Evented {
                constructor(e, t, n, i) {
                    super(), this.id = e, this.dispatcher = n, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(i), this.options = t
                }

                load(t, n) {
                    this._loaded = !1, this.fire(new e.Event("dataloading", {dataType: "source"})), this.url = this.options.url, e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, r) => {
                        this._loaded = !0, i ? this.fire(new e.ErrorEvent(i)) : r && (this.image = e.exported.getImageData(r), this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), n && n(), this._finishLoading())
                    })
                }

                loaded() {
                    return this._loaded
                }

                updateImage(e) {
                    return this.image && e.url ? (this.options.url = e.url, this.load(e.coordinates, () => {
                        this.texture = null
                    }), this) : this
                }

                _finishLoading() {
                    this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })))
                }

                onAdd(e) {
                    this.map = e, this.load()
                }

                setCoordinates(t) {
                    this.coordinates = t, delete this._boundsArray;
                    const n = t.map(e.MercatorCoordinate.fromLngLat);
                    return this.tileID = function (t) {
                        let n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0;
                        for (const e of t) n = Math.min(n, e.x), i = Math.min(i, e.y), r = Math.max(r, e.x), o = Math.max(o, e.y);
                        const a = Math.max(r - n, o - i), s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)),
                            l = Math.pow(2, s);
                        return new e.CanonicalTileID(s, Math.floor((n + r) / 2 * l), Math.floor((i + o) / 2 * l))
                    }(n), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    })), this
                }

                _clear() {
                    delete this._boundsArray
                }

                _makeBoundsArray() {
                    const t = e.tileTransform(this.tileID, this.map.transform.projection), [n, i, r, o] = this.coordinates.map(n => {
                        const i = t.projection.project(n[0], n[1]);
                        return e.getTilePoint(t, i)._round()
                    });
                    return this.perspectiveTransform = function (t, n, i, r, o, a, s, l, c, u) {
                        const d = xe(0, 0, t, 0, 0, n, t, n), h = xe(i, r, o, a, s, l, c, u);
                        return e.multiply(h, e.adjoint(d, d), h), [h[6] / h[8] * t / e.EXTENT, h[7] / h[8] * n / e.EXTENT]
                    }(this.width, this.height, n.x, n.y, i.x, i.y, o.x, o.y, r.x, r.y), this._boundsArray = new e.StructArrayLayout4i8, this._boundsArray.emplaceBack(n.x, n.y, 0, 0), this._boundsArray.emplaceBack(i.x, i.y, e.EXTENT, 0), this._boundsArray.emplaceBack(o.x, o.y, 0, e.EXTENT), this._boundsArray.emplaceBack(r.x, r.y, e.EXTENT, e.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this
                }

                prepare() {
                    if (0 === Object.keys(this.tiles).length || !this.image) return;
                    const t = this.map.painter.context, n = t.gl;
                    this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, e.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new e.Texture(t, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
                    for (const e in this.tiles) {
                        const t = this.tiles[e];
                        "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture)
                    }
                }

                loadTile(e, t) {
                    this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = "errored", t(null))
                }

                serialize() {
                    return {type: "image", url: this.options.url, coordinates: this.coordinates}
                }

                hasTransition() {
                    return !1
                }
            }

            const we = {
                vector: class extends e.Evented {
                    constructor(t, n, i, r) {
                        if (super(), this.id = t, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({type: "vector"}, n), this._collectResourceTiming = n.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest
                    }

                    load() {
                        this._loaded = !1, this.fire(new e.Event("dataloading", {dataType: "source"})), this._tileJSONRequest = _e(this._options, this.map._requestManager, (t, n) => {
                            this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new ge(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            })), this.fire(new e.Event("data", {dataType: "source", sourceDataType: "content"})))
                        })
                    }

                    loaded() {
                        return this._loaded
                    }

                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }

                    onAdd(e) {
                        this.map = e, this.load()
                    }

                    setSourceProperty(e) {
                        this._tileJSONRequest && this._tileJSONRequest.cancel(), e();
                        const t = this.map.style._getSourceCaches(this.id);
                        for (const e of t) e.clearTiles();
                        this.load()
                    }

                    setTiles(e) {
                        return this.setSourceProperty(() => {
                            this._options.tiles = e
                        }), this
                    }

                    setUrl(e) {
                        return this.setSourceProperty(() => {
                            this.url = e, this._options.url = e
                        }), this
                    }

                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null)
                    }

                    serialize() {
                        return e.extend({}, this._options)
                    }

                    loadTile(t, n) {
                        const i = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),
                            r = {
                                request: this.map._requestManager.transformRequest(i, e.ResourceType.Tile),
                                data: void 0,
                                uid: t.uid,
                                tileID: t.tileID,
                                tileZoom: t.tileZoom,
                                zoom: t.tileID.overscaledZ,
                                tileSize: this.tileSize * t.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: e.exported.devicePixelRatio,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                isSymbolTile: t.isSymbolTile
                            };
                        if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = n : t.request = t.actor.send("reloadTile", r, o.bind(this)); else if (t.actor = this._tileWorkers[i] = this._tileWorkers[i] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", r, o.bind(this), void 0, !0); else {
                            const n = e.loadVectorTile.call({deduped: this._deduped}, r, (e, n) => {
                                e || !n ? o.call(this, e) : (r.data = {
                                    cacheControl: n.cacheControl,
                                    expires: n.expires,
                                    rawData: n.rawData.slice(0)
                                }, t.actor && t.actor.send("loadTile", r, o.bind(this), void 0, !0))
                            }, !0);
                            t.request = {cancel: n}
                        }

                        function o(i, r) {
                            return delete t.request, t.aborted ? n(null) : i && 404 !== i.status ? n(i) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), n(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)))
                        }
                    }

                    abortTile(e) {
                        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                            uid: e.uid,
                            type: this.type,
                            source: this.id
                        })
                    }

                    unloadTile(e) {
                        e.unloadVectorData(), e.actor && e.actor.send("removeTile", {
                            uid: e.uid,
                            type: this.type,
                            source: this.id
                        })
                    }

                    hasTransition() {
                        return !1
                    }

                    afterUpdate() {
                        this._tileWorkers = {}
                    }
                }, raster: ye, "raster-dem": class extends ye {
                    constructor(t, n, i, r) {
                        super(t, n, i, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({type: "raster-dem"}, n), this.encoding = n.encoding || "mapbox"
                    }

                    loadTile(t, n) {
                        const i = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);

                        function r(e, i) {
                            e && (t.state = "errored", n(e)), i && (t.dem = i, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", n(null))
                        }

                        t.request = e.getImage(this.map._requestManager.transformRequest(i, e.ResourceType.Tile), function (i, o, a, s) {
                            if (delete t.request, t.aborted) t.state = "unloaded", n(null); else if (i) t.state = "errored", n(i); else if (o) {
                                this.map._refreshExpiredTiles && t.setExpiryData({cacheControl: a, expires: s});
                                const n = e.window.ImageBitmap && o instanceof e.window.ImageBitmap && (null == ve && (ve = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), ve),
                                    i = 1 - (o.width - e.prevPowerOfTwo(o.width)) / 2;
                                i < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));
                                const l = n ? o : e.exported.getImageData(o, i), c = {
                                    uid: t.uid,
                                    coord: t.tileID,
                                    source: this.id,
                                    rawImageData: l,
                                    encoding: this.encoding,
                                    padding: i
                                };
                                t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", c, r.bind(this), void 0, !0))
                            }
                        }.bind(this))
                    }

                    _getNeighboringTiles(t) {
                        const n = t.canonical, i = Math.pow(2, n.z), r = (n.x - 1 + i) % i,
                            o = 0 === n.x ? t.wrap - 1 : t.wrap, a = (n.x + 1 + i) % i,
                            s = n.x + 1 === i ? t.wrap + 1 : t.wrap, l = {};
                        return l[new e.OverscaledTileID(t.overscaledZ, o, n.z, r, n.y).key] = {backfilled: !1}, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y).key] = {backfilled: !1}, n.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, o, n.z, r, n.y - 1).key] = {backfilled: !1}, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, n.z, n.x, n.y - 1).key] = {backfilled: !1}, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y - 1).key] = {backfilled: !1}), n.y + 1 < i && (l[new e.OverscaledTileID(t.overscaledZ, o, n.z, r, n.y + 1).key] = {backfilled: !1}, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, n.z, n.x, n.y + 1).key] = {backfilled: !1}, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y + 1).key] = {backfilled: !1}), l
                    }

                    unloadTile(e) {
                        e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded"
                    }
                }, geojson: class extends e.Evented {
                    constructor(t, n, i, r) {
                        super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = i.getActor(), this.setEventedParent(r), this._data = n.data, this._options = e.extend({}, n), this._collectResourceTiming = n.collectResourceTiming, void 0 !== n.maxzoom && (this.maxzoom = n.maxzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId;
                        const o = e.EXTENT / this.tileSize;
                        this.workerOptions = e.extend({
                            source: this.id,
                            cluster: n.cluster || !1,
                            geojsonVtOptions: {
                                buffer: (void 0 !== n.buffer ? n.buffer : 128) * o,
                                tolerance: (void 0 !== n.tolerance ? n.tolerance : .375) * o,
                                extent: e.EXTENT,
                                maxZoom: this.maxzoom,
                                lineMetrics: n.lineMetrics || !1,
                                generateId: n.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: void 0 !== n.clusterMaxZoom ? n.clusterMaxZoom : this.maxzoom - 1,
                                minPoints: Math.max(2, n.clusterMinPoints || 2),
                                extent: e.EXTENT,
                                radius: (void 0 !== n.clusterRadius ? n.clusterRadius : 50) * o,
                                log: !1,
                                generateId: n.generateId || !1
                            },
                            clusterProperties: n.clusterProperties,
                            filter: n.filter
                        }, n.workerOptions)
                    }

                    onAdd(e) {
                        this.map = e, this.setData(this._data)
                    }

                    setData(e) {
                        return this._data = e, this._updateWorkerData(), this
                    }

                    getClusterExpansionZoom(e, t) {
                        return this.actor.send("geojson.getClusterExpansionZoom", {
                            clusterId: e,
                            source: this.id
                        }, t), this
                    }

                    getClusterChildren(e, t) {
                        return this.actor.send("geojson.getClusterChildren", {clusterId: e, source: this.id}, t), this
                    }

                    getClusterLeaves(e, t, n, i) {
                        return this.actor.send("geojson.getClusterLeaves", {
                            source: this.id,
                            clusterId: e,
                            limit: t,
                            offset: n
                        }, i), this
                    }

                    _updateWorkerData() {
                        if (this._pendingLoad) return void (this._coalesce = !0);
                        this.fire(new e.Event("dataloading", {dataType: "source"})), this._loaded = !1;
                        const t = e.extend({}, this.workerOptions), n = this._data;
                        "string" == typeof n ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(n), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(n), this._pendingLoad = this.actor.send(this.type + ".loadData", t, (t, n) => {
                            if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t)); else {
                                const t = {
                                    dataType: "source",
                                    sourceDataType: this._metadataFired ? "content" : "metadata"
                                };
                                this._collectResourceTiming && n && n.resourceTiming && n.resourceTiming[this.id] && (t.resourceTiming = n.resourceTiming[this.id]), this.fire(new e.Event("data", t)), this._metadataFired = !0
                            }
                            this._coalesce && (this._updateWorkerData(), this._coalesce = !1)
                        })
                    }

                    loaded() {
                        return this._loaded
                    }

                    loadTile(t, n) {
                        const i = t.actor ? "reloadTile" : "loadTile";
                        t.actor = this.actor, t.request = this.actor.send(i, {
                            type: this.type,
                            uid: t.uid,
                            tileID: t.tileID,
                            tileZoom: t.tileZoom,
                            zoom: t.tileID.overscaledZ,
                            maxZoom: this.maxzoom,
                            tileSize: this.tileSize,
                            source: this.id,
                            pixelRatio: e.exported.devicePixelRatio,
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId
                        }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? n(null) : e ? n(e) : (t.loadVectorData(r, this.map.painter, "reloadTile" === i), n(null))), void 0, "loadTile" === i)
                    }

                    abortTile(e) {
                        e.request && (e.request.cancel(), delete e.request), e.aborted = !0
                    }

                    unloadTile(e) {
                        e.unloadVectorData(), this.actor.send("removeTile", {
                            uid: e.uid,
                            type: this.type,
                            source: this.id
                        })
                    }

                    onRemove() {
                        this._pendingLoad && this._pendingLoad.cancel()
                    }

                    serialize() {
                        return e.extend({}, this._options, {type: this.type, data: this._data})
                    }

                    hasTransition() {
                        return !1
                    }
                }, video: class extends be {
                    constructor(e, t, n, i) {
                        super(e, t, n, i), this.roundZoom = !0, this.type = "video", this.options = t
                    }

                    load() {
                        this._loaded = !1;
                        const t = this.options;
                        this.urls = [];
                        for (const n of t.urls) this.urls.push(this.map._requestManager.transformRequest(n, e.ResourceType.Source).url);
                        e.getVideo(this.urls, (t, n) => {
                            this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : n && (this.video = n, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                                this.map.triggerRepaint()
                            }), this.map && this.video.play(), this._finishLoading())
                        })
                    }

                    pause() {
                        this.video && this.video.pause()
                    }

                    play() {
                        this.video && this.video.play()
                    }

                    seek(t) {
                        if (this.video) {
                            const n = this.video.seekable;
                            t < n.start(0) || t > n.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError("sources." + this.id, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = t
                        }
                    }

                    getVideo() {
                        return this.video
                    }

                    onAdd(e) {
                        this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
                    }

                    prepare() {
                        if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                        const t = this.map.painter.context, n = t.gl;
                        this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, e.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2));
                        for (const e in this.tiles) {
                            const t = this.tiles[e];
                            "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture)
                        }
                    }

                    serialize() {
                        return {type: "video", urls: this.urls, coordinates: this.coordinates}
                    }

                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }, image: be, canvas: class extends be {
                    constructor(t, n, i, r) {
                        super(t, n, i, r), n.coordinates ? Array.isArray(n.coordinates) && 4 === n.coordinates.length && !n.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => "number" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError("sources." + t, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError("sources." + t, null, 'missing required property "coordinates"'))), n.animate && "boolean" != typeof n.animate && this.fire(new e.ErrorEvent(new e.ValidationError("sources." + t, null, 'optional "animate" property must be a boolean value'))), n.canvas ? "string" == typeof n.canvas || n.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError("sources." + t, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError("sources." + t, null, 'missing required property "canvas"'))), this.options = n, this.animate = void 0 === n.animate || n.animate
                    }

                    load() {
                        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
                            this._playing = !0, this.map.triggerRepaint()
                        }, this.pause = function () {
                            this._playing && (this.prepare(), this._playing = !1)
                        }, this._finishLoading())
                    }

                    getCanvas() {
                        return this.canvas
                    }

                    onAdd(e) {
                        this.map = e, this.load(), this.canvas && this.animate && this.play()
                    }

                    onRemove() {
                        this.pause()
                    }

                    prepare() {
                        let t = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;
                        if (0 === Object.keys(this.tiles).length) return;
                        const n = this.map.painter.context, i = n.gl;
                        this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, e.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (t || this._playing) && this.texture.update(this.canvas, {premultiply: !0}) : this.texture = new e.Texture(n, this.canvas, i.RGBA, {premultiply: !0});
                        for (const e in this.tiles) {
                            const t = this.tiles[e];
                            "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture)
                        }
                    }

                    serialize() {
                        return {type: "canvas", coordinates: this.coordinates}
                    }

                    hasTransition() {
                        return this._playing
                    }

                    _hasInvalidDimensions() {
                        for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
                        return !1
                    }
                }
            }, Me = function (t, n, i, r) {
                const o = new we[n.type](t, n, i, r);
                if (o.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${o.id}`);
                return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], o), o
            };

            function Te(t, n) {
                const i = e.identity([]);
                return e.scale(i, i, [.5 * t.width, .5 * -t.height, 1]), e.translate(i, i, [1, -1, 0]), e.multiply$1(i, i, t.calculateProjMatrix(n.toUnwrapped()))
            }

            function ke(e, t, n, i, r, o, a, s = !1) {
                const l = e.tilesIn(i, a, s);
                l.sort(De);
                const c = [];
                for (const i of l) c.push({
                    wrappedTileID: i.tile.tileID.wrapped().key,
                    queryResults: i.tile.queryRenderedFeatures(t, n, e._state, i, r, o, Te(e.transform, i.tile.tileID), s)
                });
                const u = function (e) {
                    const t = {}, n = {};
                    for (const i of e) {
                        const e = i.queryResults, r = i.wrappedTileID, o = n[r] = n[r] || {};
                        for (const n in e) {
                            const i = e[n], r = o[n] = o[n] || {}, a = t[n] = t[n] || [];
                            for (const e of i) r[e.featureIndex] || (r[e.featureIndex] = !0, a.push(e))
                        }
                    }
                    return t
                }(c);
                for (const t in u) u[t].forEach(t => {
                    const n = t.feature, i = e.getFeatureState(n.layer["source-layer"], n.id);
                    n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = i
                });
                return u
            }

            function Se(e, t) {
                const n = e.getRenderableIds().map(t => e.getTileByID(t)), i = [], r = {};
                for (let e = 0; e < n.length; e++) {
                    const o = n[e], a = o.tileID.canonical.key;
                    r[a] || (r[a] = !0, o.querySourceFeatures(i, t))
                }
                return i
            }

            function De(e, t) {
                const n = e.tileID, i = t.tileID;
                return n.overscaledZ - i.overscaledZ || n.canonical.y - i.canonical.y || n.wrap - i.wrap || n.canonical.x - i.canonical.x
            }

            function Le() {
                return null != Xr.workerClass ? new Xr.workerClass : new e.window.Worker(Xr.workerUrl)
            }

            const Ee = "mapboxgl_preloaded_worker_pool";

            class Ce {
                constructor() {
                    this.active = {}
                }

                acquire(e) {
                    if (!this.workers) for (this.workers = []; this.workers.length < Ce.workerCount;) this.workers.push(new Le);
                    return this.active[e] = !0, this.workers.slice()
                }

                release(e) {
                    delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {
                        e.terminate()
                    }), this.workers = null)
                }

                isPreloaded() {
                    return !!this.active[Ee]
                }

                numActive() {
                    return Object.keys(this.active).length
                }
            }

            let Ae;

            function Ie() {
                return Ae || (Ae = new Ce), Ae
            }

            function Pe(t, n) {
                const i = {};
                for (const e in t) "ref" !== e && (i[e] = t[e]);
                return e.refProperties.forEach(e => {
                    e in n && (i[e] = n[e])
                }), i
            }

            function Re(e) {
                e = e.slice();
                const t = Object.create(null);
                for (let n = 0; n < e.length; n++) t[e[n].id] = e[n];
                for (let n = 0; n < e.length; n++) "ref" in e[n] && (e[n] = Pe(e[n], t[e[n].ref]));
                return e
            }

            Ce.workerCount = 2;
            const Ye = {
                setStyle: "setStyle",
                addLayer: "addLayer",
                removeLayer: "removeLayer",
                setPaintProperty: "setPaintProperty",
                setLayoutProperty: "setLayoutProperty",
                setFilter: "setFilter",
                addSource: "addSource",
                removeSource: "removeSource",
                setGeoJSONSourceData: "setGeoJSONSourceData",
                setLayerZoomRange: "setLayerZoomRange",
                setLayerProperty: "setLayerProperty",
                setCenter: "setCenter",
                setZoom: "setZoom",
                setBearing: "setBearing",
                setPitch: "setPitch",
                setSprite: "setSprite",
                setGlyphs: "setGlyphs",
                setTransition: "setTransition",
                setLight: "setLight",
                setTerrain: "setTerrain",
                setFog: "setFog",
                setProjection: "setProjection"
            };

            function ze(e, t, n) {
                n.push({command: Ye.addSource, args: [e, t[e]]})
            }

            function Oe(e, t, n) {
                t.push({command: Ye.removeSource, args: [e]}), n[e] = !0
            }

            function Fe(e, t, n, i) {
                Oe(e, n, i), ze(e, t, n)
            }

            function Be(e, t, n) {
                let i;
                for (i in e[n]) if (e[n].hasOwnProperty(i) && "data" !== i && !o(e[n][i], t[n][i])) return !1;
                for (i in t[n]) if (t[n].hasOwnProperty(i) && "data" !== i && !o(e[n][i], t[n][i])) return !1;
                return !0
            }

            function je(e, t, n, i, r, a) {
                let s;
                for (s in t = t || {}, e = e || {}) e.hasOwnProperty(s) && (o(e[s], t[s]) || n.push({
                    command: a,
                    args: [i, s, t[s], r]
                }));
                for (s in t) t.hasOwnProperty(s) && !e.hasOwnProperty(s) && (o(e[s], t[s]) || n.push({
                    command: a,
                    args: [i, s, t[s], r]
                }))
            }

            function He(e) {
                return e.id
            }

            function Ne(e, t) {
                return e[t.id] = t, e
            }

            class Ue {
                constructor(e, t) {
                    this.reset(e, t)
                }

                reset(e, t) {
                    this.points = e || [], this._distances = [0];
                    for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
                    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
                }

                lerp(t) {
                    if (1 === this.points.length) return this.points[0];
                    t = e.clamp(t, 0, 1);
                    let n = 1, i = this._distances[n];
                    const r = t * this.paddedLength + this.padding;
                    for (; i < r && n < this._distances.length;) i = this._distances[++n];
                    const o = n - 1, a = this._distances[o], s = i - a, l = s > 0 ? (r - a) / s : 0;
                    return this.points[o].mult(1 - l).add(this.points[n].mult(l))
                }
            }

            class We {
                constructor(e, t, n) {
                    const i = this.boxCells = [], r = this.circleCells = [];
                    this.xCellCount = Math.ceil(e / n), this.yCellCount = Math.ceil(t / n);
                    for (let e = 0; e < this.xCellCount * this.yCellCount; e++) i.push([]), r.push([]);
                    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0
                }

                keysLength() {
                    return this.boxKeys.length + this.circleKeys.length
                }

                insert(e, t, n, i, r) {
                    this._forEachCell(t, n, i, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(r)
                }

                insertCircle(e, t, n, i) {
                    this._forEachCell(t - i, n - i, t + i, n + i, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(n), this.circles.push(i)
                }

                _insertBoxCell(e, t, n, i, r, o) {
                    this.boxCells[r].push(o)
                }

                _insertCircleCell(e, t, n, i, r, o) {
                    this.circleCells[r].push(o)
                }

                _query(e, t, n, i, r, o) {
                    if (n < 0 || e > this.width || i < 0 || t > this.height) return !r && [];
                    const a = [];
                    if (e <= 0 && t <= 0 && this.width <= n && this.height <= i) {
                        if (r) return !0;
                        for (let e = 0; e < this.boxKeys.length; e++) a.push({
                            key: this.boxKeys[e],
                            x1: this.bboxes[4 * e],
                            y1: this.bboxes[4 * e + 1],
                            x2: this.bboxes[4 * e + 2],
                            y2: this.bboxes[4 * e + 3]
                        });
                        for (let e = 0; e < this.circleKeys.length; e++) {
                            const t = this.circles[3 * e], n = this.circles[3 * e + 1], i = this.circles[3 * e + 2];
                            a.push({key: this.circleKeys[e], x1: t - i, y1: n - i, x2: t + i, y2: n + i})
                        }
                        return o ? a.filter(o) : a
                    }
                    return this._forEachCell(e, t, n, i, this._queryCell, a, {
                        hitTest: r,
                        seenUids: {box: {}, circle: {}}
                    }, o), r ? a.length > 0 : a
                }

                _queryCircle(e, t, n, i, r) {
                    const o = e - n, a = e + n, s = t - n, l = t + n;
                    if (a < 0 || o > this.width || l < 0 || s > this.height) return !i && [];
                    const c = [];
                    return this._forEachCell(o, s, a, l, this._queryCellCircle, c, {
                        hitTest: i,
                        circle: {x: e, y: t, radius: n},
                        seenUids: {box: {}, circle: {}}
                    }, r), i ? c.length > 0 : c
                }

                query(e, t, n, i, r) {
                    return this._query(e, t, n, i, !1, r)
                }

                hitTest(e, t, n, i, r) {
                    return this._query(e, t, n, i, !0, r)
                }

                hitTestCircle(e, t, n, i) {
                    return this._queryCircle(e, t, n, !0, i)
                }

                _queryCell(e, t, n, i, r, o, a, s) {
                    const l = a.seenUids, c = this.boxCells[r];
                    if (null !== c) {
                        const r = this.bboxes;
                        for (const u of c) if (!l.box[u]) {
                            l.box[u] = !0;
                            const c = 4 * u;
                            if (e <= r[c + 2] && t <= r[c + 3] && n >= r[c + 0] && i >= r[c + 1] && (!s || s(this.boxKeys[u]))) {
                                if (a.hitTest) return o.push(!0), !0;
                                o.push({key: this.boxKeys[u], x1: r[c], y1: r[c + 1], x2: r[c + 2], y2: r[c + 3]})
                            }
                        }
                    }
                    const u = this.circleCells[r];
                    if (null !== u) {
                        const r = this.circles;
                        for (const c of u) if (!l.circle[c]) {
                            l.circle[c] = !0;
                            const u = 3 * c;
                            if (this._circleAndRectCollide(r[u], r[u + 1], r[u + 2], e, t, n, i) && (!s || s(this.circleKeys[c]))) {
                                if (a.hitTest) return o.push(!0), !0;
                                {
                                    const e = r[u], t = r[u + 1], n = r[u + 2];
                                    o.push({key: this.circleKeys[c], x1: e - n, y1: t - n, x2: e + n, y2: t + n})
                                }
                            }
                        }
                    }
                }

                _queryCellCircle(e, t, n, i, r, o, a, s) {
                    const l = a.circle, c = a.seenUids, u = this.boxCells[r];
                    if (null !== u) {
                        const e = this.bboxes;
                        for (const t of u) if (!c.box[t]) {
                            c.box[t] = !0;
                            const n = 4 * t;
                            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[n + 0], e[n + 1], e[n + 2], e[n + 3]) && (!s || s(this.boxKeys[t]))) return o.push(!0), !0
                        }
                    }
                    const d = this.circleCells[r];
                    if (null !== d) {
                        const e = this.circles;
                        for (const t of d) if (!c.circle[t]) {
                            c.circle[t] = !0;
                            const n = 3 * t;
                            if (this._circlesCollide(e[n], e[n + 1], e[n + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[t]))) return o.push(!0), !0
                        }
                    }
                }

                _forEachCell(e, t, n, i, r, o, a, s) {
                    const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t),
                        u = this._convertToXCellCoord(n), d = this._convertToYCellCoord(i);
                    for (let h = l; h <= u; h++) for (let l = c; l <= d; l++) if (r.call(this, e, t, n, i, this.xCellCount * l + h, o, a, s)) return
                }

                _convertToXCellCoord(e) {
                    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
                }

                _convertToYCellCoord(e) {
                    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
                }

                _circlesCollide(e, t, n, i, r, o) {
                    const a = i - e, s = r - t, l = n + o;
                    return l * l > a * a + s * s
                }

                _circleAndRectCollide(e, t, n, i, r, o, a) {
                    const s = (o - i) / 2, l = Math.abs(e - (i + s));
                    if (l > s + n) return !1;
                    const c = (a - r) / 2, u = Math.abs(t - (r + c));
                    if (u > c + n) return !1;
                    if (l <= s || u <= c) return !0;
                    const d = l - s, h = u - c;
                    return d * d + h * h <= n * n
                }
            }

            const Ve = Math.tan(85 * Math.PI / 180);

            function Ge(t, n, i, o, a, s) {
                let l = e.create();
                if (i) {
                    if ("globe" === a.projection.name) l = e.calculateGlobeMatrix(a, a.worldSize / a._projectionScaler, [0, 0]), e.multiply$1(l, l, e.globeDenormalizeECEF(e.globeTileBounds(n))); else {
                        const e = r([], s);
                        l[0] = e[0], l[1] = e[1], l[4] = e[2], l[5] = e[3]
                    }
                    o || e.rotateZ(l, l, a.angle)
                } else e.multiply$1(l, a.labelPlaneMatrix, t);
                return l
            }

            function qe(t, n, i, r, o, a) {
                if (i) {
                    if ("globe" === o.projection.name) {
                        const s = Ge(t, n, i, r, o, a);
                        return e.invert(s, s), e.multiply$1(s, t, s), s
                    }
                    {
                        const n = e.clone(t), i = e.identity([]);
                        return i[0] = a[0], i[1] = a[1], i[4] = a[2], i[5] = a[3], e.multiply$1(n, n, i), r || e.rotateZ(n, n, -o.angle), n
                    }
                }
                return o.glCoordMatrix
            }

            function Ze(t, n, i = 0) {
                const r = [t.x, t.y, i, 1];
                i ? e.transformMat4$1(r, r, n) : at(r, r, n);
                const o = r[3];
                return {point: new e.pointGeometry(r[0] / o, r[1] / o), signedDistanceFromCamera: o}
            }

            function $e(e, t) {
                return Math.min(.5 + e / t * .5, 1.5)
            }

            function Xe(e, t) {
                const n = e[0] / e[3], i = e[1] / e[3];
                return n >= -t[0] && n <= t[0] && i >= -t[1] && i <= t[1]
            }

            function Je(t, n, i, r, o, a, s, l, c, u) {
                const d = i.transform, h = r ? t.textSizeData : t.iconSizeData,
                    p = e.evaluateSizeForZoom(h, i.transform.zoom), f = [256 / i.width * 2 + 1, 256 / i.height * 2 + 1],
                    m = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;
                m.clear();
                const _ = t.lineVertexArray, g = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
                    y = i.transform.width / i.transform.height;
                let v = !1;
                for (let r = 0; r < g.length; r++) {
                    const x = g.get(r);
                    if (x.writingMode !== e.WritingMode.vertical || v || 0 !== r && g.get(r - 1).writingMode === e.WritingMode.horizontal || (v = !0), x.hidden || x.writingMode === e.WritingMode.vertical && !v) {
                        ot(x.numGlyphs, m);
                        continue
                    }
                    v = !1;
                    const b = new e.pointGeometry(x.tileAnchorX, x.tileAnchorY), w = c ? c(b) : [0, 0, 0],
                        M = d.projection.projectTilePoint(b.x, b.y, u.canonical),
                        T = [M.x + w[0], M.y + w[1], M.z + w[2]], k = [...T, 1];
                    if (e.transformMat4$1(k, k, n), !Xe(k, f)) {
                        ot(x.numGlyphs, m);
                        continue
                    }
                    const S = $e(i.transform.cameraToCenterDistance, k[3]), D = e.evaluateSizeForFeature(h, p, x),
                        L = s ? D / S : D * S, E = Ze(new e.pointGeometry(T[0], T[1]), o, T[2]);
                    if (E.signedDistanceFromCamera <= 0) {
                        ot(x.numGlyphs, m);
                        continue
                    }
                    let C = {};
                    const A = s ? null : c,
                        I = et(x, L, !1, l, n, o, a, t.glyphOffsetArray, _, m, E.point, b, C, y, A, d.projection, u);
                    v = I.useVertical, A && I.needsFlipping && (C = {}), (I.notEnoughRoom || v || I.needsFlipping && et(x, L, !0, l, n, o, a, t.glyphOffsetArray, _, m, E.point, b, C, y, A, d.projection, u).notEnoughRoom) && ot(x.numGlyphs, m)
                }
                r ? t.text.dynamicLayoutVertexBuffer.updateData(m) : t.icon.dynamicLayoutVertexBuffer.updateData(m)
            }

            function Ke(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f) {
                const m = s.glyphStartIndex + s.numGlyphs, _ = s.lineStartIndex, g = s.lineStartIndex + s.lineLength,
                    y = t.getoffsetX(s.glyphStartIndex), v = t.getoffsetX(m - 1),
                    x = it(e * y, n, i, r, o, a, s.segment, _, g, l, c, u, d, h, !0, p, f);
                if (!x) return null;
                const b = it(e * v, n, i, r, o, a, s.segment, _, g, l, c, u, d, h, !0, p, f);
                return b ? {first: x, last: b} : null
            }

            function Qe(t, n, i, r) {
                return t.writingMode === e.WritingMode.horizontal && Math.abs(i.y - n.y) > Math.abs(i.x - n.x) * r ? {useVertical: !0} : t.writingMode === e.WritingMode.vertical ? n.y < i.y ? {needsFlipping: !0} : null : 0 !== t.flipState && function (e, t, n) {
                    const i = (t.x - e.x) * n;
                    return 0 === i || Math.abs((t.y - e.y) / i) > Ve
                }(n, i, r) ? 1 === t.flipState ? {needsFlipping: !0} : null : n.x > i.x ? {needsFlipping: !0} : null
            }

            function et(t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g) {
                const y = n / 24, v = t.lineOffsetX * y, x = t.lineOffsetY * y;
                let b;
                if (t.numGlyphs > 1) {
                    const e = t.glyphStartIndex + t.numGlyphs, n = t.lineStartIndex,
                        o = t.lineStartIndex + t.lineLength, u = Ke(y, l, v, x, i, d, h, t, c, a, p, m, !1, _, g);
                    if (!u) return {notEnoughRoom: !0};
                    const w = Ze(u.first.point, s).point, M = Ze(u.last.point, s).point;
                    if (r && !i) {
                        const e = Qe(t, w, M, f);
                        if (t.flipState = e && e.needsFlipping ? 1 : 2, e) return e
                    }
                    b = [u.first];
                    for (let r = t.glyphStartIndex + 1; r < e - 1; r++) b.push(it(y * l.getoffsetX(r), v, x, i, d, h, t.segment, n, o, c, a, p, m, !1, !1, _, g));
                    b.push(u.last)
                } else {
                    if (r && !i) {
                        const n = Ze(h, o).point, i = t.lineStartIndex + t.segment + 1,
                            r = new e.pointGeometry(c.getx(i), c.gety(i)), a = Ze(r, o),
                            s = Qe(t, n, a.signedDistanceFromCamera > 0 ? a.point : nt(h, r, n, 1, o, void 0, _, g.canonical), f);
                        if (t.flipState = s && s.needsFlipping ? 1 : 2, s) return s
                    }
                    const n = it(y * l.getoffsetX(t.glyphStartIndex), v, x, i, d, h, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, c, a, p, m, !1, !1, _, g);
                    if (!n) return {notEnoughRoom: !0};
                    b = [n]
                }
                for (const t of b) e.addDynamicAttributes(u, t.point, t.angle);
                return {}
            }

            function tt(t, n, i, r, o) {
                const a = r.projectTilePoint(t.x, t.y, n);
                if (!o) return Ze(a, i, a.z);
                const s = o(t);
                return Ze(new e.pointGeometry(a.x + s[0], a.y + s[1]), i, a.z + s[2])
            }

            function nt(e, t, n, i, r, o, a, s) {
                const l = tt(e.add(e.sub(t)._unit()), s, r, a, o).point, c = n.sub(l);
                return n.add(c._mult(i / c.mag()))
            }

            function it(t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g) {
                const y = r ? t - n : t + n;
                let v = y > 0 ? 1 : -1, x = 0;
                r && (v *= -1, x = Math.PI), v < 0 && (x += Math.PI);
                let b = v > 0 ? l + s : l + s + 1, w = o, M = o, T = 0, k = 0;
                const S = Math.abs(y), D = [], L = [];
                let E = a;
                const C = () => {
                    const t = b - v;
                    return 0 === T ? a : new e.pointGeometry(u.getx(t), u.gety(t))
                }, A = () => nt(C(), E, M, S - T + 1, d, p, _, g.canonical);
                for (; T + k <= S;) {
                    if (b += v, b < l || b >= c) return null;
                    if (M = w, D.push(w), f && L.push(E || C()), w = h[b], void 0 === w) {
                        E = new e.pointGeometry(u.getx(b), u.gety(b));
                        const t = tt(E, g.canonical, d, _, p);
                        w = t.signedDistanceFromCamera > 0 ? h[b] = t.point : A()
                    } else E = null;
                    T += k, k = M.dist(w)
                }
                m && p && (E = E || new e.pointGeometry(u.getx(b), u.gety(b)), h[b] = w = void 0 === h[b] ? w : A(), k = M.dist(w));
                const I = (S - T) / k, P = w.sub(M), R = P.mult(I)._add(M);
                i && R._add(P._unit()._perp()._mult(i * v));
                const Y = x + Math.atan2(w.y - M.y, w.x - M.x);
                return D.push(R), f && (E = E || new e.pointGeometry(u.getx(b), u.gety(b)), L.push(function (t, n, i) {
                    const r = 1 - i;
                    return new e.pointGeometry(t.x * r + n.x * i, t.y * r + n.y * i)
                }(L.length > 0 ? L[L.length - 1] : E, E, I))), {point: R, angle: Y, path: D, tilePath: L}
            }

            const rt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

            function ot(e, t) {
                for (let n = 0; n < e; n++) {
                    const e = t.length;
                    t.resize(e + 4), t.float32.set(rt, 3 * e)
                }
            }

            function at(e, t, n) {
                const i = t[0], r = t[1];
                return e[0] = n[0] * i + n[4] * r + n[12], e[1] = n[1] * i + n[5] * r + n[13], e[3] = n[3] * i + n[7] * r + n[15], e
            }

            const st = 100;

            class lt {
                constructor(e, t, n = new We(e.width + 200, e.height + 200, 25), i = new We(e.width + 200, e.height + 200, 25)) {
                    this.transform = e, this.grid = n, this.ignoredGrid = i, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + st, this.screenBottomBoundary = e.height + st, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t
                }

                placeCollisionBox(e, t, n, i, r, o, a) {
                    let s = t.projectedAnchorX, l = t.projectedAnchorY, c = t.projectedAnchorZ;
                    const u = t.elevation, d = t.tileID;
                    if (u && d) {
                        const e = this.transform.projection.createTileTransform(this.transform, this.transform.worldSize),
                            n = e.upVector(d.canonical, t.tileAnchorX, t.tileAnchorY), i = e.upVectorScale(d.canonical);
                        s += n[0] * u * i, l += n[1] * u * i, c += n[2] * u * i
                    }
                    const h = this.projectAndGetPerspectiveRatio(o, s, l, c, t.tileID), p = r * h.perspectiveRatio,
                        f = (t.x1 * e + n.x - t.padding) * p + h.point.x,
                        m = (t.y1 * e + n.y - t.padding) * p + h.point.y,
                        _ = (t.x2 * e + n.x + t.padding) * p + h.point.x,
                        g = (t.y2 * e + n.y + t.padding) * p + h.point.y,
                        y = h.perspectiveRatio <= .55 || h.aboveHorizon;
                    return !this.isInsideGrid(f, m, _, g) || !i && this.grid.hitTest(f, m, _, g, a) || y ? {
                        box: [],
                        offscreen: !1
                    } : {box: [f, m, _, g], offscreen: this.isOffscreen(f, m, _, g)}
                }

                placeCollisionCircles(t, n, i, r, o, a, s, l, c, u, d, h, p, f) {
                    const m = [], _ = this.transform.elevation,
                        g = this.transform.projection.createTileTransform(this.transform, this.transform.worldSize),
                        y = _ ? _.getAtTileOffsetFunc(f, g) : e => [0, 0, 0],
                        v = new e.pointGeometry(n.tileAnchorX, n.tileAnchorY),
                        x = this.transform.projection.projectTilePoint(n.tileAnchorX, n.tileAnchorY, f.canonical),
                        b = y(v), w = [x.x + b[0], x.y + b[1], x.z + b[2]],
                        M = this.projectAndGetPerspectiveRatio(a, w[0], w[1], w[2], f), {perspectiveRatio: T} = M,
                        k = (u ? o / T : o * T) / e.ONE_EM, S = Ze(new e.pointGeometry(w[0], w[1]), s, w[2]).point,
                        D = M.signedDistanceFromCamera > 0 ? Ke(k, r, n.lineOffsetX * k, n.lineOffsetY * k, !1, S, v, n, i, s, {}, _ && !u ? y : null, u && !!_, this.transform.projection, f) : null;
                    let L = !1, E = !1, C = !0;
                    if (D && !M.aboveHorizon) {
                        const n = .5 * h * T + p, i = new e.pointGeometry(-100, -100),
                            r = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), o = new Ue,
                            a = D.first, s = D.last;
                        let u = [];
                        for (let e = a.path.length - 1; e >= 1; e--) u.push(a.path[e]);
                        for (let e = 1; e < s.path.length; e++) u.push(s.path[e]);
                        const f = 2.5 * n;
                        if (l) {
                            const e = u.map(_ ? (e, t) => {
                                const n = y(t < a.path.length - 1 ? a.tilePath[a.path.length - 1 - t] : s.tilePath[t - a.path.length + 2]);
                                return Ze(e, l, n[2])
                            } : e => Ze(e, l));
                            u = e.some(e => e.signedDistanceFromCamera <= 0) ? [] : e.map(e => e.point)
                        }
                        let g = [];
                        if (u.length > 0) {
                            const t = u[0].clone(), n = u[0].clone();
                            for (let e = 1; e < u.length; e++) t.x = Math.min(t.x, u[e].x), t.y = Math.min(t.y, u[e].y), n.x = Math.max(n.x, u[e].x), n.y = Math.max(n.y, u[e].y);
                            g = t.x >= i.x && n.x <= r.x && t.y >= i.y && n.y <= r.y ? [u] : n.x < i.x || t.x > r.x || n.y < i.y || t.y > r.y ? [] : e.clipLine([u], i.x, i.y, r.x, r.y)
                        }
                        for (const e of g) {
                            o.reset(e, .25 * n);
                            let i = 0;
                            i = o.length <= .5 * n ? 1 : Math.ceil(o.paddedLength / f) + 1;
                            for (let e = 0; e < i; e++) {
                                const r = e / Math.max(i - 1, 1), a = o.lerp(r), s = a.x + st, l = a.y + st;
                                m.push(s, l, n, 0);
                                const u = s - n, h = l - n, p = s + n, f = l + n;
                                if (C = C && this.isOffscreen(u, h, p, f), E = E || this.isInsideGrid(u, h, p, f), !t && this.grid.hitTestCircle(s, l, n, d) && (L = !0, !c)) return {
                                    circles: [],
                                    offscreen: !1,
                                    collisionDetected: L
                                }
                            }
                        }
                    }
                    return {circles: !c && L || !E ? [] : m, offscreen: C, collisionDetected: L}
                }

                queryRenderedSymbols(t) {
                    if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                    const n = [];
                    let i = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0;
                    for (const s of t) {
                        const t = new e.pointGeometry(s.x + st, s.y + st);
                        i = Math.min(i, t.x), r = Math.min(r, t.y), o = Math.max(o, t.x), a = Math.max(a, t.y), n.push(t)
                    }
                    const s = this.grid.query(i, r, o, a).concat(this.ignoredGrid.query(i, r, o, a)), l = {}, c = {};
                    for (const t of s) {
                        const i = t.key;
                        if (void 0 === l[i.bucketInstanceId] && (l[i.bucketInstanceId] = {}), l[i.bucketInstanceId][i.featureIndex]) continue;
                        const r = [new e.pointGeometry(t.x1, t.y1), new e.pointGeometry(t.x2, t.y1), new e.pointGeometry(t.x2, t.y2), new e.pointGeometry(t.x1, t.y2)];
                        e.polygonIntersectsPolygon(n, r) && (l[i.bucketInstanceId][i.featureIndex] = !0, void 0 === c[i.bucketInstanceId] && (c[i.bucketInstanceId] = []), c[i.bucketInstanceId].push(i.featureIndex))
                    }
                    return c
                }

                insertCollisionBox(e, t, n, i, r) {
                    (t ? this.ignoredGrid : this.grid).insert({
                        bucketInstanceId: n,
                        featureIndex: i,
                        collisionGroupID: r
                    }, e[0], e[1], e[2], e[3])
                }

                insertCollisionCircles(e, t, n, i, r) {
                    const o = t ? this.ignoredGrid : this.grid,
                        a = {bucketInstanceId: n, featureIndex: i, collisionGroupID: r};
                    for (let t = 0; t < e.length; t += 4) o.insertCircle(a, e[t], e[t + 1], e[t + 2])
                }

                projectAndGetPerspectiveRatio(t, n, i, r, o) {
                    const a = [n, i, r || 0, 1];
                    let s = !1;
                    if (r || this.transform.pitch > 0) {
                        e.transformMat4$1(a, a, t);
                        let l = !1;
                        this.fogState && o && (l = function (t, n, i, r, o, a) {
                            const s = a.calculateFogTileMatrix(o), l = [n, i, r];
                            return e.transformMat4(l, l, s), x(t, l, a.pitch, a._fov)
                        }(this.fogState, n, i, r || 0, o.toUnwrapped(), this.transform) > .9), s = a[2] > a[3] || l
                    } else at(a, a, t);
                    return {
                        point: new e.pointGeometry((a[0] / a[3] + 1) / 2 * this.transform.width + st, (-a[1] / a[3] + 1) / 2 * this.transform.height + st),
                        perspectiveRatio: Math.min(.5 + this.transform.cameraToCenterDistance / a[3] * .5, 1.5),
                        signedDistanceFromCamera: a[3],
                        aboveHorizon: s
                    }
                }

                isOffscreen(e, t, n, i) {
                    return n < st || e >= this.screenRightBoundary || i < st || t > this.screenBottomBoundary
                }

                isInsideGrid(e, t, n, i) {
                    return n >= 0 && e < this.gridRightBoundary && i >= 0 && t < this.gridBottomBoundary
                }

                getViewportMatrix() {
                    const t = e.identity([]);
                    return e.translate(t, t, [-100, -100, 0]), t
                }
            }

            class ct {
                constructor(e, t, n, i) {
                    this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : i && n ? 1 : 0, this.placed = n
                }

                isHidden() {
                    return 0 === this.opacity && !this.placed
                }
            }

            class ut {
                constructor(e, t, n, i, r, o = !1) {
                    this.text = new ct(e ? e.text : null, t, n, r), this.icon = new ct(e ? e.icon : null, t, i, r), this.clipped = o
                }

                isHidden() {
                    return this.text.isHidden() && this.icon.isHidden()
                }
            }

            class dt {
                constructor(e, t, n, i = !1) {
                    this.text = e, this.icon = t, this.skipFade = n, this.clipped = i
                }
            }

            class ht {
                constructor() {
                    this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = []
                }
            }

            class pt {
                constructor(e, t, n, i, r) {
                    this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = n, this.bucketIndex = i, this.tileID = r
                }
            }

            class ft {
                constructor(e) {
                    this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
                }

                get(e) {
                    if (this.crossSourceCollisions) return {ID: 0, predicate: null};
                    if (!this.collisionGroups[e]) {
                        const t = ++this.maxGroupID;
                        this.collisionGroups[e] = {ID: t, predicate: e => e.collisionGroupID === t}
                    }
                    return this.collisionGroups[e]
                }
            }

            function mt(t, n, i, r, o) {
                const {horizontalAlign: a, verticalAlign: s} = e.getAnchorAlignment(t), l = -(a - .5) * n,
                    c = -(s - .5) * i, u = e.evaluateVariableOffset(t, r);
                return new e.pointGeometry(l + u[0] * o, c + u[1] * o)
            }

            function _t(t, n, i, r, o) {
                const a = new e.pointGeometry(t, n);
                return i && a._rotate(r ? o : -o), a
            }

            class gt {
                constructor(e, t, n, i, r) {
                    this.transform = e.clone(), this.collisionIndex = new lt(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new ft(n), this.collisionCircleArrays = {}, this.prevPlacement = i, i && (i.prevPlacement = void 0), this.placedOrientations = {}
                }

                getBucketParts(t, n, i, r) {
                    const o = i.getBucket(n), a = i.latestFeatureIndex;
                    if (!o || !a || n.id !== o.layerIds[0]) return;
                    const s = o.layers[0].layout, l = i.collisionBoxArray,
                        c = Math.pow(2, this.transform.zoom - i.tileID.overscaledZ), u = i.tileSize / e.EXTENT,
                        d = i.tileID.toUnwrapped(), h = this.transform.calculateProjMatrix(d),
                        p = "map" === s.get("text-pitch-alignment"), f = "map" === s.get("text-rotation-alignment");
                    n.compileFilter();
                    const m = n.dynamicFilter(), _ = n.dynamicFilterNeedsFeature(),
                        g = this.transform.calculatePixelsToTileUnitsMatrix(i),
                        y = Ge(h, i.tileID.canonical, p, f, this.transform, g);
                    let v = null;
                    if (p) {
                        const t = qe(h, i.tileID.canonical, p, f, this.transform, g);
                        v = e.multiply$1([], this.transform.labelPlaneMatrix, t)
                    }
                    let x = null;
                    m && i.latestFeatureIndex && (x = {
                        unwrappedTileID: d,
                        dynamicFilter: m,
                        dynamicFilterNeedsFeature: _,
                        featureIndex: i.latestFeatureIndex
                    }), this.retainedQueryData[o.bucketInstanceId] = new pt(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, i.tileID);
                    const b = {
                        bucket: o,
                        layout: s,
                        posMatrix: h,
                        textLabelPlaneMatrix: y,
                        labelToScreenMatrix: v,
                        clippingData: x,
                        scale: c,
                        textPixelRatio: u,
                        holdingForFade: i.holdingForFade(),
                        collisionBoxArray: l,
                        partiallyEvaluatedTextSize: e.evaluateSizeForZoom(o.textSizeData, this.transform.zoom),
                        partiallyEvaluatedIconSize: e.evaluateSizeForZoom(o.iconSizeData, this.transform.zoom),
                        collisionGroup: this.collisionGroups.get(o.sourceID)
                    };
                    if (r) for (const e of o.sortKeyRanges) {
                        const {sortKey: n, symbolInstanceStart: i, symbolInstanceEnd: r} = e;
                        t.push({sortKey: n, symbolInstanceStart: i, symbolInstanceEnd: r, parameters: b})
                    } else t.push({symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: b})
                }

                attemptAnchorPlacement(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m, _, g) {
                    const y = [d.textOffset0, d.textOffset1], v = mt(e, n, i, y, r),
                        x = this.collisionIndex.placeCollisionBox(r, t, _t(v.x, v.y, o, a, this.transform.angle), u, s, l, c.predicate);
                    if ((!m || 0 !== this.collisionIndex.placeCollisionBox(p.getSymbolInstanceIconSize(g, this.transform.zoom, h), m, _t(v.x, v.y, o, a, this.transform.angle), u, s, l, c.predicate).box.length) && x.box.length > 0) {
                        let t;
                        return this.prevPlacement && this.prevPlacement.variableOffsets[d.crossTileID] && this.prevPlacement.placements[d.crossTileID] && this.prevPlacement.placements[d.crossTileID].text && (t = this.prevPlacement.variableOffsets[d.crossTileID].anchor), this.variableOffsets[d.crossTileID] = {
                            textOffset: y,
                            width: n,
                            height: i,
                            anchor: e,
                            textScale: r,
                            prevAnchor: t
                        }, this.markUsedJustification(p, e, d, f), p.allowVerticalPlacement && (this.markUsedOrientation(p, f, d), this.placedOrientations[d.crossTileID] = f), {
                            shift: v,
                            placedGlyphBoxes: x
                        }
                    }
                }

                placeLayerBucketPart(t, n, i, r) {
                    const {
                            bucket: o,
                            layout: a,
                            posMatrix: s,
                            textLabelPlaneMatrix: l,
                            labelToScreenMatrix: c,
                            clippingData: u,
                            textPixelRatio: d,
                            holdingForFade: h,
                            collisionBoxArray: p,
                            partiallyEvaluatedTextSize: f,
                            partiallyEvaluatedIconSize: m,
                            collisionGroup: _
                        } = t.parameters, g = a.get("text-optional"), y = a.get("icon-optional"),
                        v = a.get("text-allow-overlap"), x = a.get("icon-allow-overlap"),
                        b = "map" === a.get("text-rotation-alignment"), w = "map" === a.get("text-pitch-alignment"),
                        M = "none" !== a.get("icon-text-fit"), T = "viewport-y" === a.get("symbol-z-order"),
                        k = v && (x || !o.hasIconData() || y), S = x && (v || !o.hasTextData() || g);
                    !o.collisionArrays && p && o.deserializeCollisionBoxes(p), i && r && o.updateCollisionDebugBuffers(this.transform.zoom, p);
                    const D = (t, r, p) => {
                        if (u) {
                            const i = {zoom: this.transform.zoom, pitch: this.transform.pitch};
                            let r = null;
                            if (u.dynamicFilterNeedsFeature) {
                                const e = this.retainedQueryData[o.bucketInstanceId];
                                r = u.featureIndex.loadFeature({
                                    featureIndex: t.featureIndex,
                                    bucketIndex: e.bucketIndex,
                                    sourceLayerIndex: e.sourceLayerIndex,
                                    layoutVertexArrayOffset: 0
                                })
                            }
                            if (!(0, u.dynamicFilter)(i, r, this.retainedQueryData[o.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[t.crossTileID] = new dt(!1, !1, !1, !0), void (n[t.crossTileID] = !0)
                        }
                        if (n[t.crossTileID]) return;
                        if (h) return void (this.placements[t.crossTileID] = new dt(!1, !1, !1));
                        let T = !1, D = !1, L = !0, E = null, C = {box: null, offscreen: null},
                            A = {box: null, offscreen: null}, I = null, P = null, R = null, Y = 0, z = 0, O = 0;
                        p.textFeatureIndex ? Y = p.textFeatureIndex : t.useRuntimeCollisionCircles && (Y = t.featureIndex), p.verticalTextFeatureIndex && (z = p.verticalTextFeatureIndex);
                        const F = e => {
                            e.tileID = this.retainedQueryData[o.bucketInstanceId].tileID, (this.transform.elevation || e.elevation) && (e.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[o.bucketInstanceId].tileID, e.tileAnchorX, e.tileAnchorY) : 0)
                        }, B = p.textBox;
                        if (B) {
                            F(B);
                            const n = n => {
                                let i = e.WritingMode.horizontal;
                                if (o.allowVerticalPlacement && !n && this.prevPlacement) {
                                    const e = this.prevPlacement.placedOrientations[t.crossTileID];
                                    e && (this.placedOrientations[t.crossTileID] = e, i = e, this.markUsedOrientation(o, i, t))
                                }
                                return i
                            }, i = (n, i) => {
                                if (o.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && p.verticalTextBox) {
                                    for (const t of o.writingModes) if (t === e.WritingMode.vertical ? (C = i(), A = C) : C = n(), C && C.box && C.box.length) break
                                } else C = n()
                            };
                            if (a.get("text-variable-anchor")) {
                                let l = a.get("text-variable-anchor");
                                if (this.prevPlacement && this.prevPlacement.variableOffsets[t.crossTileID]) {
                                    const e = this.prevPlacement.variableOffsets[t.crossTileID];
                                    l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor))
                                }
                                const c = (e, n, i) => {
                                    const a = o.getSymbolInstanceTextSize(f, t, this.transform.zoom, r),
                                        c = (e.x2 - e.x1) * a + 2 * e.padding, u = (e.y2 - e.y1) * a + 2 * e.padding,
                                        h = M && !x ? n : null;
                                    h && F(h);
                                    let p = {box: [], offscreen: !1};
                                    const g = v ? 2 * l.length : l.length;
                                    for (let n = 0; n < g; ++n) {
                                        const g = this.attemptAnchorPlacement(l[n % l.length], e, c, u, a, b, w, d, s, _, n >= l.length, t, r, o, i, h, f, m);
                                        if (g && (p = g.placedGlyphBoxes, p && p.box && p.box.length)) {
                                            T = !0, E = g.shift;
                                            break
                                        }
                                    }
                                    return p
                                };
                                i(() => c(B, p.iconBox, e.WritingMode.horizontal), () => {
                                    const n = p.verticalTextBox;
                                    return n && F(n), o.allowVerticalPlacement && !(C && C.box && C.box.length) && t.numVerticalGlyphVertices > 0 && n ? c(n, p.verticalIconBox, e.WritingMode.vertical) : {
                                        box: null,
                                        offscreen: null
                                    }
                                }), C && (T = C.box, L = C.offscreen);
                                const u = n(C && C.box);
                                if (!T && this.prevPlacement) {
                                    const e = this.prevPlacement.variableOffsets[t.crossTileID];
                                    e && (this.variableOffsets[t.crossTileID] = e, this.markUsedJustification(o, e.anchor, t, u))
                                }
                            } else {
                                const a = (n, i) => {
                                    const a = o.getSymbolInstanceTextSize(f, t, this.transform.zoom, r),
                                        l = this.collisionIndex.placeCollisionBox(a, n, new e.pointGeometry(0, 0), v, d, s, _.predicate);
                                    return l && l.box && l.box.length && (this.markUsedOrientation(o, i, t), this.placedOrientations[t.crossTileID] = i), l
                                };
                                i(() => a(B, e.WritingMode.horizontal), () => {
                                    const n = p.verticalTextBox;
                                    return o.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && n ? (F(n), a(n, e.WritingMode.vertical)) : {
                                        box: null,
                                        offscreen: null
                                    }
                                }), n(C && C.box && C.box.length)
                            }
                        }
                        if (I = C, T = I && I.box && I.box.length > 0, L = I && I.offscreen, t.useRuntimeCollisionCircles) {
                            const n = o.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),
                                r = e.evaluateSizeForFeature(o.textSizeData, f, n), u = a.get("text-padding");
                            P = this.collisionIndex.placeCollisionCircles(v, n, o.lineVertexArray, o.glyphOffsetArray, r, s, l, c, i, w, _.predicate, t.collisionCircleDiameter * r / e.ONE_EM, u, this.retainedQueryData[o.bucketInstanceId].tileID), T = v || P.circles.length > 0 && !P.collisionDetected, L = L && P.offscreen
                        }
                        if (p.iconFeatureIndex && (O = p.iconFeatureIndex), p.iconBox) {
                            const t = t => {
                                F(t);
                                const n = M && E ? _t(E.x, E.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0),
                                    i = o.getSymbolInstanceIconSize(m, this.transform.zoom, r);
                                return this.collisionIndex.placeCollisionBox(i, t, n, x, d, s, _.predicate)
                            };
                            A && A.box && A.box.length && p.verticalIconBox ? (R = t(p.verticalIconBox), D = R.box.length > 0) : (R = t(p.iconBox), D = R.box.length > 0), L = L && R.offscreen
                        }
                        const j = g || 0 === t.numHorizontalGlyphVertices && 0 === t.numVerticalGlyphVertices,
                            H = y || 0 === t.numIconVertices;
                        if (j || H ? H ? j || (D = D && T) : T = D && T : D = T = D && T, T && I && I.box && this.collisionIndex.insertCollisionBox(I.box, a.get("text-ignore-placement"), o.bucketInstanceId, A && A.box && z ? z : Y, _.ID), D && R && this.collisionIndex.insertCollisionBox(R.box, a.get("icon-ignore-placement"), o.bucketInstanceId, O, _.ID), P && (T && this.collisionIndex.insertCollisionCircles(P.circles, a.get("text-ignore-placement"), o.bucketInstanceId, Y, _.ID), i)) {
                            const e = o.bucketInstanceId;
                            let t = this.collisionCircleArrays[e];
                            void 0 === t && (t = this.collisionCircleArrays[e] = new ht);
                            for (let e = 0; e < P.circles.length; e += 4) t.circles.push(P.circles[e + 0]), t.circles.push(P.circles[e + 1]), t.circles.push(P.circles[e + 2]), t.circles.push(P.collisionDetected ? 1 : 0)
                        }
                        this.placements[t.crossTileID] = new dt(T || k, D || S, L || o.justReloaded), n[t.crossTileID] = !0
                    };
                    if (T) {
                        const e = o.getSortedSymbolIndexes(this.transform.angle);
                        for (let t = e.length - 1; t >= 0; --t) {
                            const n = e[t];
                            D(o.symbolInstances.get(n), n, o.collisionArrays[n])
                        }
                    } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) D(o.symbolInstances.get(e), e, o.collisionArrays[e]);
                    if (i && o.bucketInstanceId in this.collisionCircleArrays) {
                        const t = this.collisionCircleArrays[o.bucketInstanceId];
                        e.invert(t.invProjMatrix, s), t.viewportMatrix = this.collisionIndex.getViewportMatrix()
                    }
                    o.justReloaded = !1
                }

                markUsedJustification(t, n, i, r) {
                    let o;
                    o = r === e.WritingMode.vertical ? i.verticalPlacedTextSymbolIndex : {
                        left: i.leftJustifiedTextSymbolIndex,
                        center: i.centerJustifiedTextSymbolIndex,
                        right: i.rightJustifiedTextSymbolIndex
                    }[e.getAnchorJustification(n)];
                    const a = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex, i.verticalPlacedTextSymbolIndex];
                    for (const e of a) e >= 0 && (t.text.placedSymbolArray.get(e).crossTileID = o >= 0 && e !== o ? 0 : i.crossTileID)
                }

                markUsedOrientation(t, n, i) {
                    const r = n === e.WritingMode.horizontal || n === e.WritingMode.horizontalOnly ? n : 0,
                        o = n === e.WritingMode.vertical ? n : 0,
                        a = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex];
                    for (const e of a) t.text.placedSymbolArray.get(e).placedOrientation = r;
                    i.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(i.verticalPlacedTextSymbolIndex).placedOrientation = o)
                }

                commit(e) {
                    this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                    const t = this.prevPlacement;
                    let n = !1;
                    this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
                    const i = t ? t.symbolFadeChange(e) : 1, r = t ? t.opacities : {}, o = t ? t.variableOffsets : {},
                        a = t ? t.placedOrientations : {};
                    for (const e in this.placements) {
                        const t = this.placements[e], o = r[e];
                        o ? (this.opacities[e] = new ut(o, i, t.text, t.icon, null, t.clipped), n = n || t.text !== o.text.placed || t.icon !== o.icon.placed) : (this.opacities[e] = new ut(null, i, t.text, t.icon, t.skipFade, t.clipped), n = n || t.text || t.icon)
                    }
                    for (const e in r) {
                        const t = r[e];
                        if (!this.opacities[e]) {
                            const r = new ut(t, i, !1, !1);
                            r.isHidden() || (this.opacities[e] = r, n = n || t.text.placed || t.icon.placed)
                        }
                    }
                    for (const e in o) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = o[e]);
                    for (const e in a) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = a[e]);
                    n ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e)
                }

                updateLayerOpacities(e, t) {
                    const n = {};
                    for (const i of t) {
                        const t = i.getBucket(e);
                        t && i.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, n, i.collisionBoxArray)
                    }
                }

                updateBucketOpacities(t, n, i) {
                    t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
                    const r = t.layers[0].layout, o = !!t.layers[0].dynamicFilter(), a = new ut(null, 0, !1, !1, !0),
                        s = r.get("text-allow-overlap"), l = r.get("icon-allow-overlap"),
                        c = r.get("text-variable-anchor"), u = "map" === r.get("text-rotation-alignment"),
                        d = "map" === r.get("text-pitch-alignment"), h = "none" !== r.get("icon-text-fit"),
                        p = new ut(null, 0, s && (l || !t.hasIconData() || r.get("icon-optional")), l && (s || !t.hasTextData() || r.get("text-optional")), !0);
                    !t.collisionArrays && i && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(i);
                    const f = (e, t, n) => {
                        for (let i = 0; i < t / 4; i++) e.opacityVertexArray.emplaceBack(n)
                    };
                    let m = 0;
                    for (let i = 0; i < t.symbolInstances.length; i++) {
                        const r = t.symbolInstances.get(i), {
                            numHorizontalGlyphVertices: s,
                            numVerticalGlyphVertices: l,
                            crossTileID: _
                        } = r;
                        let g = this.opacities[_];
                        n[_] ? g = a : g || (g = p, this.opacities[_] = g), n[_] = !0;
                        const y = s > 0 || l > 0, v = r.numIconVertices > 0, x = this.placedOrientations[r.crossTileID],
                            b = x === e.WritingMode.vertical,
                            w = x === e.WritingMode.horizontal || x === e.WritingMode.horizontalOnly;
                        if (!y && !v || g.isHidden() || m++, y) {
                            const e = St(g.text);
                            f(t.text, s, b ? Dt : e), f(t.text, l, w ? Dt : e);
                            const n = g.text.isHidden();
                            [r.rightJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.leftJustifiedTextSymbolIndex].forEach(e => {
                                e >= 0 && (t.text.placedSymbolArray.get(e).hidden = n || b ? 1 : 0)
                            }), r.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).hidden = n || w ? 1 : 0);
                            const i = this.variableOffsets[r.crossTileID];
                            i && this.markUsedJustification(t, i.anchor, r, x);
                            const o = this.placedOrientations[r.crossTileID];
                            o && (this.markUsedJustification(t, "left", r, o), this.markUsedOrientation(t, o, r))
                        }
                        if (v) {
                            const e = St(g.icon);
                            r.placedIconSymbolIndex >= 0 && (f(t.icon, r.numIconVertices, b ? Dt : e), t.icon.placedSymbolArray.get(r.placedIconSymbolIndex).hidden = g.icon.isHidden()), r.verticalPlacedIconSymbolIndex >= 0 && (f(t.icon, r.numVerticalIconVertices, w ? Dt : e), t.icon.placedSymbolArray.get(r.verticalPlacedIconSymbolIndex).hidden = g.icon.isHidden())
                        }
                        if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                            const n = t.collisionArrays[i];
                            if (n) {
                                let i = new e.pointGeometry(0, 0), r = !0;
                                if (n.textBox || n.verticalTextBox) {
                                    if (c) {
                                        const e = this.variableOffsets[_];
                                        e ? (i = mt(e.anchor, e.width, e.height, e.textOffset, e.textScale), u && i._rotate(d ? this.transform.angle : -this.transform.angle)) : r = !1
                                    }
                                    o && (r = !g.clipped), n.textBox && yt(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || b, i.x, i.y), n.verticalTextBox && yt(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || w, i.x, i.y)
                                }
                                const a = r && Boolean(!w && n.verticalIconBox);
                                n.iconBox && yt(t.iconCollisionBox.collisionVertexArray, g.icon.placed, a, h ? i.x : 0, h ? i.y : 0), n.verticalIconBox && yt(t.iconCollisionBox.collisionVertexArray, g.icon.placed, !a, h ? i.x : 0, h ? i.y : 0)
                            }
                        }
                    }
                    if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
                        const e = this.collisionCircleArrays[t.bucketInstanceId];
                        t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId]
                    }
                }

                symbolFadeChange(e) {
                    return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                }

                zoomAdjustment(e) {
                    return Math.max(0, (this.transform.zoom - e) / 1.5)
                }

                hasTransitions(e) {
                    return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
                }

                stillRecent(e, t) {
                    const n = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
                    return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * n > e
                }

                setStale() {
                    this.stale = !0
                }
            }

            function yt(e, t, n, i, r) {
                e.emplaceBack(t ? 1 : 0, n ? 1 : 0, i || 0, r || 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, i || 0, r || 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, i || 0, r || 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, i || 0, r || 0)
            }

            const vt = Math.pow(2, 25), xt = Math.pow(2, 24), bt = Math.pow(2, 17), wt = Math.pow(2, 16),
                Mt = Math.pow(2, 9), Tt = Math.pow(2, 8), kt = Math.pow(2, 1);

            function St(e) {
                if (0 === e.opacity && !e.placed) return 0;
                if (1 === e.opacity && e.placed) return 4294967295;
                const t = e.placed ? 1 : 0, n = Math.floor(127 * e.opacity);
                return n * vt + t * xt + n * bt + t * wt + n * Mt + t * Tt + n * kt + t
            }

            const Dt = 0;

            class Lt {
                constructor(e) {
                    this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
                }

                continuePlacement(e, t, n, i, r) {
                    const o = this._bucketParts;
                    for (; this._currentTileIndex < e.length;) if (t.getBucketParts(o, i, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
                    for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < o.length;) {
                        const e = o[this._currentPartIndex];
                        if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, n, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0
                    }
                    return !1
                }
            }

            class Et {
                constructor(e, t, n, i, r, o, a, s) {
                    this.placement = new gt(e, r, o, a, s), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = i, this._done = !1
                }

                isDone() {
                    return this._done
                }

                continuePlacement(t, n, i) {
                    const r = e.exported.now(), o = () => {
                        const t = e.exported.now() - r;
                        return !this._forceFullPlacement && t > 2
                    };
                    for (; this._currentPlacementIndex >= 0;) {
                        const e = n[t[this._currentPlacementIndex]], r = this.placement.collisionIndex.transform.zoom;
                        if ("symbol" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {
                            if (this._inProgressLayer || (this._inProgressLayer = new Lt(e)), this._inProgressLayer.continuePlacement(i[e.source], this.placement, this._showCollisionBoxes, e, o)) return;
                            delete this._inProgressLayer
                        }
                        this._currentPlacementIndex--
                    }
                    this._done = !0
                }

                commit(e) {
                    return this.placement.commit(e), this.placement
                }
            }

            const Ct = 512 / e.EXTENT / 2;

            class At {
                constructor(e, t, n) {
                    this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = n;
                    for (let n = 0; n < t.length; n++) {
                        const i = t.get(n), r = i.key;
                        this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({
                            crossTileID: i.crossTileID,
                            coord: this.getScaledCoordinates(i, e)
                        })
                    }
                }

                getScaledCoordinates(t, n) {
                    const i = Ct / Math.pow(2, n.canonical.z - this.tileID.canonical.z);
                    return {
                        x: Math.floor((n.canonical.x * e.EXTENT + t.tileAnchorX) * i),
                        y: Math.floor((n.canonical.y * e.EXTENT + t.tileAnchorY) * i)
                    }
                }

                findMatches(e, t, n) {
                    const i = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
                    for (let r = 0; r < e.length; r++) {
                        const o = e.get(r);
                        if (o.crossTileID) continue;
                        const a = this.indexedSymbolInstances[o.key];
                        if (!a) continue;
                        const s = this.getScaledCoordinates(o, t);
                        for (const e of a) if (Math.abs(e.coord.x - s.x) <= i && Math.abs(e.coord.y - s.y) <= i && !n[e.crossTileID]) {
                            n[e.crossTileID] = !0, o.crossTileID = e.crossTileID;
                            break
                        }
                    }
                }
            }

            class It {
                constructor() {
                    this.maxCrossTileID = 0
                }

                generate() {
                    return ++this.maxCrossTileID
                }
            }

            class Pt {
                constructor() {
                    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
                }

                handleWrapJump(e) {
                    const t = Math.round((e - this.lng) / 360);
                    if (0 !== t) for (const e in this.indexes) {
                        const n = this.indexes[e], i = {};
                        for (const e in n) {
                            const r = n[e];
                            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), i[r.tileID.key] = r
                        }
                        this.indexes[e] = i
                    }
                    this.lng = e
                }

                addBucket(e, t, n) {
                    if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                        if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
                        this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
                    }
                    for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;
                    this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
                    const i = this.usedCrossTileIDs[e.overscaledZ];
                    for (const n in this.indexes) {
                        const r = this.indexes[n];
                        if (Number(n) > e.overscaledZ) for (const n in r) {
                            const o = r[n];
                            o.tileID.isChildOf(e) && o.findMatches(t.symbolInstances, e, i)
                        } else {
                            const o = r[e.scaledTo(Number(n)).key];
                            o && o.findMatches(t.symbolInstances, e, i)
                        }
                    }
                    for (let e = 0; e < t.symbolInstances.length; e++) {
                        const r = t.symbolInstances.get(e);
                        r.crossTileID || (r.crossTileID = n.generate(), i[r.crossTileID] = !0)
                    }
                    return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new At(e, t.symbolInstances, t.bucketInstanceId), !0
                }

                removeBucketCrossTileIDs(e, t) {
                    for (const n in t.indexedSymbolInstances) for (const i of t.indexedSymbolInstances[n]) delete this.usedCrossTileIDs[e][i.crossTileID]
                }

                removeStaleBuckets(e) {
                    let t = !1;
                    for (const n in this.indexes) {
                        const i = this.indexes[n];
                        for (const r in i) e[i[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, i[r]), delete i[r], t = !0)
                    }
                    return t
                }
            }

            class Rt {
                constructor() {
                    this.layerIndexes = {}, this.crossTileIDs = new It, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
                }

                addLayer(e, t, n, i) {
                    let r = this.layerIndexes[e.id];
                    void 0 === r && (r = this.layerIndexes[e.id] = new Pt);
                    let o = !1;
                    const a = {};
                    "globe" !== i.name && r.handleWrapJump(n);
                    for (const n of t) {
                        const t = n.getBucket(e);
                        t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(n.tileID, t, this.crossTileIDs) && (o = !0), a[t.bucketInstanceId] = !0)
                    }
                    return r.removeStaleBuckets(a) && (o = !0), o
                }

                pruneUnusedLayers(e) {
                    const t = {};
                    e.forEach(e => {
                        t[e] = !0
                    });
                    for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e]
                }
            }

            const Yt = (t, n) => e.emitValidationErrors(t, n && n.filter(e => "source.canvas" !== e.identifier)),
                zt = e.pick(Ye, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]),
                Ot = e.pick(Ye, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ft = function () {
                    const t = {}, n = e.spec.$version;
                    for (const i in e.spec.$root) {
                        const r = e.spec.$root[i];
                        if (r.required) {
                            let e = null;
                            e = "version" === i ? n : "array" === r.type ? [] : {}, null != e && (t[i] = e)
                        }
                    }
                    return t
                }(), Bt = {fill: !0, line: !0, background: !0, hillshade: !0, raster: !0};

            class jt extends e.Evented {
                constructor(t, n = {}) {
                    super(), this.map = t, this.dispatcher = new k(Ie(), this), this.imageManager = new p, this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, n.localFontFamily ? e.LocalGlyphMode.all : n.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, n.localFontFamily || n.localIdeographFontFamily), this.lineAtlas = new e.LineAtlas(256, 512), this.crossTileSymbolIndex = new Rt, this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e.ZoomHistory, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
                    const i = this;
                    this._rtlTextPluginCallback = jt.registerForPluginStateChange(t => {
                        i.dispatcher.broadcast("syncRTLPluginState", {
                            pluginStatus: t.pluginStatus,
                            pluginURL: t.pluginURL
                        }, (t, n) => {
                            if (e.triggerPluginCompletionEvent(t), n && n.every(e => e)) for (const e in i._sourceCaches) {
                                const t = i._sourceCaches[e], n = t.getSource().type;
                                "vector" !== n && "geojson" !== n || t.reload()
                            }
                        })
                    }), this.on("data", e => {
                        if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
                        const t = this.getSource(e.sourceId);
                        if (t && t.vectorLayerIds) for (const e in this._layers) {
                            const n = this._layers[e];
                            n.source === t.id && this._validateLayer(n)
                        }
                    })
                }

                loadURL(t, n = {}) {
                    this.fire(new e.Event("dataloading", {dataType: "style"}));
                    const i = "boolean" == typeof n.validate ? n.validate : !e.isMapboxURL(t);
                    t = this.map._requestManager.normalizeStyleURL(t, n.accessToken);
                    const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);
                    this._request = e.getJSON(r, (t, n) => {
                        this._request = null, t ? this.fire(new e.ErrorEvent(t)) : n && this._load(n, i)
                    })
                }

                loadJSON(t, n = {}) {
                    this.fire(new e.Event("dataloading", {dataType: "style"})), this._request = e.exported.frame(() => {
                        this._request = null, this._load(t, !1 !== n.validate)
                    })
                }

                loadEmpty() {
                    this.fire(new e.Event("dataloading", {dataType: "style"})), this._load(Ft, !1)
                }

                _updateLayerCount(e, t) {
                    const n = t ? 1 : -1;
                    e.is3D() && (this._num3DLayers += n), "circle" === e.type && (this._numCircleLayers += n), "symbol" === e.type && (this._numSymbolLayers += n)
                }

                _load(t, n) {
                    if (n && Yt(this, e.validateStyle(t))) return;
                    this._loaded = !0, this.stylesheet = t, this.updateProjection();
                    for (const e in t.sources) this.addSource(e, t.sources[e], {validate: !1});
                    this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs);
                    const i = Re(this.stylesheet.layers);
                    this._order = i.map(e => e.id), this._layers = {}, this._serializedLayers = {};
                    for (let t of i) t = e.createStyleLayer(t), t.setEventedParent(this, {layer: {id: t.id}}), this._layers[t.id] = t, this._serializedLayers[t.id] = t.serialize(), this._updateLayerCount(t, !0);
                    this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new _(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", {dataType: "style"})), this.fire(new e.Event("style.load"))
                }

                terrainSetForDrapingOnly() {
                    return this.terrain && 0 === this.terrain.drapeRenderMode
                }

                setProjection(e) {
                    e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.updateProjection()
                }

                updateProjection() {
                    const e = this.map.transform.projection,
                        t = this.map.transform.setProjection(this.map._runtimeProjection || (this.stylesheet ? this.stylesheet.projection : void 0)),
                        n = this.map.transform.projection;
                    if (this._loaded && (n.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null)), this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), t) {
                        if (n.isReprojectedInTileSpace || e.isReprojectedInTileSpace) {
                            this.map.painter.clearBackgroundTiles();
                            for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles()
                        } else this._forceSymbolLayerUpdate();
                        this.map._update(!0)
                    }
                }

                _loadSprite(t) {
                    this._spriteRequest = function (t, n, i) {
                        let r, o, a;
                        const s = e.exported.devicePixelRatio > 1 ? "@2x" : "";
                        let l = e.getJSON(n.transformRequest(n.normalizeSpriteURL(t, s, ".json"), e.ResourceType.SpriteJSON), (e, t) => {
                                l = null, a || (a = e, r = t, u())
                            }),
                            c = e.getImage(n.transformRequest(n.normalizeSpriteURL(t, s, ".png"), e.ResourceType.SpriteImage), (e, t) => {
                                c = null, a || (a = e, o = t, u())
                            });

                        function u() {
                            if (a) i(a); else if (r && o) {
                                const t = e.exported.getImageData(o), n = {};
                                for (const i in r) {
                                    const {
                                        width: o,
                                        height: a,
                                        x: s,
                                        y: l,
                                        sdf: c,
                                        pixelRatio: u,
                                        stretchX: d,
                                        stretchY: h,
                                        content: p
                                    } = r[i], f = new e.RGBAImage({width: o, height: a});
                                    e.RGBAImage.copy(t, f, {x: s, y: l}, {x: 0, y: 0}, {
                                        width: o,
                                        height: a
                                    }), n[i] = {data: f, pixelRatio: u, sdf: c, stretchX: d, stretchY: h, content: p}
                                }
                                i(null, n)
                            }
                        }

                        return {
                            cancel() {
                                l && (l.cancel(), l = null), c && (c.cancel(), c = null)
                            }
                        }
                    }(t, this.map._requestManager, (t, n) => {
                        if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t)); else if (n) for (const e in n) this.imageManager.addImage(e, n[e]);
                        this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e.Event("data", {dataType: "style"}))
                    })
                }

                _validateLayer(t) {
                    const n = this.getSource(t.source);
                    if (!n) return;
                    const i = t.sourceLayer;
                    i && ("geojson" === n.type || n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(i)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${i}" does not exist on source "${n.id}" as specified by style layer "${t.id}"`)))
                }

                loaded() {
                    if (!this._loaded) return !1;
                    if (Object.keys(this._updatedSources).length) return !1;
                    for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;
                    return !!this.imageManager.isLoaded()
                }

                _serializeLayers(e) {
                    const t = [];
                    for (const n of e) {
                        const e = this._layers[n];
                        "custom" !== e.type && t.push(e.serialize())
                    }
                    return t
                }

                hasTransitions() {
                    if (this.light && this.light.hasTransition()) return !0;
                    if (this.fog && this.fog.hasTransition()) return !0;
                    for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;
                    for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
                    return !1
                }

                get order() {
                    return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order
                }

                isLayerDraped(e) {
                    return !!this.terrain && Bt[e.type]
                }

                _checkLoaded() {
                    if (!this._loaded) throw new Error("Style is not done loading")
                }

                update(t) {
                    if (!this._loaded) return;
                    const n = this._changed;
                    if (this._changed) {
                        const e = Object.keys(this._updatedLayers), n = Object.keys(this._removedLayers);
                        (e.length || n.length) && this._updateWorkerLayers(e, n);
                        for (const e in this._updatedSources) {
                            const t = this._updatedSources[e];
                            "reload" === t ? this._reloadSource(e) : "clear" === t && this._clearSource(e)
                        }
                        this._updateTilesForChangedImages();
                        for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);
                        this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates()
                    }
                    const i = {};
                    for (const e in this._sourceCaches) {
                        const t = this._sourceCaches[e];
                        i[e] = t.used, t.used = !1
                    }
                    for (const e of this._order) {
                        const n = this._layers[e];
                        if (n.recalculate(t, this._availableImages), !n.isHidden(t.zoom)) {
                            const e = this._getLayerSourceCache(n);
                            e && (e.used = !0)
                        }
                        const i = this.map.painter;
                        if (i) {
                            const e = n.getProgramIds();
                            if (!e) continue;
                            const r = n.getProgramConfiguration(t.zoom);
                            for (const t of e) i.useProgram(t, r)
                        }
                    }
                    for (const t in i) {
                        const n = this._sourceCaches[t];
                        i[t] !== n.used && n.getSource().fire(new e.Event("data", {
                            sourceDataType: "visibility",
                            dataType: "source",
                            sourceId: n.getSource().id
                        }))
                    }
                    this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), n && this.fire(new e.Event("data", {dataType: "style"}))
                }

                _updateTilesForChangedImages() {
                    const e = Object.keys(this._changedImages);
                    if (e.length) {
                        for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);
                        this._changedImages = {}
                    }
                }

                _updateWorkerLayers(e, t) {
                    this.dispatcher.broadcast("updateLayers", {layers: this._serializeLayers(e), removedIds: t})
                }

                _resetUpdates() {
                    this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}
                }

                setState(t) {
                    if (this._checkLoaded(), Yt(this, e.validateStyle(t))) return !1;
                    (t = e.clone$1(t)).layers = Re(t.layers);
                    const n = function (e, t) {
                        if (!e) return [{command: Ye.setStyle, args: [t]}];
                        let n = [];
                        try {
                            if (!o(e.version, t.version)) return [{command: Ye.setStyle, args: [t]}];
                            o(e.center, t.center) || n.push({
                                command: Ye.setCenter,
                                args: [t.center]
                            }), o(e.zoom, t.zoom) || n.push({
                                command: Ye.setZoom,
                                args: [t.zoom]
                            }), o(e.bearing, t.bearing) || n.push({
                                command: Ye.setBearing,
                                args: [t.bearing]
                            }), o(e.pitch, t.pitch) || n.push({
                                command: Ye.setPitch,
                                args: [t.pitch]
                            }), o(e.sprite, t.sprite) || n.push({
                                command: Ye.setSprite,
                                args: [t.sprite]
                            }), o(e.glyphs, t.glyphs) || n.push({
                                command: Ye.setGlyphs,
                                args: [t.glyphs]
                            }), o(e.transition, t.transition) || n.push({
                                command: Ye.setTransition,
                                args: [t.transition]
                            }), o(e.light, t.light) || n.push({
                                command: Ye.setLight,
                                args: [t.light]
                            }), o(e.fog, t.fog) || n.push({
                                command: Ye.setFog,
                                args: [t.fog]
                            }), o(e.projection, t.projection) || n.push({
                                command: Ye.setProjection,
                                args: [t.projection]
                            });
                            const i = {}, r = [];
                            !function (e, t, n, i) {
                                let r;
                                for (r in t = t || {}, e = e || {}) e.hasOwnProperty(r) && (t.hasOwnProperty(r) || Oe(r, n, i));
                                for (r in t) t.hasOwnProperty(r) && (e.hasOwnProperty(r) ? o(e[r], t[r]) || ("geojson" === e[r].type && "geojson" === t[r].type && Be(e, t, r) ? n.push({
                                    command: Ye.setGeoJSONSourceData,
                                    args: [r, t[r].data]
                                }) : Fe(r, t, n, i)) : ze(r, t, n))
                            }(e.sources, t.sources, r, i);
                            const a = [];
                            e.layers && e.layers.forEach(e => {
                                i[e.source] ? n.push({command: Ye.removeLayer, args: [e.id]}) : a.push(e)
                            });
                            let s = e.terrain;
                            s && i[s.source] && (n.push({
                                command: Ye.setTerrain,
                                args: [void 0]
                            }), s = void 0), n = n.concat(r), o(s, t.terrain) || n.push({
                                command: Ye.setTerrain,
                                args: [t.terrain]
                            }), function (e, t, n) {
                                t = t || [];
                                const i = (e = e || []).map(He), r = t.map(He), a = e.reduce(Ne, {}),
                                    s = t.reduce(Ne, {}), l = i.slice(), c = Object.create(null);
                                let u, d, h, p, f, m, _;
                                for (u = 0, d = 0; u < i.length; u++) h = i[u], s.hasOwnProperty(h) ? d++ : (n.push({
                                    command: Ye.removeLayer,
                                    args: [h]
                                }), l.splice(l.indexOf(h, d), 1));
                                for (u = 0, d = 0; u < r.length; u++) h = r[r.length - 1 - u], l[l.length - 1 - u] !== h && (a.hasOwnProperty(h) ? (n.push({
                                    command: Ye.removeLayer,
                                    args: [h]
                                }), l.splice(l.lastIndexOf(h, l.length - d), 1)) : d++, m = l[l.length - u], n.push({
                                    command: Ye.addLayer,
                                    args: [s[h], m]
                                }), l.splice(l.length - u, 0, h), c[h] = !0);
                                for (u = 0; u < r.length; u++) if (h = r[u], p = a[h], f = s[h], !c[h] && !o(p, f)) if (o(p.source, f.source) && o(p["source-layer"], f["source-layer"]) && o(p.type, f.type)) {
                                    for (_ in je(p.layout, f.layout, n, h, null, Ye.setLayoutProperty), je(p.paint, f.paint, n, h, null, Ye.setPaintProperty), o(p.filter, f.filter) || n.push({
                                        command: Ye.setFilter,
                                        args: [h, f.filter]
                                    }), o(p.minzoom, f.minzoom) && o(p.maxzoom, f.maxzoom) || n.push({
                                        command: Ye.setLayerZoomRange,
                                        args: [h, f.minzoom, f.maxzoom]
                                    }), p) p.hasOwnProperty(_) && "layout" !== _ && "paint" !== _ && "filter" !== _ && "metadata" !== _ && "minzoom" !== _ && "maxzoom" !== _ && (0 === _.indexOf("paint.") ? je(p[_], f[_], n, h, _.slice(6), Ye.setPaintProperty) : o(p[_], f[_]) || n.push({
                                        command: Ye.setLayerProperty,
                                        args: [h, _, f[_]]
                                    }));
                                    for (_ in f) f.hasOwnProperty(_) && !p.hasOwnProperty(_) && "layout" !== _ && "paint" !== _ && "filter" !== _ && "metadata" !== _ && "minzoom" !== _ && "maxzoom" !== _ && (0 === _.indexOf("paint.") ? je(p[_], f[_], n, h, _.slice(6), Ye.setPaintProperty) : o(p[_], f[_]) || n.push({
                                        command: Ye.setLayerProperty,
                                        args: [h, _, f[_]]
                                    }))
                                } else n.push({
                                    command: Ye.removeLayer,
                                    args: [h]
                                }), m = l[l.lastIndexOf(h) + 1], n.push({command: Ye.addLayer, args: [f, m]})
                            }(a, t.layers, n)
                        } catch (e) {
                            console.warn("Unable to compute style diff:", e), n = [{command: Ye.setStyle, args: [t]}]
                        }
                        return n
                    }(this.serialize(), t).filter(e => !(e.command in Ot));
                    if (0 === n.length) return !1;
                    const i = n.filter(e => !(e.command in zt));
                    if (i.length > 0) throw new Error(`Unimplemented: ${i.map(e => e.command).join(", ")}.`);
                    return n.forEach(e => {
                        "setTransition" !== e.command && this[e.command].apply(this, e.args)
                    }), this.stylesheet = t, this.updateProjection(), !0
                }

                addImage(t, n) {
                    if (this.getImage(t)) return this.fire(new e.ErrorEvent(new Error("An image with this name already exists.")));
                    this.imageManager.addImage(t, n), this._afterImageUpdated(t)
                }

                updateImage(e, t) {
                    this.imageManager.updateImage(e, t)
                }

                getImage(e) {
                    return this.imageManager.getImage(e)
                }

                removeImage(t) {
                    if (!this.getImage(t)) return this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
                    this.imageManager.removeImage(t), this._afterImageUpdated(t)
                }

                _afterImageUpdated(t) {
                    this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", {dataType: "style"}))
                }

                listImages() {
                    return this._checkLoaded(), this._availableImages.slice()
                }

                addSource(t, n, i = {}) {
                    if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error("There is already a source with this ID");
                    if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
                    if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(e.validateStyle.source, "sources." + t, n, null, i)) return;
                    this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
                    const r = Me(t, n, this.dispatcher, this);
                    r.setEventedParent(this, () => ({
                        isSourceLoaded: this.loaded(),
                        source: r.serialize(),
                        sourceId: t
                    }));
                    const o = n => {
                        const i = (n ? "symbol:" : "other:") + t,
                            o = this._sourceCaches[i] = new e.SourceCache(i, r, n);
                        (n ? this._symbolSourceCaches : this._otherSourceCaches)[t] = o, o.style = this, o.onAdd(this.map)
                    };
                    o(!1), "vector" !== n.type && "geojson" !== n.type || o(!0), r.onAdd && r.onAdd(this.map), this._changed = !0
                }

                removeSource(t) {
                    this._checkLoaded();
                    const n = this.getSource(t);
                    if (void 0 === n) throw new Error("There is no source with this ID");
                    for (const n in this._layers) if (this._layers[n].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${n}" is using it.`)));
                    if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
                    const i = this._getSourceCaches(t);
                    for (const t of i) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: t.getSource().id
                    })), t.setEventedParent(null), t.clearTiles();
                    delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], n.setEventedParent(null), n.onRemove && n.onRemove(this.map), this._changed = !0
                }

                setGeoJSONSourceData(e, t) {
                    this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0
                }

                getSource(e) {
                    const t = this._getSourceCache(e);
                    return t && t.getSource()
                }

                addLayer(t, n, i = {}) {
                    this._checkLoaded();
                    const r = t.id;
                    if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
                    let o;
                    if ("custom" === t.type) {
                        if (Yt(this, e.validateCustomStyleLayer(t))) return;
                        o = e.createStyleLayer(t)
                    } else {
                        if ("object" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, {source: r})), this._validate(e.validateStyle.layer, "layers." + r, t, {arrayIndex: -1}, i)) return;
                        o = e.createStyleLayer(t), this._validateLayer(o), o.setEventedParent(this, {layer: {id: r}}), this._serializedLayers[o.id] = o.serialize(), this._updateLayerCount(o, !0)
                    }
                    const a = n ? this._order.indexOf(n) : this._order.length;
                    if (n && -1 === a) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${n}" does not exist on this map.`)));
                    this._order.splice(a, 0, r), this._layerOrderChanged = !0, this._layers[r] = o;
                    const s = this._getLayerSourceCache(o);
                    if (this._removedLayers[r] && o.source && s && "custom" !== o.type) {
                        const e = this._removedLayers[r];
                        delete this._removedLayers[r], e.type !== o.type ? this._updatedSources[o.source] = "clear" : (this._updatedSources[o.source] = "reload", s.pause())
                    }
                    this._updateLayer(o), o.onAdd && o.onAdd(this.map), this._updateDrapeFirstLayers()
                }

                moveLayer(t, n) {
                    if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
                    if (t === n) return;
                    const i = this._order.indexOf(t);
                    this._order.splice(i, 1);
                    const r = n ? this._order.indexOf(n) : this._order.length;
                    n && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${n}" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers())
                }

                removeLayer(t) {
                    this._checkLoaded();
                    const n = this._layers[t];
                    if (!n) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));
                    n.setEventedParent(null), this._updateLayerCount(n, !1);
                    const i = this._order.indexOf(t);
                    this._order.splice(i, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = n, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], n.onRemove && n.onRemove(this.map), this._updateDrapeFirstLayers()
                }

                getLayer(e) {
                    return this._layers[e]
                }

                hasLayer(e) {
                    return e in this._layers
                }

                hasLayerType(e) {
                    for (const t in this._layers) if (this._layers[t].type === e) return !0;
                    return !1
                }

                setLayerZoomRange(t, n, i) {
                    this._checkLoaded();
                    const r = this.getLayer(t);
                    r ? r.minzoom === n && r.maxzoom === i || (null != n && (r.minzoom = n), null != i && (r.maxzoom = i), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)))
                }

                setFilter(t, n, i = {}) {
                    this._checkLoaded();
                    const r = this.getLayer(t);
                    if (r) {
                        if (!o(r.filter, n)) return null == n ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(e.validateStyle.filter, `layers.${r.id}.filter`, n, {layerType: r.type}, i) || (r.filter = e.clone$1(n), this._updateLayer(r)))
                    } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be filtered.`)))
                }

                getFilter(t) {
                    return e.clone$1(this.getLayer(t).filter)
                }

                setLayoutProperty(t, n, i, r = {}) {
                    this._checkLoaded();
                    const a = this.getLayer(t);
                    a ? o(a.getLayoutProperty(n), i) || (a.setLayoutProperty(n, i, r), this._updateLayer(a)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)))
                }

                getLayoutProperty(t, n) {
                    const i = this.getLayer(t);
                    if (i) return i.getLayoutProperty(n);
                    this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)))
                }

                setPaintProperty(t, n, i, r = {}) {
                    this._checkLoaded();
                    const a = this.getLayer(t);
                    a ? o(a.getPaintProperty(n), i) || (a.setPaintProperty(n, i, r) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[t] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)))
                }

                getPaintProperty(e, t) {
                    return this.getLayer(e).getPaintProperty(t)
                }

                setFeatureState(t, n) {
                    this._checkLoaded();
                    const i = t.source, r = t.sourceLayer, o = this.getSource(i);
                    if (void 0 === o) return void this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
                    const a = o.type;
                    if ("geojson" === a && r) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                    if ("vector" === a && !r) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
                    const s = this._getSourceCaches(i);
                    for (const e of s) e.setFeatureState(r, t.id, n)
                }

                removeFeatureState(t, n) {
                    this._checkLoaded();
                    const i = t.source, r = this.getSource(i);
                    if (void 0 === r) return void this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
                    const o = r.type, a = "vector" === o ? t.sourceLayer : void 0;
                    if ("vector" === o && !a) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    if (n && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                    const s = this._getSourceCaches(i);
                    for (const e of s) e.removeFeatureState(a, t.id, n)
                }

                getFeatureState(t) {
                    this._checkLoaded();
                    const n = t.source, i = t.sourceLayer, r = this.getSource(n);
                    if (void 0 !== r) {
                        if ("vector" !== r.type || i) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(n)[0].getFeatureState(i, t.id);
                        this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    } else this.fire(new e.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`)))
                }

                getTransition() {
                    return e.extend({duration: 300, delay: 0}, this.stylesheet && this.stylesheet.transition)
                }

                serialize() {
                    const t = {};
                    for (const e in this._sourceCaches) {
                        const n = this._sourceCaches[e].getSource();
                        t[n.id] || (t[n.id] = n.serialize())
                    }
                    return e.filterObject({
                        version: this.stylesheet.version,
                        name: this.stylesheet.name,
                        metadata: this.stylesheet.metadata,
                        light: this.stylesheet.light,
                        terrain: this.stylesheet.terrain,
                        fog: this.stylesheet.fog,
                        center: this.stylesheet.center,
                        zoom: this.stylesheet.zoom,
                        bearing: this.stylesheet.bearing,
                        pitch: this.stylesheet.pitch,
                        sprite: this.stylesheet.sprite,
                        glyphs: this.stylesheet.glyphs,
                        transition: this.stylesheet.transition,
                        projection: this.stylesheet.projection,
                        sources: t,
                        layers: this._serializeLayers(this._order)
                    }, e => void 0 !== e)
                }

                _updateLayer(e) {
                    this._updatedLayers[e.id] = !0;
                    const t = this._getLayerSourceCache(e);
                    e.source && !this._updatedSources[e.source] && t && "raster" !== t.getSource().type && (this._updatedSources[e.source] = "reload", t.pause()), this._changed = !0, e.invalidateCompiledFilter()
                }

                _flattenAndSortRenderedFeatures(e) {
                    const t = e => "fill-extrusion" === this._layers[e].type, n = {}, i = [];
                    for (let r = this._order.length - 1; r >= 0; r--) {
                        const o = this._order[r];
                        if (t(o)) {
                            n[o] = r;
                            for (const t of e) {
                                const e = t[o];
                                if (e) for (const t of e) i.push(t)
                            }
                        }
                    }
                    i.sort((e, t) => t.intersectionZ - e.intersectionZ);
                    const r = [];
                    for (let o = this._order.length - 1; o >= 0; o--) {
                        const a = this._order[o];
                        if (t(a)) for (let e = i.length - 1; e >= 0; e--) {
                            const t = i[e].feature;
                            if (n[t.layer.id] < o) break;
                            r.push(t), i.pop()
                        } else for (const t of e) {
                            const e = t[a];
                            if (e) for (const t of e) r.push(t.feature)
                        }
                    }
                    return r
                }

                queryRenderedFeatures(t, n, i) {
                    n && n.filter && this._validate(e.validateStyle.filter, "queryRenderedFeatures.filter", n.filter, null, n);
                    const r = {};
                    if (n && n.layers) {
                        if (!Array.isArray(n.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                        for (const t of n.layers) {
                            const n = this._layers[t];
                            if (!n) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];
                            r[n.source] = !0
                        }
                    }
                    const o = [];
                    n.availableImages = this._availableImages;
                    const a = n && n.layers ? n.layers.some(e => {
                        const t = this.getLayer(e);
                        return t && t.is3D()
                    }) : this.has3DLayers(), s = fe.createFromScreenPoints(t, i);
                    for (const e in this._sourceCaches) {
                        const t = this._sourceCaches[e].getSource().id;
                        n.layers && !r[t] || o.push(ke(this._sourceCaches[e], this._layers, this._serializedLayers, s, n, i, a, !!this.map._showQueryGeometry))
                    }
                    return this.placement && o.push(function (e, t, n, i, r, o, a) {
                        const s = {}, l = o.queryRenderedSymbols(i), c = [];
                        for (const e of Object.keys(l).map(Number)) c.push(a[e]);
                        c.sort(De);
                        for (const n of c) {
                            const i = n.featureIndex.lookupSymbolFeatures(l[n.bucketInstanceId], t, n.bucketIndex, n.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);
                            for (const e in i) {
                                const t = s[e] = s[e] || [], r = i[e];
                                r.sort((e, t) => {
                                    const i = n.featureSortOrder;
                                    if (i) {
                                        const n = i.indexOf(e.featureIndex);
                                        return i.indexOf(t.featureIndex) - n
                                    }
                                    return t.featureIndex - e.featureIndex
                                });
                                for (const e of r) t.push(e)
                            }
                        }
                        for (const t in s) s[t].forEach(i => {
                            const r = i.feature, o = n(e[t]).getFeatureState(r.layer["source-layer"], r.id);
                            r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = o
                        });
                        return s
                    }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s.screenGeometry, n, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o)
                }

                querySourceFeatures(t, n) {
                    n && n.filter && this._validate(e.validateStyle.filter, "querySourceFeatures.filter", n.filter, null, n);
                    const i = this._getSourceCaches(t);
                    let r = [];
                    for (const e of i) r = r.concat(Se(e, n));
                    return r
                }

                addSourceType(e, t, n) {
                    return jt.getSourceType(e) ? n(new Error(`A source type called "${e}" already exists.`)) : (jt.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                        name: e,
                        url: t.workerSourceURL
                    }, n) : n(null, null))
                }

                getLight() {
                    return this.light.getLight()
                }

                setLight(t, n = {}) {
                    this._checkLoaded();
                    const i = this.light.getLight();
                    let r = !1;
                    for (const e in t) if (!o(t[e], i[e])) {
                        r = !0;
                        break
                    }
                    if (!r) return;
                    const a = {
                        now: e.exported.now(),
                        transition: e.extend({duration: 300, delay: 0}, this.stylesheet.transition)
                    };
                    this.light.setLight(t, n), this.light.updateTransitions(a)
                }

                getTerrain() {
                    return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null
                }

                setTerrainForDraping() {
                    this.setTerrain({source: "", exaggeration: 0}, 0)
                }

                setTerrain(t, n = 1) {
                    if (this._checkLoaded(), !t) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                    if (1 === n) {
                        if ("object" == typeof t.source) {
                            const n = "terrain-dem-src";
                            this.addSource(n, t.source), t = e.clone$1(t), t = e.extend(t, {source: n})
                        }
                        if (this._validate(e.validateStyle.terrain, "terrain", t)) return
                    }
                    if (!this.terrain || this.terrain && n !== this.terrain.drapeRenderMode) this._createTerrain(t, n); else {
                        const n = this.terrain, i = n.get();
                        for (const r in t) if (!o(t[r], i[r])) {
                            n.set(t), this.stylesheet.terrain = t;
                            const i = {
                                now: e.exported.now(),
                                transition: e.extend({duration: 0}, this.stylesheet.transition)
                            };
                            n.updateTransitions(i);
                            break
                        }
                    }
                    this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0
                }

                _createFog(t) {
                    const n = this.fog = new T(t, this.map.transform);
                    this.stylesheet.fog = t;
                    const i = {now: e.exported.now(), transition: e.extend({duration: 0}, this.stylesheet.transition)};
                    n.updateTransitions(i)
                }

                _updateMarkersOpacity() {
                    0 !== this.map._markers.length && this.map._requestDomTask(() => {
                        for (const e of this.map._markers) e._evaluateOpacity()
                    })
                }

                getFog() {
                    return this.fog ? this.fog.get() : null
                }

                setFog(t) {
                    if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                    if (this.fog) {
                        const n = this.fog, i = n.get();
                        for (const r in t) if (!o(t[r], i[r])) {
                            n.set(t), this.stylesheet.fog = t;
                            const i = {
                                now: e.exported.now(),
                                transition: e.extend({duration: 0}, this.stylesheet.transition)
                            };
                            n.updateTransitions(i);
                            break
                        }
                    } else this._createFog(t);
                    this._markersNeedUpdate = !0
                }

                _updateDrapeFirstLayers() {
                    if (!this.map._optimizeForTerrain || !this.terrain) return;
                    const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),
                        t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));
                    this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t)
                }

                _createTerrain(t, n) {
                    const i = this.terrain = new v(t, n);
                    this.stylesheet.terrain = t, this.dispatcher.broadcast("enableTerrain", !0), this._force3DLayerUpdate();
                    const r = {now: e.exported.now(), transition: e.extend({duration: 0}, this.stylesheet.transition)};
                    i.updateTransitions(r)
                }

                _force3DLayerUpdate() {
                    for (const e in this._layers) {
                        const t = this._layers[e];
                        "fill-extrusion" === t.type && this._updateLayer(t)
                    }
                }

                _forceSymbolLayerUpdate() {
                    for (const e in this._layers) {
                        const t = this._layers[e];
                        "symbol" === t.type && this._updateLayer(t)
                    }
                }

                _validate(t, n, i, r, o = {}) {
                    return (!o || !1 !== o.validate) && Yt(this, t.call(e.validateStyle, e.extend({
                        key: n,
                        style: this.serialize(),
                        value: i,
                        styleSpec: e.spec
                    }, r)))
                }

                _remove() {
                    this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                    for (const e in this._layers) this._layers[e].setEventedParent(null);
                    for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);
                    this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove()
                }

                _clearSource(e) {
                    const t = this._getSourceCaches(e);
                    for (const e of t) e.clearTiles()
                }

                _reloadSource(e) {
                    const t = this._getSourceCaches(e);
                    for (const e of t) e.resume(), e.reload()
                }

                _updateSources(e) {
                    for (const t in this._sourceCaches) this._sourceCaches[t].update(e)
                }

                _generateCollisionBoxes() {
                    for (const e in this._sourceCaches) {
                        const t = this._sourceCaches[e];
                        t.resume(), t.reload()
                    }
                }

                _updatePlacement(t, n, i, r, o = !1) {
                    let a = !1, s = !1;
                    const l = {};
                    for (const e of this._order) {
                        const n = this._layers[e];
                        if ("symbol" !== n.type) continue;
                        if (!l[n.source]) {
                            const e = this._getLayerSourceCache(n);
                            if (!e) continue;
                            l[n.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1))
                        }
                        const i = this.crossTileSymbolIndex.addLayer(n, l[n.source], t.center.lng, t.projection);
                        a = a || i
                    }
                    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), o = o || this._layerOrderChanged || 0 === i, this._layerOrderChanged && this.fire(new e.Event("neworder")), (o || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new Et(t, this._order, o, n, i, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), s = !0), a && this.pauseablePlacement.placement.setStale()), s || a) for (const e of this._order) {
                        const t = this._layers[e];
                        "symbol" === t.type && this.placement.updateLayerOpacities(t, l[t.source])
                    }
                    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now())
                }

                _releaseSymbolFadeTiles() {
                    for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles()
                }

                getImages(e, t, n) {
                    this.imageManager.getImages(t.icons, n), this._updateTilesForChangedImages();
                    const i = e => {
                        e && e.setDependencies(t.tileID.key, t.type, t.icons)
                    };
                    i(this._otherSourceCaches[t.source]), i(this._symbolSourceCaches[t.source])
                }

                getGlyphs(e, t, n) {
                    this.glyphManager.getGlyphs(t.stacks, n)
                }

                getResource(t, n, i) {
                    return e.makeRequest(n, i)
                }

                _getSourceCache(e) {
                    return this._otherSourceCaches[e]
                }

                _getLayerSourceCache(e) {
                    return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source]
                }

                _getSourceCaches(e) {
                    const t = [];
                    return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t
                }

                has3DLayers() {
                    return this._num3DLayers > 0
                }

                hasSymbolLayers() {
                    return this._numSymbolLayers > 0
                }

                hasCircleLayers() {
                    return this._numCircleLayers > 0
                }

                _clearWorkerCaches() {
                    this.dispatcher.broadcast("clearCaches")
                }

                destroy() {
                    this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain)
                }
            }

            jt.getSourceType = function (e) {
                return we[e]
            }, jt.setSourceType = function (e, t) {
                we[e] = t
            }, jt.registerForPluginStateChange = e.registerForPluginStateChange;
            var Ht = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif",
                Nt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
            let Ut = {}, Wt = {};
            Ut = Zt("", "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", !0), Wt = Zt("#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", !0);
            const Vt = Zt("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef TERRAIN\nhighp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#endif", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#if defined(PROJECTION_GLOBE_VIEW) && !defined(PROJECTED_POS_ON_VIEWPORT)\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {\n#if defined(PROJECTION_GLOBE_VIEW) && !defined(PROJECTED_POS_ON_VIEWPORT)\nreturn mix(globe,mercator,t);\n#else\nreturn globe;\n#endif\n}\n#ifdef PROJECTION_GLOBE_VIEW\nmat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."),
                Gt = Ht;
            var qt = {
                background: Zt("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                backgroundPattern: Zt("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                circle: Zt("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec2 scaled_extrude=extrude*a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=scaled_extrude.x*surface_vectors[0]+scaled_extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\n#else \nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\n#if defined(SCALE_WITH_MAP) && defined(PROJECTION_GLOBE_VIEW)\nview_scale*=a_scale;\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
                clippingMask: Zt("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                heatmap: Zt("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nextrude*=a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                heatmapTexture: Zt("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
                collisionBox: Zt("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                collisionCircle: Zt("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                debug: Zt("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
                fill: Zt("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                fillOutline: Zt("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                fillOutlinePattern: Zt("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                fillPattern: Zt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                fillExtrusion: Zt("varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(pos.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                fillExtrusionPattern: Zt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\n#else\nvec3 p=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
                hillshadePrepare: Zt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                hillshade: Zt("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                line: Zt("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nvec4 out_color=texture2D(u_gradient_image,v_uv);\n#else\nvec4 out_color=color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#ifdef RENDER_LINE_GRADIENT\nattribute vec3 a_packed;\n#else\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];float a_linesofar=a_packed[2];highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                linePattern: Zt("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                raster: Zt("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                symbolIcon: Zt("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
                symbolSDF: Zt("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_tile_id;uniform float u_zoom_transition;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
                symbolTextAndIcon: Zt("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
                terrainRaster: Zt("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"),
                terrainDepth: Zt("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
                skybox: Zt("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Nt),
                skyboxGradient: Zt("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Nt),
                skyboxCapture: Zt("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
                globeRaster: Zt("uniform sampler2D u_image0;varying vec2 v_pos0;void main() {gl_FragColor=texture2D(u_image0,v_pos0);\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;attribute vec3 a_globe_pos;attribute vec2 a_merc_pos;attribute vec2 a_uv;varying vec2 v_pos0;const float wireframeOffset=1e3;void main() {v_pos0=a_uv;vec2 uv=a_uv*EXTENT;vec4 up_vector=vec4(elevationVector(uv),1.0);float height=elevation(uv);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nvec4 globe=u_globe_matrix*vec4(a_globe_pos+up_vector.xyz*height,1.0);vec4 mercator=vec4(0.0);if (u_zoom_transition > 0.0) {mercator=vec4(a_merc_pos,height,1.0);mercator.xy-=u_merc_center;mercator.x=wrap(mercator.x,-0.5,0.5);mercator=u_merc_matrix*mercator;}vec3 position=mix(globe.xyz,mercator.xyz,u_zoom_transition);gl_Position=u_proj_matrix*vec4(position,1.0);}"),
                globeAtmosphere: Zt("uniform vec2 u_center;uniform float u_radius;uniform vec2 u_screen_size;uniform float u_opacity;uniform highp float u_fadeout_range;uniform vec3 u_start_color;uniform vec3 u_end_color;uniform float u_pixel_ratio;void main() {highp vec2 fragCoord=gl_FragCoord.xy/u_pixel_ratio;fragCoord.y=u_screen_size.y-fragCoord.y;float distFromCenter=length(fragCoord-u_center);float normDistFromCenter=length(fragCoord-u_center)/u_radius;if (normDistFromCenter < 1.0)\ndiscard;float t=clamp(1.0-sqrt(normDistFromCenter-1.0)/u_fadeout_range,0.0,1.0);vec3 color=mix(u_start_color,u_end_color,1.0-t);gl_FragColor=vec4(color*t*u_opacity,u_opacity);}", "attribute vec3 a_pos;void main() {gl_Position=vec4(a_pos,1.0);}")
            };

            function Zt(e, t, n) {
                const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                    r = /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g,
                    o = t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), a = e.match(r), s = t.match(r),
                    l = Ht.match(r);
                let c = s ? s.concat(a) : a;
                n || (Ut.staticUniforms && (c = Ut.staticUniforms.concat(c)), Wt.staticUniforms && (c = Wt.staticUniforms.concat(c))), c && (c = c.concat(l));
                const u = {};
                return {
                    fragmentSource: e = e.replace(i, (e, t, n, i, r) => (u[r] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nvarying ${n} ${i} ${r};\n#else\nuniform ${n} ${i} u_${r};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${r}\n    ${n} ${i} ${r} = u_${r};\n#endif\n`)),
                    vertexSource: t = t.replace(i, (e, t, n, i, r) => {
                        const o = "float" === i ? "vec2" : "vec4", a = r.match(/color/) ? "color" : o;
                        return u[r] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nattribute ${n} ${o} a_${r};\nvarying ${n} ${i} ${r};\n#else\nuniform ${n} ${i} u_${r};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${n} ${i} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${n} ${i} ${r} = u_${r};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nattribute ${n} ${o} a_${r};\n#else\nuniform ${n} ${i} u_${r};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${n} ${i} ${r} = a_${r};\n#else\n    ${n} ${i} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${n} ${i} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${n} ${i} ${r} = u_${r};\n#endif\n`
                    }),
                    staticAttributes: o,
                    staticUniforms: c
                }
            }

            class $t {
                constructor() {
                    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
                }

                bind(e, t, n, i, r, o, a, s) {
                    this.context = e;
                    let l = this.boundPaintVertexBuffers.length !== i.length;
                    for (let e = 0; !l && e < i.length; e++) this.boundPaintVertexBuffers[e] !== i[e] && (l = !0);
                    e.extVertexArrayObject && this.vao && this.boundProgram === t && this.boundLayoutVertexBuffer === n && !l && this.boundIndexBuffer === r && this.boundVertexOffset === o && this.boundDynamicVertexBuffer === a && this.boundDynamicVertexBuffer2 === s ? (e.bindVertexArrayOES.set(this.vao), a && a.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(t, n, i, r, o, a, s)
                }

                freshBind(e, t, n, i, r, o, a) {
                    let s;
                    const l = e.numAttributes, c = this.context, u = c.gl;
                    if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = i, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = a; else {
                        s = c.currentNumAttributes || 0;
                        for (let e = l; e < s; e++) u.disableVertexAttribArray(e)
                    }
                    t.enableAttributes(u, e);
                    for (const t of n) t.enableAttributes(u, e);
                    o && o.enableAttributes(u, e), a && a.enableAttributes(u, e), t.bind(), t.setVertexAttribPointers(u, e, r);
                    for (const t of n) t.bind(), t.setVertexAttribPointers(u, e, r);
                    o && (o.bind(), o.setVertexAttribPointers(u, e, r)), i && i.bind(), a && (a.bind(), a.setVertexAttribPointers(u, e, r)), c.currentNumAttributes = l
                }

                destroy() {
                    this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null)
                }
            }

            function Xt(t, n) {
                const i = Math.pow(2, n.canonical.z), r = n.canonical.y;
                return [new e.MercatorCoordinate(0, r / i).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / i).toLngLat().lat]
            }

            function Jt(t, n, i, r, o, a, s) {
                const l = t.context, c = l.gl, u = i.fbo;
                if (!u) return;
                t.prepareDrawTile(n);
                const d = t.useProgram("hillshade");
                l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, u.colorAttachment.get());
                const h = ((e, t, n, i) => {
                    const r = n.paint.get("hillshade-shadow-color"), o = n.paint.get("hillshade-highlight-color"),
                        a = n.paint.get("hillshade-accent-color");
                    let s = n.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                    "viewport" === n.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);
                    const l = !e.options.moving;
                    return {
                        u_matrix: i || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l),
                        u_image: 0,
                        u_latrange: Xt(0, t.tileID),
                        u_light: [n.paint.get("hillshade-exaggeration"), s],
                        u_shadow: r,
                        u_highlight: o,
                        u_accent: a
                    }
                })(t, i, r, t.terrain ? n.projMatrix : null);
                t.prepareDrawProgram(l, d, n.toUnwrapped());
                const {
                    tileBoundsBuffer: p,
                    tileBoundsIndexBuffer: f,
                    tileBoundsSegments: m
                } = t.getTileBoundsBuffers(i);
                d.draw(l, c.TRIANGLES, o, a, s, e.CullFaceMode.disabled, h, r.id, p, f, m)
            }

            function Kt(t, n, i) {
                if (!n.needsDEMTextureUpload) return;
                const r = t.context, o = r.gl;
                r.pixelStoreUnpackPremultiplyAlpha.set(!1), n.demTexture = n.demTexture || t.getTileTexture(i.stride);
                const a = i.getPixels();
                n.demTexture ? n.demTexture.update(a, {premultiply: !1}) : n.demTexture = new e.Texture(r, a, o.RGBA, {premultiply: !1}), n.needsDEMTextureUpload = !1
            }

            function Qt(t, n, i, r, o, a) {
                const s = t.context, l = s.gl;
                if (!n.dem) return;
                const c = n.dem;
                if (s.activeTexture.set(l.TEXTURE1), Kt(t, n, c), !n.demTexture) return;
                n.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
                const u = c.dim;
                s.activeTexture.set(l.TEXTURE0);
                let d = n.fbo;
                if (!d) {
                    const t = new e.Texture(s, {width: u, height: u, data: null}, l.RGBA);
                    t.bind(l.LINEAR, l.CLAMP_TO_EDGE), d = n.fbo = s.createFramebuffer(u, u, !0), d.colorAttachment.set(t.texture)
                }
                s.bindFramebuffer.set(d.framebuffer), s.viewport.set([0, 0, u, u]);
                const {
                    tileBoundsBuffer: h,
                    tileBoundsIndexBuffer: p,
                    tileBoundsSegments: f
                } = t.getMercatorTileBoundsBuffers();
                t.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, r, o, a, e.CullFaceMode.disabled, ((t, n) => {
                    const i = n.stride, r = e.create();
                    return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), {
                        u_matrix: r,
                        u_image: 1,
                        u_dimension: [i, i],
                        u_zoom: t.overscaledZ,
                        u_unpack: n.unpackVector
                    }
                })(n.tileID, c), i.id, h, p, f), n.needsHillshadePrepare = !1
            }

            const en = (t, n) => ({
                u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                u_image0: new e.Uniform1i(t, n.u_image0),
                u_skirt_height: new e.Uniform1f(t, n.u_skirt_height)
            }), tn = (e, t) => ({u_matrix: e, u_image0: 0, u_skirt_height: t}), nn = (e, t, n, i, r) => ({
                u_proj_matrix: Float32Array.from(e),
                u_globe_matrix: t,
                u_merc_matrix: n,
                u_zoom_transition: i,
                u_merc_center: r,
                u_image0: 0
            });

            function rn(e, t) {
                return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key
            }

            const on = new class {
                constructor() {
                    this.operations = {}
                }

                newMorphing(e, t, n, i, r) {
                    if (e in this.operations) {
                        const t = this.operations[e];
                        t.to.tileID.key !== n.tileID.key && (t.queued = n)
                    } else this.operations[e] = {startTime: i, phase: 0, duration: r, from: t, to: n, queued: null}
                }

                getMorphValuesForProxy(e) {
                    if (!(e in this.operations)) return null;
                    const t = this.operations[e];
                    return {from: t.from, to: t.to, phase: t.phase}
                }

                update(e) {
                    for (const t in this.operations) {
                        const n = this.operations[t];
                        for (n.phase = (e - n.startTime) / n.duration; n.phase >= 1 || !this._validOp(n);) if (!this._nextOp(n, e)) {
                            delete this.operations[t];
                            break
                        }
                    }
                }

                _nextOp(e, t) {
                    return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0)
                }

                _validOp(e) {
                    return e.from.hasData() && e.to.hasData()
                }
            }, an = {0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME"};

            function sn(e, t) {
                const n = 1 << e.z;
                return !t && (0 === e.x || e.x === n - 1) || 0 === e.y || e.y === n - 1
            }

            const ln = e => ({u_matrix: e});

            function cn(t, n, i, r, o) {
                if (o > 0) {
                    const a = e.exported.now(), s = (a - t.timeAdded) / o, l = n ? (a - n.timeAdded) / o : -1,
                        c = i.getSource(), u = r.coveringZoomLevel({tileSize: c.tileSize, roundZoom: c.roundZoom}),
                        d = !n || Math.abs(n.tileID.overscaledZ - u) > Math.abs(t.tileID.overscaledZ - u),
                        h = d && t.refreshedUponExpiration ? 1 : e.clamp(d ? s : 1 - l, 0, 1);
                    return t.refreshedUponExpiration && s >= 1 && (t.refreshedUponExpiration = !1), n ? {
                        opacity: 1,
                        mix: 1 - h
                    } : {opacity: h, mix: 0}
                }
                return {opacity: 1, mix: 0}
            }

            class un extends e.SourceCache {
                constructor(e) {
                    const t = {type: "raster-dem", maxzoom: e.transform.maxZoom}, n = new k(Ie(), null),
                        i = Me("mock-dem", t, n, e.style);
                    super("mock-dem", i, !1), i.setEventedParent(this), this._sourceLoaded = !0
                }

                _loadTile(e, t) {
                    e.state = "loaded", t(null)
                }
            }

            class dn extends e.SourceCache {
                constructor(e) {
                    const t = Me("proxy", {type: "geojson", maxzoom: e.transform.maxZoom}, new k(Ie(), null), e.style);
                    super("proxy", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}
                }

                update(t, n, i) {
                    if (t.freezeTileCoverage) return;
                    this.transform = t;
                    const r = t.coveringTiles({
                        tileSize: this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom,
                        reparseOverscaled: this._source.reparseOverscaled
                    }).reduce((n, i) => {
                        if (n[i.key] = "", !this._tiles[i.key]) {
                            const n = new e.Tile(i, this._source.tileSize * i.overscaleFactor(), t.tileZoom);
                            n.state = "loaded", this._tiles[i.key] = n
                        }
                        return n
                    }, {});
                    for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e])
                }

                freeFBO(e) {
                    const t = this.proxyCachedFBO[e];
                    if (void 0 !== t) {
                        const n = Object.values(t);
                        this.renderCachePool.push(...n), delete this.proxyCachedFBO[e]
                    }
                }

                deallocRenderCache() {
                    this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}
                }
            }

            class hn extends e.OverscaledTileID {
                constructor(e, t, n) {
                    super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = n
                }
            }

            class pn extends e.Elevation {
                constructor(t, n) {
                    super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                    const [i, r, o] = function (t) {
                        const n = new e.StructArrayLayout4i8, i = new e.StructArrayLayout3ui6, r = 131;
                        n.reserve(17161), i.reserve(33800);
                        const o = e.EXTENT / 128, a = e.EXTENT + o / 2, s = a + o;
                        for (let t = -o; t < s; t += o) for (let i = -o; i < s; i += o) {
                            const r = i < 0 || i > a || t < 0 || t > a ? 24575 : 0,
                                o = e.clamp(Math.round(i), 0, e.EXTENT), s = e.clamp(Math.round(t), 0, e.EXTENT);
                            n.emplaceBack(o + r, s, o, s)
                        }
                        const l = (e, t) => {
                            const n = t * r + e;
                            i.emplaceBack(n + 1, n, n + r), i.emplaceBack(n + r, n + r + 1, n + 1)
                        };
                        for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);
                        return [0, 129].forEach(e => {
                            for (let t = 0; t < 130; t++) l(t, e), l(e, t)
                        }), [n, i, 32768]
                    }(), a = t.context;
                    this.gridBuffer = a.createVertexBuffer(i, e.boundsAttributes.members), this.gridIndexBuffer = a.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, i.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, i.length, o), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new dn(n.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, 0, e.EXTENT, 0, e.EXTENT, 0, 1);
                    const s = a.gl;
                    this._overlapStencilMode = new e.StencilMode({
                        func: s.GEQUAL,
                        mask: 255
                    }, 0, 255, s.KEEP, s.KEEP, s.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = n, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new un(n.map)
                }

                set style(e) {
                    e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency()
                }

                update(t, n, i) {
                    if (t && t.terrain) {
                        this._style !== t && (this.style = t), this.enabled = !0;
                        const r = t.terrain.properties;
                        this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");
                        const o = () => {
                            this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                            const t = this.getScaledDemTileSize();
                            this.sourceCache.update(n, t, !0), this.resetTileLookupCache(this.sourceCache.id)
                        };
                        this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, o(), this._initializing = !0), o(), n.updateElevation(!i), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(n), this._emptyDEMTextureDirty = !0
                    } else this._disable()
                }

                resetTileLookupCache(e) {
                    this._findCoveringTileCache[e] = {}
                }

                getScaledDemTileSize() {
                    return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
                }

                _checkRenderCacheEfficiency() {
                    const t = this.renderCacheEfficiency(this._style);
                    this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`)
                }

                _onStyleDataEvent(e) {
                    e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0)
                }

                _disable() {
                    if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1
                }

                destroy() {
                    this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture)
                }

                _source() {
                    return this.enabled ? this.sourceCache : null
                }

                exaggeration() {
                    return this._exaggeration
                }

                get visibleDemTiles() {
                    return this._visibleDemTiles
                }

                get drapeBufferSize() {
                    const e = 2 * this.proxySourceCache.getSource().tileSize;
                    return [e, e]
                }

                set useVertexMorphing(e) {
                    this._useVertexMorphing = e
                }

                updateTileBinding(t) {
                    if (!this.enabled) return;
                    this.prevTerrainTileForTile = this.terrainTileForTile;
                    const n = this.proxySourceCache, i = this.painter.transform;
                    this._initializing && (this._initializing = 0 === i._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(i.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                    const r = this.proxyCoords = n.getIds().map(e => {
                        const t = n.getTileByID(e).tileID;
                        return t.projMatrix = i.calculateProjMatrix(t.toUnwrapped()), t
                    });
                    !function (t, n) {
                        const i = n.transform.pointCoordinate(n.transform.getCameraPoint()),
                            r = new e.pointGeometry(i.x, i.y);
                        t.sort((t, n) => {
                            if (n.overscaledZ - t.overscaledZ) return n.overscaledZ - t.overscaledZ;
                            const i = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),
                                o = new e.pointGeometry(n.canonical.x + (1 << n.canonical.z) * n.wrap, n.canonical.y),
                                a = r.mult(1 << t.canonical.z);
                            return a.x -= .5, a.y -= .5, a.distSqr(i) - a.distSqr(o)
                        })
                    }(r, this.painter), this._previousZoom = i.zoom;
                    const o = this.proxyToSource || {};
                    this.proxyToSource = {}, r.forEach(e => {
                        this.proxyToSource[e.key] = {}
                    }), this.terrainTileForTile = {};
                    const a = this._style._sourceCaches;
                    for (const e in a) {
                        const n = a[e];
                        if (!n.used) continue;
                        if (n !== this.sourceCache && this.resetTileLookupCache(n.id), this._setupProxiedCoordsForOrtho(n, t[e], o), n.usedForTerrain) continue;
                        const i = t[e];
                        n.getSource().reparseOverscaled && this._assignTerrainTiles(i)
                    }
                    this.proxiedCoords[n.id] = r.map(e => new hn(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(o), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();
                    const s = {};
                    this._visibleDemTiles = [];
                    for (const e of this.proxyCoords) {
                        const t = this.terrainTileForTile[e.key];
                        if (!t) continue;
                        const n = t.tileID.key;
                        n in s || (this._visibleDemTiles.push(t), s[n] = n)
                    }
                }

                _assignTerrainTiles(e) {
                    this._initializing || e.forEach(e => {
                        if (this.terrainTileForTile[e.key]) return;
                        const t = this._findTileCoveringTileID(e, this.sourceCache);
                        t && (this.terrainTileForTile[e.key] = t)
                    })
                }

                _prepareDEMTextures() {
                    const e = this.painter.context, t = e.gl;
                    for (const n in this.terrainTileForTile) {
                        const i = this.terrainTileForTile[n], r = i.dem;
                        !r || i.demTexture && !i.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), Kt(this.painter, i, r))
                    }
                }

                _prepareDemTileUniforms(e, t, n, i) {
                    if (!t || null == t.demTexture) return !1;
                    const r = e.tileID.canonical, o = Math.pow(2, t.tileID.canonical.z - r.z), a = i || "";
                    return n["u_dem_tl" + a] = [r.x * o % 1, r.y * o % 1], n["u_dem_scale" + a] = o, !0
                }

                get emptyDEMTexture() {
                    return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
                }

                get emptyDepthBufferTexture() {
                    const t = this.painter.context, n = t.gl;
                    if (!this._emptyDepthBufferTexture) {
                        const i = {width: 1, height: 1, data: new Uint8Array([255, 255, 255, 255])};
                        this._emptyDepthBufferTexture = new e.Texture(t, i, n.RGBA, {premultiply: !1})
                    }
                    return this._emptyDepthBufferTexture
                }

                _getLoadedAreaMinimum() {
                    let e = 0;
                    const t = this._visibleDemTiles.reduce((t, n) => {
                        if (!n.dem) return t;
                        const i = n.dem.tree.minimums[0];
                        return i > 0 && e++, t + i
                    }, 0);
                    return e ? t / e : 0
                }

                _updateEmptyDEMTexture() {
                    const t = this.painter.context, n = t.gl;
                    t.activeTexture.set(n.TEXTURE2);
                    const i = this._getLoadedAreaMinimum(), r = {
                        width: 1,
                        height: 1,
                        data: new Uint8Array(e.DEMData.pack(i, this.sourceCache.getSource().encoding))
                    };
                    this._emptyDEMTextureDirty = !1;
                    let o = this._emptyDEMTexture;
                    return o ? o.update(r, {premultiply: !1}) : o = this._emptyDEMTexture = new e.Texture(t, r, n.RGBA, {premultiply: !1}), o
                }

                setupElevationDraw(t, n, i) {
                    const r = this.painter.context, o = r.gl, a = (s = this.sourceCache.getSource().encoding, {
                        u_dem: 2,
                        u_dem_prev: 4,
                        u_dem_unpack: e.DEMData.getUnpackVector(s),
                        u_dem_tl: [0, 0],
                        u_dem_tl_prev: [0, 0],
                        u_dem_scale: 0,
                        u_dem_scale_prev: 0,
                        u_dem_size: 0,
                        u_dem_lerp: 1,
                        u_depth: 3,
                        u_depth_size_inv: [0, 0],
                        u_exaggeration: 0,
                        u_tile_tl_up: [0, 0, 1],
                        u_tile_tr_up: [0, 0, 1],
                        u_tile_br_up: [0, 0, 1],
                        u_tile_bl_up: [0, 0, 1],
                        u_tile_up_scale: 1
                    });
                    var s;
                    a.u_dem_size = this.sourceCache.getSource().tileSize, a.u_exaggeration = this.exaggeration();
                    const l = this.painter.transform, c = l.projection.createTileTransform(l, l.worldSize),
                        u = t.tileID.canonical;
                    a.u_tile_tl_up = c.upVector(u, 0, 0), a.u_tile_tr_up = c.upVector(u, e.EXTENT, 0), a.u_tile_br_up = c.upVector(u, e.EXTENT, e.EXTENT), a.u_tile_bl_up = c.upVector(u, 0, e.EXTENT), a.u_tile_up_scale = c.upVectorScale(u);
                    let d = null, h = null, p = 1;
                    if (i && i.morphing && this._useVertexMorphing) {
                        const e = i.morphing.srcDemTile, n = i.morphing.dstDemTile;
                        p = i.morphing.phase, e && n && (this._prepareDemTileUniforms(t, e, a, "_prev") && (h = e), this._prepareDemTileUniforms(t, n, a) && (d = n))
                    }
                    if (h && d ? (r.activeTexture.set(o.TEXTURE2), d.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST), r.activeTexture.set(o.TEXTURE4), h.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST), a.u_dem_lerp = p) : (d = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(o.TEXTURE2), (this._prepareDemTileUniforms(t, d, a) ? d.demTexture : this.emptyDEMTexture).bind(o.NEAREST, o.CLAMP_TO_EDGE)), r.activeTexture.set(o.TEXTURE3), i && i.useDepthForOcclusion ? (this._depthTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), a.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height]) : (this.emptyDepthBufferTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), a.u_depth_size_inv = [1, 1]), i && i.useMeterToDem && d) {
                        const t = (1 << d.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                        a.u_meter_to_dem = t
                    }
                    i && i.labelPlaneMatrixInv && (a.u_label_plane_matrix_inv = i.labelPlaneMatrixInv), n.setTerrainUniformValues(r, a)
                }

                renderToBackBuffer(t) {
                    const n = this.painter, i = this.painter.context;
                    0 !== t.length && (i.bindFramebuffer.set(null), i.viewport.set([0, 0, n.width, n.height]), this.renderingToTexture = !1, function (t, n, i, r, o) {
                        if ("globe" === t.transform.projection.name) !function (t, n, i, r, o) {
                            const a = t.context, s = a.gl;
                            let l, c;
                            const u = t.options.showTerrainWireframe ? 2 : 0, d = (e, n) => {
                                    if (c === e) return;
                                    const i = [];
                                    n && i.push(an[u]), i.push(an[e]), i.push("PROJECTION_GLOBE_VIEW"), l = t.useProgram("globeRaster", null, i), c = e
                                }, h = t.colorModeForRenderPass(),
                                p = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
                            on.update(o);
                            const f = t.transform, m = e.calculateGlobeMatrix(f, f.worldSize),
                                _ = e.calculateGlobeMercatorMatrix(f),
                                g = [e.mercatorXfromLng(f.center.lng), e.mercatorYfromLat(f.center.lat)],
                                y = t.globeSharedBuffers;
                            (u ? [!1, !0] : [!1]).forEach(u => {
                                c = -1;
                                const v = u ? s.LINES : s.TRIANGLES;
                                for (const c of r) {
                                    const r = i.getTile(c),
                                        x = Math.pow(2, c.canonical.z), [b, w] = e.globeBuffersForTileMesh(t, r, c, x),
                                        M = e.StencilMode.disabled, T = n.prevTerrainTileForTile[c.key],
                                        k = n.terrainTileForTile[c.key];
                                    rn(T, k) && on.newMorphing(c.key, T, k, o, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                                    const S = on.getMorphValuesForProxy(c.key), D = S ? 1 : 0, L = {};
                                    S && e.extend$1(L, {
                                        morphing: {
                                            srcDemTile: S.from,
                                            dstDemTile: S.to,
                                            phase: e.easeCubicInOut(S.phase)
                                        }
                                    });
                                    const E = e.globeMatrixForTile(c.canonical, m),
                                        C = nn(f.projMatrix, E, _, e.globeToMercatorTransition(f.zoom), g);
                                    if (d(D, u), n.setupElevationDraw(r, l, L), t.prepareDrawProgram(a, l, c.toUnwrapped()), y) {
                                        const [n, i] = u ? y.getWirefameBuffer(t.context) : [y.gridIndexBuffer, y.gridSegments];
                                        l.draw(a, v, p, M, h, e.CullFaceMode.backCCW, C, "globe_raster", b, n, i)
                                    }
                                    if (!u) {
                                        const t = [0 === c.canonical.y ? e.globePoleMatrixForTile(c.canonical, !1, f) : null, c.canonical.y === x - 1 ? e.globePoleMatrixForTile(c.canonical, !0, f) : null];
                                        for (const n of t) {
                                            if (!n) continue;
                                            const t = nn(f.projMatrix, n, n, 0, g);
                                            y && l.draw(a, v, p, M, h, e.CullFaceMode.disabled, t, "globe_pole_raster", w, y.poleIndexBuffer, y.poleSegments)
                                        }
                                    }
                                }
                            })
                        }(t, n, i, r, o); else {
                            const a = t.context, s = a.gl;
                            let l, c;
                            const u = t.options.showTerrainWireframe ? 2 : 0, d = (e, n) => {
                                    if (c === e) return;
                                    const i = [an[e]];
                                    n && i.push(an[u]), l = t.useProgram("terrainRaster", null, i), c = e
                                }, h = t.colorModeForRenderPass(),
                                p = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
                            on.update(o);
                            const f = t.transform, m = 6 * Math.pow(1.5, 22 - f.zoom) * n.exaggeration();
                            (u ? [!1, !0] : [!1]).forEach(u => {
                                c = -1;
                                const _ = u ? s.LINES : s.TRIANGLES, [g, y] = u ? n.getWirefameBuffer() : [n.gridIndexBuffer, n.gridSegments];
                                for (const c of r) {
                                    const r = i.getTile(c), v = e.StencilMode.disabled,
                                        x = n.prevTerrainTileForTile[c.key], b = n.terrainTileForTile[c.key];
                                    rn(x, b) && on.newMorphing(c.key, x, b, o, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST);
                                    const w = on.getMorphValuesForProxy(c.key), M = w ? 1 : 0;
                                    let T;
                                    w && (T = {
                                        morphing: {
                                            srcDemTile: w.from,
                                            dstDemTile: w.to,
                                            phase: e.easeCubicInOut(w.phase)
                                        }
                                    });
                                    const k = tn(c.projMatrix, sn(c.canonical, f.renderWorldCopies) ? m / 10 : m);
                                    d(M, u), n.setupElevationDraw(r, l, T), t.prepareDrawProgram(a, l, c.toUnwrapped()), l.draw(a, _, p, v, h, e.CullFaceMode.backCCW, k, "terrain_raster", n.gridBuffer, g, y)
                                }
                            })
                        }
                    }(n, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, t.splice(0, t.length))
                }

                renderBatch(t) {
                    if (0 === this._drapedRenderBatches.length) return t + 1;
                    this.renderingToTexture = !0;
                    const n = this.painter, i = this.painter.context, r = this.proxySourceCache,
                        o = this.proxiedCoords[r.id], a = this._drapedRenderBatches.shift(), s = [], l = n.style.order;
                    let c = 0;
                    for (const u of o) {
                        const o = r.getTileByID(u.proxyTileKey),
                            d = r.proxyCachedFBO[u.key] ? r.proxyCachedFBO[u.key][t] : void 0,
                            h = void 0 !== d ? r.renderCache[d] : this.pool[c++], p = void 0 !== d;
                        if (o.texture = h.tex, p && !h.dirty) {
                            s.push(o.tileID);
                            continue
                        }
                        let f;
                        i.bindFramebuffer.set(h.fb.framebuffer), this.renderedToTile = !1, h.dirty && (i.clear({
                            color: e.Color.transparent,
                            stencil: 0
                        }), h.dirty = !1);
                        for (let e = a.start; e <= a.end; ++e) {
                            const t = n.style._layers[l[e]];
                            if (t.isHidden(n.transform.zoom)) continue;
                            const r = n.style._getLayerSourceCache(t), o = r ? this.proxyToSource[u.key][r.id] : [u];
                            if (!o) continue;
                            const a = o;
                            i.viewport.set([0, 0, h.fb.width, h.fb.height]), f !== (r ? r.id : null) && (this._setupStencil(h, o, t, r), f = r ? r.id : null), n.renderLayer(n, r, t, a)
                        }
                        this.renderedToTile ? (h.dirty = !0, s.push(o.tileID)) : p || --c, 5 === c && (c = 0, this.renderToBackBuffer(s))
                    }
                    return this.renderToBackBuffer(s), this.renderingToTexture = !1, i.bindFramebuffer.set(null), i.viewport.set([0, 0, n.width, n.height]), a.end + 1
                }

                postRender() {
                }

                renderCacheEfficiency(e) {
                    const t = e.order.length;
                    if (0 === t) return {efficiency: 100};
                    let n, i = 0, r = 0, o = !1;
                    for (let a = 0; a < t; ++a) {
                        const t = e._layers[e.order[a]];
                        this._style.isLayerDraped(t) ? (o && ++i, ++r) : o || (o = !0, n = t.id)
                    }
                    return 0 === r ? {efficiency: 100} : {efficiency: 100 * (1 - i / r), firstUndrapedLayer: n}
                }

                getMinElevationBelowMSL() {
                    let e = 0;
                    return this._visibleDemTiles.filter(e => e.dem).forEach(t => {
                        e = Math.min(e, t.dem.tree.minimums[0])
                    }), 0 === e ? e : (e - 30) * this._exaggeration
                }

                raycast(e, t, n) {
                    if (!this._visibleDemTiles) return null;
                    const i = this._visibleDemTiles.filter(e => e.dem).map(i => {
                        const r = i.tileID, o = Math.pow(2, r.overscaledZ), {x: a, y: s} = r.canonical, l = a / o,
                            c = (a + 1) / o, u = s / o, d = (s + 1) / o;
                        return {
                            minx: l,
                            miny: u,
                            maxx: c,
                            maxy: d,
                            t: i.dem.tree.raycastRoot(l, u, c, d, e, t, n),
                            tile: i
                        }
                    });
                    i.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));
                    for (const r of i) {
                        if (null == r.t) return null;
                        const i = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, n);
                        if (null != i) return i
                    }
                    return null
                }

                _createFBO() {
                    const t = this.painter.context, n = t.gl, i = this.drapeBufferSize;
                    t.activeTexture.set(n.TEXTURE0);
                    const r = new e.Texture(t, {width: i[0], height: i[1], data: null}, n.RGBA);
                    r.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                    const o = t.createFramebuffer(i[0], i[1], !1);
                    return o.colorAttachment.set(r.texture), o.depthAttachment = new de(t, o.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, i[0], i[1]), this._stencilRef = 0, o.depthAttachment.set(this._sharedDepthStencil), t.clear({stencil: 0})) : o.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && n.texParameterf(n.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {
                        fb: o,
                        tex: r,
                        dirty: !1
                    }
                }

                _initFBOPool() {
                    for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO())
                }

                _shouldDisableRenderCache() {
                    if (this._style.light && this._style.light.hasTransition()) return !0;
                    for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;
                    return this._style.order.some(e => {
                        const t = this._style._layers[e], n = t.isHidden(this.painter.transform.zoom),
                            i = t.getCrossfadeParameters(), r = !!i && 1 !== i.t, o = t.hasTransition();
                        return "custom" !== t.type && !n && (r || o)
                    })
                }

                _clearRasterFadeFromRenderCache() {
                    let e = !1;
                    for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof ye) {
                        e = !0;
                        break
                    }
                    if (e) for (let e = 0; e < this._style.order.length; ++e) {
                        const t = this._style._layers[this._style.order[e]],
                            n = t.isHidden(this.painter.transform.zoom), i = this._style._getLayerSourceCache(t);
                        if ("raster" !== t.type || n || !i) continue;
                        const r = t.paint.get("raster-fade-duration");
                        for (const e of this.proxyCoords) {
                            const t = this.proxyToSource[e.key][i.id];
                            if (t) for (const e of t) {
                                const t = cn(i.getTile(e), i.findLoadedParent(e, 0), i, this.painter.transform, r);
                                (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(i.id, e)
                            }
                        }
                    }
                }

                _setupDrapedRenderBatches() {
                    const e = this._style.order, t = e.length;
                    if (0 === t) return;
                    const n = [];
                    let i, r = 0, o = this._style._layers[e[r]];
                    for (; !this._style.isLayerDraped(o) && o.isHidden(this.painter.transform.zoom) && ++r < t;) o = this._style._layers[e[r]];
                    for (; r < t; ++r) {
                        const t = this._style._layers[e[r]];
                        t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === i && (i = r) : void 0 !== i && (n.push({
                            start: i,
                            end: r - 1
                        }), i = void 0))
                    }
                    void 0 !== i && n.push({start: i, end: r - 1}), this._drapedRenderBatches = n
                }

                _setupRenderCache(e) {
                    const t = this.proxySourceCache;
                    if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                        if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {
                            const e = Object.values(t.proxyCachedFBO);
                            t.proxyCachedFBO = {};
                            for (let n = 0; n < e.length; ++n) {
                                const i = Object.values(e[n]);
                                t.renderCachePool.push(...i)
                            }
                        }
                        return
                    }
                    this._clearRasterFadeFromRenderCache();
                    const n = this.proxyCoords, i = this._tilesDirty;
                    for (let r = n.length - 1; r >= 0; r--) {
                        const o = n[r];
                        if (t.getTileByID(o.key), void 0 !== t.proxyCachedFBO[o.key]) {
                            const n = e[o.key], r = this.proxyToSource[o.key];
                            let a = 0;
                            for (const e in r) {
                                const t = r[e], o = n[e];
                                if (!o || o.length !== t.length || t.some((t, n) => t !== o[n] || i[e] && i[e].hasOwnProperty(t.key))) {
                                    a = -1;
                                    break
                                }
                                ++a
                            }
                            for (const e in t.proxyCachedFBO[o.key]) t.renderCache[t.proxyCachedFBO[o.key][e]].dirty = a < 0 || a !== Object.values(n).length
                        }
                    }
                    const r = [...this._drapedRenderBatches];
                    r.sort((e, t) => t.end - t.start - (e.end - e.start));
                    for (const e of r) for (const i of n) {
                        if (t.proxyCachedFBO[i.key]) continue;
                        let n = t.renderCachePool.pop();
                        void 0 === n && t.renderCache.length < 50 && (n = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== n && (t.proxyCachedFBO[i.key] = {}, t.proxyCachedFBO[i.key][e.start] = n, t.renderCache[n].dirty = !0)
                    }
                    this._tilesDirty = {}
                }

                _setupStencil(e, t, n, i) {
                    if (!i || !this._sourceTilesOverlap[i.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                    const r = this.painter.context, o = r.gl;
                    if (t.length <= 1) return void (this._overlapStencilType = !1);
                    let a;
                    if (n.isTileClipped()) a = t.length, this._overlapStencilMode.test = {
                        func: o.EQUAL,
                        mask: 255
                    }, this._overlapStencilType = "Clip"; else {
                        if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                        a = 1, this._overlapStencilMode.test = {
                            func: o.GREATER,
                            mask: 255
                        }, this._overlapStencilType = "Mask"
                    }
                    this._stencilRef + a > 255 && (r.clear({stencil: 0}), this._stencilRef = 0), this._stencilRef += a, this._overlapStencilMode.ref = this._stencilRef, n.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref)
                }

                clipOrMaskOverlapStencilType() {
                    return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType
                }

                stencilModeForRTTOverlap(t) {
                    return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e.StencilMode.disabled
                }

                _renderTileClippingMasks(t, n) {
                    const i = this.painter, r = this.painter.context, o = r.gl;
                    i._tileClippingMaskIDs = {}, r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
                    const a = i.useProgram("clippingMask");
                    for (const s of t) {
                        const t = i._tileClippingMaskIDs[s.key] = --n;
                        a.draw(r, o.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
                            func: o.ALWAYS,
                            mask: 0
                        }, t, 255, o.KEEP, o.KEEP, o.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, ln(s.projMatrix), "$clipping", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments)
                    }
                }

                pointCoordinate(t) {
                    const n = this.painter.transform;
                    if (t.x < 0 || t.x > n.width || t.y < 0 || t.y > n.height) return null;
                    const i = [t.x, t.y, 1, 1];
                    e.transformMat4$1(i, i, n.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), i[0] /= n.worldSize, i[1] /= n.worldSize;
                    const r = n._camera.position, o = e.mercatorZfromAltitude(1, n.center.lat),
                        a = [r[0], r[1], r[2] / o, 0], s = e.subtract([], i.slice(0, 3), a);
                    e.normalize(s, s);
                    const l = this.raycast(a, s, this._exaggeration);
                    return null !== l && l ? (e.scaleAndAdd(a, a, s, l), a[3] = a[2], a[2] *= o, a) : null
                }

                drawDepth() {
                    const t = this.painter, n = t.context, i = this.proxySourceCache, r = Math.ceil(t.width),
                        o = Math.ceil(t.height);
                    if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === o || (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture), !this._depthFBO) {
                        const t = n.gl, i = n.createFramebuffer(r, o, !0);
                        n.activeTexture.set(t.TEXTURE0);
                        const a = new e.Texture(n, {width: r, height: o, data: null}, t.RGBA);
                        a.bind(t.NEAREST, t.CLAMP_TO_EDGE), i.colorAttachment.set(a.texture);
                        const s = n.createRenderbuffer(n.gl.DEPTH_COMPONENT16, r, o);
                        i.depthAttachment.set(s), this._depthFBO = i, this._depthTexture = a
                    }
                    n.bindFramebuffer.set(this._depthFBO.framebuffer), n.viewport.set([0, 0, r, o]), function (t, n, i, r) {
                        if ("globe" === t.transform.projection.name) return;
                        const o = t.context, a = o.gl;
                        o.clear({depth: 1});
                        const s = t.useProgram("terrainDepth"),
                            l = new e.DepthMode(a.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);
                        for (const t of r) {
                            const r = i.getTile(t), c = tn(t.projMatrix, 0);
                            n.setupElevationDraw(r, s), s.draw(o, a.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, "terrain_depth", n.gridBuffer, n.gridIndexBuffer, n.gridNoSkirtSegments)
                        }
                    }(t, this, i, this.proxyCoords)
                }

                _setupProxiedCoordsForOrtho(e, t, n) {
                    if (e.getSource() instanceof be) return this._setupProxiedCoordsForImageSource(e, t, n);
                    this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};
                    const i = this.proxiedCoords[e.id] = [], r = this.proxyCoords;
                    for (let t = 0; t < r.length; t++) {
                        const o = r[t], a = this._findTileCoveringTileID(o, e);
                        if (a) {
                            const t = this._createProxiedId(o, a, n[o.key] && n[o.key][e.id]);
                            i.push(t), this.proxyToSource[o.key][e.id] = [t]
                        }
                    }
                    let o = !1;
                    for (let r = 0; r < t.length; r++) {
                        const a = e.getTile(t[r]);
                        if (!a || !a.hasData()) continue;
                        const s = this._findTileCoveringTileID(a.tileID, this.proxySourceCache);
                        if (s && s.tileID.canonical.z !== a.tileID.canonical.z) {
                            const t = this.proxyToSource[s.tileID.key][e.id],
                                r = this._createProxiedId(s.tileID, a, n[s.tileID.key] && n[s.tileID.key][e.id]);
                            t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[s.tileID.key][e.id] = [r], i.push(r), o = !0
                        }
                    }
                    this._sourceTilesOverlap[e.id] = o
                }

                _setupProxiedCoordsForImageSource(t, n, i) {
                    if (!t.getSource().loaded()) return;
                    const r = this.proxiedCoords[t.id] = [], o = this.proxyCoords, a = t.getSource(),
                        s = new e.pointGeometry(a.tileID.x, a.tileID.y)._div(1 << a.tileID.z),
                        l = a.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - s.x), e.min.y = Math.min(e.min.y, t.y - s.y), e.max.x = Math.max(e.max.x, t.x - s.x), e.max.y = Math.max(e.max.y, t.y - s.y), e), {
                            min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),
                            max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)
                        }), c = (t, n) => {
                            const i = t.wrap + t.canonical.x / (1 << t.canonical.z),
                                r = t.canonical.y / (1 << t.canonical.z), o = e.EXTENT / (1 << t.canonical.z),
                                a = n.wrap + n.canonical.x / (1 << n.canonical.z), s = n.canonical.y / (1 << n.canonical.z);
                            return i + o < a + l.min.x || i > a + l.max.x || r + o < s + l.min.y || r > s + l.max.y
                        };
                    for (let e = 0; e < o.length; e++) {
                        const a = o[e];
                        for (let e = 0; e < n.length; e++) {
                            const o = t.getTile(n[e]);
                            if (!o || !o.hasData()) continue;
                            if (c(a, o.tileID)) continue;
                            const s = this._createProxiedId(a, o, i[a.key] && i[a.key][t.id]),
                                l = this.proxyToSource[a.key][t.id];
                            l ? l.push(s) : this.proxyToSource[a.key][t.id] = [s], r.push(s)
                        }
                    }
                }

                _createProxiedId(t, n, i) {
                    let r = this.orthoMatrix;
                    if (i) {
                        const e = i.find(e => e.key === n.tileID.key);
                        if (e) return e
                    }
                    if (n.tileID.key !== t.key) {
                        const i = t.canonical.z - n.tileID.canonical.z;
                        let o, a, s;
                        r = e.create();
                        const l = n.tileID.wrap - t.wrap << t.overscaledZ;
                        i > 0 ? (o = e.EXTENT >> i, a = o * ((n.tileID.canonical.x << i) - t.canonical.x + l), s = o * ((n.tileID.canonical.y << i) - t.canonical.y)) : (o = e.EXTENT << -i, a = e.EXTENT * (n.tileID.canonical.x - (t.canonical.x + l << -i)), s = e.EXTENT * (n.tileID.canonical.y - (t.canonical.y << -i))), e.ortho(r, 0, o, 0, o, 0, 1), e.translate(r, r, [a, s, 0])
                    }
                    return new hn(n.tileID, t.key, r)
                }

                _findTileCoveringTileID(t, n) {
                    let i = n.getTile(t);
                    if (i && i.hasData()) return i;
                    const r = this._findCoveringTileCache[n.id], o = r[t.key];
                    if (i = o ? n.getTileByID(o) : null, i && i.hasData() || null === o) return i;
                    let a = i ? i.tileID : t, s = a.overscaledZ;
                    const l = n.getSource().minzoom, c = [];
                    if (!o) {
                        const r = n.getSource().maxzoom;
                        if (t.canonical.z >= r) {
                            const i = t.canonical.z - r;
                            n.getSource().reparseOverscaled ? (s = Math.max(t.canonical.z + 2, n.transform.tileZoom), a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> i, t.canonical.y >> i)) : 0 !== i && (s = r, a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> i, t.canonical.y >> i))
                        }
                        a.key !== t.key && (c.push(a.key), i = n.getTile(a))
                    }
                    const u = e => {
                        c.forEach(t => {
                            r[t] = e
                        }), c.length = 0
                    };
                    for (s -= 1; s >= l && (!i || !i.hasData()); s--) {
                        i && u(i.tileID.key);
                        const e = a.calculateScaledKey(s);
                        if (i = n.getTileByID(e), i && i.hasData()) break;
                        const t = r[e];
                        if (null === t) break;
                        void 0 === t ? c.push(e) : i = n.getTileByID(t)
                    }
                    return u(i ? i.tileID.key : null), i && i.hasData() ? i : null
                }

                findDEMTileFor(e) {
                    return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null
                }

                prepareDrawTile(e) {
                    this.renderedToTile = !0
                }

                _clearRenderCacheForTile(e, t) {
                    let n = this._tilesDirty[e];
                    n || (n = this._tilesDirty[e] = {}), n[t.key] = !0
                }

                getWirefameBuffer() {
                    if (!this.wireframeSegments) {
                        const t = function (t) {
                            let n, i, r;
                            const o = new e.StructArrayLayout2ui4, a = 131;
                            for (i = 1; i < 129; i++) {
                                for (n = 1; n < 129; n++) r = i * a + n, o.emplaceBack(r, r + 1), o.emplaceBack(r, r + a), o.emplaceBack(r + 1, r + a), 128 === i && o.emplaceBack(r + a, r + a + 1);
                                o.emplaceBack(r + 1, r + 1 + a)
                            }
                            return o
                        }();
                        this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length)
                    }
                    return [this.wireframeIndexBuffer, this.wireframeSegments]
                }
            }

            function fn(e) {
                const t = [];
                for (let n = 0; n < e.length; n++) {
                    if (null === e[n]) continue;
                    const i = e[n].split(" ");
                    t.push(i.pop())
                }
                return t
            }

            class mn {
                static cacheKey(e, t, n) {
                    let i = `${e}${n ? n.cacheKey : ""}`;
                    for (const e of t) i += "/" + e;
                    return i
                }

                constructor(t, n, i, r, o, a) {
                    const s = t.gl;
                    this.program = s.createProgram();
                    const l = fn(i.staticAttributes), c = r ? r.getBinderAttributes() : [], u = l.concat(c),
                        d = i.staticUniforms ? fn(i.staticUniforms) : [], h = r ? r.getBinderUniforms() : [],
                        p = d.concat(h), f = [];
                    for (const e of p) f.indexOf(e) < 0 && f.push(e);
                    let m = r ? r.defines() : [];
                    m = m.concat(a.map(e => "#define " + e));
                    const _ = m.concat("\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", Gt, Vt.fragmentSource, Wt.fragmentSource, i.fragmentSource).join("\n"),
                        g = m.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", Gt, Vt.vertexSource, Wt.vertexSource, Ut.vertexSource, i.vertexSource).join("\n"),
                        y = s.createShader(s.FRAGMENT_SHADER);
                    if (s.isContextLost()) return void (this.failedToCreate = !0);
                    s.shaderSource(y, _), s.compileShader(y), s.attachShader(this.program, y);
                    const v = s.createShader(s.VERTEX_SHADER);
                    if (s.isContextLost()) return void (this.failedToCreate = !0);
                    s.shaderSource(v, g), s.compileShader(v), s.attachShader(this.program, v), this.attributes = {};
                    const x = {};
                    this.numAttributes = u.length;
                    for (let e = 0; e < this.numAttributes; e++) u[e] && (s.bindAttribLocation(this.program, e, u[e]), this.attributes[u[e]] = e);
                    s.linkProgram(this.program), s.deleteShader(v), s.deleteShader(y);
                    for (let e = 0; e < f.length; e++) {
                        const t = f[e];
                        if (t && !x[t]) {
                            const e = s.getUniformLocation(this.program, t);
                            e && (x[t] = e)
                        }
                    }
                    this.fixedUniforms = o(t, x), this.binderUniforms = r ? r.getUniforms(t, x) : [], -1 !== a.indexOf("TERRAIN") && (this.terrainUniforms = ((t, n) => ({
                        u_dem: new e.Uniform1i(t, n.u_dem),
                        u_dem_prev: new e.Uniform1i(t, n.u_dem_prev),
                        u_dem_unpack: new e.Uniform4f(t, n.u_dem_unpack),
                        u_dem_tl: new e.Uniform2f(t, n.u_dem_tl),
                        u_dem_scale: new e.Uniform1f(t, n.u_dem_scale),
                        u_dem_tl_prev: new e.Uniform2f(t, n.u_dem_tl_prev),
                        u_dem_scale_prev: new e.Uniform1f(t, n.u_dem_scale_prev),
                        u_dem_size: new e.Uniform1f(t, n.u_dem_size),
                        u_dem_lerp: new e.Uniform1f(t, n.u_dem_lerp),
                        u_exaggeration: new e.Uniform1f(t, n.u_exaggeration),
                        u_depth: new e.Uniform1i(t, n.u_depth),
                        u_depth_size_inv: new e.Uniform2f(t, n.u_depth_size_inv),
                        u_meter_to_dem: new e.Uniform1f(t, n.u_meter_to_dem),
                        u_label_plane_matrix_inv: new e.UniformMatrix4f(t, n.u_label_plane_matrix_inv),
                        u_tile_tl_up: new e.Uniform3f(t, n.u_tile_tl_up),
                        u_tile_tr_up: new e.Uniform3f(t, n.u_tile_tr_up),
                        u_tile_br_up: new e.Uniform3f(t, n.u_tile_br_up),
                        u_tile_bl_up: new e.Uniform3f(t, n.u_tile_bl_up),
                        u_tile_up_scale: new e.Uniform1f(t, n.u_tile_up_scale)
                    }))(t, x)), -1 !== a.indexOf("FOG") && (this.fogUniforms = ((t, n) => ({
                        u_fog_matrix: new e.UniformMatrix4f(t, n.u_fog_matrix),
                        u_fog_range: new e.Uniform2f(t, n.u_fog_range),
                        u_fog_color: new e.Uniform4f(t, n.u_fog_color),
                        u_fog_horizon_blend: new e.Uniform1f(t, n.u_fog_horizon_blend),
                        u_fog_temporal_offset: new e.Uniform1f(t, n.u_fog_temporal_offset)
                    }))(t, x))
                }

                setTerrainUniformValues(e, t) {
                    if (!this.terrainUniforms) return;
                    const n = this.terrainUniforms;
                    if (!this.failedToCreate) {
                        e.program.set(this.program);
                        for (const e in t) n[e].set(t[e])
                    }
                }

                setFogUniformValues(e, t) {
                    if (!this.fogUniforms) return;
                    const n = this.fogUniforms;
                    if (!this.failedToCreate) {
                        e.program.set(this.program);
                        for (const e in t) n[e].location && n[e].set(t[e])
                    }
                }

                draw(e, t, n, i, r, o, a, s, l, c, u, d, h, p, f, m) {
                    const _ = e.gl;
                    if (this.failedToCreate) return;
                    e.program.set(this.program), e.setDepthMode(n), e.setStencilMode(i), e.setColorMode(r), e.setCullFace(o);
                    for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(a[e]);
                    p && p.setUniforms(e, this.binderUniforms, d, {zoom: h});
                    const g = {[_.LINES]: 2, [_.TRIANGLES]: 3, [_.LINE_STRIP]: 1}[t];
                    for (const n of u.get()) {
                        const i = n.vaos || (n.vaos = {});
                        (i[s] || (i[s] = new $t)).bind(e, this, l, p ? p.getPaintVertexBuffers() : [], c, n.vertexOffset, f, m), _.drawElements(t, n.primitiveLength * g, _.UNSIGNED_SHORT, n.primitiveOffset * g * 2)
                    }
                }
            }

            function _n(e, t, n) {
                const i = 1 / S(n, 1, t.transform.tileZoom), r = Math.pow(2, n.tileID.overscaledZ),
                    o = n.tileSize * Math.pow(2, t.transform.tileZoom) / r,
                    a = o * (n.tileID.canonical.x + n.tileID.wrap * r), s = o * n.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_texsize: n.imageAtlasTexture.size,
                    u_scale: [i, e.fromScale, e.toScale],
                    u_fade: e.t,
                    u_pixel_coord_upper: [a >> 16, s >> 16],
                    u_pixel_coord_lower: [65535 & a, 65535 & s]
                }
            }

            const gn = (t, n, i, r) => {
                    const o = n.style.light, a = o.properties.get("position"), s = [a.x, a.y, a.z], l = e.create$1();
                    "viewport" === o.properties.get("anchor") && (e.fromRotation(l, -n.transform.angle), e.transformMat3(s, s, l));
                    const c = o.properties.get("color");
                    return {
                        u_matrix: t,
                        u_lightpos: s,
                        u_lightintensity: o.properties.get("intensity"),
                        u_lightcolor: [c.r, c.g, c.b],
                        u_vertical_gradient: +i,
                        u_opacity: r
                    }
                },
                yn = (t, n, i, r, o, a, s) => e.extend(gn(t, n, i, r), _n(a, n, s), {u_height_factor: -Math.pow(2, o.overscaledZ) / s.tileSize / 8}),
                vn = e => ({u_matrix: e}), xn = (t, n, i, r) => e.extend(vn(t), _n(i, n, r)),
                bn = (e, t) => ({u_matrix: e, u_world: t}),
                wn = (t, n, i, r, o) => e.extend(xn(t, n, i, r), {u_world: o}), Mn = (t, n, i, r) => {
                    const o = t.transform;
                    let a;
                    return a = "map" === r.paint.get("circle-pitch-alignment") ? o.calculatePixelsToTileUnitsMatrix(i) : new Float32Array([o.pixelsToGLUnits[0], 0, 0, o.pixelsToGLUnits[1]]), {
                        u_camera_to_center_distance: o.cameraToCenterDistance,
                        u_matrix: t.translatePosMatrix(n.projMatrix, i, r.paint.get("circle-translate"), r.paint.get("circle-translate-anchor")),
                        u_device_pixel_ratio: e.exported.devicePixelRatio,
                        u_extrude_scale: a
                    }
                }, Tn = e => {
                    const t = [];
                    return "map" === e.paint.get("circle-pitch-alignment") && t.push("PITCH_WITH_MAP"), "map" === e.paint.get("circle-pitch-scale") && t.push("SCALE_WITH_MAP"), t
                }, kn = (t, n, i) => {
                    const r = e.EXTENT / i.tileSize;
                    return {
                        u_matrix: t,
                        u_camera_to_center_distance: n.cameraToCenterDistance,
                        u_extrude_scale: [n.pixelsToGLUnits[0] / r, n.pixelsToGLUnits[1] / r]
                    }
                }, Sn = (e, t, n = 1) => ({u_matrix: e, u_color: t, u_overlay: 0, u_overlay_scale: n}),
                Dn = (e, t, n, i) => ({u_matrix: e, u_extrude_scale: S(t, 1, n), u_intensity: i}),
                Ln = (t, n, i, r, o, a) => {
                    const s = t.transform, l = s.calculatePixelsToTileUnitsMatrix(n), c = {
                        u_matrix: An(t, n, i, o),
                        u_pixels_to_tile_units: l,
                        u_device_pixel_ratio: e.exported.devicePixelRatio,
                        u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]],
                        u_dash_image: 0,
                        u_gradient_image: 1,
                        u_image_height: a,
                        u_texsize: [0, 0],
                        u_scale: [0, 0, 0],
                        u_mix: 0,
                        u_alpha_discard_threshold: 0
                    };
                    if (In(i)) {
                        const e = Cn(n, t.transform);
                        c.u_texsize = n.lineAtlasTexture.size, c.u_scale = [e, r.fromScale, r.toScale], c.u_mix = r.t
                    }
                    return c
                }, En = (t, n, i, r, o) => {
                    const a = t.transform, s = Cn(n, a);
                    return {
                        u_matrix: An(t, n, i, o),
                        u_texsize: n.imageAtlasTexture.size,
                        u_pixels_to_tile_units: a.calculatePixelsToTileUnitsMatrix(n),
                        u_device_pixel_ratio: e.exported.devicePixelRatio,
                        u_image: 0,
                        u_scale: [s, r.fromScale, r.toScale],
                        u_fade: r.t,
                        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],
                        u_alpha_discard_threshold: 0
                    }
                };

            function Cn(e, t) {
                return 1 / S(e, 1, t.tileZoom)
            }

            function An(e, t, n, i) {
                return e.translatePosMatrix(i || t.tileID.projMatrix, t, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"))
            }

            function In(e) {
                const t = e.paint.get("line-dasharray").value;
                return t.value || "constant" !== t.kind
            }

            const Pn = (e, t, n, i, r, o) => {
                return {
                    u_matrix: e,
                    u_tl_parent: t,
                    u_scale_parent: n,
                    u_fade_t: i.mix,
                    u_opacity: i.opacity * r.paint.get("raster-opacity"),
                    u_image0: 0,
                    u_image1: 1,
                    u_brightness_low: r.paint.get("raster-brightness-min"),
                    u_brightness_high: r.paint.get("raster-brightness-max"),
                    u_saturation_factor: (s = r.paint.get("raster-saturation"), s > 0 ? 1 - 1 / (1.001 - s) : -s),
                    u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a),
                    u_spin_weights: Rn(r.paint.get("raster-hue-rotate")),
                    u_perspective_transform: o
                };
                var a, s
            };

            function Rn(e) {
                e *= Math.PI / 180;
                const t = Math.sin(e), n = Math.cos(e);
                return [(2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3]
            }

            const Yn = (e, t, n, i, r, o, a, s, l, c, u, d, h, p) => {
                    const f = r.transform;
                    return {
                        u_is_size_zoom_constant: +("constant" === e || "source" === e),
                        u_is_size_feature_constant: +("constant" === e || "camera" === e),
                        u_size_t: t ? t.uSizeT : 0,
                        u_size: t ? t.uSize : 0,
                        u_camera_to_center_distance: f.cameraToCenterDistance,
                        u_pitch: f.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +n,
                        u_aspect_ratio: f.width / f.height,
                        u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,
                        u_matrix: o,
                        u_label_plane_matrix: a,
                        u_coord_matrix: s,
                        u_is_text: +l,
                        u_pitch_with_map: +i,
                        u_texsize: c,
                        u_tile_id: u,
                        u_zoom_transition: d,
                        u_inv_rot_matrix: h,
                        u_merc_center: p,
                        u_texture: 0
                    }
                }, zn = (t, n, i, r, o, a, s, l, c, u, d, h, p, f, m) => {
                    const {cameraToCenterDistance: _, _pitch: g} = o.transform;
                    return e.extend(Yn(t, n, i, r, o, a, s, l, c, u, h, p, f, m), {
                        u_gamma_scale: r ? _ * Math.cos(o.terrain ? 0 : g) : 1,
                        u_device_pixel_ratio: e.exported.devicePixelRatio,
                        u_is_halo: +d
                    })
                },
                On = (t, n, i, r, o, a, s, l, c, u, d, h, p, f) => e.extend(zn(t, n, i, r, o, a, s, l, !0, c, !0, d, h, p, f), {
                    u_texsize_icon: u,
                    u_texture_icon: 1
                }), Fn = (e, t, n) => ({u_matrix: e, u_opacity: t, u_color: n}),
                Bn = (t, n, i, r, o, a) => e.extend(function (e, t, n, i) {
                    const r = n.imageManager.getPattern(e.from.toString()),
                        o = n.imageManager.getPattern(e.to.toString()), {
                            width: a,
                            height: s
                        } = n.imageManager.getPixelSize(), l = Math.pow(2, i.tileID.overscaledZ),
                        c = i.tileSize * Math.pow(2, n.transform.tileZoom) / l,
                        u = c * (i.tileID.canonical.x + i.tileID.wrap * l), d = c * i.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: r.tl,
                        u_pattern_br_a: r.br,
                        u_pattern_tl_b: o.tl,
                        u_pattern_br_b: o.br,
                        u_texsize: [a, s],
                        u_mix: t.t,
                        u_pattern_size_a: r.displaySize,
                        u_pattern_size_b: o.displaySize,
                        u_scale_a: t.fromScale,
                        u_scale_b: t.toScale,
                        u_tile_units_to_pixels: 1 / S(i, 1, n.transform.tileZoom),
                        u_pixel_coord_upper: [u >> 16, d >> 16],
                        u_pixel_coord_lower: [65535 & u, 65535 & d]
                    }
                }(r, a, i, o), {u_matrix: t, u_opacity: n}), jn = {
                    fillExtrusion: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_lightpos: new e.Uniform3f(t, n.u_lightpos),
                        u_lightintensity: new e.Uniform1f(t, n.u_lightintensity),
                        u_lightcolor: new e.Uniform3f(t, n.u_lightcolor),
                        u_vertical_gradient: new e.Uniform1f(t, n.u_vertical_gradient),
                        u_opacity: new e.Uniform1f(t, n.u_opacity)
                    }),
                    fillExtrusionPattern: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_lightpos: new e.Uniform3f(t, n.u_lightpos),
                        u_lightintensity: new e.Uniform1f(t, n.u_lightintensity),
                        u_lightcolor: new e.Uniform3f(t, n.u_lightcolor),
                        u_vertical_gradient: new e.Uniform1f(t, n.u_vertical_gradient),
                        u_height_factor: new e.Uniform1f(t, n.u_height_factor),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_pixel_coord_upper: new e.Uniform2f(t, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new e.Uniform2f(t, n.u_pixel_coord_lower),
                        u_scale: new e.Uniform3f(t, n.u_scale),
                        u_fade: new e.Uniform1f(t, n.u_fade),
                        u_opacity: new e.Uniform1f(t, n.u_opacity)
                    }),
                    fill: (t, n) => ({u_matrix: new e.UniformMatrix4f(t, n.u_matrix)}),
                    fillPattern: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_pixel_coord_upper: new e.Uniform2f(t, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new e.Uniform2f(t, n.u_pixel_coord_lower),
                        u_scale: new e.Uniform3f(t, n.u_scale),
                        u_fade: new e.Uniform1f(t, n.u_fade)
                    }),
                    fillOutline: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_world: new e.Uniform2f(t, n.u_world)
                    }),
                    fillOutlinePattern: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_world: new e.Uniform2f(t, n.u_world),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_pixel_coord_upper: new e.Uniform2f(t, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new e.Uniform2f(t, n.u_pixel_coord_lower),
                        u_scale: new e.Uniform3f(t, n.u_scale),
                        u_fade: new e.Uniform1f(t, n.u_fade)
                    }),
                    circle: (t, n) => ({
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_extrude_scale: new e.UniformMatrix2f(t, n.u_extrude_scale),
                        u_device_pixel_ratio: new e.Uniform1f(t, n.u_device_pixel_ratio),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix)
                    }),
                    collisionBox: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_extrude_scale: new e.Uniform2f(t, n.u_extrude_scale)
                    }),
                    collisionCircle: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_inv_matrix: new e.UniformMatrix4f(t, n.u_inv_matrix),
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_viewport_size: new e.Uniform2f(t, n.u_viewport_size)
                    }),
                    debug: (t, n) => ({
                        u_color: new e.UniformColor(t, n.u_color),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_overlay: new e.Uniform1i(t, n.u_overlay),
                        u_overlay_scale: new e.Uniform1f(t, n.u_overlay_scale)
                    }),
                    clippingMask: (t, n) => ({u_matrix: new e.UniformMatrix4f(t, n.u_matrix)}),
                    heatmap: (t, n) => ({
                        u_extrude_scale: new e.Uniform1f(t, n.u_extrude_scale),
                        u_intensity: new e.Uniform1f(t, n.u_intensity),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix)
                    }),
                    heatmapTexture: (t, n) => ({
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_color_ramp: new e.Uniform1i(t, n.u_color_ramp),
                        u_opacity: new e.Uniform1f(t, n.u_opacity)
                    }),
                    hillshade: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_latrange: new e.Uniform2f(t, n.u_latrange),
                        u_light: new e.Uniform2f(t, n.u_light),
                        u_shadow: new e.UniformColor(t, n.u_shadow),
                        u_highlight: new e.UniformColor(t, n.u_highlight),
                        u_accent: new e.UniformColor(t, n.u_accent)
                    }),
                    hillshadePrepare: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_dimension: new e.Uniform2f(t, n.u_dimension),
                        u_zoom: new e.Uniform1f(t, n.u_zoom),
                        u_unpack: new e.Uniform4f(t, n.u_unpack)
                    }),
                    line: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_pixels_to_tile_units: new e.UniformMatrix2f(t, n.u_pixels_to_tile_units),
                        u_device_pixel_ratio: new e.Uniform1f(t, n.u_device_pixel_ratio),
                        u_units_to_pixels: new e.Uniform2f(t, n.u_units_to_pixels),
                        u_dash_image: new e.Uniform1i(t, n.u_dash_image),
                        u_gradient_image: new e.Uniform1i(t, n.u_gradient_image),
                        u_image_height: new e.Uniform1f(t, n.u_image_height),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_scale: new e.Uniform3f(t, n.u_scale),
                        u_mix: new e.Uniform1f(t, n.u_mix),
                        u_alpha_discard_threshold: new e.Uniform1f(t, n.u_alpha_discard_threshold)
                    }),
                    linePattern: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_pixels_to_tile_units: new e.UniformMatrix2f(t, n.u_pixels_to_tile_units),
                        u_device_pixel_ratio: new e.Uniform1f(t, n.u_device_pixel_ratio),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_units_to_pixels: new e.Uniform2f(t, n.u_units_to_pixels),
                        u_scale: new e.Uniform3f(t, n.u_scale),
                        u_fade: new e.Uniform1f(t, n.u_fade),
                        u_alpha_discard_threshold: new e.Uniform1f(t, n.u_alpha_discard_threshold)
                    }),
                    raster: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_tl_parent: new e.Uniform2f(t, n.u_tl_parent),
                        u_scale_parent: new e.Uniform1f(t, n.u_scale_parent),
                        u_fade_t: new e.Uniform1f(t, n.u_fade_t),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_image0: new e.Uniform1i(t, n.u_image0),
                        u_image1: new e.Uniform1i(t, n.u_image1),
                        u_brightness_low: new e.Uniform1f(t, n.u_brightness_low),
                        u_brightness_high: new e.Uniform1f(t, n.u_brightness_high),
                        u_saturation_factor: new e.Uniform1f(t, n.u_saturation_factor),
                        u_contrast_factor: new e.Uniform1f(t, n.u_contrast_factor),
                        u_spin_weights: new e.Uniform3f(t, n.u_spin_weights),
                        u_perspective_transform: new e.Uniform2f(t, n.u_perspective_transform)
                    }),
                    symbolIcon: (t, n) => ({
                        u_is_size_zoom_constant: new e.Uniform1i(t, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new e.Uniform1i(t, n.u_is_size_feature_constant),
                        u_size_t: new e.Uniform1f(t, n.u_size_t),
                        u_size: new e.Uniform1f(t, n.u_size),
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_pitch: new e.Uniform1f(t, n.u_pitch),
                        u_rotate_symbol: new e.Uniform1i(t, n.u_rotate_symbol),
                        u_aspect_ratio: new e.Uniform1f(t, n.u_aspect_ratio),
                        u_fade_change: new e.Uniform1f(t, n.u_fade_change),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_label_plane_matrix: new e.UniformMatrix4f(t, n.u_label_plane_matrix),
                        u_coord_matrix: new e.UniformMatrix4f(t, n.u_coord_matrix),
                        u_is_text: new e.Uniform1i(t, n.u_is_text),
                        u_pitch_with_map: new e.Uniform1i(t, n.u_pitch_with_map),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_tile_id: new e.Uniform3f(t, n.u_tile_id),
                        u_zoom_transition: new e.Uniform1f(t, n.u_zoom_transition),
                        u_inv_rot_matrix: new e.UniformMatrix4f(t, n.u_inv_rot_matrix),
                        u_merc_center: new e.Uniform2f(t, n.u_merc_center),
                        u_texture: new e.Uniform1i(t, n.u_texture)
                    }),
                    symbolSDF: (t, n) => ({
                        u_is_size_zoom_constant: new e.Uniform1i(t, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new e.Uniform1i(t, n.u_is_size_feature_constant),
                        u_size_t: new e.Uniform1f(t, n.u_size_t),
                        u_size: new e.Uniform1f(t, n.u_size),
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_pitch: new e.Uniform1f(t, n.u_pitch),
                        u_rotate_symbol: new e.Uniform1i(t, n.u_rotate_symbol),
                        u_aspect_ratio: new e.Uniform1f(t, n.u_aspect_ratio),
                        u_fade_change: new e.Uniform1f(t, n.u_fade_change),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_label_plane_matrix: new e.UniformMatrix4f(t, n.u_label_plane_matrix),
                        u_coord_matrix: new e.UniformMatrix4f(t, n.u_coord_matrix),
                        u_is_text: new e.Uniform1i(t, n.u_is_text),
                        u_pitch_with_map: new e.Uniform1i(t, n.u_pitch_with_map),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_texture: new e.Uniform1i(t, n.u_texture),
                        u_gamma_scale: new e.Uniform1f(t, n.u_gamma_scale),
                        u_device_pixel_ratio: new e.Uniform1f(t, n.u_device_pixel_ratio),
                        u_tile_id: new e.Uniform3f(t, n.u_tile_id),
                        u_zoom_transition: new e.Uniform1f(t, n.u_zoom_transition),
                        u_inv_rot_matrix: new e.UniformMatrix4f(t, n.u_inv_rot_matrix),
                        u_merc_center: new e.Uniform2f(t, n.u_merc_center),
                        u_is_halo: new e.Uniform1i(t, n.u_is_halo)
                    }),
                    symbolTextAndIcon: (t, n) => ({
                        u_is_size_zoom_constant: new e.Uniform1i(t, n.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new e.Uniform1i(t, n.u_is_size_feature_constant),
                        u_size_t: new e.Uniform1f(t, n.u_size_t),
                        u_size: new e.Uniform1f(t, n.u_size),
                        u_camera_to_center_distance: new e.Uniform1f(t, n.u_camera_to_center_distance),
                        u_pitch: new e.Uniform1f(t, n.u_pitch),
                        u_rotate_symbol: new e.Uniform1i(t, n.u_rotate_symbol),
                        u_aspect_ratio: new e.Uniform1f(t, n.u_aspect_ratio),
                        u_fade_change: new e.Uniform1f(t, n.u_fade_change),
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_label_plane_matrix: new e.UniformMatrix4f(t, n.u_label_plane_matrix),
                        u_coord_matrix: new e.UniformMatrix4f(t, n.u_coord_matrix),
                        u_is_text: new e.Uniform1i(t, n.u_is_text),
                        u_pitch_with_map: new e.Uniform1i(t, n.u_pitch_with_map),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_texsize_icon: new e.Uniform2f(t, n.u_texsize_icon),
                        u_texture: new e.Uniform1i(t, n.u_texture),
                        u_texture_icon: new e.Uniform1i(t, n.u_texture_icon),
                        u_gamma_scale: new e.Uniform1f(t, n.u_gamma_scale),
                        u_device_pixel_ratio: new e.Uniform1f(t, n.u_device_pixel_ratio),
                        u_is_halo: new e.Uniform1i(t, n.u_is_halo)
                    }),
                    background: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_color: new e.UniformColor(t, n.u_color)
                    }),
                    backgroundPattern: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_image: new e.Uniform1i(t, n.u_image),
                        u_pattern_tl_a: new e.Uniform2f(t, n.u_pattern_tl_a),
                        u_pattern_br_a: new e.Uniform2f(t, n.u_pattern_br_a),
                        u_pattern_tl_b: new e.Uniform2f(t, n.u_pattern_tl_b),
                        u_pattern_br_b: new e.Uniform2f(t, n.u_pattern_br_b),
                        u_texsize: new e.Uniform2f(t, n.u_texsize),
                        u_mix: new e.Uniform1f(t, n.u_mix),
                        u_pattern_size_a: new e.Uniform2f(t, n.u_pattern_size_a),
                        u_pattern_size_b: new e.Uniform2f(t, n.u_pattern_size_b),
                        u_scale_a: new e.Uniform1f(t, n.u_scale_a),
                        u_scale_b: new e.Uniform1f(t, n.u_scale_b),
                        u_pixel_coord_upper: new e.Uniform2f(t, n.u_pixel_coord_upper),
                        u_pixel_coord_lower: new e.Uniform2f(t, n.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new e.Uniform1f(t, n.u_tile_units_to_pixels)
                    }),
                    terrainRaster: en,
                    terrainDepth: en,
                    skybox: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_sun_direction: new e.Uniform3f(t, n.u_sun_direction),
                        u_cubemap: new e.Uniform1i(t, n.u_cubemap),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_temporal_offset: new e.Uniform1f(t, n.u_temporal_offset)
                    }),
                    skyboxGradient: (t, n) => ({
                        u_matrix: new e.UniformMatrix4f(t, n.u_matrix),
                        u_color_ramp: new e.Uniform1i(t, n.u_color_ramp),
                        u_center_direction: new e.Uniform3f(t, n.u_center_direction),
                        u_radius: new e.Uniform1f(t, n.u_radius),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_temporal_offset: new e.Uniform1f(t, n.u_temporal_offset)
                    }),
                    skyboxCapture: (t, n) => ({
                        u_matrix_3f: new e.UniformMatrix3f(t, n.u_matrix_3f),
                        u_sun_direction: new e.Uniform3f(t, n.u_sun_direction),
                        u_sun_intensity: new e.Uniform1f(t, n.u_sun_intensity),
                        u_color_tint_r: new e.Uniform4f(t, n.u_color_tint_r),
                        u_color_tint_m: new e.Uniform4f(t, n.u_color_tint_m),
                        u_luminance: new e.Uniform1f(t, n.u_luminance)
                    }),
                    globeRaster: (t, n) => ({
                        u_proj_matrix: new e.UniformMatrix4f(t, n.u_proj_matrix),
                        u_globe_matrix: new e.UniformMatrix4f(t, n.u_globe_matrix),
                        u_merc_matrix: new e.UniformMatrix4f(t, n.u_merc_matrix),
                        u_zoom_transition: new e.Uniform1f(t, n.u_zoom_transition),
                        u_merc_center: new e.Uniform2f(t, n.u_merc_center),
                        u_image0: new e.Uniform1i(t, n.u_image0)
                    }),
                    globeAtmosphere: (t, n) => ({
                        u_center: new e.Uniform2f(t, n.u_center),
                        u_radius: new e.Uniform1f(t, n.u_radius),
                        u_screen_size: new e.Uniform2f(t, n.u_screen_size),
                        u_pixel_ratio: new e.Uniform1f(t, n.u_pixel_ratio),
                        u_opacity: new e.Uniform1f(t, n.u_opacity),
                        u_fadeout_range: new e.Uniform1f(t, n.u_fadeout_range),
                        u_start_color: new e.Uniform3f(t, n.u_start_color),
                        u_end_color: new e.Uniform3f(t, n.u_end_color)
                    })
                };
            let Hn;

            function Nn(t, n, i, r, o, a, s) {
                const l = t.context, c = l.gl, u = t.useProgram("collisionBox"), d = [];
                let h = 0, p = 0;
                for (let f = 0; f < r.length; f++) {
                    const m = r[f], _ = n.getTile(m), g = _.getBucket(i);
                    if (!g) continue;
                    let y = m.projMatrix;
                    0 === o[0] && 0 === o[1] || (y = t.translatePosMatrix(m.projMatrix, _, o, a));
                    const v = s ? g.textCollisionBox : g.iconCollisionBox, x = g.collisionCircleArray;
                    if (x.length > 0) {
                        const n = e.create(), i = y;
                        e.mul(n, g.placementInvProjMatrix, t.transform.glCoordMatrix), e.mul(n, n, g.placementViewportMatrix), d.push({
                            circleArray: x,
                            circleOffset: p,
                            transform: i,
                            invTransform: n
                        }), h += x.length / 4, p = h
                    }
                    v && (t.terrain && t.terrain.setupElevationDraw(_, u), u.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, kn(y, t.transform, _), i.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, null, t.transform.zoom, null, v.collisionVertexBuffer, v.collisionVertexBufferExt))
                }
                if (!s || !d.length) return;
                const f = t.useProgram("collisionCircle"), m = new e.StructArrayLayout2f1f2i16;
                m.resize(4 * h), m._trim();
                let _ = 0;
                for (const e of d) for (let t = 0; t < e.circleArray.length / 4; t++) {
                    const n = 4 * t, i = e.circleArray[n + 0], r = e.circleArray[n + 1], o = e.circleArray[n + 2],
                        a = e.circleArray[n + 3];
                    m.emplace(_++, i, r, o, a, 0), m.emplace(_++, i, r, o, a, 1), m.emplace(_++, i, r, o, a, 2), m.emplace(_++, i, r, o, a, 3)
                }
                (!Hn || Hn.length < 2 * h) && (Hn = function (t) {
                    const n = 2 * t, i = new e.StructArrayLayout3ui6;
                    i.resize(n), i._trim();
                    for (let e = 0; e < n; e++) {
                        const t = 6 * e;
                        i.uint16[t + 0] = 4 * e + 0, i.uint16[t + 1] = 4 * e + 1, i.uint16[t + 2] = 4 * e + 2, i.uint16[t + 3] = 4 * e + 2, i.uint16[t + 4] = 4 * e + 3, i.uint16[t + 5] = 4 * e + 0
                    }
                    return i
                }(h));
                const g = l.createIndexBuffer(Hn, !0), y = l.createVertexBuffer(m, e.collisionCircleLayout.members, !0);
                for (const n of d) {
                    const r = {
                        u_matrix: n.transform,
                        u_inv_matrix: n.invTransform,
                        u_camera_to_center_distance: (v = t.transform).cameraToCenterDistance,
                        u_viewport_size: [v.width, v.height]
                    };
                    f.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, i.id, y, g, e.SegmentVector.simpleSegment(0, 2 * n.circleOffset, n.circleArray.length, n.circleArray.length / 2), null, t.transform.zoom, null, null, null)
                }
                var v;
                y.destroy(), g.destroy()
            }

            const Un = e.identity(new Float32Array(16));

            function Wn(t, n, i, r, o, a) {
                const {horizontalAlign: s, verticalAlign: l} = e.getAnchorAlignment(t), c = -(s - .5) * n,
                    u = -(l - .5) * i, d = e.evaluateVariableOffset(t, r);
                return new e.pointGeometry((c / o + d[0]) * a, (u / o + d[1]) * a)
            }

            function Vn(t, n, i, r, o, a, s, l, c, u, d, h) {
                const p = t.text.placedSymbolArray, f = t.text.dynamicLayoutVertexArray,
                    m = t.icon.dynamicLayoutVertexArray, _ = {}, g = l.projMatrix, y = a.elevation,
                    v = y ? y.getAtTileOffsetFunc(l, h) : e => [0, 0, 0];
                f.clear();
                for (let l = 0; l < p.length; l++) {
                    const h = p.get(l), m = t.allowVerticalPlacement && !h.placedOrientation,
                        y = h.hidden || !h.crossTileID || m ? null : r[h.crossTileID];
                    if (y) {
                        const r = new e.pointGeometry(h.tileAnchorX, h.tileAnchorY), l = v(r),
                            p = Ze(r, i ? g : s, l[2]), m = $e(a.cameraToCenterDistance, p.signedDistanceFromCamera);
                        let x = o.evaluateSizeForFeature(t.textSizeData, u, h) * m / e.ONE_EM;
                        i && (x *= t.tilePixelRatio / c);
                        const {width: b, height: w, anchor: M, textOffset: T, textScale: k} = y,
                            S = Wn(M, b, w, T, k, x),
                            D = i ? Ze(r.add(S), s, l[2]).point : p.point.add(n ? S.rotate(-a.angle) : S),
                            L = t.allowVerticalPlacement && h.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
                        for (let t = 0; t < h.numGlyphs; t++) e.addDynamicAttributes(f, D, L);
                        d && h.associatedIconIndex >= 0 && (_[h.associatedIconIndex] = {shiftedAnchor: D, angle: L})
                    } else ot(h.numGlyphs, f)
                }
                if (d) {
                    m.clear();
                    const n = t.icon.placedSymbolArray;
                    for (let t = 0; t < n.length; t++) {
                        const i = n.get(t);
                        if (i.hidden) ot(i.numGlyphs, m); else {
                            const n = _[t];
                            if (n) for (let t = 0; t < i.numGlyphs; t++) e.addDynamicAttributes(m, n.shiftedAnchor, n.angle); else ot(i.numGlyphs, m)
                        }
                    }
                    t.icon.dynamicLayoutVertexBuffer.updateData(m)
                }
                t.text.dynamicLayoutVertexBuffer.updateData(f)
            }

            function Gn(e, t, n) {
                return n.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon"
            }

            function qn(t, n, i, r, o, a, s, l, c, u, d, h) {
                const p = t.context, f = p.gl, m = t.transform, _ = m.projection.createTileTransform(m, m.worldSize),
                    g = "map" === l, y = "map" === c, v = g && "point" !== i.layout.get("symbol-placement"),
                    x = g && !y && !v, b = void 0 !== i.layout.get("symbol-sort-key").constantOr(1);
                let w = !1;
                const M = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                    T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],
                    k = i.layout.get("text-variable-anchor"), S = "globe" === m.projection.name,
                    D = S ? e.globeToMercatorTransition(m.zoom) : 0, L = [], E = [];
                t.terrain && y && E.push("PITCH_WITH_MAP_TERRAIN"), S && E.push("PROJECTION_GLOBE_VIEW"), v && E.push("PROJECTED_POS_ON_VIEWPORT");
                for (const l of r) {
                    const r = n.getTile(l), c = r.getBucket(i);
                    if (!c || c.projection !== m.projection.name) continue;
                    const d = o ? c.text : c.icon;
                    if (!d || c.fullyClipped || !d.segments.get().length) continue;
                    const h = d.programConfigurations.get(i.id), p = o || c.sdfIcons,
                        M = o ? c.textSizeData : c.iconSizeData, S = y || 0 !== m.pitch,
                        C = t.useProgram(Gn(p, o, c), h, E), A = e.evaluateSizeForZoom(M, m.zoom),
                        I = [l.canonical.x, l.canonical.y, 1 << l.canonical.z];
                    let P, R, Y, z, O = [0, 0], F = null;
                    if (o) {
                        if (R = r.glyphAtlasTexture, Y = f.LINEAR, P = r.glyphAtlasTexture.size, c.iconsInText) {
                            O = r.imageAtlasTexture.size, F = r.imageAtlasTexture;
                            const e = "composite" === M.kind || "camera" === M.kind;
                            z = S || t.options.rotating || t.options.zooming || e ? f.LINEAR : f.NEAREST
                        }
                    } else {
                        const e = 1 !== i.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                        R = r.imageAtlasTexture, Y = p || t.options.rotating || t.options.zooming || e || S ? f.LINEAR : f.NEAREST, P = r.imageAtlasTexture.size
                    }
                    const B = t.transform.calculatePixelsToTileUnitsMatrix(r),
                        j = Ge(l.projMatrix, r.tileID.canonical, y, g, t.transform, B),
                        H = t.terrain && y && v ? e.invert(new Float32Array(16), j) : Un,
                        N = qe(l.projMatrix, r.tileID.canonical, y, g, t.transform, B), U = k && c.hasTextData(),
                        W = "none" !== i.layout.get("icon-text-fit") && U && c.hasIconData();
                    if (v) {
                        const e = m.elevation, n = e ? e.getAtTileOffsetFunc(l, _) : e => [0, 0, 0];
                        Je(c, l.projMatrix, t, o, j, N, y, u, n, l)
                    }
                    const V = t.translatePosMatrix(l.projMatrix, r, a, s), G = v || o && k || W ? Un : j,
                        q = t.translatePosMatrix(N, r, a, s, !0),
                        Z = p && 0 !== i.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1);
                    let $;
                    const X = _.createInversionMatrix(l.toUnwrapped());
                    $ = p ? c.iconsInText ? On(M.kind, A, x, y, t, V, G, q, P, O, I, D, X, T) : zn(M.kind, A, x, y, t, V, G, q, o, P, !0, I, D, X, T) : Yn(M.kind, A, x, y, t, V, G, q, o, P, I, D, X, T);
                    const J = {
                        program: C,
                        buffers: d,
                        uniformValues: $,
                        atlasTexture: R,
                        atlasTextureIcon: F,
                        atlasInterpolation: Y,
                        atlasInterpolationIcon: z,
                        isSDF: p,
                        hasHalo: Z,
                        tile: r,
                        labelPlaneMatrixInv: H
                    };
                    if (b && c.canOverlap) {
                        w = !0;
                        const t = d.segments.get();
                        for (const n of t) L.push({segments: new e.SegmentVector([n]), sortKey: n.sortKey, state: J})
                    } else L.push({segments: d.segments, sortKey: 0, state: J})
                }
                w && L.sort((e, t) => e.sortKey - t.sortKey);
                for (const e of L) {
                    const n = e.state;
                    if (t.terrain && t.terrain.setupElevationDraw(n.tile, n.program, {
                        useDepthForOcclusion: !S,
                        labelPlaneMatrixInv: n.labelPlaneMatrixInv
                    }), p.activeTexture.set(f.TEXTURE0), n.atlasTexture.bind(n.atlasInterpolation, f.CLAMP_TO_EDGE), n.atlasTextureIcon && (p.activeTexture.set(f.TEXTURE1), n.atlasTextureIcon && n.atlasTextureIcon.bind(n.atlasInterpolationIcon, f.CLAMP_TO_EDGE)), n.isSDF) {
                        const r = n.uniformValues;
                        n.hasHalo && (r.u_is_halo = 1, Zn(n.buffers, e.segments, i, t, n.program, M, d, h, r)), r.u_is_halo = 0
                    }
                    Zn(n.buffers, e.segments, i, t, n.program, M, d, h, n.uniformValues)
                }
            }

            function Zn(t, n, i, r, o, a, s, l, c) {
                const u = r.context;
                o.draw(u, u.gl.TRIANGLES, a, s, l, e.CullFaceMode.disabled, c, i.id, t.layoutVertexBuffer, t.indexBuffer, n, i.paint, r.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer)
            }

            function $n(t, n, i, r, o, a, s) {
                const l = t.context.gl, c = i.paint.get("fill-pattern"), u = c && c.constantOr(1),
                    d = i.getCrossfadeParameters();
                let h, p, f, m, _;
                s ? (p = u && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h = l.LINES) : (p = u ? "fillPattern" : "fill", h = l.TRIANGLES);
                for (const g of r) {
                    const r = n.getTile(g);
                    if (u && !r.patternsLoaded()) continue;
                    const y = r.getBucket(i);
                    if (!y) continue;
                    t.prepareDrawTile(g);
                    const v = y.programConfigurations.get(i.id), x = t.useProgram(p, v);
                    u && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers(d));
                    const b = c.constantOr(null);
                    if (b && r.imageAtlas) {
                        const e = r.imageAtlas, t = e.patternPositions[b.to.toString()],
                            n = e.patternPositions[b.from.toString()];
                        t && n && v.setConstantPatternPositions(t, n)
                    }
                    const w = t.translatePosMatrix(g.projMatrix, r, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"));
                    if (s) {
                        m = y.indexBuffer2, _ = y.segments2;
                        const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
                        f = "fillOutlinePattern" === p && u ? wn(w, t, d, r, e) : bn(w, e)
                    } else m = y.indexBuffer, _ = y.segments, f = u ? xn(w, t, d, r) : vn(w);
                    t.prepareDrawProgram(t.context, x, g.toUnwrapped()), x.draw(t.context, h, o, t.stencilModeForClipping(g), a, e.CullFaceMode.disabled, f, i.id, y.layoutVertexBuffer, m, _, i.paint, t.transform.zoom, v)
                }
            }

            function Xn(t, n, i, r, o, a, s) {
                const l = t.context, c = l.gl, u = i.paint.get("fill-extrusion-pattern"), d = u.constantOr(1),
                    h = i.getCrossfadeParameters(), p = i.paint.get("fill-extrusion-opacity");
                for (const f of r) {
                    const r = n.getTile(f), m = r.getBucket(i);
                    if (!m) continue;
                    const _ = m.programConfigurations.get(i.id),
                        g = t.useProgram(d ? "fillExtrusionPattern" : "fillExtrusion", _);
                    if (t.terrain) {
                        const e = t.terrain;
                        if (!m.enableTerrain) continue;
                        if (e.setupElevationDraw(r, g, {useMeterToDem: !0}), Jn(l, n, f, m, i, e), !m.centroidVertexBuffer) {
                            const e = g.attributes.a_centroid_pos;
                            void 0 !== e && c.vertexAttrib2f(e, 0, 0)
                        }
                    }
                    d && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), _.updatePaintBuffers(h));
                    const y = u.constantOr(null);
                    if (y && r.imageAtlas) {
                        const e = r.imageAtlas, t = e.patternPositions[y.to.toString()],
                            n = e.patternPositions[y.from.toString()];
                        t && n && _.setConstantPatternPositions(t, n)
                    }
                    const v = t.translatePosMatrix(f.projMatrix, r, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),
                        x = i.paint.get("fill-extrusion-vertical-gradient"),
                        b = d ? yn(v, t, x, p, f, h, r) : gn(v, t, x, p);
                    t.prepareDrawProgram(l, g, f.toUnwrapped()), g.draw(l, l.gl.TRIANGLES, o, a, s, e.CullFaceMode.backCCW, b, i.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, i.paint, t.transform.zoom, _, t.terrain ? m.centroidVertexBuffer : null)
                }
            }

            function Jn(t, n, i, r, o, a) {
                const s = [t => {
                        let n = t.canonical.x - 1, i = t.wrap;
                        return n < 0 && (n = (1 << t.canonical.z) - 1, i--), new e.OverscaledTileID(t.overscaledZ, i, t.canonical.z, n, t.canonical.y)
                    }, t => {
                        let n = t.canonical.x + 1, i = t.wrap;
                        return n === 1 << t.canonical.z && (n = 0, i++), new e.OverscaledTileID(t.overscaledZ, i, t.canonical.z, n, t.canonical.y)
                    }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],
                    l = e => {
                        const t = n.getSource().maxzoom, i = e => {
                            const t = n.getTileByID(e);
                            if (t && t.hasData()) return t.getBucket(o)
                        };
                        let r, a, s;
                        return (e.overscaledZ === e.canonical.z || e.overscaledZ >= t) && (r = i(e.key)), e.overscaledZ >= t && (a = i(e.calculateScaledKey(e.overscaledZ + 1))), e.overscaledZ > t && (s = i(e.calculateScaledKey(e.overscaledZ - 1))), r || a || s
                    }, c = [0, 0, 0],
                    u = (t, n) => (c[0] = Math.min(t.min.y, n.min.y), c[1] = Math.max(t.max.y, n.max.y), c[2] = e.EXTENT - n.min.x > t.max.x ? n.min.x - e.EXTENT : t.max.x, c),
                    d = (t, n) => (c[0] = Math.min(t.min.x, n.min.x), c[1] = Math.max(t.max.x, n.max.x), c[2] = e.EXTENT - n.min.y > t.max.y ? n.min.y - e.EXTENT : t.max.y, c),
                    h = [(e, t) => u(e, t), (e, t) => u(t, e), (e, t) => d(e, t), (e, t) => d(t, e)],
                    p = new e.pointGeometry(0, 0);
                let f, m, _;
                const g = (t, n, r, o, s) => {
                    const l = [[o ? r : t, o ? t : r, 0], [o ? r : n, o ? n : r, 0]], c = s < 0 ? e.EXTENT + s : s,
                        u = [o ? c : (t + n) / 2, o ? (t + n) / 2 : c, 0];
                    return 0 === r && s < 0 || 0 !== r && s > 0 ? a.getForTilePoints(_, [u], !0, m) : l.push(u), a.getForTilePoints(i, l, !0, f), Math.max(l[0][2], l[1][2], u[2]) / a.exaggeration()
                };
                for (let t = 0; t < 4; t++) {
                    const n = r.borders[t];
                    if (0 === n.length && (r.borderDone[t] = !0), r.borderDone[t]) continue;
                    const o = _ = s[t](i), c = l(o);
                    if (!c || !c.enableTerrain) continue;
                    if (m = a.findDEMTileFor(o), !m || !m.dem) continue;
                    if (!f) {
                        const e = a.findDEMTileFor(i);
                        if (!e || !e.dem) return;
                        f = e
                    }
                    const u = (t < 2 ? 1 : 5) - t, d = c.borders[u];
                    let y = 0;
                    for (let i = 0; i < n.length; i++) {
                        const o = r.featuresOnBorder[n[i]], a = o.borders[t];
                        let s;
                        for (; y < d.length && (s = c.featuresOnBorder[d[y]], !(s.borders[u][1] > a[0] + 3));) c.borderDone[u] || c.encodeCentroid(void 0, s, !1), y++;
                        if (s && y < d.length) {
                            const n = y;
                            let i = 0;
                            for (; !(s.borders[u][0] > a[1] - 3) && (i++, ++y !== d.length);) s = c.featuresOnBorder[d[y]];
                            if (s = c.featuresOnBorder[d[n]], o.intersectsCount() > 1 || s.intersectsCount() > 1 || 1 !== i) {
                                1 !== i && (y = n), r.encodeCentroid(void 0, o, !1), c.borderDone[u] || c.encodeCentroid(void 0, s, !1);
                                continue
                            }
                            const l = h[t](o, s), f = t % 2 ? e.EXTENT - 1 : 0;
                            p.x = g(l[0], Math.min(e.EXTENT - 1, l[1]), f, t < 2, l[2]), p.y = 0, r.encodeCentroid(p, o, !1), c.borderDone[u] || c.encodeCentroid(p, s, !1)
                        } else r.encodeCentroid(void 0, o, !1)
                    }
                    r.borderDone[t] = r.needsCentroidUpdate = !0, c.borderDone[u] || (c.borderDone[u] = c.needsCentroidUpdate = !0)
                }
                (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t)
            }

            const Kn = new e.Color(1, 0, 0, 1), Qn = new e.Color(0, 1, 0, 1), ei = new e.Color(0, 0, 1, 1),
                ti = new e.Color(1, 0, 1, 1), ni = new e.Color(0, 1, 1, 1);

            function ii(e, t, n, i) {
                oi(e, 0, t + n / 2, e.transform.width, n, i)
            }

            function ri(e, t, n, i) {
                oi(e, t - n / 2, 0, n, e.transform.height, i)
            }

            function oi(t, n, i, r, o, a) {
                const s = t.context, l = s.gl;
                l.enable(l.SCISSOR_TEST), l.scissor(n * e.exported.devicePixelRatio, i * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio), s.clear({color: a}), l.disable(l.SCISSOR_TEST)
            }

            function ai(t, n, i) {
                const r = t.context, o = r.gl, a = i.projMatrix, s = t.useProgram("debug"), l = n.getTileByID(i.key);
                t.terrain && t.terrain.setupElevationDraw(l, s);
                const c = e.DepthMode.disabled, u = e.StencilMode.disabled, d = t.colorModeForRenderPass(),
                    h = "$debug";
                r.activeTexture.set(o.TEXTURE0), t.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE), l._makeDebugTileBoundsBuffers(t.context, t.transform.projection);
                const p = l._tileDebugBuffer || t.debugBuffer, f = l._tileDebugIndexBuffer || t.debugIndexBuffer,
                    m = l._tileDebugSegments || t.debugSegments;
                s.draw(r, o.LINE_STRIP, c, u, d, e.CullFaceMode.disabled, Sn(a, e.Color.red), h, p, f, m);
                const _ = l.latestRawTileData, g = Math.floor((_ && _.byteLength || 0) / 1024),
                    y = n.getTile(i).tileSize, v = 512 / Math.min(y, 512) * (i.overscaledZ / t.transform.zoom) * .5;
                let x = i.canonical.toString();
                i.overscaledZ !== i.canonical.z && (x += " => " + i.overscaledZ), function (e, t) {
                    e.initDebugOverlayCanvas();
                    const n = e.debugOverlayCanvas, i = e.context.gl, r = e.debugOverlayCanvas.getContext("2d");
                    r.clearRect(0, 0, n.width, n.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(n), e.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
                }(t, `${x} ${g}kb`), s.draw(r, o.TRIANGLES, c, u, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Sn(a, e.Color.transparent, v), h, t.debugBuffer, t.quadTriangleIndexBuffer, t.debugSegments)
            }

            const si = e.createLayout([{name: "a_pos_3f", components: 3, type: "Float32"}]), {members: li} = si;

            function ci(e, t, n, i) {
                e.emplaceBack(t, n, i)
            }

            class ui {
                constructor(t) {
                    this.vertexArray = new e.StructArrayLayout3f12, this.indices = new e.StructArrayLayout3ui6, ci(this.vertexArray, -1, -1, 1), ci(this.vertexArray, 1, -1, 1), ci(this.vertexArray, -1, 1, 1), ci(this.vertexArray, 1, 1, 1), ci(this.vertexArray, -1, -1, -1), ci(this.vertexArray, 1, -1, -1), ci(this.vertexArray, -1, 1, -1), ci(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, li), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12)
                }
            }

            function di(t, n, i, r, o, a) {
                const s = t.gl, l = n.paint.get("sky-atmosphere-color"), c = n.paint.get("sky-atmosphere-halo-color"),
                    u = n.paint.get("sky-atmosphere-sun-intensity"), d = ((e, t, n, i, r) => ({
                        u_matrix_3f: e,
                        u_sun_direction: t,
                        u_sun_intensity: n,
                        u_color_tint_r: [i.r, i.g, i.b, i.a],
                        u_color_tint_m: [r.r, r.g, r.b, r.a],
                        u_luminance: 5e-5
                    }))(e.fromMat4([], r), o, u, l, c);
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + a, n.skyboxTexture, 0), i.draw(t, s.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, d, "skyboxCapture", n.skyboxGeometry.vertexBuffer, n.skyboxGeometry.indexBuffer, n.skyboxGeometry.segment)
            }

            const hi = {
                symbol: function (t, n, i, r, o) {
                    if ("translucent" !== t.renderPass) return;
                    const a = e.StencilMode.disabled, s = t.colorModeForRenderPass();
                    i.layout.get("text-variable-anchor") && function (t, n, i, r, o, a, s) {
                        const l = n.transform, c = "map" === o, u = "map" === a,
                            d = l.projection.createTileTransform(l, l.worldSize);
                        for (const o of t) {
                            const t = r.getTile(o), a = t.getBucket(i);
                            if (!a || a.projection !== l.projection.name || !a.text || !a.text.segments.get().length) continue;
                            const h = e.evaluateSizeForZoom(a.textSizeData, l.zoom),
                                p = n.transform.calculatePixelsToTileUnitsMatrix(t),
                                f = Ge(o.projMatrix, t.tileID.canonical, u, c, n.transform, p),
                                m = "none" !== i.layout.get("icon-text-fit") && a.hasIconData();
                            if (h) {
                                const n = Math.pow(2, l.zoom - t.tileID.overscaledZ);
                                Vn(a, c, u, s, e.symbolSize, l, f, o, n, h, m, d)
                            }
                        }
                    }(r, t, i, n, i.layout.get("text-rotation-alignment"), i.layout.get("text-pitch-alignment"), o), 0 !== i.paint.get("icon-opacity").constantOr(1) && qn(t, n, i, r, !1, i.paint.get("icon-translate"), i.paint.get("icon-translate-anchor"), i.layout.get("icon-rotation-alignment"), i.layout.get("icon-pitch-alignment"), i.layout.get("icon-keep-upright"), a, s), 0 !== i.paint.get("text-opacity").constantOr(1) && qn(t, n, i, r, !0, i.paint.get("text-translate"), i.paint.get("text-translate-anchor"), i.layout.get("text-rotation-alignment"), i.layout.get("text-pitch-alignment"), i.layout.get("text-keep-upright"), a, s), n.map.showCollisionBoxes && (Nn(t, n, i, r, i.paint.get("text-translate"), i.paint.get("text-translate-anchor"), !0), Nn(t, n, i, r, i.paint.get("icon-translate"), i.paint.get("icon-translate-anchor"), !1))
                }, circle: function (t, n, i, r) {
                    if ("translucent" !== t.renderPass) return;
                    const o = i.paint.get("circle-opacity"), a = i.paint.get("circle-stroke-width"),
                        s = i.paint.get("circle-stroke-opacity"),
                        l = void 0 !== i.layout.get("circle-sort-key").constantOr(1);
                    if (0 === o.constantOr(1) && (0 === a.constantOr(1) || 0 === s.constantOr(1))) return;
                    const c = t.context, u = c.gl, d = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                        h = e.StencilMode.disabled, p = t.colorModeForRenderPass(), f = [];
                    for (let o = 0; o < r.length; o++) {
                        const a = r[o], s = n.getTile(a), c = s.getBucket(i);
                        if (!c) continue;
                        const u = c.programConfigurations.get(i.id), d = Tn(i), h = {
                            programConfiguration: u,
                            program: t.useProgram("circle", u, d),
                            layoutVertexBuffer: c.layoutVertexBuffer,
                            indexBuffer: c.indexBuffer,
                            uniformValues: Mn(t, a, s, i),
                            tile: s
                        };
                        if (l) {
                            const t = c.segments.get();
                            for (const n of t) f.push({
                                segments: new e.SegmentVector([n]),
                                sortKey: n.sortKey,
                                state: h
                            })
                        } else f.push({segments: c.segments, sortKey: 0, state: h})
                    }
                    l && f.sort((e, t) => e.sortKey - t.sortKey);
                    const m = {useDepthForOcclusion: !("globe" === t.transform.projection.name)};
                    for (const n of f) {
                        const {
                            programConfiguration: r,
                            program: o,
                            layoutVertexBuffer: a,
                            indexBuffer: s,
                            uniformValues: l,
                            tile: f
                        } = n.state, _ = n.segments;
                        t.terrain && t.terrain.setupElevationDraw(f, o, m), t.prepareDrawProgram(c, o, f.tileID.toUnwrapped()), o.draw(c, u.TRIANGLES, d, h, p, e.CullFaceMode.disabled, l, i.id, a, s, _, i.paint, t.transform.zoom, r)
                    }
                }, heatmap: function (t, n, i, r) {
                    if (0 !== i.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) {
                        const o = t.context, a = o.gl, s = e.StencilMode.disabled,
                            l = new e.ColorMode([a.ONE, a.ONE], e.Color.transparent, [!0, !0, !0, !0]);
                        !function (e, t, n) {
                            const i = e.gl;
                            e.activeTexture.set(i.TEXTURE1), e.viewport.set([0, 0, t.width / 4, t.height / 4]);
                            let r = n.heatmapFbo;
                            if (r) i.bindTexture(i.TEXTURE_2D, r.colorAttachment.get()), e.bindFramebuffer.set(r.framebuffer); else {
                                const o = i.createTexture();
                                i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), r = n.heatmapFbo = e.createFramebuffer(t.width / 4, t.height / 4, !1), function (e, t, n, i) {
                                    const r = e.gl;
                                    r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, t.width / 4, t.height / 4, 0, r.RGBA, e.extRenderToTextureHalfFloat ? e.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), i.colorAttachment.set(n)
                                }(e, t, o, r)
                            }
                        }(o, t, i), o.clear({color: e.Color.transparent});
                        for (let c = 0; c < r.length; c++) {
                            const u = r[c];
                            if (n.hasRenderableParent(u)) continue;
                            const d = n.getTile(u), h = d.getBucket(i);
                            if (!h) continue;
                            const p = h.programConfigurations.get(i.id),
                                f = t.useProgram("heatmap", p), {zoom: m} = t.transform;
                            t.terrain && t.terrain.setupElevationDraw(d, f), t.prepareDrawProgram(o, f, u.toUnwrapped()), f.draw(o, a.TRIANGLES, e.DepthMode.disabled, s, l, e.CullFaceMode.disabled, Dn(u.projMatrix, d, m, i.paint.get("heatmap-intensity")), i.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, i.paint, t.transform.zoom, p)
                        }
                        o.viewport.set([0, 0, t.width, t.height])
                    } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, n) {
                        const i = t.context, r = i.gl, o = n.heatmapFbo;
                        if (!o) return;
                        i.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, o.colorAttachment.get()), i.activeTexture.set(r.TEXTURE1);
                        let a = n.colorRampTexture;
                        a || (a = n.colorRampTexture = new e.Texture(i, n.colorRamp, r.RGBA)), a.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram("heatmapTexture").draw(i, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, n, i) => ({
                            u_image: 0,
                            u_color_ramp: 1,
                            u_opacity: t.paint.get("heatmap-opacity")
                        }))(0, n), n.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, n.paint, t.transform.zoom)
                    }(t, i))
                }, line: function (t, n, i, r) {
                    if ("translucent" !== t.renderPass) return;
                    const o = i.paint.get("line-opacity"), a = i.paint.get("line-width");
                    if (0 === o.constantOr(1) || 0 === a.constantOr(1)) return;
                    const s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly), l = t.colorModeForRenderPass(),
                        c = i.paint.get("line-dasharray"), u = c.constantOr(1), d = i.layout.get("line-cap"),
                        h = i.paint.get("line-pattern"), p = h.constantOr(1), f = i.paint.get("line-gradient"),
                        m = i.getCrossfadeParameters(), _ = p ? "linePattern" : "line", g = t.context, y = g.gl,
                        v = (e => {
                            const t = [];
                            In(e) && t.push("RENDER_LINE_DASH"), e.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT");
                            const n = e.paint.get("line-pattern").constantOr(1),
                                i = 1 !== e.paint.get("line-opacity").constantOr(1);
                            return !n && i && t.push("RENDER_LINE_ALPHA_DISCARD"), t
                        })(i);
                    let x = v.includes("RENDER_LINE_ALPHA_DISCARD");
                    t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (x = !1);
                    for (const o of r) {
                        const r = n.getTile(o);
                        if (p && !r.patternsLoaded()) continue;
                        const a = r.getBucket(i);
                        if (!a) continue;
                        t.prepareDrawTile(o);
                        const b = a.programConfigurations.get(i.id), w = t.useProgram(_, b, v), M = h.constantOr(null);
                        if (M && r.imageAtlas) {
                            const e = r.imageAtlas, t = e.patternPositions[M.to.toString()],
                                n = e.patternPositions[M.from.toString()];
                            t && n && b.setConstantPatternPositions(t, n)
                        }
                        const T = c.constantOr(null), k = d.constantOr(null);
                        if (!p && T && k && r.lineAtlas) {
                            const e = r.lineAtlas, t = e.getDash(T.to, k), n = e.getDash(T.from, k);
                            t && n && b.setConstantPatternPositions(t, n)
                        }
                        const S = t.terrain ? o.projMatrix : null,
                            D = p ? En(t, r, i, m, S) : Ln(t, r, i, m, S, a.lineClipsArray.length);
                        if (f) {
                            const r = a.gradients[i.id];
                            let s = r.texture;
                            if (i.gradientVersion !== r.version) {
                                let l = 256;
                                if (i.stepInterpolant) {
                                    const i = n.getSource().maxzoom,
                                        r = o.canonical.z === i ? Math.ceil(1 << t.transform.maxZoom - o.canonical.z) : 1;
                                    l = e.clamp(e.nextPowerOfTwo(a.maxLineLength / e.EXTENT * 1024 * r), 256, g.maxTextureSize)
                                }
                                r.gradient = e.renderColorRamp({
                                    expression: i.gradientExpression(),
                                    evaluationKey: "lineProgress",
                                    resolution: l,
                                    image: r.gradient || void 0,
                                    clips: a.lineClipsArray
                                }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(g, r.gradient, y.RGBA), r.version = i.gradientVersion, s = r.texture
                            }
                            g.activeTexture.set(y.TEXTURE1), s.bind(i.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE)
                        }
                        u && (g.activeTexture.set(y.TEXTURE0), r.lineAtlasTexture.bind(y.LINEAR, y.REPEAT), b.updatePaintBuffers(m)), p && (g.activeTexture.set(y.TEXTURE0), r.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), b.updatePaintBuffers(m)), t.prepareDrawProgram(g, w, o.toUnwrapped());
                        const L = n => {
                            w.draw(g, y.TRIANGLES, s, n, l, e.CullFaceMode.disabled, D, i.id, a.layoutVertexBuffer, a.indexBuffer, a.segments, i.paint, t.transform.zoom, b, a.layoutVertexBuffer2)
                        };
                        if (x) {
                            const n = t.stencilModeForClipping(o).ref;
                            0 === n && t.terrain && g.clear({stencil: 0});
                            const i = {func: y.EQUAL, mask: 255};
                            D.u_alpha_discard_threshold = .8, L(new e.StencilMode(i, n, 255, y.KEEP, y.KEEP, y.INVERT)), D.u_alpha_discard_threshold = 0, L(new e.StencilMode(i, n, 255, y.KEEP, y.KEEP, y.KEEP))
                        } else L(t.stencilModeForClipping(o))
                    }
                    x && (t.resetStencilClippingMasks(), t.terrain && g.clear({stencil: 0}))
                }, fill: function (t, n, i, r) {
                    const o = i.paint.get("fill-color"), a = i.paint.get("fill-opacity");
                    if (0 === a.constantOr(1)) return;
                    const s = t.colorModeForRenderPass(), l = i.paint.get("fill-pattern"),
                        c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === o.constantOr(e.Color.transparent).a && 1 === a.constantOr(0) ? "opaque" : "translucent";
                    if (t.renderPass === c) {
                        const o = t.depthModeForSublayer(1, "opaque" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
                        $n(t, n, i, r, o, s, !1)
                    }
                    if ("translucent" === t.renderPass && i.paint.get("fill-antialias")) {
                        const o = t.depthModeForSublayer(i.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
                        $n(t, n, i, r, o, s, !0)
                    }
                }, "fill-extrusion": function (t, n, i, r) {
                    const o = i.paint.get("fill-extrusion-opacity");
                    if (0 !== o && "translucent" === t.renderPass) {
                        const a = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
                        if (1 !== o || i.paint.get("fill-extrusion-pattern").constantOr(1)) Xn(t, n, i, r, a, e.StencilMode.disabled, e.ColorMode.disabled), Xn(t, n, i, r, a, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks(); else {
                            const o = t.colorModeForRenderPass();
                            Xn(t, n, i, r, a, e.StencilMode.disabled, o)
                        }
                    }
                }, hillshade: function (t, n, i, r) {
                    if ("offscreen" !== t.renderPass && "translucent" !== t.renderPass) return;
                    const o = t.context, a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                        s = t.colorModeForRenderPass(),
                        l = t.terrain && t.terrain.renderingToTexture, [c, u] = "translucent" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);
                    for (const r of u) {
                        const o = n.getTile(r);
                        if (o.needsHillshadePrepare && "offscreen" === t.renderPass) Qt(t, o, i, a, e.StencilMode.disabled, s); else if ("translucent" === t.renderPass) {
                            const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
                            Jt(t, r, o, i, a, e, s)
                        }
                    }
                    o.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks()
                }, raster: function (t, n, i, r, o, a) {
                    if ("translucent" !== t.renderPass) return;
                    if (0 === i.paint.get("raster-opacity")) return;
                    if (!r.length) return;
                    const s = t.context, l = s.gl, c = n.getSource(), u = t.useProgram("raster"),
                        d = t.colorModeForRenderPass(),
                        h = t.terrain && t.terrain.renderingToTexture, [p, f] = c instanceof be || h ? [{}, r] : t.stencilConfigForOverlap(r),
                        m = f[f.length - 1].overscaledZ, _ = !t.options.moving;
                    for (const r of f) {
                        const o = h ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === i.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),
                            f = r.toUnwrapped(), g = n.getTile(r);
                        if (h && (!g || !g.hasData())) continue;
                        const y = h ? r.projMatrix : t.transform.calculateProjMatrix(f, _),
                            v = t.terrain && h ? t.terrain.stencilModeForRTTOverlap(r) : p[r.overscaledZ],
                            x = a ? 0 : i.paint.get("raster-fade-duration");
                        g.registerFadeDuration(x);
                        const b = n.findLoadedParent(r, 0), w = cn(g, b, n, t.transform, x);
                        let M, T;
                        t.terrain && t.terrain.prepareDrawTile(r);
                        const k = "nearest" === i.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                        s.activeTexture.set(l.TEXTURE0), g.texture.bind(k, l.CLAMP_TO_EDGE), s.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(k, l.CLAMP_TO_EDGE), M = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), T = [g.tileID.canonical.x * M % 1, g.tileID.canonical.y * M % 1]) : g.texture.bind(k, l.CLAMP_TO_EDGE);
                        const S = Pn(y, T || [0, 0], M || 1, w, i, c instanceof be ? c.perspectiveTransform : [0, 0]);
                        if (t.prepareDrawProgram(s, u, f), c instanceof be) u.draw(s, l.TRIANGLES, o, e.StencilMode.disabled, d, e.CullFaceMode.disabled, S, i.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments); else {
                            const {
                                tileBoundsBuffer: n,
                                tileBoundsIndexBuffer: r,
                                tileBoundsSegments: a
                            } = t.getTileBoundsBuffers(g);
                            u.draw(s, l.TRIANGLES, o, v, d, e.CullFaceMode.disabled, S, i.id, n, r, a)
                        }
                    }
                    t.resetStencilClippingMasks()
                }, background: function (t, n, i, r) {
                    const o = i.paint.get("background-color"), a = i.paint.get("background-opacity");
                    if (0 === a) return;
                    const s = t.context, l = s.gl, c = t.transform, u = c.tileSize,
                        d = i.paint.get("background-pattern");
                    if (t.isPatternMissing(d)) return;
                    const h = !d && 1 === o.a && 1 === a && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (t.renderPass !== h) return;
                    const p = e.StencilMode.disabled,
                        f = t.depthModeForSublayer(0, "opaque" === h ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),
                        m = t.colorModeForRenderPass(), _ = t.useProgram(d ? "backgroundPattern" : "background");
                    let g, y = r;
                    y || (g = t.getBackgroundTiles(), y = Object.values(g).map(e => e.tileID)), d && (s.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));
                    const v = i.getCrossfadeParameters();
                    for (const h of y) {
                        const y = h.toUnwrapped(), x = r ? h.projMatrix : t.transform.calculateProjMatrix(y);
                        t.prepareDrawTile(h);
                        const b = n ? n.getTile(h) : g ? g[h.key] : new e.Tile(h, u, c.zoom, t),
                            w = d ? Bn(x, a, t, d, {tileID: h, tileSize: u}, v) : Fn(x, a, o);
                        t.prepareDrawProgram(s, _, y);
                        const {
                            tileBoundsBuffer: M,
                            tileBoundsIndexBuffer: T,
                            tileBoundsSegments: k
                        } = t.getTileBoundsBuffers(b);
                        _.draw(s, l.TRIANGLES, f, p, m, e.CullFaceMode.disabled, w, i.id, M, T, k)
                    }
                }, sky: function (t, n, i) {
                    const r = t.transform,
                        o = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),
                        a = i.paint.get("sky-opacity") * o;
                    if (0 === a) return;
                    const s = t.context, l = i.paint.get("sky-type"),
                        c = new e.DepthMode(s.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), u = t.frameCounter / 1e3 % 1;
                    "atmosphere" === l ? "offscreen" === t.renderPass ? i.needsSkyboxCapture(t) && (function (t, n, i, r) {
                        const o = t.context, a = o.gl;
                        let s = n.skyboxFbo;
                        if (!s) {
                            s = n.skyboxFbo = o.createFramebuffer(32, 32, !1), n.skyboxGeometry = new ui(o), n.skyboxTexture = o.gl.createTexture(), a.bindTexture(a.TEXTURE_CUBE_MAP, n.skyboxTexture), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MAG_FILTER, a.LINEAR);
                            for (let e = 0; e < 6; ++e) a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, a.RGBA, 32, 32, 0, a.RGBA, a.UNSIGNED_BYTE, null)
                        }
                        o.bindFramebuffer.set(s.framebuffer), o.viewport.set([0, 0, 32, 32]);
                        const l = n.getCenter(t, !0), c = t.useProgram("skyboxCapture"), u = new Float64Array(16);
                        e.identity(u), e.rotateY(u, u, .5 * -Math.PI), di(o, n, c, u, l, 0), e.identity(u), e.rotateY(u, u, .5 * Math.PI), di(o, n, c, u, l, 1), e.identity(u), e.rotateX(u, u, .5 * -Math.PI), di(o, n, c, u, l, 2), e.identity(u), e.rotateX(u, u, .5 * Math.PI), di(o, n, c, u, l, 3), e.identity(u), di(o, n, c, u, l, 4), e.identity(u), e.rotateY(u, u, Math.PI), di(o, n, c, u, l, 5), o.viewport.set([0, 0, t.width, t.height])
                    }(t, i), i.markSkyboxValid(t)) : "sky" === t.renderPass && function (t, n, i, r, o) {
                        const a = t.context, s = a.gl, l = t.transform, c = t.useProgram("skybox");
                        a.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_CUBE_MAP, n.skyboxTexture);
                        const u = ((e, t, n, i, r) => ({
                            u_matrix: e,
                            u_sun_direction: t,
                            u_cubemap: 0,
                            u_opacity: i,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, n.getCenter(t, !1), 0, r, o);
                        t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, i, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, u, "skybox", n.skyboxGeometry.vertexBuffer, n.skyboxGeometry.indexBuffer, n.skyboxGeometry.segment)
                    }(t, i, c, a, u) : "gradient" === l && "sky" === t.renderPass && function (t, n, i, r, o) {
                        const a = t.context, s = a.gl, l = t.transform, c = t.useProgram("skyboxGradient");
                        n.skyboxGeometry || (n.skyboxGeometry = new ui(a)), a.activeTexture.set(s.TEXTURE0);
                        let u = n.colorRampTexture;
                        u || (u = n.colorRampTexture = new e.Texture(a, n.colorRamp, s.RGBA)), u.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                        const d = ((t, n, i, r, o) => ({
                            u_matrix: t,
                            u_color_ramp: 0,
                            u_center_direction: n,
                            u_radius: e.degToRad(i),
                            u_opacity: r,
                            u_temporal_offset: o
                        }))(l.skyboxMatrix, n.getCenter(t, !1), n.paint.get("sky-gradient-radius"), r, o);
                        t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, i, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, d, "skyboxGradient", n.skyboxGeometry.vertexBuffer, n.skyboxGeometry.indexBuffer, n.skyboxGeometry.segment)
                    }(t, i, c, a, u)
                }, debug: function (e, t, n) {
                    for (let i = 0; i < n.length; i++) ai(e, t, n[i])
                }, custom: function (t, n, i) {
                    const r = t.context, o = i.implementation;
                    if (t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes("custom")) e.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers."); else if ("offscreen" === t.renderPass) {
                        const e = o.prerender;
                        e && (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), e.call(o, r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState())
                    } else if ("translucent" === t.renderPass) {
                        t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(e.StencilMode.disabled);
                        const n = "3d" === o.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);
                        r.setDepthMode(n), o.render(r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null)
                    }
                }
            };

            class pi {
                constructor(t, n) {
                    this.context = new pe(t), this.transform = n, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Rt, this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}
                }

                updateTerrain(e, t) {
                    const n = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                    if (!(n || this._terrain && this._terrain.enabled)) return;
                    this._terrain || (this._terrain = new pn(this, e));
                    const i = this._terrain;
                    this.transform.elevation = n ? i : null, i.update(e, this.transform, t)
                }

                _updateFog(e) {
                    const t = e.fog;
                    if (!t || t.getOpacity(this.transform.pitch) < 1 || t.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                    const [n, i] = t.getFovAdjustedRange(this.transform._fov);
                    if (n > i) return void (this.transform.fogCullDistSq = null);
                    const r = n + .78 * (i - n);
                    this.transform.fogCullDistSq = r * r
                }

                get terrain() {
                    return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null
                }

                resize(t, n) {
                    if (this.width = t * e.exported.devicePixelRatio, this.height = n * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize()
                }

                setup() {
                    const t = this.context, n = new e.StructArrayLayout2i4;
                    n.emplaceBack(0, 0), n.emplaceBack(e.EXTENT, 0), n.emplaceBack(0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(n, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
                    const i = new e.StructArrayLayout2i4;
                    i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
                    const r = new e.StructArrayLayout2i4;
                    r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
                    const o = new e.StructArrayLayout4i8;
                    o.emplaceBack(0, 0, 0, 0), o.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), o.emplaceBack(0, e.EXTENT, 0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(o, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
                    const a = new e.StructArrayLayout3ui6;
                    a.emplaceBack(0, 1, 2), a.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(a);
                    const s = new e.StructArrayLayout1ui2;
                    for (const e of [0, 1, 3, 2, 0]) s.emplaceBack(e);
                    this.debugIndexBuffer = t.createIndexBuffer(s), this.emptyTexture = new e.Texture(t, {
                        width: 1,
                        height: 1,
                        data: new Uint8Array([0, 0, 0, 0])
                    }, t.gl.RGBA), this.identityMat = e.create();
                    const l = this.context.gl;
                    this.stencilClearMode = new e.StencilMode({
                        func: l.ALWAYS,
                        mask: 0
                    }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now())
                }

                getMercatorTileBoundsBuffers() {
                    return {
                        tileBoundsBuffer: this.mercatorBoundsBuffer,
                        tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                        tileBoundsSegments: this.mercatorBoundsSegments
                    }
                }

                getTileBoundsBuffers(e) {
                    return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                        tileBoundsBuffer: e._tileBoundsBuffer,
                        tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                        tileBoundsSegments: e._tileBoundsSegments
                    } : this.getMercatorTileBoundsBuffers()
                }

                clearStencil() {
                    const t = this.context, n = t.gl;
                    this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t, n.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, ln(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                }

                resetStencilClippingMasks() {
                    this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {})
                }

                _renderTileClippingMasks(t, n, i) {
                    if (!n || this.currentStencilSource === n.id || !t.isTileClipped() || !i || 0 === i.length) return;
                    if (this._tileClippingMaskIDs && !this.terrain) {
                        let e = !1;
                        for (const t of i) if (void 0 === this._tileClippingMaskIDs[t.key]) {
                            e = !0;
                            break
                        }
                        if (!e) return
                    }
                    this.currentStencilSource = n.id;
                    const r = this.context, o = r.gl;
                    this.nextStencilID + i.length > 256 && this.clearStencil(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
                    const a = this.useProgram("clippingMask");
                    this._tileClippingMaskIDs = {};
                    for (const t of i) {
                        const i = n.getTile(t), s = this._tileClippingMaskIDs[t.key] = this.nextStencilID++, {
                            tileBoundsBuffer: l,
                            tileBoundsIndexBuffer: c,
                            tileBoundsSegments: u
                        } = this.getTileBoundsBuffers(i);
                        a.draw(r, o.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
                            func: o.ALWAYS,
                            mask: 0
                        }, s, 255, o.KEEP, o.KEEP, o.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, ln(t.projMatrix), "$clipping", l, c, u)
                    }
                }

                stencilModeFor3D() {
                    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                    const t = this.nextStencilID++, n = this.context.gl;
                    return new e.StencilMode({func: n.NOTEQUAL, mask: 255}, t, 255, n.KEEP, n.KEEP, n.REPLACE)
                }

                stencilModeForClipping(t) {
                    if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
                    const n = this.context.gl;
                    return new e.StencilMode({
                        func: n.EQUAL,
                        mask: 255
                    }, this._tileClippingMaskIDs[t.key], 0, n.KEEP, n.KEEP, n.REPLACE)
                }

                stencilConfigForOverlap(t) {
                    const n = this.context.gl, i = t.sort((e, t) => t.overscaledZ - e.overscaledZ),
                        r = i[i.length - 1].overscaledZ, o = i[0].overscaledZ - r + 1;
                    if (o > 1) {
                        this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil();
                        const t = {};
                        for (let i = 0; i < o; i++) t[i + r] = new e.StencilMode({
                            func: n.GEQUAL,
                            mask: 255
                        }, i + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
                        return this.nextStencilID += o, [t, i]
                    }
                    return [{[r]: e.StencilMode.disabled}, i]
                }

                colorModeForRenderPass() {
                    const t = this.context.gl;
                    if (this._showOverdrawInspector) {
                        const n = 1 / 8;
                        return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(n, n, n, 0), [!0, !0, !0, !0])
                    }
                    return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended
                }

                depthModeForSublayer(t, n, i) {
                    if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;
                    const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
                    return new e.DepthMode(i || this.context.gl.LEQUAL, n, [r, r])
                }

                opaquePassEnabledForLayer() {
                    return this.currentLayer < this.opaquePassCutoff
                }

                render(t, n) {
                    this.style = t, this.options = n, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
                    const i = this.style.order, r = this.style._sourceCaches;
                    for (const e in r) {
                        const t = r[e];
                        t.used && t.prepare(this.context)
                    }
                    const o = {}, a = {}, s = {};
                    for (const e in r) {
                        const t = r[e];
                        o[e] = t.getVisibleCoordinates(), a[e] = o[e].slice().reverse(), s[e] = t.getVisibleCoordinates(!0).reverse()
                    }
                    this.opaquePassCutoff = 1 / 0;
                    for (let e = 0; e < i.length; e++) if (this.style._layers[i[e]].is3D()) {
                        this.opaquePassCutoff = e;
                        break
                    }
                    if (this.terrain && (this.terrain.updateTileBinding(s), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl)) return;
                    this.renderPass = "offscreen";
                    for (const e of i) {
                        const n = this.style._layers[e], i = t._getLayerSourceCache(n);
                        if (!n.hasOffscreenPass() || n.isHidden(this.transform.zoom)) continue;
                        const r = i ? a[i.id] : void 0;
                        ("custom" === n.type || n.isSky() || r && r.length) && this.renderLayer(this, i, n, r)
                    }
                    this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
                    let l = e.Color.transparent;
                    if (this.style.fog && this.style.fog.getOpacity(this.transform.pitch) && (l = this.style.fog.properties.get("color")), this.context.clear({
                        color: n.showOverdrawInspector ? e.Color.black : l,
                        depth: 1
                    }), this.clearStencil(), this._showOverdrawInspector = n.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = i.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                        const e = this.style._layers[i[this.currentLayer]], n = t._getLayerSourceCache(e);
                        if (e.isSky()) continue;
                        const r = n ? a[n.id] : void 0;
                        this._renderTileClippingMasks(e, n, r), this.renderLayer(this, n, e, r)
                    }
                    if (this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < i.length; this.currentLayer++) {
                        const e = this.style._layers[i[this.currentLayer]], n = t._getLayerSourceCache(e);
                        e.isSky() && this.renderLayer(this, n, e, n ? a[n.id] : void 0)
                    }
                    for ("globe" === this.transform.projection.name && function (t) {
                        const n = t.context, i = n.gl, r = t.transform,
                            o = new e.DepthMode(i.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
                            a = t.useProgram("globeAtmosphere"), s = r._camera.getWorldToCamera(r.worldSize, 1),
                            l = r._camera.getCameraToClipPerspective(r._fov, r.width / r.height, r._nearZ, r._farZ),
                            c = e.mul([], s, e.calculateGlobeMatrix(r, r.worldSize)),
                            u = e.mul([], r.labelPlaneMatrix, l), d = e.transformMat4([], [0, 0, 0], c),
                            h = e.add([], d, [r.worldSize / Math.PI / 2, 0, 0]), p = e.transformMat4([], d, u),
                            f = e.transformMat4([], h, u), m = e.length(e.sub([], f, p)),
                            _ = 1 - e.globeToMercatorTransition(r.zoom), g = {
                                u_center: p,
                                u_radius: m,
                                u_screen_size: [r.width, r.height],
                                u_pixel_ratio: e.exported.devicePixelRatio,
                                u_opacity: _,
                                u_fadeout_range: 2,
                                u_start_color: [1, 1, 1],
                                u_end_color: [.0118, .7451, .9882]
                            };
                        t.prepareDrawProgram(n, a);
                        const y = t.globeSharedBuffers;
                        y && a.draw(n, i.TRIANGLES, o, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, g, "skybox", y.atmosphereVertexBuffer, y.atmosphereIndexBuffer, y.atmosphereSegments)
                    }(this), this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < i.length;) {
                        const e = this.style._layers[i[this.currentLayer]], n = t._getLayerSourceCache(e);
                        if (e.isSky()) {
                            ++this.currentLayer;
                            continue
                        }
                        if (this.terrain && this.style.isLayerDraped(e)) {
                            if (e.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;
                                continue
                            }
                            this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                            continue
                        }
                        const r = n ? ("symbol" === e.type ? s : a)[n.id] : void 0;
                        this._renderTileClippingMasks(e, n, n ? o[n.id] : void 0), this.renderLayer(this, n, e, r), ++this.currentLayer
                    }
                    if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
                        let n = null;
                        e.values(this.style._layers).forEach(e => {
                            const i = t._getLayerSourceCache(e);
                            i && !e.isHidden(this.transform.zoom) && (!n || n.getSource().maxzoom < i.getSource().maxzoom) && (n = i)
                        }), n && this.options.showTileBoundaries && hi.debug(this, n, n.getVisibleCoordinates())
                    }
                    this.options.showPadding && function (e) {
                        const t = e.transform.padding;
                        ii(e, e.transform.height - (t.top || 0), 3, Kn), ii(e, t.bottom || 0, 3, Qn), ri(e, t.left || 0, 3, ei), ri(e, e.transform.width - (t.right || 0), 3, ti);
                        const n = e.transform.centerPoint;
                        !function (e, t, n, i) {
                            oi(e, t - 1, n - 10, 2, 20, i), oi(e, t - 10, n - 1, 20, 2, i)
                        }(e, n.x, e.transform.height - n.y, ni)
                    }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy())
                }

                renderLayer(e, t, n, i) {
                    n.isHidden(this.transform.zoom) || ("background" === n.type || "sky" === n.type || "custom" === n.type || i && i.length) && (this.id = n.id, this.gpuTimingStart(n), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(n.type) || hi[n.type](e, t, n, i, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd())
                }

                gpuTimingStart(e) {
                    if (!this.options.gpuTiming) return;
                    const t = this.context.extTimerQuery;
                    let n = this.gpuTimers[e.id];
                    n || (n = this.gpuTimers[e.id] = {
                        calls: 0,
                        cpuTime: 0,
                        query: t.createQueryEXT()
                    }), n.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, n.query)
                }

                gpuTimingEnd() {
                    if (!this.options.gpuTiming) return;
                    const e = this.context.extTimerQuery;
                    e.endQueryEXT(e.TIME_ELAPSED_EXT)
                }

                collectGpuTimers() {
                    const e = this.gpuTimers;
                    return this.gpuTimers = {}, e
                }

                queryGpuTimers(e) {
                    const t = {};
                    for (const n in e) {
                        const i = e[n], r = this.context.extTimerQuery,
                            o = r.getQueryObjectEXT(i.query, r.QUERY_RESULT_EXT) / 1e6;
                        r.deleteQueryEXT(i.query), t[n] = o
                    }
                    return t
                }

                translatePosMatrix(t, n, i, r, o) {
                    if (!i[0] && !i[1]) return t;
                    const a = o ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                    if (a) {
                        const e = Math.sin(a), t = Math.cos(a);
                        i = [i[0] * t - i[1] * e, i[0] * e + i[1] * t]
                    }
                    const s = [o ? i[0] : S(n, i[0], this.transform.zoom), o ? i[1] : S(n, i[1], this.transform.zoom), 0],
                        l = new Float32Array(16);
                    return e.translate(l, t, s), l
                }

                saveTileTexture(e) {
                    const t = this._tileTextures[e.size[0]];
                    t ? t.push(e) : this._tileTextures[e.size[0]] = [e]
                }

                getTileTexture(e) {
                    const t = this._tileTextures[e];
                    return t && t.length > 0 ? t.pop() : null
                }

                isPatternMissing(e) {
                    if (!e) return !1;
                    if (!e.from || !e.to) return !0;
                    const t = this.imageManager.getPattern(e.from.toString()),
                        n = this.imageManager.getPattern(e.to.toString());
                    return !t || !n
                }

                currentGlobalDefines() {
                    const e = this.terrain && this.terrain.renderingToTexture, t = this.style && this.style.fog, n = [];
                    return this.terrain && !this.terrain.renderingToTexture && n.push("TERRAIN"), t && !e && 0 !== t.getOpacity(this.transform.pitch) && n.push("FOG"), e && n.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && n.push("OVERDRAW_INSPECTOR"), n
                }

                useProgram(e, t, n) {
                    this.cache = this.cache || {};
                    const i = n || [], r = this.currentGlobalDefines().concat(i), o = mn.cacheKey(e, r, t);
                    return this.cache[o] || (this.cache[o] = new mn(this.context, e, qt[e], t, jn[e], r)), this.cache[o]
                }

                setCustomLayerDefaults() {
                    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
                }

                setBaseState() {
                    const e = this.context.gl;
                    this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
                }

                initDebugOverlayCanvas() {
                    null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
                }

                destroy() {
                    this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                }

                prepareDrawTile(e) {
                    this.terrain && this.terrain.prepareDrawTile(e)
                }

                prepareDrawProgram(e, t, n) {
                    if (this.terrain && this.terrain.renderingToTexture) return;
                    const i = this.style.fog;
                    if (i) {
                        const r = i.getOpacity(this.transform.pitch);
                        0 !== r && t.setFogUniformValues(e, ((e, t, n, i) => {
                            const r = t.properties.get("color"), o = e.frameCounter / 1e3 % 1,
                                a = [r.r / r.a, r.g / r.a, r.b / r.a, i];
                            return {
                                u_fog_matrix: n ? e.transform.calculateFogTileMatrix(n) : e.identityMat,
                                u_fog_range: t.getFovAdjustedRange(e.transform._fov),
                                u_fog_color: a,
                                u_fog_horizon_blend: t.properties.get("horizon-blend"),
                                u_fog_temporal_offset: o
                            }
                        })(this, i, n, r))
                    }
                }

                setTileLoadedFlag(e) {
                    this.tileLoaded = e
                }

                saveCanvasCopy() {
                    this.frameCopies.push(this.canvasCopy()), this.tileLoaded = !1
                }

                canvasCopy() {
                    const e = this.context.gl, t = e.createTexture();
                    return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t
                }

                getCanvasCopiesAndTimestamps() {
                    return {canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps}
                }

                averageElevationNeedsEasing() {
                    if (!this.transform._elevation) return !1;
                    const e = this.style && this.style.fog;
                    return !!e && 0 !== e.getOpacity(this.transform.pitch)
                }

                getBackgroundTiles() {
                    const t = this._backgroundTiles, n = this._backgroundTiles = {},
                        i = this.transform.coveringTiles({tileSize: 512});
                    for (const r of i) n[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);
                    return n
                }

                clearBackgroundTiles() {
                    this._backgroundTiles = {}
                }
            }

            class fi {
                constructor(e = 0, t = 0, n = 0, i = 0) {
                    if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(n) || n < 0 || isNaN(i) || i < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                    this.top = e, this.bottom = t, this.left = n, this.right = i
                }

                interpolate(t, n, i) {
                    return null != n.top && null != t.top && (this.top = e.number(t.top, n.top, i)), null != n.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, n.bottom, i)), null != n.left && null != t.left && (this.left = e.number(t.left, n.left, i)), null != n.right && null != t.right && (this.right = e.number(t.right, n.right, i)), this
                }

                getCenter(t, n) {
                    const i = e.clamp((this.left + t - this.right) / 2, 0, t),
                        r = e.clamp((this.top + n - this.bottom) / 2, 0, n);
                    return new e.pointGeometry(i, r)
                }

                equals(e) {
                    return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
                }

                clone() {
                    return new fi(this.top, this.bottom, this.left, this.right)
                }

                toJSON() {
                    return {top: this.top, bottom: this.bottom, left: this.left, right: this.right}
                }
            }

            function mi(t, n) {
                const i = e.getColumn(t, 3);
                e.fromQuat(t, n), e.setColumn(t, 3, i)
            }

            function _i(t, n) {
                e.setColumn(t, 3, [n[0], n[1], n[2], 1])
            }

            function gi(t, n) {
                const i = e.identity$1([]);
                return e.rotateZ$1(i, i, -n), e.rotateX$1(i, i, -t), i
            }

            function yi(t, n) {
                const i = [t[0], t[1], 0], r = [n[0], n[1], 0];
                if (e.length(i) >= 1e-15) {
                    const t = e.normalize([], i);
                    e.scale$2(r, t, e.dot(r, t)), n[0] = r[0], n[1] = r[1]
                }
                const o = e.cross([], n, t);
                if (e.len(o) < 1e-15) return null;
                const a = Math.atan2(-o[1], o[0]);
                return gi(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), a)
            }

            class vi {
                constructor(e, t) {
                    this.position = e, this.orientation = t
                }

                get position() {
                    return this._position
                }

                set position(t) {
                    this._position = this._renderWorldCopies ? function (t) {
                        if (!t) return;
                        const n = Array.isArray(t) ? new e.MercatorCoordinate(t[0], t[1], t[2]) : t;
                        return n.x = e.wrap(n.x, 0, 1), n
                    }(t) : t
                }

                lookAtPoint(t, n) {
                    if (this.orientation = null, !this.position) return;
                    const i = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,
                        r = this.position, o = e.MercatorCoordinate.fromLngLat(t, i),
                        a = [o.x - r.x, o.y - r.y, o.z - r.z];
                    n || (n = [0, 0, 1]), n[2] = Math.abs(n[2]), this.orientation = yi(a, n)
                }

                setPitchBearing(t, n) {
                    this.orientation = gi(e.degToRad(t), e.degToRad(-n))
                }
            }

            class xi {
                constructor(t, n) {
                    this._transform = e.identity([]), this._orientation = e.identity$1([]), n && (this._orientation = n, mi(this._transform, this._orientation)), t && _i(this._transform, t)
                }

                get mercatorPosition() {
                    const t = this.position;
                    return new e.MercatorCoordinate(t[0], t[1], t[2])
                }

                get position() {
                    const t = e.getColumn(this._transform, 3);
                    return [t[0], t[1], t[2]]
                }

                set position(e) {
                    _i(this._transform, e)
                }

                get orientation() {
                    return this._orientation
                }

                set orientation(e) {
                    this._orientation = e, mi(this._transform, this._orientation)
                }

                getPitchBearing() {
                    const e = this.forward(), t = this.right();
                    return {
                        bearing: Math.atan2(-t[1], t[0]),
                        pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
                    }
                }

                setPitchBearing(e, t) {
                    this._orientation = gi(e, t), mi(this._transform, this._orientation)
                }

                forward() {
                    const t = e.getColumn(this._transform, 2);
                    return [-t[0], -t[1], -t[2]]
                }

                up() {
                    const t = e.getColumn(this._transform, 1);
                    return [-t[0], -t[1], -t[2]]
                }

                right() {
                    const t = e.getColumn(this._transform, 0);
                    return [t[0], t[1], t[2]]
                }

                getCameraToWorld(t, n) {
                    const i = new Float64Array(16);
                    return e.invert(i, this.getWorldToCamera(t, n)), i
                }

                getWorldToCameraPosition(t, n, i) {
                    const r = this.position;
                    e.scale$2(r, r, -t);
                    const o = new Float64Array(16);
                    return e.fromScaling(o, [i, i, i]), e.translate(o, o, r), o[10] *= n, o
                }

                getWorldToCamera(t, n) {
                    const i = new Float64Array(16), r = new Float64Array(4), o = this.position;
                    return e.conjugate(r, this._orientation), e.scale$2(o, o, -t), e.fromQuat(i, r), e.translate(i, i, o), i[1] *= -1, i[5] *= -1, i[9] *= -1, i[13] *= -1, i[8] *= n, i[9] *= n, i[10] *= n, i[11] *= n, i
                }

                getCameraToClipPerspective(t, n, i, r) {
                    const o = new Float64Array(16);
                    return e.perspective(o, t, n, i, r), o
                }

                getDistanceToElevation(t) {
                    const n = 0 === t ? 0 : e.mercatorZfromAltitude(t, this.position[1]), i = this.forward();
                    return (n - this.position[2]) / i[2]
                }

                clone() {
                    return new xi([...this.position], [...this.orientation])
                }
            }

            function bi(t, n) {
                const i = Mi(t), r = function (t, n, i, r, o) {
                    const a = new e.LngLat(i.lng - 180 * Ti, i.lat), s = new e.LngLat(i.lng + 180 * Ti, i.lat),
                        l = t.project(a.lng, a.lat), c = t.project(s.lng, s.lat), u = -Math.atan2(c.y - l.y, c.x - l.x),
                        d = e.MercatorCoordinate.fromLngLat(i);
                    d.y = e.clamp(d.y, -.999975, .999975);
                    const h = d.toLngLat(), p = t.project(h.lng, h.lat), f = e.MercatorCoordinate.fromLngLat(h);
                    f.x += Ti;
                    const m = f.toLngLat(), _ = t.project(m.lng, m.lat), g = Si(_.x - p.x, _.y - p.y, u),
                        y = e.MercatorCoordinate.fromLngLat(h);
                    y.y += Ti;
                    const v = y.toLngLat(), x = t.project(v.lng, v.lat), b = Si(x.x - p.x, x.y - p.y, u),
                        w = Math.abs(g.x) / Math.abs(b.y), M = e.identity([]);
                    e.rotateZ(M, M, -u * (1 - (o ? 0 : r)));
                    const T = e.identity([]);
                    return e.scale(T, T, [1, 1 - (1 - w) * r, 1]), T[4] = -b.x / b.y * r, e.rotateZ(T, T, u), e.multiply$1(T, M, T), T
                }(t.projection, 0, t.center, i, n), o = wi(t);
                return e.scale(r, r, [o, o, 1]), r
            }

            function wi(t) {
                const n = t.projection, i = Mi(t), r = ki(n, t.center), o = ki(n, e.LngLat.convert(n.center));
                return Math.pow(2, r * i + (1 - i) * o)
            }

            function Mi(t) {
                const n = t.projection.range;
                if (!n) return 0;
                const i = Math.max(t.width, t.height), r = Math.log(i / 1024) / Math.LN2;
                return e.smoothstep(n[0] + r, n[1] + r, t.zoom)
            }

            const Ti = 1 / 4e4;

            function ki(t, n) {
                const i = e.clamp(n.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
                    r = new e.LngLat(n.lng - 180 * Ti, i), o = new e.LngLat(n.lng + 180 * Ti, i),
                    a = t.project(r.lng, i), s = t.project(o.lng, i), l = e.MercatorCoordinate.fromLngLat(r),
                    c = e.MercatorCoordinate.fromLngLat(o), u = s.x - a.x, d = s.y - a.y, h = c.x - l.x, p = c.y - l.y,
                    f = Math.sqrt((h * h + p * p) / (u * u + d * d));
                return Math.log(f) / Math.LN2
            }

            function Si(e, t, n) {
                const i = Math.cos(n), r = Math.sin(n);
                return {x: e * i - t * r, y: e * r + t * i}
            }

            class Di {
                constructor(t, n, i, r, o) {
                    this.tileSize = 512, this._renderWorldCopies = void 0 === o || o, this._minZoom = t || 0, this._maxZoom = n || 22, this._minPitch = null == i ? 0 : i, this._maxPitch = null == r ? 60 : r, this.setProjection(), this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new fi, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new xi, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._projectionScaler = 1, this._horizonShift = .1
                }

                clone() {
                    const e = new Di(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
                    return e.setProjection(this.getProjection()), e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e.tileSize = this.tileSize, e.setMaxBounds(this.getMaxBounds()), e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._cameraZoom = this._cameraZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e
                }

                get elevation() {
                    return this._elevation
                }

                set elevation(e) {
                    this._elevation !== e && (this._elevation = e, e ? this._updateCenterElevation() && this._updateCameraOnTerrain() : (this._cameraZoom = null, this._centerAltitude = 0), this._calcMatrices())
                }

                updateElevation(e) {
                    this._terrainEnabled() && null == this._cameraZoom && this._updateCenterElevation() && this._updateCameraOnTerrain(), e && this._constrainCameraAltitude(), this._calcMatrices()
                }

                getProjection() {
                    return e.pick(this.projection, ["name", "center", "parallels"])
                }

                setProjection(t) {
                    null == t && (t = {name: "mercator"}), this.projectionOptions = t;
                    const n = this.projection ? this.getProjection() : void 0;
                    return this.projection = e.getProjection(t), !o(n, this.getProjection()) && (this._calcMatrices(), !0)
                }

                get minZoom() {
                    return this._minZoom
                }

                set minZoom(e) {
                    this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e))
                }

                get maxZoom() {
                    return this._maxZoom
                }

                set maxZoom(e) {
                    this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e))
                }

                get minPitch() {
                    return this._minPitch
                }

                set minPitch(e) {
                    this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e))
                }

                get maxPitch() {
                    return this._maxPitch
                }

                set maxPitch(e) {
                    this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e))
                }

                get renderWorldCopies() {
                    return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies
                }

                set renderWorldCopies(e) {
                    void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e
                }

                get worldSize() {
                    return this.tileSize * this.scale
                }

                get cameraWorldSize() {
                    const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                    return this._worldSizeFromZoom(this._zoomFromMercatorZ(e))
                }

                get pixelsPerMeter() {
                    return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
                }

                get cameraPixelsPerMeter() {
                    return this.projection.pixelsPerMeter(this.center.lat, this.cameraWorldSize)
                }

                get centerOffset() {
                    return this.centerPoint._sub(this.size._div(2))
                }

                get size() {
                    return new e.pointGeometry(this.width, this.height)
                }

                get bearing() {
                    return e.wrap(this.rotation, -180, 180)
                }

                set bearing(e) {
                    this.rotation = e
                }

                get rotation() {
                    return -this.angle / Math.PI * 180
                }

                set rotation(t) {
                    const n = -t * Math.PI / 180;
                    var i;
                    this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = (i = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (i[1] = 0, i[2] = 0), i[0] = 1, i[3] = 1, i), function (e, t, n) {
                        var i = t[0], r = t[1], o = t[2], a = t[3], s = Math.sin(n), l = Math.cos(n);
                        e[0] = i * l + o * s, e[1] = r * l + a * s, e[2] = i * -s + o * l, e[3] = r * -s + a * l
                    }(this.rotationMatrix, this.rotationMatrix, this.angle))
                }

                get pitch() {
                    return this._pitch / Math.PI * 180
                }

                set pitch(t) {
                    const n = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
                    this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices())
                }

                get fov() {
                    return this._fov / Math.PI * 180
                }

                set fov(e) {
                    e = Math.max(.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices())
                }

                get averageElevation() {
                    return this._averageElevation
                }

                set averageElevation(e) {
                    this._averageElevation = e, this._calcFogMatrices()
                }

                get zoom() {
                    return this._zoom
                }

                set zoom(e) {
                    const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                    this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._terrainEnabled() && this._updateCameraOnTerrain(), this._constrain(), this._calcMatrices())
                }

                _setZoom(e) {
                    this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom
                }

                _updateCenterElevation() {
                    if (!this._elevation) return !1;
                    const e = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center), -1);
                    return -1 === e ? (this._cameraZoom = null, !1) : (this._centerAltitude = e, !0)
                }

                _updateCameraOnTerrain() {
                    this._cameraZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize)
                }

                sampleAverageElevation() {
                    if (!this._elevation) return 0;
                    const t = this._elevation, n = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],
                        i = this.horizonLineFromTop();
                    let r = 0, o = 0;
                    for (let a = 0; a < n.length; a++) {
                        const s = new e.pointGeometry(n[a][0] * this.width, i + n[a][1] * (this.height - i)),
                            l = t.pointCoordinate(s);
                        if (!l) continue;
                        const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                        r += l[3] * c, o += c
                    }
                    return 0 === o ? NaN : r / o
                }

                get center() {
                    return this._center
                }

                set center(e) {
                    e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCenterElevation() ? this._updateCameraOnTerrain() : this._cameraZoom = null : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices())
                }

                _updateZoomFromElevation() {
                    if (null == this._cameraZoom || !this._elevation) return;
                    const e = this._cameraZoom,
                        t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
                        n = this.pixelsPerMeter / this.worldSize * t, i = this._mercatorZfromZoom(e),
                        r = this._mercatorZfromZoom(this._maxZoom), o = Math.max(i - n, r);
                    this._setZoom(this._zoomFromMercatorZ(o))
                }

                get padding() {
                    return this._edgeInsets.toJSON()
                }

                set padding(e) {
                    this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
                }

                computeZoomRelativeTo(t) {
                    const n = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
                    let i;
                    i = t.z < this._camera.position[2] ? [n.x, n.y, n.z] : [t.x, t.y, t.z];
                    const r = e.length(e.sub([], this._camera.position, i));
                    return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom)
                }

                setFreeCameraOptions(t) {
                    if (!this.height) return;
                    if (!t.position && !t.orientation) return;
                    this._updateCameraState();
                    let n = !1;
                    if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (n = this._setCameraOrientation(t.orientation)), t.position) {
                        const i = [t.position.x, t.position.y, t.position.z];
                        e.exactEquals$1(i, this._camera.position) || (this._setCameraPosition(i), n = !0)
                    }
                    n && (this._updateStateFromCamera(), this.recenterOnTerrain())
                }

                getFreeCameraOptions() {
                    this._updateCameraState();
                    const t = this._camera.position, n = new vi;
                    return n.position = new e.MercatorCoordinate(t[0], t[1], t[2]), n.orientation = this._camera.orientation, n._elevation = this.elevation, n._renderWorldCopies = this.renderWorldCopies, n
                }

                _setCameraOrientation(t) {
                    if (!e.length$1(t)) return !1;
                    e.normalize$1(t, t);
                    const n = e.transformQuat([], [0, 0, -1], t), i = e.transformQuat([], [0, -1, 0], t);
                    if (i[2] < 0) return !1;
                    const r = yi(n, i);
                    return !!r && (this._camera.orientation = r, !0)
                }

                _setCameraPosition(t) {
                    const n = this.zoomScale(this.minZoom) * this.tileSize,
                        i = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
                    t[2] = e.clamp(t[2], r / i, r / n), this._camera.position = t
                }

                get centerPoint() {
                    return this._edgeInsets.getCenter(this.width, this.height)
                }

                get fovAboveCenter() {
                    return this._fov * (.5 + this.centerOffset.y / this.height)
                }

                isPaddingEqual(e) {
                    return this._edgeInsets.equals(e)
                }

                interpolatePadding(e, t, n) {
                    this._unmodified = !1, this._edgeInsets.interpolate(e, t, n), this._constrain(), this._calcMatrices()
                }

                coveringZoomLevel(e) {
                    const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                    return Math.max(0, t)
                }

                getVisibleUnwrappedCoordinates(t) {
                    const n = [new e.UnwrappedTileID(0, t)];
                    if (this.renderWorldCopies) {
                        const i = this.pointCoordinate(new e.pointGeometry(0, 0)),
                            r = this.pointCoordinate(new e.pointGeometry(this.width, 0)),
                            o = this.pointCoordinate(new e.pointGeometry(this.width, this.height)),
                            a = this.pointCoordinate(new e.pointGeometry(0, this.height)),
                            s = Math.floor(Math.min(i.x, r.x, o.x, a.x)), l = Math.floor(Math.max(i.x, r.x, o.x, a.x)),
                            c = 1;
                        for (let i = s - c; i <= l + c; i++) 0 !== i && n.push(new e.UnwrappedTileID(i, t))
                    }
                    return n
                }

                coveringTiles(t) {
                    let n = this.coveringZoomLevel(t);
                    const i = n, r = this.elevation && !t.isTerrainDEM, o = "mercator" === this.projection.name;
                    if (void 0 !== t.minzoom && n < t.minzoom) return [];
                    void 0 !== t.maxzoom && n > t.maxzoom && (n = t.maxzoom);
                    const a = this.locationCoordinate(this.center), s = 1 << n, l = [s * a.x, s * a.y, 0],
                        c = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, n, "globe" !== this.projection.name),
                        u = this.pointCoordinate(this.getCameraPoint()),
                        d = s * e.mercatorZfromAltitude(1, this.center.lat),
                        h = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),
                        p = [s * u.x, s * u.y, h],
                        f = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),
                        m = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? n : 0,
                        _ = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,
                        g = t.isTerrainDEM ? -_ : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
                        y = this.projection.isReprojectedInTileSpace ? wi(this) : 1, v = t => {
                            const n = 1 / 4e4, i = new e.MercatorCoordinate(t.x + n, t.y, t.z),
                                r = new e.MercatorCoordinate(t.x, t.y + n, t.z), o = t.toLngLat(), a = i.toLngLat(),
                                s = r.toLngLat(), l = this.locationCoordinate(o), c = this.locationCoordinate(a),
                                u = this.locationCoordinate(s), d = Math.hypot(c.x - l.x, c.y - l.y),
                                h = Math.hypot(u.x - l.x, u.y - l.y);
                            return Math.sqrt(d * h) * y / n
                        }, x = t => {
                            const n = _, i = g;
                            return {
                                aabb: e.tileAABB(this, s, 0, 0, 0, t, i, n, this.projection),
                                zoom: 0,
                                x: 0,
                                y: 0,
                                minZ: i,
                                maxZ: n,
                                wrap: t,
                                fullyVisible: !1
                            }
                        }, b = [];
                    let w = [];
                    const M = n, T = t.reparseOverscaled ? i : n, k = e => e * e, S = k((h - this._centerAltitude) * d),
                        D = e => {
                            if (!this._elevation || !e.tileID || !o) return;
                            const t = this._elevation.getMinMaxForTile(e.tileID), n = e.aabb;
                            t ? (n.min[2] = t.min, n.max[2] = t.max, n.center[2] = (n.min[2] + n.max[2]) / 2) : (e.shouldSplit = L(e), e.shouldSplit || (n.min[2] = n.max[2] = n.center[2] = this._centerAltitude))
                        }, L = t => {
                            if (t.zoom < m) return !0;
                            if (t.zoom === M) return !1;
                            if (null != t.shouldSplit) return t.shouldSplit;
                            const n = t.aabb.distanceX(p), o = t.aabb.distanceY(p);
                            let a = S;
                            r && (a = k(t.aabb.distanceZ(p) * d));
                            let s = 1;
                            if (this.projection.isReprojectedInTileSpace && i <= 5) {
                                const n = Math.pow(2, t.zoom),
                                    i = v(new e.MercatorCoordinate((t.x + .5) / n, (t.y + .5) / n));
                                s = i > .85 ? 1 : i
                            }
                            const l = n * n + o * o + a;
                            return l < k((1 << M - t.zoom) * f * s * ((e, t) => {
                                if (t * k(.707) < e) return 1;
                                const n = Math.sqrt(t / e);
                                return n / (1.4144271570014144 + (Math.pow(1.1, n - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                            })(Math.max(a, S), l))
                        };
                    if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) b.push(x(-e)), b.push(x(e));
                    for (b.push(x(0)); b.length > 0;) {
                        const i = b.pop(), a = i.x, u = i.y;
                        let d = i.fullyVisible;
                        if (!d) {
                            const e = i.aabb.intersects(c);
                            if (0 === e) continue;
                            d = 2 === e
                        }
                        if (i.zoom !== M && L(i)) for (let t = 0; t < 4; t++) {
                            const n = (a << 1) + t % 2, l = (u << 1) + (t >> 1), c = {
                                aabb: o ? i.aabb.quadrant(t) : e.tileAABB(this, s, i.zoom + 1, n, l, i.wrap, i.minZ, i.maxZ, this.projection),
                                zoom: i.zoom + 1,
                                x: n,
                                y: l,
                                wrap: i.wrap,
                                fullyVisible: d,
                                tileID: void 0,
                                shouldSplit: void 0,
                                minZ: i.minZ,
                                maxZ: i.maxZ
                            };
                            r && (c.tileID = new e.OverscaledTileID(i.zoom + 1 === M ? T : i.zoom + 1, i.wrap, i.zoom + 1, n, l), D(c)), b.push(c)
                        } else {
                            const r = i.zoom === M ? T : i.zoom;
                            if (t.minzoom && t.minzoom > r) continue;
                            const o = l[0] - (.5 + a + (i.wrap << i.zoom)) * (1 << n - i.zoom), s = l[1] - .5 - u,
                                c = i.tileID ? i.tileID : new e.OverscaledTileID(r, i.wrap, i.zoom, a, u);
                            w.push({tileID: c, distanceSq: o * o + s * s})
                        }
                    }
                    if (this.fogCullDistSq) {
                        const n = this.fogCullDistSq, i = this.horizonLineFromTop();
                        w = w.filter(r => {
                            const o = [0, 0, 0, 1], a = [e.EXTENT, e.EXTENT, 0, 1],
                                s = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                            e.transformMat4$1(o, o, s), e.transformMat4$1(a, a, s);
                            const l = e.getAABBPointSquareDist(o, a);
                            if (0 === l) return !0;
                            let c = !1;
                            const u = this._elevation;
                            if (u && l > n && 0 !== i) {
                                const n = this.calculateProjMatrix(r.tileID.toUnwrapped());
                                let o;
                                t.isTerrainDEM || (o = u.getMinMaxForTile(r.tileID)), o || (o = {min: g, max: _});
                                const a = e.furthestTileCorner(this.rotation),
                                    s = [a[0] * e.EXTENT, a[1] * e.EXTENT, o.max];
                                e.transformMat4(s, s, n), c = (1 - s[1]) * this.height * .5 < i
                            }
                            return l < n || c
                        })
                    }
                    return w.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID)
                }

                resize(e, t) {
                    this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices()
                }

                get unmodified() {
                    return this._unmodified
                }

                zoomScale(e) {
                    return Math.pow(2, e)
                }

                scaleZoom(e) {
                    return Math.log(e) / Math.LN2
                }

                project(t) {
                    const n = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
                        i = this.projection.project(t.lng, n);
                    return new e.pointGeometry(i.x * this.worldSize, i.y * this.worldSize)
                }

                unproject(e) {
                    return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize)
                }

                get point() {
                    return this.project(this.center)
                }

                setLocationAtPoint(t, n) {
                    const i = this.pointCoordinate(n), r = this.pointCoordinate(this.centerPoint),
                        o = this.locationCoordinate(t);
                    this.setLocation(new e.MercatorCoordinate(o.x - (i.x - r.x), o.y - (i.y - r.y)))
                }

                setLocation(e) {
                    this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap())
                }

                locationPoint(e) {
                    return this.projection.locationPoint(this, e)
                }

                locationPoint3D(e) {
                    return this._coordinatePoint(this.locationCoordinate(e), !0)
                }

                pointLocation(e) {
                    return this.coordinateLocation(this.pointCoordinate(e))
                }

                pointLocation3D(e) {
                    return this.coordinateLocation(this.pointCoordinate3D(e))
                }

                locationCoordinate(t, n) {
                    const i = n ? e.mercatorZfromAltitude(n, t.lat) : void 0, r = this.projection.project(t.lng, t.lat);
                    return new e.MercatorCoordinate(r.x, r.y, i)
                }

                coordinateLocation(e) {
                    return this.projection.unproject(e.x, e.y)
                }

                pointRayIntersection(t, n) {
                    const i = null != n ? n : this._centerAltitude, r = [t.x, t.y, 0, 1], o = [t.x, t.y, 1, 1];
                    e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse);
                    const a = o[3];
                    e.scale$1(r, r, 1 / r[3]), e.scale$1(o, o, 1 / a);
                    const s = r[2], l = o[2];
                    return {p0: r, p1: o, t: s === l ? 0 : (i - s) / (l - s)}
                }

                screenPointToMercatorRay(t) {
                    const n = [t.x, t.y, 0, 1], i = [t.x, t.y, 1, 1];
                    return e.transformMat4$1(n, n, this.pixelMatrixInverse), e.transformMat4$1(i, i, this.pixelMatrixInverse), e.scale$1(n, n, 1 / n[3]), e.scale$1(i, i, 1 / i[3]), n[2] = e.mercatorZfromAltitude(n[2], this._center.lat) * this.worldSize, i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, e.scale$1(n, n, 1 / this.worldSize), e.scale$1(i, i, 1 / this.worldSize), new e.Ray([n[0], n[1], n[2]], e.normalize([], e.sub([], i, n)))
                }

                rayIntersectionCoordinate(t) {
                    const {p0: n, p1: i, t: r} = t, o = e.mercatorZfromAltitude(n[2], this._center.lat),
                        a = e.mercatorZfromAltitude(i[2], this._center.lat);
                    return new e.MercatorCoordinate(e.number(n[0], i[0], r) / this.worldSize, e.number(n[1], i[1], r) / this.worldSize, e.number(o, a, r))
                }

                pointCoordinate(e, t = this._centerAltitude) {
                    return this.projection.createTileTransform(this, this.worldSize).pointCoordinate(e.x, e.y, t)
                }

                pointCoordinate3D(t) {
                    if (!this.elevation) return this.pointCoordinate(t);
                    const n = this.elevation;
                    let i = this.elevation.pointCoordinate(t);
                    if (i) return new e.MercatorCoordinate(i[0], i[1], i[2]);
                    let r = 0, o = this.horizonLineFromTop();
                    if (t.y > o) return this.pointCoordinate(t);
                    const a = .02 * o, s = t.clone();
                    for (let t = 0; t < 10 && o - r > a; t++) {
                        s.y = e.number(r, o, .66);
                        const t = n.pointCoordinate(s);
                        t ? (o = s.y, i = t) : r = s.y
                    }
                    return i ? new e.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t)
                }

                isPointAboveHorizon(e) {
                    if (this.elevation) return !this.elevation.pointCoordinate(e);
                    {
                        const t = this.horizonLineFromTop();
                        return e.y < t
                    }
                }

                _coordinatePoint(t, n) {
                    const i = n && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
                        r = [t.x * this.worldSize, t.y * this.worldSize, i + t.toAltitude(), 1];
                    return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE)
                }

                _getBounds(t, n) {
                    const i = new e.pointGeometry(this._edgeInsets.left, this._edgeInsets.top),
                        r = new e.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top),
                        o = new e.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom),
                        a = new e.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
                    let s = this.pointCoordinate(i, t), l = this.pointCoordinate(r, t);
                    const c = this.pointCoordinate(o, n), u = this.pointCoordinate(a, n),
                        d = (e, t) => (t.y - e.y) / (t.x - e.x);
                    return s.y > 1 && l.y >= 0 ? s = new e.MercatorCoordinate((1 - u.y) / d(u, s) + u.x, 1) : s.y < 0 && l.y <= 1 && (s = new e.MercatorCoordinate(-u.y / d(u, s) + u.x, 0)), l.y > 1 && s.y >= 0 ? l = new e.MercatorCoordinate((1 - c.y) / d(c, l) + c.x, 1) : l.y < 0 && s.y <= 1 && (l = new e.MercatorCoordinate(-c.y / d(c, l) + c.x, 0)), (new e.LngLatBounds).extend(this.coordinateLocation(s)).extend(this.coordinateLocation(l)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(c))
                }

                _getBounds3D() {
                    const e = this.elevation;
                    if (!e.visibleDemTiles.length) return this._getBounds(0, 0);
                    const t = e.visibleDemTiles.reduce((e, t) => {
                        if (t.dem) {
                            const n = t.dem.tree;
                            e.min = Math.min(e.min, n.minimums[0]), e.max = Math.max(e.max, n.maximums[0])
                        }
                        return e
                    }, {min: Number.MAX_VALUE, max: 0});
                    return this._getBounds(t.min * e.exaggeration(), t.max * e.exaggeration())
                }

                getBounds() {
                    return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0)
                }

                horizonLineFromTop(e = !0) {
                    const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,
                        n = this.height / 2 - t * (1 - this._horizonShift);
                    return e ? Math.max(0, n) : n
                }

                getMaxBounds() {
                    return this.maxBounds
                }

                setMaxBounds(t) {
                    this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain()
                }

                calculatePosMatrix(e, t) {
                    return this.projection.createTileTransform(this, t).createTileMatrix(e)
                }

                calculateDistanceTileData(t) {
                    const n = t.key, i = this._distanceTileDataCache;
                    if (i[n]) return i[n];
                    const r = t.canonical, o = 1 / this.height, a = this.cameraWorldSize / this.zoomScale(r.z),
                        s = (r.x + Math.pow(2, r.z) * t.wrap) * a, l = r.y * a, c = this.point, u = this.angle,
                        d = Math.sin(-u), h = -Math.cos(-u);
                    return i[n] = {
                        bearing: [d, h],
                        center: [(c.x - s) * o, (c.y - l) * o],
                        scale: a / e.EXTENT * o
                    }, i[n]
                }

                calculateFogTileMatrix(t) {
                    const n = t.key, i = this._fogTileMatrixCache;
                    if (i[n]) return i[n];
                    const r = this.calculatePosMatrix(t, this.cameraWorldSize);
                    return e.multiply$1(r, this.worldToFogMatrix, r), i[n] = new Float32Array(r), i[n]
                }

                calculateProjMatrix(t, n = !1) {
                    const i = t.key, r = n ? this._alignedProjMatrixCache : this._projMatrixCache;
                    if (r[i]) return r[i];
                    const o = this.calculatePosMatrix(t, this.worldSize);
                    return e.multiply$1(o, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : n ? this.alignedProjMatrix : this.projMatrix, o), r[i] = new Float32Array(o), r[i]
                }

                calculatePixelsToTileUnitsMatrix(t) {
                    const n = t.tileID.key, i = this._pixelsToTileUnitsCache;
                    if (i[n]) return i[n];
                    const r = function (t, n) {
                        const {scale: i} = t.tileTransform,
                            r = i * e.EXTENT / (t.tileSize * Math.pow(2, n.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));
                        return o = new Float32Array(4), l = (a = n.inverseAdjustmentMatrix)[1], c = a[2], u = a[3], h = (s = [r, r])[1], o[0] = a[0] * (d = s[0]), o[1] = l * d, o[2] = c * h, o[3] = u * h, o;
                        var o, a, s, l, c, u, d, h
                    }(t, this);
                    return i[n] = r, i[n]
                }

                customLayerMatrix() {
                    return this.mercatorMatrix.slice()
                }

                recenterOnTerrain() {
                    if (!this._elevation) return;
                    const t = this._elevation;
                    this._updateCameraState();
                    const n = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
                        i = this._computeCameraPosition(n), r = this._camera.forward(),
                        o = e.mercatorZfromAltitude(1, this._center.lat);
                    i[2] /= o, r[2] /= o, e.normalize(r, r);
                    const a = t.raycast(i, r, t.exaggeration());
                    if (a) {
                        const t = e.scaleAndAdd([], i, r, a),
                            n = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),
                            s = (n.z + e.length([n.x - i[0], n.y - i[1], n.z - i[2] * o])) * this._projectionScaler;
                        this._cameraZoom = this._zoomFromMercatorZ(s), this._centerAltitude = n.toAltitude(), this._center = this.coordinateLocation(n), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices()
                    }
                }

                _constrainCameraAltitude() {
                    if (!this._elevation) return;
                    const t = this._elevation;
                    this._updateCameraState();
                    const n = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
                        i = this._computeCameraPosition(n), r = t.getAtPointOrZero(new e.MercatorCoordinate(...i)),
                        o = this._minimumHeightOverTerrain() * Math.cos(e.degToRad(this._maxPitch)),
                        a = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * r;
                    if (a < o) {
                        const t = this.locationCoordinate(this._center, this._centerAltitude),
                            n = [t.x - i[0], t.y - i[1], t.z - i[2]], r = e.length(n);
                        n[2] -= (o - a) / this._projectionScaler;
                        const s = e.length(n);
                        if (0 === s) return;
                        e.scale$2(n, n, r / s * this._projectionScaler), this._camera.position = [t.x - n[0], t.y - n[1], t.z * this._projectionScaler - n[2]], this._camera.orientation = yi(n, this._camera.up()), this._updateStateFromCamera()
                    }
                }

                _constrain() {
                    if (!this.center || !this.width || !this.height || this._constraining) return;
                    if (this._constraining = !0, this.projection.isReprojectedInTileSpace) {
                        const t = this.center;
                        return t.lat = e.clamp(t.lat, this.minLat, this.maxLat), !this.maxBounds && this.renderWorldCopies || (t.lng = e.clamp(t.lng, this.minLng, this.maxLng)), this.center = t, void (this._constraining = !1)
                    }
                    const t = this._unmodified, {x: n, y: i} = this.point;
                    let r = 0, o = n, a = i;
                    const s = this.width / 2, l = this.height / 2, c = this.worldMinY * this.scale,
                        u = this.worldMaxY * this.scale;
                    if (i - l < c && (a = c + l), i + l > u && (a = u - l), u - c < this.height && (r = Math.max(r, this.height / (u - c)), a = (u + c) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                        const e = this.worldMinX * this.scale, t = this.worldMaxX * this.scale,
                            i = this.worldSize / 2 - (e + t) / 2;
                        o = (n + i + this.worldSize) % this.worldSize - i, o - s < e && (o = e + s), o + s > t && (o = t - s), t - e < this.width && (r = Math.max(r, this.width / (t - e)), o = (t + e) / 2)
                    }
                    o === n && a === i || (this.center = this.unproject(new e.pointGeometry(o, a))), r && (this.zoom += this.scaleZoom(r)), this._constrainCameraAltitude(), this._unmodified = t, this._constraining = !1
                }

                _minZoomForBounds() {
                    let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                    return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e
                }

                _maxCameraBoundsDistance() {
                    return this._mercatorZfromZoom(this._minZoomForBounds())
                }

                _calcMatrices() {
                    if (!this.height) return;
                    const t = this._fov / 2, n = this.centerOffset, i = this.pixelsPerMeter;
                    this._projectionScaler = i / (e.mercatorZfromAltitude(1, this.center.lat) * this.worldSize), this.cameraToCenterDistance = .5 / Math.tan(t) * this.height * this._projectionScaler, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                    const o = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? i : 1),
                        a = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                    a[8] = 2 * -n.x / this.width, a[9] = 2 * n.y / this.height;
                    let s = e.mul([], a, o);
                    if (this.projection.isReprojectedInTileSpace) {
                        const t = this.locationCoordinate(this.center), n = e.identity([]);
                        e.translate(n, n, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply$1(n, n, bi(this)), e.translate(n, n, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply$1(s, s, n), this.inverseAdjustmentMatrix = function (e) {
                            const t = bi(e, !0);
                            return r([], [t[0], t[1], t[4], t[5]])
                        }(this)
                    } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                    this.mercatorMatrix = e.scale([], s, [this.worldSize, this.worldSize, this.worldSize / i, 1]), this.projMatrix = s, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
                    const l = new Float32Array(16);
                    e.identity(l), e.scale(l, l, [1, -1, 1]), e.rotateX(l, l, this._pitch), e.rotateZ(l, l, this.angle);
                    const c = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),
                        u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                    c[8] = 2 * -n.x / this.width, c[9] = 2 * (n.y + u) / this.height, this.skyboxMatrix = e.multiply$1(l, c, l);
                    const d = this.point, h = d.x, p = d.y, f = this.width % 2 / 2, m = this.height % 2 / 2,
                        _ = Math.cos(this.angle), g = Math.sin(this.angle), y = h - Math.round(h) + _ * f + g * m,
                        v = p - Math.round(p) + _ * m + g * f, x = new Float64Array(s);
                    if (e.translate(x, x, [y > .5 ? y - 1 : y, v > .5 ? v - 1 : v, 0]), this.alignedProjMatrix = x, s = e.create(), e.scale(s, s, [this.width / 2, -this.height / 2, 1]), e.translate(s, s, [1, -1, 0]), this.labelPlaneMatrix = s, s = e.create(), e.scale(s, s, [1, -1, 1]), e.translate(s, s, [-1, -1, 0]), e.scale(s, s, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = s, this.pixelMatrix = e.multiply$1(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, s = e.invert(new Float64Array(16), this.pixelMatrix), !s) throw new Error("failed to invert matrix");
                    this.pixelMatrixInverse = s, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}
                }

                _calcFogMatrices() {
                    this._fogTileMatrixCache = {};
                    const t = this.cameraWorldSize, n = this.cameraPixelsPerMeter, i = this._camera.position,
                        r = 1 / this.height, o = [t, t, n];
                    e.scale$2(o, o, r), e.scale$2(i, i, -1), e.multiply$2(i, i, o);
                    const a = e.create();
                    e.translate(a, a, i), e.scale(a, a, o), this.mercatorFogMatrix = a, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, n, r)
                }

                _computeCameraPosition(e) {
                    const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, n = this._camera.forward(),
                        i = this.point,
                        r = this._mercatorZfromZoom(this._cameraZoom ? this._cameraZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;
                    return [i.x / this.worldSize - n[0] * r, i.y / this.worldSize - n[1] * r, e / this.worldSize * this._centerAltitude - n[2] * r]
                }

                _updateCameraState() {
                    this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition())
                }

                _translateCameraConstrained(t) {
                    const n = this._maxCameraBoundsDistance() * Math.cos(this._pitch), i = t[2];
                    let r = 1;
                    i > 0 && (r = Math.min((n - this._camera.position[2]) / i, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, r), this._updateStateFromCamera()
                }

                _updateStateFromCamera() {
                    const t = this._camera.position, n = this._camera.forward(), {
                            pitch: i,
                            bearing: r
                        } = this._camera.getPitchBearing(),
                        o = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._projectionScaler,
                        a = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),
                        s = Math.max((t[2] - o) / Math.cos(i), a), l = this._zoomFromMercatorZ(s);
                    e.scaleAndAdd(t, t, n, s), this._pitch = e.clamp(i, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._terrainEnabled() && this._updateCameraOnTerrain(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices()
                }

                _worldSizeFromZoom(e) {
                    return Math.pow(2, e) * this.tileSize
                }

                _mercatorZfromZoom(e) {
                    return this.cameraToCenterDistance / this._worldSizeFromZoom(e)
                }

                _minimumHeightOverTerrain() {
                    const e = Math.min((null != this._cameraZoom ? this._cameraZoom : this._zoom) + 2, this._maxZoom);
                    return this._mercatorZfromZoom(e)
                }

                _zoomFromMercatorZ(e) {
                    return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize))
                }

                _terrainEnabled() {
                    return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator to enable terrain."), 1))
                }

                anyCornerOffEdge(t, n) {
                    const i = Math.min(t.x, n.x), r = Math.max(t.x, n.x), o = Math.min(t.y, n.y),
                        a = Math.max(t.y, n.y);
                    if (o < this.horizonLineFromTop(!1)) return !0;
                    if ("mercator" !== this.projection.name) return !1;
                    const s = [new e.pointGeometry(i, o), new e.pointGeometry(r, a), new e.pointGeometry(i, a), new e.pointGeometry(r, o)],
                        l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                    for (const e of s) {
                        const t = this.pointRayIntersection(e);
                        if (t.t < 0) return !0;
                        const n = this.rayIntersectionCoordinate(t);
                        if (n.x < l || n.y < 0 || n.x > c || n.y > 1) return !0
                    }
                    return !1
                }

                isHorizonVisible() {
                    return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height))
                }

                zoomDeltaToMovement(t, n) {
                    const i = e.length(e.sub([], this._camera.position, t)), r = this._zoomFromMercatorZ(i) + n;
                    return i - this._mercatorZfromZoom(r)
                }

                getCameraPoint() {
                    const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e.pointGeometry(0, t))
                }
            }

            function Li(e, t) {
                let n = !1, i = null;
                const r = () => {
                    i = null, n && (e(), i = setTimeout(r, t), n = !1)
                };
                return () => (n = !0, i || r(), i)
            }

            class Ei {
                constructor(t) {
                    this._hashName = t && encodeURIComponent(t), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Li(this._updateHashUnthrottled.bind(this), 300)
                }

                addTo(t) {
                    return this._map = t, e.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
                }

                remove() {
                    return e.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this
                }

                getHashString(t) {
                    const n = this._map.getCenter(), i = Math.round(100 * this._map.getZoom()) / 100,
                        r = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), o = Math.pow(10, r),
                        a = Math.round(n.lng * o) / o, s = Math.round(n.lat * o) / o, l = this._map.getBearing(),
                        c = this._map.getPitch();
                    let u = "";
                    if (u += t ? `/${a}/${s}/${i}` : `${i}/${s}/${a}`, (l || c) && (u += "/" + Math.round(10 * l) / 10), c && (u += "/" + Math.round(c)), this._hashName) {
                        const t = this._hashName;
                        let n = !1;
                        const i = e.window.location.hash.slice(1).split("&").map(e => {
                            const i = e.split("=")[0];
                            return i === t ? (n = !0, `${i}=${u}`) : e
                        }).filter(e => e);
                        return n || i.push(`${t}=${u}`), "#" + i.join("&")
                    }
                    return "#" + u
                }

                _getCurrentHash() {
                    const t = e.window.location.hash.replace("#", "");
                    if (this._hashName) {
                        let e;
                        return t.split("&").map(e => e.split("=")).forEach(t => {
                            t[0] === this._hashName && (e = t)
                        }), (e && e[1] || "").split("/")
                    }
                    return t.split("/")
                }

                _onHashChange() {
                    const e = this._getCurrentHash();
                    if (e.length >= 3 && !e.some(e => isNaN(e))) {
                        const t = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e[3] || 0) : this._map.getBearing();
                        return this._map.jumpTo({
                            center: [+e[2], +e[1]],
                            zoom: +e[0],
                            bearing: t,
                            pitch: +(e[4] || 0)
                        }), !0
                    }
                    return !1
                }

                _updateHashUnthrottled() {
                    const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
                    e.window.history.replaceState(e.window.history.state, null, t)
                }
            }

            const Ci = {linearity: .3, easing: e.bezier(0, 0, .3, 1)},
                Ai = e.extend({deceleration: 2500, maxSpeed: 1400}, Ci),
                Ii = e.extend({deceleration: 20, maxSpeed: 1400}, Ci),
                Pi = e.extend({deceleration: 1e3, maxSpeed: 360}, Ci),
                Ri = e.extend({deceleration: 1e3, maxSpeed: 90}, Ci);

            class Yi {
                constructor(e) {
                    this._map = e, this.clear()
                }

                clear() {
                    this._inertiaBuffer = []
                }

                record(t) {
                    this._drainInertiaBuffer(), this._inertiaBuffer.push({time: e.exported.now(), settings: t})
                }

                _drainInertiaBuffer() {
                    const t = this._inertiaBuffer, n = e.exported.now();
                    for (; t.length > 0 && n - t[0].time > 160;) t.shift()
                }

                _onMoveEnd(t) {
                    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                    const n = {
                        zoom: 0,
                        bearing: 0,
                        pitch: 0,
                        pan: new e.pointGeometry(0, 0),
                        pinchAround: void 0,
                        around: void 0
                    };
                    for (const {settings: e} of this._inertiaBuffer) n.zoom += e.zoomDelta || 0, n.bearing += e.bearingDelta || 0, n.pitch += e.pitchDelta || 0, e.panDelta && n.pan._add(e.panDelta), e.around && (n.around = e.around), e.pinchAround && (n.pinchAround = e.pinchAround);
                    const i = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
                        r = {};
                    if (n.pan.mag()) {
                        const o = Oi(n.pan.mag(), i, e.extend({}, Ai, t || {}));
                        r.offset = n.pan.mult(o.amount / n.pan.mag()), r.center = this._map.transform.center, zi(r, o)
                    }
                    if (n.zoom) {
                        const e = Oi(n.zoom, i, Ii);
                        r.zoom = this._map.transform.zoom + e.amount, zi(r, e)
                    }
                    if (n.bearing) {
                        const t = Oi(n.bearing, i, Pi);
                        r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), zi(r, t)
                    }
                    if (n.pitch) {
                        const e = Oi(n.pitch, i, Ri);
                        r.pitch = this._map.transform.pitch + e.amount, zi(r, e)
                    }
                    if (r.zoom || r.bearing) {
                        const e = void 0 === n.pinchAround ? n.around : n.pinchAround;
                        r.around = e ? this._map.unproject(e) : this._map.getCenter()
                    }
                    return this.clear(), e.extend(r, {noMoveStart: !0})
                }
            }

            function zi(e, t) {
                (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing)
            }

            function Oi(t, n, i) {
                const {maxSpeed: r, linearity: o, deceleration: a} = i, s = e.clamp(t * o / (n / 1e3), -r, r),
                    l = Math.abs(s) / (a * o);
                return {easing: i.easing, duration: 1e3 * l, amount: s * (l / 2)}
            }

            class Fi extends e.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(t, n, i, r = {}) {
                    const o = a.mousePos(n.getCanvasContainer(), i), s = n.unproject(o);
                    super(t, e.extend({
                        point: o,
                        lngLat: s,
                        originalEvent: i
                    }, r)), this._defaultPrevented = !1, this.target = n
                }
            }

            class Bi extends e.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(t, n, i) {
                    const r = "touchend" === t ? i.changedTouches : i.touches,
                        o = a.touchPos(n.getCanvasContainer(), r), s = o.map(e => n.unproject(e)),
                        l = o.reduce((e, t, n, i) => e.add(t.div(i.length)), new e.pointGeometry(0, 0));
                    super(t, {
                        points: o,
                        point: l,
                        lngLats: s,
                        lngLat: n.unproject(l),
                        originalEvent: i
                    }), this._defaultPrevented = !1
                }
            }

            class ji extends e.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(e, t, n) {
                    super(e, {originalEvent: n}), this._defaultPrevented = !1
                }
            }

            class Hi {
                constructor(e, t) {
                    this._map = e, this._clickTolerance = t.clickTolerance
                }

                reset() {
                    delete this._mousedownPos
                }

                wheel(e) {
                    return this._firePreventable(new ji(e.type, this._map, e))
                }

                mousedown(e, t) {
                    return this._mousedownPos = t, this._firePreventable(new Fi(e.type, this._map, e))
                }

                mouseup(e) {
                    this._map.fire(new Fi(e.type, this._map, e))
                }

                preclick(t) {
                    const n = e.extend({}, t);
                    n.type = "preclick", this._map.fire(new Fi(n.type, this._map, n))
                }

                click(e, t) {
                    this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Fi(e.type, this._map, e)))
                }

                dblclick(e) {
                    return this._firePreventable(new Fi(e.type, this._map, e))
                }

                mouseover(e) {
                    this._map.fire(new Fi(e.type, this._map, e))
                }

                mouseout(e) {
                    this._map.fire(new Fi(e.type, this._map, e))
                }

                touchstart(e) {
                    return this._firePreventable(new Bi(e.type, this._map, e))
                }

                touchmove(e) {
                    this._map.fire(new Bi(e.type, this._map, e))
                }

                touchend(e) {
                    this._map.fire(new Bi(e.type, this._map, e))
                }

                touchcancel(e) {
                    this._map.fire(new Bi(e.type, this._map, e))
                }

                _firePreventable(e) {
                    if (this._map.fire(e), e.defaultPrevented) return {}
                }

                isEnabled() {
                    return !0
                }

                isActive() {
                    return !1
                }

                enable() {
                }

                disable() {
                }
            }

            class Ni {
                constructor(e) {
                    this._map = e
                }

                reset() {
                    this._delayContextMenu = !1, delete this._contextMenuEvent
                }

                mousemove(e) {
                    this._map.fire(new Fi(e.type, this._map, e))
                }

                mousedown() {
                    this._delayContextMenu = !0
                }

                mouseup() {
                    this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Fi("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
                }

                contextmenu(e) {
                    this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Fi(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
                }

                isEnabled() {
                    return !0
                }

                isActive() {
                    return !1
                }

                enable() {
                }

                disable() {
                }
            }

            class Ui {
                constructor(e, t) {
                    this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1
                }

                isEnabled() {
                    return !!this._enabled
                }

                isActive() {
                    return !!this._active
                }

                enable() {
                    this.isEnabled() || (this._enabled = !0)
                }

                disable() {
                    this.isEnabled() && (this._enabled = !1)
                }

                mousedown(e, t) {
                    this.isEnabled() && e.shiftKey && 0 === e.button && (a.disableDrag(), this._startPos = this._lastPos = t, this._active = !0)
                }

                mousemoveWindow(e, t) {
                    if (!this._active) return;
                    const n = t;
                    if (this._lastPos.equals(n) || !this._box && n.dist(this._startPos) < this._clickTolerance) return;
                    const i = this._startPos;
                    this._lastPos = n, this._box || (this._box = a.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                    const r = Math.min(i.x, n.x), o = Math.max(i.x, n.x), s = Math.min(i.y, n.y),
                        l = Math.max(i.y, n.y);
                    this._map._requestDomTask(() => {
                        this._box && (this._box.style.transform = `translate(${r}px,${s}px)`, this._box.style.width = o - r + "px", this._box.style.height = l - s + "px")
                    })
                }

                mouseupWindow(t, n) {
                    if (!this._active) return;
                    if (0 !== t.button) return;
                    const i = this._startPos, r = n;
                    if (this.reset(), a.suppressClick(), i.x !== r.x || i.y !== r.y) return this._map.fire(new e.Event("boxzoomend", {originalEvent: t})), {cameraAnimation: e => e.fitScreenCoordinates(i, r, this._map.getBearing(), {linear: !1})};
                    this._fireEvent("boxzoomcancel", t)
                }

                keydown(e) {
                    this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e))
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), a.enableDrag(), delete this._startPos, delete this._lastPos
                }

                _fireEvent(t, n) {
                    return this._map.fire(new e.Event(t, {originalEvent: n}))
                }
            }

            function Wi(e, t) {
                const n = {};
                for (let i = 0; i < e.length; i++) n[e[i].identifier] = t[i];
                return n
            }

            class Vi {
                constructor(e) {
                    this.reset(), this.numTouches = e.numTouches
                }

                reset() {
                    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
                }

                touchstart(t, n, i) {
                    (this.centroid || i.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = t.timeStamp), i.length === this.numTouches && (this.centroid = function (t) {
                        const n = new e.pointGeometry(0, 0);
                        for (const e of t) n._add(e);
                        return n.div(t.length)
                    }(n), this.touches = Wi(i, n)))
                }

                touchmove(e, t, n) {
                    if (this.aborted || !this.centroid) return;
                    const i = Wi(n, t);
                    for (const e in this.touches) {
                        const t = this.touches[e], n = i[e];
                        (!n || n.dist(t) > 30) && (this.aborted = !0)
                    }
                }

                touchend(e, t, n) {
                    if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === n.length) {
                        const e = !this.aborted && this.centroid;
                        if (this.reset(), e) return e
                    }
                }
            }

            class Gi {
                constructor(e) {
                    this.singleTap = new Vi(e), this.numTaps = e.numTaps, this.reset()
                }

                reset() {
                    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
                }

                touchstart(e, t, n) {
                    this.singleTap.touchstart(e, t, n)
                }

                touchmove(e, t, n) {
                    this.singleTap.touchmove(e, t, n)
                }

                touchend(e, t, n) {
                    const i = this.singleTap.touchend(e, t, n);
                    if (i) {
                        const t = e.timeStamp - this.lastTime < 500, n = !this.lastTap || this.lastTap.dist(i) < 30;
                        if (t && n || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = i, this.count === this.numTaps) return this.reset(), i
                    }
                }
            }

            class qi {
                constructor() {
                    this._zoomIn = new Gi({numTouches: 1, numTaps: 2}), this._zoomOut = new Gi({
                        numTouches: 2,
                        numTaps: 1
                    }), this.reset()
                }

                reset() {
                    this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
                }

                touchstart(e, t, n) {
                    this._zoomIn.touchstart(e, t, n), this._zoomOut.touchstart(e, t, n)
                }

                touchmove(e, t, n) {
                    this._zoomIn.touchmove(e, t, n), this._zoomOut.touchmove(e, t, n)
                }

                touchend(e, t, n) {
                    const i = this._zoomIn.touchend(e, t, n), r = this._zoomOut.touchend(e, t, n);
                    return i ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: t => t.easeTo({
                            duration: 300,
                            zoom: t.getZoom() + 1,
                            around: t.unproject(i)
                        }, {originalEvent: e})
                    }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: t => t.easeTo({
                            duration: 300,
                            zoom: t.getZoom() - 1,
                            around: t.unproject(r)
                        }, {originalEvent: e})
                    }) : void 0
                }

                touchcancel() {
                    this.reset()
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            const Zi = {0: 1, 2: 2};

            class $i {
                constructor(e) {
                    this.reset(), this._clickTolerance = e.clickTolerance || 1
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton
                }

                _correctButton(e, t) {
                    return !1
                }

                _move(e, t) {
                    return {}
                }

                mousedown(e, t) {
                    if (this._lastPoint) return;
                    const n = a.mouseButton(e);
                    this._correctButton(e, n) && (this._lastPoint = t, this._eventButton = n)
                }

                mousemoveWindow(e, t) {
                    const n = this._lastPoint;
                    if (n) if (e.preventDefault(), function (e, t) {
                        const n = Zi[t];
                        return void 0 === e.buttons || (e.buttons & n) !== n
                    }(e, this._eventButton)) this.reset(); else if (this._moved || !(t.dist(n) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(n, t)
                }

                mouseupWindow(e) {
                    this._lastPoint && a.mouseButton(e) === this._eventButton && (this._moved && a.suppressClick(), this.reset())
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class Xi extends $i {
                mousedown(e, t) {
                    super.mousedown(e, t), this._lastPoint && (this._active = !0)
                }

                _correctButton(e, t) {
                    return 0 === t && !e.ctrlKey
                }

                _move(e, t) {
                    return {around: t, panDelta: t.sub(e)}
                }
            }

            class Ji extends $i {
                _correctButton(e, t) {
                    return 0 === t && e.ctrlKey || 2 === t
                }

                _move(e, t) {
                    const n = .8 * (t.x - e.x);
                    if (n) return this._active = !0, {bearingDelta: n}
                }

                contextmenu(e) {
                    e.preventDefault()
                }
            }

            class Ki extends $i {
                _correctButton(e, t) {
                    return 0 === t && e.ctrlKey || 2 === t
                }

                _move(e, t) {
                    const n = -.5 * (t.y - e.y);
                    if (n) return this._active = !0, {pitchDelta: n}
                }

                contextmenu(e) {
                    e.preventDefault()
                }
            }

            class Qi {
                constructor(t, n) {
                    this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = n.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
                }

                reset() {
                    this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0)
                }

                touchstart(e, t, n) {
                    return this._calculateTransform(e, t, n)
                }

                touchmove(e, t, n) {
                    if (this._active && !(n.length < this._minTouches)) {
                        if (this._map._cooperativeGestures && !this._map.isMoving()) {
                            if (1 === n.length) return void this._showTouchPanBlockerAlert();
                            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer))
                        }
                        return e.preventDefault(), this._calculateTransform(e, t, n)
                    }
                }

                touchend(e, t, n) {
                    this._calculateTransform(e, t, n), this._active && n.length < this._minTouches && this.reset()
                }

                touchcancel() {
                    this.reset()
                }

                _calculateTransform(t, n, i) {
                    i.length > 0 && (this._active = !0);
                    const r = Wi(i, n), o = new e.pointGeometry(0, 0), a = new e.pointGeometry(0, 0);
                    let s = 0;
                    for (const e in r) {
                        const t = r[e], n = this._touches[e];
                        n && (o._add(t), a._add(t.sub(n)), s++, r[e] = t)
                    }
                    if (this._touches = r, s < this._minTouches || !a.mag()) return;
                    const l = a.div(s);
                    return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                        around: o.div(s),
                        panDelta: l
                    }
                }

                enable() {
                    this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
                }

                disable() {
                    this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }

                _addTouchPanBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = a.create("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))) + "px")
                }

                _showTouchPanBlockerAlert() {
                    "hidden" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                        this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show")
                    }, 500)
                }
            }

            class er {
                constructor() {
                    this.reset()
                }

                reset() {
                    this._active = !1, delete this._firstTwoTouches
                }

                _start(e) {
                }

                _move(e, t, n) {
                    return {}
                }

                touchstart(e, t, n) {
                    this._firstTwoTouches || n.length < 2 || (this._firstTwoTouches = [n[0].identifier, n[1].identifier], this._start([t[0], t[1]]))
                }

                touchmove(e, t, n) {
                    if (!this._firstTwoTouches) return;
                    e.preventDefault();
                    const [i, r] = this._firstTwoTouches, o = tr(n, t, i), a = tr(n, t, r);
                    if (!o || !a) return;
                    const s = this._aroundCenter ? null : o.add(a).div(2);
                    return this._move([o, a], s, e)
                }

                touchend(e, t, n) {
                    if (!this._firstTwoTouches) return;
                    const [i, r] = this._firstTwoTouches, o = tr(n, t, i), s = tr(n, t, r);
                    o && s || (this._active && a.suppressClick(), this.reset())
                }

                touchcancel() {
                    this.reset()
                }

                enable(e) {
                    this._enabled = !0, this._aroundCenter = !!e && "center" === e.around
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            function tr(e, t, n) {
                for (let i = 0; i < e.length; i++) if (e[i].identifier === n) return t[i]
            }

            function nr(e, t) {
                return Math.log(e / t) / Math.LN2
            }

            class ir extends er {
                reset() {
                    super.reset(), delete this._distance, delete this._startDistance
                }

                _start(e) {
                    this._startDistance = this._distance = e[0].dist(e[1])
                }

                _move(e, t) {
                    const n = this._distance;
                    if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(nr(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                        zoomDelta: nr(this._distance, n),
                        pinchAround: t
                    }
                }
            }

            function rr(e, t) {
                return 180 * e.angleWith(t) / Math.PI
            }

            class or extends er {
                reset() {
                    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
                }

                _start(e) {
                    this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
                }

                _move(e, t) {
                    const n = this._vector;
                    if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
                        bearingDelta: rr(this._vector, n),
                        pinchAround: t
                    }
                }

                _isBelowThreshold(e) {
                    this._minDiameter = Math.min(this._minDiameter, e.mag());
                    const t = 25 / (Math.PI * this._minDiameter) * 360, n = rr(e, this._startVector);
                    return Math.abs(n) < t
                }
            }

            function ar(e) {
                return Math.abs(e.y) > Math.abs(e.x)
            }

            class sr extends er {
                constructor(e) {
                    super(), this._map = e
                }

                reset() {
                    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
                }

                _start(e) {
                    this._lastPoints = e, ar(e[0].sub(e[1])) && (this._valid = !1)
                }

                _move(e, t, n) {
                    const i = e[0].sub(this._lastPoints[0]), r = e[1].sub(this._lastPoints[1]);
                    if (!(this._map._cooperativeGestures && n.touches.length < 3) && (this._valid = this.gestureBeginsVertically(i, r, n.timeStamp), this._valid)) return this._lastPoints = e, this._active = !0, {pitchDelta: (i.y + r.y) / 2 * -.5}
                }

                gestureBeginsVertically(e, t, n) {
                    if (void 0 !== this._valid) return this._valid;
                    const i = e.mag() >= 2, r = t.mag() >= 2;
                    if (!i && !r) return;
                    if (!i || !r) return void 0 === this._firstMove && (this._firstMove = n), n - this._firstMove < 100 && void 0;
                    const o = e.y > 0 == t.y > 0;
                    return ar(e) && ar(t) && o
                }
            }

            const lr = {panStep: 100, bearingStep: 15, pitchStep: 10};

            class cr {
                constructor() {
                    const e = lr;
                    this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                keydown(e) {
                    if (e.altKey || e.ctrlKey || e.metaKey) return;
                    let t = 0, n = 0, i = 0, r = 0, o = 0;
                    switch (e.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            t = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            t = -1;
                            break;
                        case 37:
                            e.shiftKey ? n = -1 : (e.preventDefault(), r = -1);
                            break;
                        case 39:
                            e.shiftKey ? n = 1 : (e.preventDefault(), r = 1);
                            break;
                        case 38:
                            e.shiftKey ? i = 1 : (e.preventDefault(), o = -1);
                            break;
                        case 40:
                            e.shiftKey ? i = -1 : (e.preventDefault(), o = 1);
                            break;
                        default:
                            return
                    }
                    return this._rotationDisabled && (n = 0, i = 0), {
                        cameraAnimation: a => {
                            const s = a.getZoom();
                            a.easeTo({
                                duration: 300,
                                easeId: "keyboardHandler",
                                easing: ur,
                                zoom: t ? Math.round(s) + t * (e.shiftKey ? 2 : 1) : s,
                                bearing: a.getBearing() + n * this._bearingStep,
                                pitch: a.getPitch() + i * this._pitchStep,
                                offset: [-r * this._panStep, -o * this._panStep],
                                center: a.getCenter()
                            }, {originalEvent: e})
                        }
                    }
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }

                disableRotation() {
                    this._rotationDisabled = !0
                }

                enableRotation() {
                    this._rotationDisabled = !1
                }
            }

            function ur(e) {
                return e * (2 - e)
            }

            const dr = 4.000244140625;

            class hr {
                constructor(t, n) {
                    this._map = t, this._el = t.getCanvasContainer(), this._handler = n, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert", "_isFullscreen"], this)
                }

                setZoomRate(e) {
                    this._defaultZoomRate = e
                }

                setWheelZoomRate(e) {
                    this._wheelZoomRate = e
                }

                isEnabled() {
                    return !!this._enabled
                }

                isActive() {
                    return !!this._active || void 0 !== this._finishTimeout
                }

                isZooming() {
                    return !!this._zooming
                }

                enable(e) {
                    this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker())
                }

                disable() {
                    this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()))
                }

                wheel(t) {
                    if (!this.isEnabled()) return;
                    if (this._map._cooperativeGestures) {
                        if (!(t.ctrlKey || t.metaKey || this.isZooming() || this._isFullscreen())) return void this._showBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer))
                    }
                    let n = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
                    const i = e.exported.now(), r = i - (this._lastWheelEventTime || 0);
                    this._lastWheelEventTime = i, 0 !== n && n % dr == 0 ? this._type = "wheel" : 0 !== n && Math.abs(n) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), t.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = t, this._delta -= n, this._active || this._start(t)), t.preventDefault()
                }

                _onTimeout(e) {
                    this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e)
                }

                _start(e) {
                    if (!this._delta) return;
                    this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                    const t = a.mousePos(this._el, e);
                    this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame())
                }

                renderFrame() {
                    if (!this._frameId) return;
                    if (this._frameId = null, !this.isActive()) return;
                    const t = this._map.transform,
                        n = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
                    if (0 !== this._delta) {
                        const e = "wheel" === this._type && Math.abs(this._delta) > dr ? this._wheelZoomRate : this._defaultZoomRate;
                        let i = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
                        this._delta < 0 && 0 !== i && (i = 1 / i);
                        const r = n(), o = Math.pow(2, r),
                            a = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : o;
                        this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(a * i))), "wheel" === this._type && (this._startZoom = n(), this._easing = this._smoothOutEasing(200)), this._delta = 0
                    }
                    const i = "number" == typeof this._targetZoom ? this._targetZoom : n(), r = this._startZoom,
                        o = this._easing;
                    let a, s = !1;
                    if ("wheel" === this._type && r && o) {
                        const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), n = o(t);
                        a = e.number(r, i, n), t < 1 ? this._frameId || (this._frameId = !0) : s = !0
                    } else a = i, s = !0;
                    return this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout(() => {
                        this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout
                    }, 200)), {
                        noInertia: !0,
                        needsRenderFrame: !s,
                        zoomDelta: a - n(),
                        around: this._aroundPoint,
                        aroundCoord: this._aroundCoord,
                        originalEvent: this._lastWheelEvent
                    }
                }

                _smoothOutEasing(t) {
                    let n = e.ease;
                    if (this._prevEase) {
                        const t = this._prevEase, i = (e.exported.now() - t.start) / t.duration,
                            r = t.easing(i + .01) - t.easing(i), o = .27 / Math.sqrt(r * r + 1e-4) * .01,
                            a = Math.sqrt(.0729 - o * o);
                        n = e.bezier(o, a, .25, 1)
                    }
                    return this._prevEase = {start: e.exported.now(), duration: t, easing: n}, n
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                _addScrollZoomBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = a.create("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))) + "px")
                }

                _isFullscreen() {
                    return !!e.window.document.fullscreenElement || !!e.window.document.webkitFullscreenElement
                }

                _showBlockerAlert() {
                    "hidden" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                        this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show")
                    }, 200)
                }
            }

            class pr {
                constructor(e, t) {
                    this._clickZoom = e, this._tapZoom = t
                }

                enable() {
                    this._clickZoom.enable(), this._tapZoom.enable()
                }

                disable() {
                    this._clickZoom.disable(), this._tapZoom.disable()
                }

                isEnabled() {
                    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                }

                isActive() {
                    return this._clickZoom.isActive() || this._tapZoom.isActive()
                }
            }

            class fr {
                constructor() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                blur() {
                    this.reset()
                }

                dblclick(e, t) {
                    return e.preventDefault(), {
                        cameraAnimation: n => {
                            n.easeTo({
                                duration: 300,
                                zoom: n.getZoom() + (e.shiftKey ? -1 : 1),
                                around: n.unproject(t)
                            }, {originalEvent: e})
                        }
                    }
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class mr {
                constructor() {
                    this._tap = new Gi({numTouches: 1, numTaps: 1}), this.reset()
                }

                reset() {
                    this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset()
                }

                touchstart(e, t, n) {
                    this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? n.length > 0 && (this._swipePoint = t[0], this._swipeTouch = n[0].identifier) : this._tap.touchstart(e, t, n))
                }

                touchmove(e, t, n) {
                    if (this._tapTime) {
                        if (this._swipePoint) {
                            if (n[0].identifier !== this._swipeTouch) return;
                            const i = t[0], r = i.y - this._swipePoint.y;
                            return this._swipePoint = i, e.preventDefault(), this._active = !0, {zoomDelta: r / 128}
                        }
                    } else this._tap.touchmove(e, t, n)
                }

                touchend(e, t, n) {
                    this._tapTime ? this._swipePoint && 0 === n.length && this.reset() : this._tap.touchend(e, t, n) && (this._tapTime = e.timeStamp)
                }

                touchcancel() {
                    this.reset()
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class _r {
                constructor(e, t, n) {
                    this._el = e, this._mousePan = t, this._touchPan = n
                }

                enable(e) {
                    this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan")
                }

                disable() {
                    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan")
                }

                isEnabled() {
                    return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                }

                isActive() {
                    return this._mousePan.isActive() || this._touchPan.isActive()
                }
            }

            class gr {
                constructor(e, t, n) {
                    this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = n
                }

                enable() {
                    this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable()
                }

                disable() {
                    this._mouseRotate.disable(), this._mousePitch.disable()
                }

                isEnabled() {
                    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                }

                isActive() {
                    return this._mouseRotate.isActive() || this._mousePitch.isActive()
                }
            }

            class yr {
                constructor(e, t, n, i) {
                    this._el = e, this._touchZoom = t, this._touchRotate = n, this._tapDragZoom = i, this._rotationDisabled = !1, this._enabled = !0
                }

                enable(e) {
                    this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate")
                }

                disable() {
                    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate")
                }

                isEnabled() {
                    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                }

                isActive() {
                    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                }

                disableRotation() {
                    this._rotationDisabled = !0, this._touchRotate.disable()
                }

                enableRotation() {
                    this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
                }
            }

            const vr = e => e.zoom || e.drag || e.pitch || e.rotate;

            class xr extends e.Event {
            }

            class br {
                constructor() {
                    this.constants = [1, 1, .01], this.radius = 0
                }

                setup(t, n) {
                    const i = e.sub([], n, t);
                    this.radius = e.length(i[2] < 0 ? e.div([], i, this.constants) : [i[0], i[1], 0])
                }

                projectRay(t) {
                    e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);
                    const n = e.scale$2([], t, this.radius);
                    if (n[2] > 0) {
                        const t = e.scale$2([], [0, 0, 1], e.dot(n, [0, 0, 1])),
                            i = e.scale$2([], e.normalize([], [n[0], n[1], 0]), this.radius),
                            r = e.add([], n, e.scale$2([], e.sub([], e.add([], i, t), n), 2));
                        n[0] = r[0], n[1] = r[1]
                    }
                    return n
                }
            }

            function wr(e) {
                return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta
            }

            class Mr {
                constructor(t, n) {
                    this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Yi(t), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new br, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(n), e.bindAll(["handleEvent", "handleWindowEvent"], this);
                    const i = this._el;
                    this._listeners = [[i, "touchstart", {passive: !0}], [i, "touchmove", {passive: !1}], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [e.window.document, "mousemove", {capture: !0}], [e.window.document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", {capture: !1}], [i, "keyup", void 0], [i, "wheel", {passive: !1}], [i, "contextmenu", void 0], [e.window, "blur", void 0]];
                    for (const [t, n, i] of this._listeners) t.addEventListener(n, t === e.window.document ? this.handleWindowEvent : this.handleEvent, i)
                }

                destroy() {
                    for (const [t, n, i] of this._listeners) t.removeEventListener(n, t === e.window.document ? this.handleWindowEvent : this.handleEvent, i)
                }

                _addDefaultHandlers(e) {
                    const t = this._map, n = t.getCanvasContainer();
                    this._add("mapEvent", new Hi(t, e));
                    const i = t.boxZoom = new Ui(t, e);
                    this._add("boxZoom", i);
                    const r = new qi, o = new fr;
                    t.doubleClickZoom = new pr(o, r), this._add("tapZoom", r), this._add("clickZoom", o);
                    const a = new mr;
                    this._add("tapDragZoom", a);
                    const s = t.touchPitch = new sr(t);
                    this._add("touchPitch", s);
                    const l = new Ji(e), c = new Ki(e);
                    t.dragRotate = new gr(e, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);
                    const u = new Xi(e), d = new Qi(t, e);
                    t.dragPan = new _r(n, u, d), this._add("mousePan", u), this._add("touchPan", d, ["touchZoom", "touchRotate"]);
                    const h = new or, p = new ir;
                    t.touchZoomRotate = new yr(n, p, h, a), this._add("touchRotate", h, ["touchPan", "touchZoom"]), this._add("touchZoom", p, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Ni(t));
                    const f = t.scrollZoom = new hr(t, this);
                    this._add("scrollZoom", f, ["mousePan"]);
                    const m = t.keyboard = new cr;
                    this._add("keyboard", m);
                    for (const n of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e.interactive && e[n] && t[n].enable(e[n])
                }

                _add(e, t, n) {
                    this._handlers.push({handlerName: e, handler: t, allowed: n}), this._handlersById[e] = t
                }

                stop(e) {
                    if (!this._updatingCamera) {
                        for (const {handler: e} of this._handlers) e.reset();
                        this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
                    }
                }

                isActive() {
                    for (const {handler: e} of this._handlers) if (e.isActive()) return !0;
                    return !1
                }

                isZooming() {
                    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                }

                isRotating() {
                    return !!this._eventsInProgress.rotate
                }

                isMoving() {
                    return Boolean(vr(this._eventsInProgress)) || this.isZooming()
                }

                _blockedByActive(e, t, n) {
                    for (const i in e) if (i !== n && (!t || t.indexOf(i) < 0)) return !0;
                    return !1
                }

                handleWindowEvent(e) {
                    this.handleEvent(e, e.type + "Window")
                }

                _getMapTouches(e) {
                    const t = [];
                    for (const n of e) this._el.contains(n.target) && t.push(n);
                    return t
                }

                handleEvent(e, t) {
                    this._updatingCamera = !0;
                    const n = "renderFrame" === e.type, i = n ? void 0 : e, r = {needsRenderFrame: !1}, o = {}, s = {},
                        l = e.touches ? this._getMapTouches(e.touches) : void 0,
                        c = l ? a.touchPos(this._el, l) : n ? void 0 : a.mousePos(this._el, e);
                    for (const {handlerName: n, handler: a, allowed: u} of this._handlers) {
                        if (!a.isEnabled()) continue;
                        let d;
                        this._blockedByActive(s, u, n) ? a.reset() : a[t || e.type] && (d = a[t || e.type](e, c, l), this.mergeHandlerResult(r, o, d, n, i), d && d.needsRenderFrame && this._triggerRenderFrame()), (d || a.isActive()) && (s[n] = a)
                    }
                    const u = {};
                    for (const e in this._previousActiveHandlers) s[e] || (u[e] = i);
                    this._previousActiveHandlers = s, (Object.keys(u).length || wr(r)) && (this._changes.push([r, o, u]), this._triggerRenderFrame()), (Object.keys(s).length || wr(r)) && this._map._stop(!0), this._updatingCamera = !1;
                    const {cameraAnimation: d} = r;
                    d && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], d(this._map))
                }

                mergeHandlerResult(t, n, i, r, o) {
                    if (!i) return;
                    e.extend(t, i);
                    const a = {handlerName: r, originalEvent: i.originalEvent || o};
                    void 0 !== i.zoomDelta && (n.zoom = a), void 0 !== i.panDelta && (n.drag = a), void 0 !== i.pitchDelta && (n.pitch = a), void 0 !== i.bearingDelta && (n.rotate = a)
                }

                _applyChanges() {
                    const t = {}, n = {}, i = {};
                    for (const [r, o, a] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(n, o), e.extend(i, a);
                    this._updateMapTransform(t, n, i), this._changes = []
                }

                _updateMapTransform(t, n, i) {
                    const r = this._map, o = r.transform, a = e => [e.x, e.y, e.z];
                    if ((e => {
                        const t = this._eventsInProgress.drag;
                        return t && !this._handlersById[t.handlerName].isActive()
                    })() && !wr(t)) {
                        const e = o.zoom;
                        o.cameraElevationReference = "sea", o.recenterOnTerrain(), o.cameraElevationReference = "ground", e !== o.zoom && this._map._update(!0)
                    }
                    if (!wr(t)) return this._fireEvents(n, i, !0);
                    let {
                        panDelta: s,
                        zoomDelta: l,
                        bearingDelta: c,
                        pitchDelta: u,
                        around: d,
                        aroundCoord: h,
                        pinchAround: p
                    } = t;
                    void 0 !== p && (d = p), (e => n.drag && !this._eventsInProgress.drag)() && d && (this._dragOrigin = a(o.pointCoordinate3D(d)), this._trackingEllipsoid.setup(o._camera.position, this._dragOrigin)), o.cameraElevationReference = "sea", r._stop(!0), d = d || r.transform.centerPoint, c && (o.bearing += c), u && (o.pitch += u), o._updateCameraState();
                    const f = [0, 0, 0];
                    if (s) {
                        const e = o.pointCoordinate(d), t = o.pointCoordinate(d.sub(s));
                        e && t && (f[0] = t.x - e.x, f[1] = t.y - e.y)
                    }
                    const m = o.zoom, _ = [0, 0, 0];
                    if (l) {
                        const t = a(h || o.pointCoordinate3D(d)),
                            n = {dir: e.normalize([], e.sub([], t, o._camera.position))};
                        if (n.dir[2] < 0) {
                            const i = o.zoomDeltaToMovement(t, l);
                            e.scale$2(_, n.dir, i)
                        }
                    }
                    const g = e.add(f, f, _);
                    o._translateCameraConstrained(g), l && Math.abs(o.zoom - m) > 1e-4 && o.recenterOnTerrain(), o.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(n, i, !0)
                }

                _fireEvents(t, n, i) {
                    const r = vr(this._eventsInProgress), o = vr(t), a = {};
                    for (const e in t) {
                        const {originalEvent: n} = t[e];
                        this._eventsInProgress[e] || (a[e + "start"] = n), this._eventsInProgress[e] = t[e]
                    }
                    !r && o && this._fireEvent("movestart", o.originalEvent);
                    for (const e in a) this._fireEvent(e, a[e]);
                    o && this._fireEvent("move", o.originalEvent);
                    for (const e in t) {
                        const {originalEvent: n} = t[e];
                        this._fireEvent(e, n)
                    }
                    const s = {};
                    let l;
                    for (const e in this._eventsInProgress) {
                        const {handlerName: t, originalEvent: i} = this._eventsInProgress[e];
                        this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = n[t] || i, s[e + "end"] = l)
                    }
                    for (const e in s) this._fireEvent(e, s[e]);
                    const c = vr(this._eventsInProgress);
                    if (i && (r || o) && !c) {
                        this._updatingCamera = !0;
                        const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                            n = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
                        t ? (n(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {originalEvent: l})) : (this._map.fire(new e.Event("moveend", {originalEvent: l})), n(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1
                    }
                }

                _fireEvent(t, n) {
                    this._map.fire(new e.Event(t, n ? {originalEvent: n} : {}))
                }

                _requestFrame() {
                    return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {
                        delete this._frameId, this.handleEvent(new xr("renderFrame", {timeStamp: e})), this._applyChanges()
                    })
                }

                _triggerRenderFrame() {
                    void 0 === this._frameId && (this._frameId = this._requestFrame())
                }
            }

            const Tr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";

            class kr extends e.Evented {
                constructor(t, n) {
                    super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = n.bearingSnap, e.bindAll(["_renderFrameCallback"], this)
                }

                getCenter() {
                    return new e.LngLat(this.transform.center.lng, this.transform.center.lat)
                }

                setCenter(e, t) {
                    return this.jumpTo({center: e}, t)
                }

                panBy(t, n, i) {
                    return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({offset: t}, n), i)
                }

                panTo(t, n, i) {
                    return this.easeTo(e.extend({center: t}, n), i)
                }

                getZoom() {
                    return this.transform.zoom
                }

                setZoom(e, t) {
                    return this.jumpTo({zoom: e}, t), this
                }

                zoomTo(t, n, i) {
                    return this.easeTo(e.extend({zoom: t}, n), i)
                }

                zoomIn(e, t) {
                    return this.zoomTo(this.getZoom() + 1, e, t), this
                }

                zoomOut(e, t) {
                    return this.zoomTo(this.getZoom() - 1, e, t), this
                }

                getBearing() {
                    return this.transform.bearing
                }

                setBearing(e, t) {
                    return this.jumpTo({bearing: e}, t), this
                }

                getPadding() {
                    return this.transform.padding
                }

                setPadding(e, t) {
                    return this.jumpTo({padding: e}, t), this
                }

                rotateTo(t, n, i) {
                    return this.easeTo(e.extend({bearing: t}, n), i)
                }

                resetNorth(t, n) {
                    return this.rotateTo(0, e.extend({duration: 1e3}, t), n), this
                }

                resetNorthPitch(t, n) {
                    return this.easeTo(e.extend({bearing: 0, pitch: 0, duration: 1e3}, t), n), this
                }

                snapToNorth(e, t) {
                    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this
                }

                getPitch() {
                    return this.transform.pitch
                }

                setPitch(e, t) {
                    return this.jumpTo({pitch: e}, t), this
                }

                cameraForBounds(t, n) {
                    t = e.LngLatBounds.convert(t);
                    const i = n && n.bearing || 0;
                    return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), i, n)
                }

                _extendCameraOptions(t) {
                    const n = {top: 0, bottom: 0, right: 0, left: 0};
                    if ("number" == typeof (t = e.extend({
                        padding: n,
                        offset: [0, 0],
                        maxZoom: this.transform.maxZoom
                    }, t)).padding) {
                        const e = t.padding;
                        t.padding = {top: e, bottom: e, right: e, left: e}
                    }
                    return t.padding = e.extend(n, t.padding), t
                }

                _cameraForBoxAndBearing(t, n, i, r) {
                    const o = this._extendCameraOptions(r), a = this.transform, s = a.padding,
                        l = a.project(e.LngLat.convert(t)), c = a.project(e.LngLat.convert(n)),
                        u = l.rotate(-e.degToRad(i)), d = c.rotate(-e.degToRad(i)),
                        h = new e.pointGeometry(Math.max(u.x, d.x), Math.max(u.y, d.y)),
                        p = new e.pointGeometry(Math.min(u.x, d.x), Math.min(u.y, d.y)), f = h.sub(p),
                        m = (a.width - (s.left + s.right + o.padding.left + o.padding.right)) / f.x,
                        _ = (a.height - (s.top + s.bottom + o.padding.top + o.padding.bottom)) / f.y;
                    if (_ < 0 || m < 0) return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                    const g = Math.min(a.scaleZoom(a.scale * Math.min(m, _)), o.maxZoom),
                        y = "number" == typeof o.offset.x ? new e.pointGeometry(o.offset.x, o.offset.y) : e.pointGeometry.convert(o.offset),
                        v = new e.pointGeometry((o.padding.left - o.padding.right) / 2, (o.padding.top - o.padding.bottom) / 2).rotate(i * Math.PI / 180),
                        x = y.add(v).mult(a.scale / a.zoomScale(g));
                    return {center: a.unproject(l.add(c).div(2).sub(x)), zoom: g, bearing: i}
                }

                _cameraForBox(t, n, i, r, o) {
                    const a = this._extendCameraOptions(o);
                    i = i || 0, r = r || 0, t = e.LngLat.convert(t), n = e.LngLat.convert(n);
                    const s = this.transform.clone();
                    s.padding = a.padding;
                    const l = this.getFreeCameraOptions(), c = new e.LngLat(.5 * (t.lng + n.lng), .5 * (t.lat + n.lat)),
                        u = .5 * (i + r);
                    if (s._camera.position[2] < e.mercatorZfromAltitude(u, c.lat)) return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                    l.lookAtPoint(c), s.setFreeCameraOptions(l);
                    const d = e.MercatorCoordinate.fromLngLat(t), h = e.MercatorCoordinate.fromLngLat(n),
                        p = s.pointRayIntersection(s.centerPoint, u),
                        f = [(m = s.rayIntersectionCoordinate(p)).x, m.y, m.z];
                    var m;
                    const _ = s.screenPointToMercatorRay(s.centerPoint), g = "globe" !== s.projection.name;
                    let y, v = 0;
                    do {
                        const n = Math.floor(s.zoom), o = 1 << n, a = Math.min(o * d.x, o * h.x),
                            l = Math.min(o * d.y, o * h.y), c = Math.max(o * d.x, o * h.x),
                            u = Math.max(o * d.y, o * h.y), p = new e.Aabb([a, l, i], [c, u, r]),
                            m = e.Frustum.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, n, g);
                        if (2 !== p.intersects(m)) {
                            y && (s._camera.position = e.scaleAndAdd([], s._camera.position, _.dir, -y), s._updateStateFromCamera());
                            break
                        }
                        const v = e.sub([], s._camera.position, f);
                        y = .5 * e.length(v), s._camera.position = e.scaleAndAdd([], s._camera.position, _.dir, y);
                        try {
                            s._updateStateFromCamera()
                        } catch (t) {
                            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                        }
                    } while (++v < 10);
                    return {center: s.center, zoom: s.zoom, bearing: s.bearing, pitch: s.pitch}
                }

                fitBounds(e, t, n) {
                    return this._fitInternal(this.cameraForBounds(e, t), t, n)
                }

                _raycastElevationBox(t, n) {
                    const i = this.transform.elevation;
                    if (!i) return;
                    const r = new e.pointGeometry(t.x, n.y), o = new e.pointGeometry(n.x, t.y),
                        a = i.pointCoordinate(t);
                    if (!a) return;
                    const s = i.pointCoordinate(n);
                    if (!s) return;
                    const l = i.pointCoordinate(r);
                    if (!l) return;
                    const c = i.pointCoordinate(o);
                    if (!c) return;
                    const u = new e.MercatorCoordinate(a[0], a[1]).toLngLat(),
                        d = new e.MercatorCoordinate(s[0], s[1]).toLngLat(),
                        h = new e.MercatorCoordinate(l[0], l[1]).toLngLat(),
                        p = new e.MercatorCoordinate(c[0], c[1]).toLngLat(),
                        f = Math.min(u.lng, Math.min(d.lng, Math.min(h.lng, p.lng))),
                        m = Math.min(u.lat, Math.min(d.lat, Math.min(h.lat, p.lat))),
                        _ = Math.max(u.lng, Math.max(d.lng, Math.max(h.lng, p.lng))),
                        g = Math.max(u.lat, Math.max(d.lat, Math.max(h.lat, p.lat))),
                        y = Math.min(a[3], Math.min(s[3], Math.min(l[3], c[3]))),
                        v = Math.max(a[3], Math.max(s[3], Math.max(l[3], c[3])));
                    return {
                        minLngLat: new e.LngLat(f, m),
                        maxLngLat: new e.LngLat(_, g),
                        minAltitude: y,
                        maxAltitude: v
                    }
                }

                fitScreenCoordinates(t, n, i, r, o) {
                    let a, s, l, c;
                    const u = e.pointGeometry.convert(t), d = e.pointGeometry.convert(n),
                        h = this._raycastElevationBox(u, d);
                    if (h) a = h.minLngLat, s = h.maxLngLat, l = h.minAltitude, c = h.maxAltitude; else {
                        if (this.transform.anyCornerOffEdge(u, d)) return this;
                        a = this.transform.pointLocation(u), s = this.transform.pointLocation(d)
                    }
                    return this._fitInternal(0 === this.transform.pitch ? this._cameraForBoxAndBearing(this.transform.pointLocation(e.pointGeometry.convert(t)), this.transform.pointLocation(e.pointGeometry.convert(n)), i, r) : this._cameraForBox(a, s, l, c, r), r, o)
                }

                _fitInternal(t, n, i) {
                    return t ? (delete (n = e.extend(t, n)).padding, n.linear ? this.easeTo(n, i) : this.flyTo(n, i)) : this
                }

                jumpTo(t, n) {
                    this.stop();
                    const i = t.preloadOnly ? this.transform.clone() : this.transform;
                    let r = !1, o = !1, a = !1;
                    return "zoom" in t && i.zoom !== +t.zoom && (r = !0, i.zoom = +t.zoom), void 0 !== t.center && (i.center = e.LngLat.convert(t.center)), "bearing" in t && i.bearing !== +t.bearing && (o = !0, i.bearing = +t.bearing), "pitch" in t && i.pitch !== +t.pitch && (a = !0, i.pitch = +t.pitch), null == t.padding || i.isPaddingEqual(t.padding) || (i.padding = t.padding), t.preloadOnly ? (this._preloadTiles(i), this) : (this.fire(new e.Event("movestart", n)).fire(new e.Event("move", n)), r && this.fire(new e.Event("zoomstart", n)).fire(new e.Event("zoom", n)).fire(new e.Event("zoomend", n)), o && this.fire(new e.Event("rotatestart", n)).fire(new e.Event("rotate", n)).fire(new e.Event("rotateend", n)), a && this.fire(new e.Event("pitchstart", n)).fire(new e.Event("pitch", n)).fire(new e.Event("pitchend", n)), this.fire(new e.Event("moveend", n)))
                }

                getFreeCameraOptions() {
                    return this.transform.projection.supportsFreeCamera || e.warnOnce(Tr), this.transform.getFreeCameraOptions()
                }

                setFreeCameraOptions(t, n) {
                    const i = this.transform;
                    if (!i.projection.supportsFreeCamera) return void e.warnOnce(Tr);
                    this.stop();
                    const r = i.zoom, o = i.pitch, a = i.bearing;
                    i.setFreeCameraOptions(t);
                    const s = r !== i.zoom, l = o !== i.pitch, c = a !== i.bearing;
                    return this.fire(new e.Event("movestart", n)).fire(new e.Event("move", n)), s && this.fire(new e.Event("zoomstart", n)).fire(new e.Event("zoom", n)).fire(new e.Event("zoomend", n)), c && this.fire(new e.Event("rotatestart", n)).fire(new e.Event("rotate", n)).fire(new e.Event("rotateend", n)), l && this.fire(new e.Event("pitchstart", n)).fire(new e.Event("pitch", n)).fire(new e.Event("pitchend", n)), this.fire(new e.Event("moveend", n)), this
                }

                easeTo(t, n) {
                    this._stop(!1, t.easeId), (!1 === (t = e.extend({
                        offset: [0, 0],
                        duration: 500,
                        easing: e.ease
                    }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0);
                    const i = this.transform, r = this.getZoom(), o = this.getBearing(), a = this.getPitch(),
                        s = this.getPadding(), l = "zoom" in t ? +t.zoom : r,
                        c = "bearing" in t ? this._normalizeBearing(t.bearing, o) : o, u = "pitch" in t ? +t.pitch : a,
                        d = "padding" in t ? t.padding : i.padding, h = e.pointGeometry.convert(t.offset);
                    let p = i.centerPoint.add(h);
                    const f = "globe" === i.projection.name ? i.pointCoordinate(p).toLngLat() : i.pointLocation(p),
                        m = e.LngLat.convert(t.center || f);
                    this._normalizeCenter(m);
                    const _ = i.project(f), g = i.project(m).sub(_), y = i.zoomScale(l - r);
                    let v, x;
                    t.around && (v = e.LngLat.convert(t.around), x = i.locationPoint(v));
                    const b = this._zooming || l !== r, w = this._rotating || o !== c, M = this._pitching || u !== a,
                        T = !i.isPaddingEqual(d), k = i => f => {
                            if (b && (i.zoom = e.number(r, l, f)), w && (i.bearing = e.number(o, c, f)), M && (i.pitch = e.number(a, u, f)), T && (i.interpolatePadding(s, d, f), p = i.centerPoint.add(h)), v) i.setLocationAtPoint(v, x); else {
                                const e = i.zoomScale(i.zoom - r), t = l > r ? Math.min(2, y) : Math.max(.5, y),
                                    n = Math.pow(t, 1 - f), o = i.unproject(_.add(g.mult(f * n)).mult(e));
                                i.setLocationAtPoint(i.renderWorldCopies ? o.wrap() : o, p)
                            }
                            return t.preloadOnly || this._fireMoveEvents(n), i
                        };
                    if (t.preloadOnly) {
                        const e = this._emulate(k, t.duration, i);
                        return this._preloadTiles(e), this
                    }
                    const S = {
                        moving: this._moving,
                        zooming: this._zooming,
                        rotating: this._rotating,
                        pitching: this._pitching
                    };
                    return this._zooming = b, this._rotating = w, this._pitching = M, this._padding = T, this._easeId = t.easeId, this._prepareEase(n, t.noMoveStart, S), this._ease(k(i), e => {
                        i.recenterOnTerrain(), this._afterEase(n, e)
                    }, t), this
                }

                _prepareEase(t, n, i = {}) {
                    this._moving = !0, this.transform.cameraElevationReference = "sea", n || i.moving || this.fire(new e.Event("movestart", t)), this._zooming && !i.zooming && this.fire(new e.Event("zoomstart", t)), this._rotating && !i.rotating && this.fire(new e.Event("rotatestart", t)), this._pitching && !i.pitching && this.fire(new e.Event("pitchstart", t))
                }

                _fireMoveEvents(t) {
                    this.fire(new e.Event("move", t)), this._zooming && this.fire(new e.Event("zoom", t)), this._rotating && this.fire(new e.Event("rotate", t)), this._pitching && this.fire(new e.Event("pitch", t))
                }

                _afterEase(t, n) {
                    if (this._easeId && n && this._easeId === n) return;
                    delete this._easeId, this.transform.cameraElevationReference = "ground";
                    const i = this._zooming, r = this._rotating, o = this._pitching;
                    this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, i && this.fire(new e.Event("zoomend", t)), r && this.fire(new e.Event("rotateend", t)), o && this.fire(new e.Event("pitchend", t)), this.fire(new e.Event("moveend", t))
                }

                flyTo(t, n) {
                    if (!t.essential && e.exported.prefersReducedMotion) {
                        const i = e.pick(t, ["center", "zoom", "bearing", "pitch", "around"]);
                        return this.jumpTo(i, n)
                    }
                    this.stop(), t = e.extend({offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease}, t);
                    const i = this.transform, r = this.getZoom(), o = this.getBearing(), a = this.getPitch(),
                        s = this.getPadding(), l = "zoom" in t ? e.clamp(+t.zoom, i.minZoom, i.maxZoom) : r,
                        c = "bearing" in t ? this._normalizeBearing(t.bearing, o) : o, u = "pitch" in t ? +t.pitch : a,
                        d = "padding" in t ? t.padding : i.padding, h = i.zoomScale(l - r),
                        p = e.pointGeometry.convert(t.offset);
                    let f = i.centerPoint.add(p);
                    const m = i.pointLocation(f), _ = e.LngLat.convert(t.center || m);
                    this._normalizeCenter(_);
                    const g = i.project(m), y = i.project(_).sub(g);
                    let v = t.curve;
                    const x = Math.max(i.width, i.height), b = x / h, w = y.mag();
                    if ("minZoom" in t) {
                        const n = e.clamp(Math.min(t.minZoom, r, l), i.minZoom, i.maxZoom), o = x / i.zoomScale(n - r);
                        v = Math.sqrt(o / w * 2)
                    }
                    const M = v * v;

                    function T(e) {
                        const t = (b * b - x * x + (e ? -1 : 1) * M * M * w * w) / (2 * (e ? b : x) * M * w);
                        return Math.log(Math.sqrt(t * t + 1) - t)
                    }

                    function k(e) {
                        return (Math.exp(e) - Math.exp(-e)) / 2
                    }

                    function S(e) {
                        return (Math.exp(e) + Math.exp(-e)) / 2
                    }

                    const D = T(0);
                    let L = function (e) {
                        return S(D) / S(D + v * e)
                    }, E = function (e) {
                        return x * ((S(D) * (k(t = D + v * e) / S(t)) - k(D)) / M) / w;
                        var t
                    }, C = (T(1) - D) / v;
                    if (Math.abs(w) < 1e-6 || !isFinite(C)) {
                        if (Math.abs(x - b) < 1e-6) return this.easeTo(t, n);
                        const e = b < x ? -1 : 1;
                        C = Math.abs(Math.log(b / x)) / v, E = function () {
                            return 0
                        }, L = function (t) {
                            return Math.exp(e * v * t)
                        }
                    }
                    t.duration = "duration" in t ? +t.duration : 1e3 * C / ("screenSpeed" in t ? +t.screenSpeed / v : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
                    const A = o !== c, I = u !== a, P = !i.isPaddingEqual(d), R = i => h => {
                        const m = h * C, v = 1 / L(m);
                        i.zoom = 1 === h ? l : r + i.scaleZoom(v), A && (i.bearing = e.number(o, c, h)), I && (i.pitch = e.number(a, u, h)), P && (i.interpolatePadding(s, d, h), f = i.centerPoint.add(p));
                        const x = 1 === h ? _ : i.unproject(g.add(y.mult(E(m))).mult(v));
                        return i.setLocationAtPoint(i.renderWorldCopies ? x.wrap() : x, f), i._updateCenterElevation(), t.preloadOnly || this._fireMoveEvents(n), i
                    };
                    if (t.preloadOnly) {
                        const e = this._emulate(R, t.duration, i);
                        return this._preloadTiles(e), this
                    }
                    return this._zooming = !0, this._rotating = A, this._pitching = I, this._padding = P, this._prepareEase(n, !1), this._ease(R(i), () => this._afterEase(n), t), this
                }

                isEasing() {
                    return !!this._easeFrameId
                }

                stop() {
                    return this._stop()
                }

                _stop(e, t) {
                    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                        const e = this._onEaseEnd;
                        delete this._onEaseEnd, e.call(this, t)
                    }
                    if (!e) {
                        const e = this.handlers;
                        e && e.stop(!1)
                    }
                    return this
                }

                _ease(t, n, i) {
                    !1 === i.animate || 0 === i.duration ? (t(1), n()) : (this._easeStart = e.exported.now(), this._easeOptions = i, this._onEaseFrame = t, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                }

                _renderFrameCallback() {
                    const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
                    this._onEaseFrame(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                }

                _normalizeBearing(t, n) {
                    t = e.wrap(t, -180, 180);
                    const i = Math.abs(t - n);
                    return Math.abs(t - 360 - n) < i && (t -= 360), Math.abs(t + 360 - n) < i && (t += 360), t
                }

                _normalizeCenter(e) {
                    const t = this.transform;
                    if (!t.renderWorldCopies || t.maxBounds) return;
                    const n = e.lng - t.center.lng;
                    e.lng += n > 180 ? -360 : n < -180 ? 360 : 0
                }

                _emulate(e, t, n) {
                    const i = Math.ceil(15 * t / 1e3), r = [], o = e(n.clone());
                    for (let e = 0; e <= i; e++) {
                        const t = o(e / i);
                        r.push(t.clone())
                    }
                    return r
                }
            }

            class Sr {
                constructor(t = {}) {
                    this.options = t, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
                }

                getDefaultPosition() {
                    return "bottom-right"
                }

                onAdd(e) {
                    const t = this.options && this.options.compact;
                    return this._map = e, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = a.create("button", "mapboxgl-ctrl-attrib-button", this._container), a.create("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", !0), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = a.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container
                }

                onRemove() {
                    this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0
                }

                _setElementTitle(e, t) {
                    const n = this._map._getUIString("AttributionControl." + t);
                    e.setAttribute("aria-label", n), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", n)
                }

                _toggleAttribution() {
                    this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"))
                }

                _updateEditLink() {
                    let t = this._editLink;
                    t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                    const n = [{key: "owner", value: this.styleOwner}, {
                        key: "id",
                        value: this.styleId
                    }, {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN
                    }];
                    if (t) {
                        const i = n.reduce((e, t, i) => (t.value && (e += `${t.key}=${t.value}${i < n.length - 1 ? "&" : ""}`), e), "?");
                        t.href = `${e.config.FEEDBACK_URL}/${i}${this._map._hash ? this._map._hash.getHashString(!0) : ""}`, t.rel = "noopener nofollow", this._setElementTitle(t, "MapFeedback")
                    }
                }

                _updateData(e) {
                    !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink())
                }

                _updateAttributions() {
                    if (!this._map.style) return;
                    let e = [];
                    if (this._map.style.stylesheet) {
                        const e = this._map.style.stylesheet;
                        this.styleOwner = e.owner, this.styleId = e.id
                    }
                    const t = this._map.style._sourceCaches;
                    for (const n in t) {
                        const i = t[n];
                        if (i.used) {
                            const t = i.getSource();
                            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution)
                        }
                    }
                    e.sort((e, t) => e.length - t.length), e = e.filter((t, n) => {
                        for (let i = n + 1; i < e.length; i++) if (e[i].indexOf(t) >= 0) return !1;
                        return !0
                    }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));
                    const n = e.join(" | ");
                    n !== this._attribHTML && (this._attribHTML = n, e.length ? (this._innerContainer.innerHTML = n, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null)
                }

                _updateCompact() {
                    this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
                }
            }

            class Dr {
                constructor() {
                    e.bindAll(["_updateLogo"], this), e.bindAll(["_updateCompact"], this)
                }

                onAdd(e) {
                    this._map = e, this._container = a.create("div", "mapboxgl-ctrl");
                    const t = a.create("a", "mapboxgl-ctrl-logo");
                    return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
                }

                onRemove() {
                    this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact)
                }

                getDefaultPosition() {
                    return "bottom-left"
                }

                _updateLogo(e) {
                    e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none")
                }

                _logoRequired() {
                    if (!this._map.style) return !0;
                    const e = this._map.style._sourceCaches;
                    if (0 === Object.entries(e).length) return !0;
                    for (const t in e) {
                        const n = e[t].getSource();
                        if (n.hasOwnProperty("mapbox_logo") && !n.mapbox_logo) return !1
                    }
                    return !0
                }

                _updateCompact() {
                    const e = this._container.children;
                    if (e.length) {
                        const t = e[0];
                        this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact")
                    }
                }
            }

            class Lr {
                constructor() {
                    this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
                }

                add(e) {
                    const t = ++this._id;
                    return this._queue.push({callback: e, id: t, cancelled: !1}), t
                }

                remove(e) {
                    const t = this._currentlyRunning, n = t ? this._queue.concat(t) : this._queue;
                    for (const t of n) if (t.id === e) return void (t.cancelled = !0)
                }

                run(e = 0) {
                    const t = this._currentlyRunning = this._queue;
                    this._queue = [];
                    for (const n of t) if (!n.cancelled && (n.callback(e), this._cleared)) break;
                    this._cleared = !1, this._currentlyRunning = !1
                }

                clear() {
                    this._currentlyRunning && (this._cleared = !0), this._queue = []
                }
            }

            function Er(t, n, i) {
                if (t = new e.LngLat(t.lng, t.lat), n) {
                    const r = new e.LngLat(t.lng - 360, t.lat), o = new e.LngLat(t.lng + 360, t.lat),
                        a = 360 * Math.ceil(Math.abs(t.lng - i.center.lng) / 360), s = i.locationPoint(t).distSqr(n),
                        l = n.x < 0 || n.y < 0 || n.x > i.width || n.y > i.height;
                    i.locationPoint(r).distSqr(n) < s && (l || Math.abs(r.lng - i.center.lng) < a) ? t = r : i.locationPoint(o).distSqr(n) < s && (l || Math.abs(o.lng - i.center.lng) < a) && (t = o)
                }
                for (; Math.abs(t.lng - i.center.lng) > 180;) {
                    const e = i.locationPoint(t);
                    if (e.x >= 0 && e.y >= 0 && e.x <= i.width && e.y <= i.height) break;
                    t.lng > i.center.lng ? t.lng -= 360 : t.lng += 360
                }
                return t
            }

            const Cr = {
                center: "translate(-50%,-50%)",
                top: "translate(-50%,0)",
                "top-left": "translate(0,0)",
                "top-right": "translate(-100%,0)",
                bottom: "translate(-50%,-100%)",
                "bottom-left": "translate(0,-100%)",
                "bottom-right": "translate(-100%,-100%)",
                left: "translate(0,-50%)",
                right: "translate(-100%,-50%)"
            };

            class Ar extends e.Evented {
                constructor(t, n) {
                    if (super(), (t instanceof e.window.HTMLElement || n) && (t = e.extend({element: t}, n)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && "auto" !== t.pitchAlignment ? t.pitchAlignment : this._rotationAlignment, this._updateMoving = () => this._update(!0), t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]); else {
                        this._defaultMarker = !0, this._element = a.create("div");
                        const n = 41, i = 27, r = a.createSVG("svg", {
                                display: "block",
                                height: n * this._scale + "px",
                                width: i * this._scale + "px",
                                viewBox: `0 0 ${i} ${n}`
                            }, this._element),
                            o = a.createSVG("radialGradient", {id: "shadowGradient"}, a.createSVG("defs", {}, r));
                        a.createSVG("stop", {
                            offset: "10%",
                            "stop-opacity": .4
                        }, o), a.createSVG("stop", {
                            offset: "100%",
                            "stop-opacity": .05
                        }, o), a.createSVG("ellipse", {
                            cx: 13.5,
                            cy: 34.8,
                            rx: 10.5,
                            ry: 5.25,
                            fill: "url(#shadowGradient)"
                        }, r), a.createSVG("path", {
                            fill: this._color,
                            d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                        }, r), a.createSVG("path", {
                            opacity: .25,
                            d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                        }, r), a.createSVG("circle", {
                            fill: "white",
                            cx: 13.5,
                            cy: 13.5,
                            r: 5.5
                        }, r), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14])
                    }
                    this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", e => {
                        e.preventDefault()
                    }), this._element.addEventListener("mousedown", e => {
                        e.preventDefault()
                    });
                    const i = this._element.classList;
                    for (const e in Cr) i.remove("mapboxgl-marker-anchor-" + e);
                    i.add("mapboxgl-marker-anchor-" + this._anchor), this._popup = null
                }

                addTo(e) {
                    return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick)), this
                }

                remove() {
                    return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._updateMoving), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._map.off("remove", this._clearFadeTimer), this._map._removeMarker(this), delete this._map), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this
                }

                getLngLat() {
                    return this._lngLat
                }

                setLngLat(t) {
                    return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this
                }

                getElement() {
                    return this._element
                }

                setPopup(e) {
                    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                        if (!("offset" in e.options)) {
                            const t = 38.1, n = 13.5, i = Math.sqrt(Math.pow(n, 2) / 2);
                            e.options.offset = this._defaultMarker ? {
                                top: [0, 0],
                                "top-left": [0, 0],
                                "top-right": [0, 0],
                                bottom: [0, -t],
                                "bottom-left": [i, -1 * (t - n + i)],
                                "bottom-right": [-i, -1 * (t - n + i)],
                                left: [n, -1 * (t - n)],
                                right: [-n, -1 * (t - n)]
                            } : this._offset
                        }
                        this._popup = e, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false")
                    }
                    return this
                }

                _onKeyPress(e) {
                    const t = e.code, n = e.charCode || e.keyCode;
                    "Space" !== t && "Enter" !== t && 32 !== n && 13 !== n || this.togglePopup()
                }

                _onMapClick(e) {
                    const t = e.originalEvent.target, n = this._element;
                    this._popup && (t === n || n.contains(t)) && this.togglePopup()
                }

                getPopup() {
                    return this._popup
                }

                togglePopup() {
                    const e = this._popup;
                    return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this
                }

                _evaluateOpacity() {
                    const e = this._pos ? this._pos.sub(this._transformedOffset()) : null;
                    if (!this._withinScreenBounds(e)) return void this._clearFadeTimer();
                    const t = this._map.unproject(e);
                    let n = !1;
                    if (this._map.transform._terrainEnabled() && this._map.getTerrain()) {
                        const e = this._map.getFreeCameraOptions();
                        if (e.position) {
                            const i = e.position.toLngLat();
                            n = i.distanceTo(t) < .9 * i.distanceTo(this._lngLat)
                        }
                    }
                    const i = (1 - this._map._queryFogOpacity(t)) * (n ? .2 : 1);
                    this._element.style.opacity = "" + i, this._popup && this._popup._setOpacity("" + i), this._fadeTimer = null
                }

                _clearFadeTimer() {
                    this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null)
                }

                _withinScreenBounds(e) {
                    const t = this._map.transform;
                    return !!e && e.x >= 0 && e.x < t.width && e.y >= 0 && e.y < t.height
                }

                _updateDOM() {
                    const t = this._pos || new e.pointGeometry(0, 0), n = this._calculatePitch(),
                        i = this._calculateRotation();
                    this._element.style.transform = `${Cr[this._anchor]} translate(${t.x}px, ${t.y}px) rotateX(${n}deg) rotateZ(${i}deg)`
                }

                _calculatePitch() {
                    return "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? 0 : "map" === this._pitchAlignment ? this._map.getPitch() : 0
                }

                _calculateRotation() {
                    return "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? this._rotation : "map" === this._rotationAlignment ? this._rotation - this._map.getBearing() : 0
                }

                _update(t) {
                    e.window.cancelAnimationFrame(this._updateFrameId), this._map && (this._map.transform.renderWorldCopies && (this._lngLat = Er(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._transformedOffset()), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {
                        this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM())
                    }) : this._pos = this._pos.round(), this._map._requestDomTask(() => {
                        this._map && (this._element && this._pos && this._anchor && this._updateDOM(), !this._map.getTerrain() && !this._map.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)))
                    }))
                }

                _transformedOffset() {
                    if (!this._defaultMarker) return this._offset;
                    const e = this._map.transform, t = this._offset.mult(this._scale);
                    return "map" === this._rotationAlignment && t._rotate(e.angle), "map" === this._pitchAlignment && (t.y *= Math.cos(e._pitch)), t
                }

                getOffset() {
                    return this._offset
                }

                setOffset(t) {
                    return this._offset = e.pointGeometry.convert(t), this._update(), this
                }

                _onMove(t) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || this._map._clickTolerance;
                        this._isDragging = t.point.dist(this._pointerdownPos) >= e
                    }
                    this._isDragging && (this._pos = t.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag")))
                }

                _onUp() {
                    this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive"
                }

                _addDragHandler(e) {
                    this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos).add(this._transformedOffset()), this._pointerdownPos = e.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
                }

                setDraggable(e) {
                    return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
                }

                isDraggable() {
                    return this._draggable
                }

                setRotation(e) {
                    return this._rotation = e || 0, this._update(), this
                }

                getRotation() {
                    return this._rotation
                }

                setRotationAlignment(e) {
                    return this._rotationAlignment = e || "auto", this._update(), this
                }

                getRotationAlignment() {
                    return this._rotationAlignment
                }

                setPitchAlignment(e) {
                    return this._pitchAlignment = e && "auto" !== e ? e : this._rotationAlignment, this._update(), this
                }

                getPitchAlignment() {
                    return this._pitchAlignment
                }
            }

            class Ir {
                constructor(e) {
                    this.jumpTo(e)
                }

                getValue(t) {
                    if (t <= this._startTime) return this._start;
                    if (t >= this._endTime) return this._end;
                    const n = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));
                    return this._start * (1 - n) + this._end * n
                }

                isEasing(e) {
                    return e >= this._startTime && e <= this._endTime
                }

                jumpTo(e) {
                    this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e
                }

                easeTo(e, t, n) {
                    this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + n
                }
            }

            const Pr = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable": "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScaleControl.Feet": "ft",
                "ScaleControl.Meters": "m",
                "ScaleControl.Kilometers": "km",
                "ScaleControl.Miles": "mi",
                "ScaleControl.NauticalMiles": "nm",
                "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map"
            }, {HTMLImageElement: Rr, HTMLElement: Yr, ImageBitmap: zr} = e.window, Or = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                optimizeForTerrain: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                crossSourceCollisions: !0
            };

            function Fr(e) {
                e.parentNode && e.parentNode.removeChild(e)
            }

            const Br = {showCompass: !0, showZoom: !0, visualizePitch: !1};

            class jr {
                constructor(t, n, i = !1) {
                    this._clickTolerance = 10, this.element = n, this.mouseRotate = new Ji({clickTolerance: t.dragRotate._mouseRotate._clickTolerance}), this.map = t, i && (this.mousePitch = new Ki({clickTolerance: t.dragRotate._mousePitch._clickTolerance})), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), n.addEventListener("mousedown", this.mousedown), n.addEventListener("touchstart", this.touchstart, {passive: !1}), n.addEventListener("touchmove", this.touchmove), n.addEventListener("touchend", this.touchend), n.addEventListener("touchcancel", this.reset)
                }

                down(e, t) {
                    this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), a.disableDrag()
                }

                move(e, t) {
                    const n = this.map, i = this.mouseRotate.mousemoveWindow(e, t);
                    if (i && i.bearingDelta && n.setBearing(n.getBearing() + i.bearingDelta), this.mousePitch) {
                        const i = this.mousePitch.mousemoveWindow(e, t);
                        i && i.pitchDelta && n.setPitch(n.getPitch() + i.pitchDelta)
                    }
                }

                off() {
                    const e = this.element;
                    e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, {passive: !1}), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp()
                }

                offTemp() {
                    a.enableDrag(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup)
                }

                mousedown(t) {
                    this.down(e.extend({}, t, {
                        ctrlKey: !0,
                        preventDefault: () => t.preventDefault()
                    }), a.mousePos(this.element, t)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup)
                }

                mousemove(e) {
                    this.move(e, a.mousePos(this.element, e))
                }

                mouseup(e) {
                    this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp()
                }

                touchstart(e) {
                    1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = a.touchPos(this.element, e.targetTouches)[0], this.down({
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => e.preventDefault()
                    }, this._startPos))
                }

                touchmove(e) {
                    1 !== e.targetTouches.length ? this.reset() : (this._lastPos = a.touchPos(this.element, e.targetTouches)[0], this.move({preventDefault: () => e.preventDefault()}, this._lastPos))
                }

                touchend(e) {
                    0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset()
                }

                reset() {
                    this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
                }
            }

            const Hr = {
                positionOptions: {enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3},
                fitBoundsOptions: {maxZoom: 15},
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
                showUserHeading: !1
            };
            let Nr, Ur = 0, Wr = !1;
            const Vr = {maxWidth: 100, unit: "metric"};

            function Gr(e, t, n) {
                const i = n && n.maxWidth || 100, r = e._containerHeight / 2, o = e.unproject([0, r]),
                    a = e.unproject([i, r]), s = o.distanceTo(a);
                if (n && "imperial" === n.unit) {
                    const n = 3.2808 * s;
                    n > 5280 ? qr(t, i, n / 5280, e._getUIString("ScaleControl.Miles"), e) : qr(t, i, n, e._getUIString("ScaleControl.Feet"), e)
                } else n && "nautical" === n.unit ? qr(t, i, s / 1852, e._getUIString("ScaleControl.NauticalMiles"), e) : s >= 1e3 ? qr(t, i, s / 1e3, e._getUIString("ScaleControl.Kilometers"), e) : qr(t, i, s, e._getUIString("ScaleControl.Meters"), e)
            }

            function qr(e, t, n, i, r) {
                const o = function (e) {
                    const t = Math.pow(10, ("" + Math.floor(e)).length - 1);
                    let n = e / t;
                    return n = n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : n >= 1 ? 1 : function (e) {
                        const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
                        return Math.round(e * t) / t
                    }(n), t * n
                }(n), a = o / n;
                r._requestDomTask(() => {
                    e.style.width = t * a + "px", e.innerHTML = `${o}&nbsp;${i}`
                })
            }

            const Zr = {closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px"},
                $r = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "),
                Xr = {
                    version: e.version,
                    supported: t,
                    setRTLTextPlugin: e.setRTLTextPlugin,
                    getRTLTextPluginStatus: e.getRTLTextPluginStatus,
                    Map: class extends kr {
                        constructor(t) {
                            if (null != (t = e.extend({}, Or, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                            if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                            if (null != t.minPitch && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                            if (null != t.maxPitch && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                            if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Di(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._renderTaskQueue = new Lr, this._domRenderTaskQueue = new Lr, this._controls = [], this._markers = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, Pr, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevation = new Ir(0), this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, "string" == typeof t.container) {
                                if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`)
                            } else {
                                if (!(t.container instanceof Yr)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                                this._container = t.container
                            }
                            if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                            this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, !1), e.window.addEventListener("resize", this._onWindowResize, !1), e.window.addEventListener("orientationchange", this._onWindowResize, !1), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1)), this.handlers = new Mr(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, {
                                localFontFamily: this._localFontFamily,
                                localIdeographFontFamily: this._localIdeographFontFamily
                            }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new Ei("string" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                                center: t.center,
                                zoom: t.zoom,
                                bearing: t.bearing,
                                pitch: t.pitch
                            }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, {duration: 0})))), this.resize(), t.attributionControl && this.addControl(new Sr({customAttribution: t.customAttribution})), this._logoControl = new Dr, this.addControl(this._logoControl, t.logoPosition), this.on("style.load", () => {
                                this.transform.unmodified && this.jumpTo(this.style.stylesheet)
                            }), this.on("data", t => {
                                this._update("style" === t.dataType), this.fire(new e.Event(t.dataType + "data", t))
                            }), this.on("dataloading", t => {
                                this.fire(new e.Event(t.dataType + "dataloading", t))
                            })
                        }

                        _getMapId() {
                            return this._mapId
                        }

                        addControl(t, n) {
                            if (void 0 === n && (n = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const i = t.onAdd(this);
                            this._controls.push(t);
                            const r = this._controlPositions[n];
                            return -1 !== n.indexOf("bottom") ? r.insertBefore(i, r.firstChild) : r.appendChild(i), this
                        }

                        removeControl(t) {
                            if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const n = this._controls.indexOf(t);
                            return n > -1 && this._controls.splice(n, 1), t.onRemove(this), this
                        }

                        hasControl(e) {
                            return this._controls.indexOf(e) > -1
                        }

                        getContainer() {
                            return this._container
                        }

                        getCanvasContainer() {
                            return this._canvasContainer
                        }

                        getCanvas() {
                            return this._canvas
                        }

                        resize(t) {
                            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                            const n = !this._moving;
                            return n && this.fire(new e.Event("movestart", t)).fire(new e.Event("move", t)), this.fire(new e.Event("resize", t)), n && this.fire(new e.Event("moveend", t)), this
                        }

                        getBounds() {
                            return this.transform.getBounds()
                        }

                        getMaxBounds() {
                            return this.transform.getMaxBounds() || null
                        }

                        setMaxBounds(t) {
                            return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update()
                        }

                        setMinZoom(t) {
                            if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
                            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                        }

                        getMinZoom() {
                            return this.transform.minZoom
                        }

                        setMaxZoom(t) {
                            if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
                            throw new Error("maxZoom must be greater than the current minZoom")
                        }

                        getMaxZoom() {
                            return this.transform.maxZoom
                        }

                        setMinPitch(t) {
                            if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");
                            if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
                            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                        }

                        getMinPitch() {
                            return this.transform.minPitch
                        }

                        setMaxPitch(t) {
                            if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85");
                            if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
                            throw new Error("maxPitch must be greater than the current minPitch")
                        }

                        getMaxPitch() {
                            return this.transform.maxPitch
                        }

                        getRenderWorldCopies() {
                            return this.transform.renderWorldCopies
                        }

                        setRenderWorldCopies(e) {
                            return this.transform.renderWorldCopies = e, this._update()
                        }

                        getProjection() {
                            return this.transform.getProjection()
                        }

                        setProjection(e) {
                            return this._lazyInitEmptyStyle(), "string" == typeof e && (e = {name: e}), this._runtimeProjection = e, this.style.updateProjection(), this._transitionFromGlobe = !1, this
                        }

                        project(t) {
                            return this.transform.locationPoint3D(e.LngLat.convert(t))
                        }

                        unproject(t) {
                            return this.transform.pointLocation3D(e.pointGeometry.convert(t))
                        }

                        isMoving() {
                            return this._moving || this.handlers && this.handlers.isMoving()
                        }

                        isZooming() {
                            return this._zooming || this.handlers && this.handlers.isZooming()
                        }

                        isRotating() {
                            return this._rotating || this.handlers && this.handlers.isRotating()
                        }

                        _createDelegatedListener(e, t, n) {
                            if ("mouseenter" === e || "mouseover" === e) {
                                let i = !1;
                                const r = r => {
                                    const o = t.filter(e => this.getLayer(e)),
                                        a = o.length ? this.queryRenderedFeatures(r.point, {layers: o}) : [];
                                    a.length ? i || (i = !0, n.call(this, new Fi(e, this, r.originalEvent, {features: a}))) : i = !1
                                }, o = () => {
                                    i = !1
                                };
                                return {layers: new Set(t), listener: n, delegates: {mousemove: r, mouseout: o}}
                            }
                            if ("mouseleave" === e || "mouseout" === e) {
                                let i = !1;
                                const r = r => {
                                    const o = t.filter(e => this.getLayer(e));
                                    (o.length ? this.queryRenderedFeatures(r.point, {layers: o}) : []).length ? i = !0 : i && (i = !1, n.call(this, new Fi(e, this, r.originalEvent)))
                                }, o = t => {
                                    i && (i = !1, n.call(this, new Fi(e, this, t.originalEvent)))
                                };
                                return {layers: new Set(t), listener: n, delegates: {mousemove: r, mouseout: o}}
                            }
                            {
                                const i = e => {
                                    const i = t.filter(e => this.getLayer(e)),
                                        r = i.length ? this.queryRenderedFeatures(e.point, {layers: i}) : [];
                                    r.length && (e.features = r, n.call(this, e), delete e.features)
                                };
                                return {layers: new Set(t), listener: n, delegates: {[e]: i}}
                            }
                        }

                        on(e, t, n) {
                            if (void 0 === n) return super.on(e, t);
                            Array.isArray(t) || (t = [t]);
                            const i = this._createDelegatedListener(e, t, n);
                            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(i);
                            for (const e in i.delegates) this.on(e, i.delegates[e]);
                            return this
                        }

                        once(e, t, n) {
                            if (void 0 === n) return super.once(e, t);
                            Array.isArray(t) || (t = [t]);
                            const i = this._createDelegatedListener(e, t, n);
                            for (const e in i.delegates) this.once(e, i.delegates[e]);
                            return this
                        }

                        off(e, t, n) {
                            if (void 0 === n) return super.off(e, t);
                            t = new Set(Array.isArray(t) ? t : [t]);
                            const i = (e, t) => {
                                if (e.size !== t.size) return !1;
                                for (const n of e) if (!t.has(n)) return !1;
                                return !0
                            }, r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                            return r && (e => {
                                for (let r = 0; r < e.length; r++) {
                                    const o = e[r];
                                    if (o.listener === n && i(o.layers, t)) {
                                        for (const e in o.delegates) this.off(e, o.delegates[e]);
                                        return e.splice(r, 1), this
                                    }
                                }
                            })(r), this
                        }

                        queryRenderedFeatures(t, n) {
                            return this.style ? (void 0 !== n || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (n = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], n = n || {}, this.transform)) : []
                        }

                        querySourceFeatures(e, t) {
                            return this.style.querySourceFeatures(e, t)
                        }

                        queryTerrainElevation(t, n) {
                            const i = this.transform.elevation;
                            return i ? (n = e.extend({}, {exaggerated: !0}, n), i.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, n.exaggerated)) : null
                        }

                        setStyle(t, n) {
                            return !1 !== (n = e.extend({}, {
                                localIdeographFontFamily: this._localIdeographFontFamily,
                                localFontFamily: this._localFontFamily
                            }, n)).diff && n.localIdeographFontFamily === this._localIdeographFontFamily && n.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, n), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._localFontFamily = n.localFontFamily, this._updateStyle(t, n))
                        }

                        _getUIString(e) {
                            const t = this._locale[e];
                            if (null == t) throw new Error(`Missing UI string '${e}'`);
                            return t
                        }

                        _updateStyle(e, t) {
                            return this.style && (this.style.setEventedParent(null), this.style._remove(), delete this.style), e && (this.style = new jt(this, t || {}), this.style.setEventedParent(this, {style: this.style}), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this
                        }

                        _lazyInitEmptyStyle() {
                            this.style || (this.style = new jt(this, {}), this.style.setEventedParent(this, {style: this.style}), this.style.loadEmpty())
                        }

                        _diffStyle(t, n) {
                            if ("string" == typeof t) {
                                const i = this._requestManager.normalizeStyleURL(t),
                                    r = this._requestManager.transformRequest(i, e.ResourceType.Style);
                                e.getJSON(r, (t, i) => {
                                    t ? this.fire(new e.ErrorEvent(t)) : i && this._updateDiff(i, n)
                                })
                            } else "object" == typeof t && this._updateDiff(t, n)
                        }

                        _updateDiff(t, n) {
                            try {
                                this.style.setState(t) && this._update(!0)
                            } catch (i) {
                                e.warnOnce(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(t, n)
                            }
                        }

                        getStyle() {
                            if (this.style) return this.style.serialize()
                        }

                        isStyleLoaded() {
                            return this.style ? this.style.loaded() : e.warnOnce("There is no style added to the map.")
                        }

                        addSource(e, t) {
                            return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0)
                        }

                        isSourceLoaded(t) {
                            const n = this.style && this.style._getSourceCaches(t);
                            if (0 !== n.length) return n.every(e => e.loaded());
                            this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`)))
                        }

                        areTilesLoaded() {
                            const e = this.style && this.style._sourceCaches;
                            for (const t in e) {
                                const n = e[t]._tiles;
                                for (const e in n) {
                                    const t = n[e];
                                    if ("loaded" !== t.state && "errored" !== t.state) return !1
                                }
                            }
                            return !0
                        }

                        addSourceType(e, t, n) {
                            return this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, n)
                        }

                        removeSource(e) {
                            return this.style.removeSource(e), this._updateTerrain(), this._update(!0)
                        }

                        getSource(e) {
                            return this.style.getSource(e)
                        }

                        addImage(t, n, {pixelRatio: i = 1, sdf: r = !1, stretchX: o, stretchY: a, content: s} = {}) {
                            if (this._lazyInitEmptyStyle(), n instanceof Rr || zr && n instanceof zr) {
                                const {width: l, height: c, data: u} = e.exported.getImageData(n);
                                this.style.addImage(t, {
                                    data: new e.RGBAImage({width: l, height: c}, u),
                                    pixelRatio: i,
                                    stretchX: o,
                                    stretchY: a,
                                    content: s,
                                    sdf: r,
                                    version: 0
                                })
                            } else {
                                if (void 0 === n.width || void 0 === n.height) return this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                                {
                                    const {width: l, height: c, data: u} = n, d = n;
                                    this.style.addImage(t, {
                                        data: new e.RGBAImage({
                                            width: l,
                                            height: c
                                        }, new Uint8Array(u)),
                                        pixelRatio: i,
                                        stretchX: o,
                                        stretchY: a,
                                        content: s,
                                        sdf: r,
                                        version: 0,
                                        userImage: d
                                    }), d.onAdd && d.onAdd(this, t)
                                }
                            }
                        }

                        updateImage(t, n) {
                            const i = this.style.getImage(t);
                            if (!i) return this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                            const r = n instanceof Rr || zr && n instanceof zr ? e.exported.getImageData(n) : n, {
                                width: o,
                                height: a,
                                data: s
                            } = r;
                            return void 0 === o || void 0 === a ? this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : o !== i.data.width || a !== i.data.height ? this.fire(new e.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (i.data.replace(s, !(n instanceof Rr || zr && n instanceof zr)), void this.style.updateImage(t, i))
                        }

                        hasImage(t) {
                            return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), !1)
                        }

                        removeImage(e) {
                            this.style.removeImage(e)
                        }

                        loadImage(t, n) {
                            e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, i) => {
                                n(t, i instanceof Rr ? e.exported.getImageData(i) : i)
                            })
                        }

                        listImages() {
                            return this.style.listImages()
                        }

                        addLayer(e, t) {
                            return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0)
                        }

                        moveLayer(e, t) {
                            return this.style.moveLayer(e, t), this._update(!0)
                        }

                        removeLayer(e) {
                            return this.style.removeLayer(e), this._update(!0)
                        }

                        getLayer(e) {
                            return this.style.getLayer(e)
                        }

                        setLayerZoomRange(e, t, n) {
                            return this.style.setLayerZoomRange(e, t, n), this._update(!0)
                        }

                        setFilter(e, t, n = {}) {
                            return this.style.setFilter(e, t, n), this._update(!0)
                        }

                        getFilter(e) {
                            return this.style.getFilter(e)
                        }

                        setPaintProperty(e, t, n, i = {}) {
                            return this.style.setPaintProperty(e, t, n, i), this._update(!0)
                        }

                        getPaintProperty(e, t) {
                            return this.style.getPaintProperty(e, t)
                        }

                        setLayoutProperty(e, t, n, i = {}) {
                            return this.style.setLayoutProperty(e, t, n, i), this._update(!0)
                        }

                        getLayoutProperty(e, t) {
                            return this.style.getLayoutProperty(e, t)
                        }

                        setLight(e, t = {}) {
                            return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0)
                        }

                        getLight() {
                            return this.style.getLight()
                        }

                        setTerrain(e) {
                            return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0)
                        }

                        _updateProjection() {
                            "globe" === this.transform.projection.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX && !this._transitionFromGlobe && (this.setProjection({name: "mercator"}), this._transitionFromGlobe = !0)
                        }

                        getTerrain() {
                            return this.style ? this.style.getTerrain() : null
                        }

                        setFog(e) {
                            return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0)
                        }

                        getFog() {
                            return this.style ? this.style.getFog() : null
                        }

                        _queryFogOpacity(t) {
                            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0
                        }

                        setFeatureState(e, t) {
                            return this.style.setFeatureState(e, t), this._update()
                        }

                        removeFeatureState(e, t) {
                            return this.style.removeFeatureState(e, t), this._update()
                        }

                        getFeatureState(e) {
                            return this.style.getFeatureState(e)
                        }

                        _updateContainerDimensions() {
                            if (!this._container) return;
                            const t = this._container.getBoundingClientRect().width || 400,
                                n = this._container.getBoundingClientRect().height || 300;
                            let i, r = this._container;
                            for (; r && !i;) {
                                const t = e.window.getComputedStyle(r).transform;
                                t && "none" !== t && (i = t.match(/matrix.*\((.+)\)/)[1].split(", ")), r = r.parentElement
                            }
                            i ? (this._containerWidth = i[0] && "0" !== i[0] ? Math.abs(t / i[0]) : t, this._containerHeight = i[3] && "0" !== i[3] ? Math.abs(n / i[3]) : n) : (this._containerWidth = t, this._containerHeight = n)
                        }

                        _detectMissingCSS() {
                            "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                        }

                        _setupContainer() {
                            const e = this._container;
                            e.classList.add("mapboxgl-map"), (this._missingCSSCanary = a.create("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
                            const t = this._canvasContainer = a.create("div", "mapboxgl-canvas-container", e);
                            this._interactive && t.classList.add("mapboxgl-interactive"), this._canvas = a.create("canvas", "mapboxgl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                            const n = this._controlContainer = a.create("div", "mapboxgl-control-container", e),
                                i = this._controlPositions = {};
                            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(e => {
                                i[e] = a.create("div", "mapboxgl-ctrl-" + e, n)
                            }), this._container.addEventListener("scroll", this._onMapScroll, !1)
                        }

                        _resizeCanvas(t, n) {
                            const i = e.exported.devicePixelRatio || 1;
                            this._canvas.width = i * Math.ceil(t), this._canvas.height = i * Math.ceil(n), this._canvas.style.width = t + "px", this._canvas.style.height = n + "px"
                        }

                        _addMarker(e) {
                            this._markers.push(e)
                        }

                        _removeMarker(e) {
                            const t = this._markers.indexOf(e);
                            -1 !== t && this._markers.splice(t, 1)
                        }

                        _setupPainter() {
                            const n = e.extend({}, t.webGLContextAttributes, {
                                    failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                                    antialias: this._antialias || !1
                                }),
                                i = this._canvas.getContext("webgl", n) || this._canvas.getContext("experimental-webgl", n);
                            i ? (e.storeAuthState(i, !0), this.painter = new pi(i, this.transform), this.on("data", e => {
                                "source" === e.dataType && this.painter.setTileLoadedFlag(!0)
                            }), e.exported$1.testSupport(i)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")))
                        }

                        _contextLost(t) {
                            t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", {originalEvent: t}))
                        }

                        _contextRestored(t) {
                            this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", {originalEvent: t}))
                        }

                        _onMapScroll(e) {
                            if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
                        }

                        loaded() {
                            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                        }

                        _update(e) {
                            return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
                        }

                        _requestRenderFrame(e) {
                            return this._update(), this._renderTaskQueue.add(e)
                        }

                        _cancelRenderFrame(e) {
                            this._renderTaskQueue.remove(e)
                        }

                        _requestDomTask(e) {
                            !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e)
                        }

                        _render(t) {
                            let n;
                            const i = this.painter.context.extTimerQuery, r = e.exported.now();
                            this.listens("gpu-timing-frame") && (n = i.createQueryEXT(), i.beginQueryEXT(i.TIME_ELAPSED_EXT, n));
                            let o = this._updateAverageElevation(r);
                            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;
                            this._updateProjection();
                            let a = !1;
                            const s = this._isInitialLoad ? 0 : this._fadeDuration;
                            if (this.style && this._styleDirty) {
                                this._styleDirty = !1;
                                const t = this.transform.zoom, n = this.transform.pitch, i = e.exported.now();
                                this.style.zoomHistory.update(t, i);
                                const r = new e.EvaluationParameters(t, {
                                    now: i,
                                    fadeDuration: s,
                                    pitch: n,
                                    zoomHistory: this.style.zoomHistory,
                                    transition: this.style.getTransition()
                                }), o = r.crossFadingFactor();
                                1 === o && o === this._crossFadingFactor || (a = !0, this._crossFadingFactor = o), this.style.update(r)
                            }
                            if (this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0), this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), this.style._updateSources(this.transform), this._forceMarkerUpdate()), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
                                showTileBoundaries: this.showTileBoundaries,
                                showTerrainWireframe: this.showTerrainWireframe,
                                showOverdrawInspector: this._showOverdrawInspector,
                                showQueryGeometry: !!this._showQueryGeometry,
                                rotating: this.isRotating(),
                                zooming: this.isZooming(),
                                moving: this.isMoving(),
                                fadeDuration: s,
                                isInitialLoad: this._isInitialLoad,
                                showPadding: this.showPadding,
                                gpuTiming: !!this.listens("gpu-timing-layer"),
                                speedIndexTiming: this.speedIndexTiming
                            }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event("load"))), this.style && (this.style.hasTransitions() || a) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                                const t = e.exported.now() - r;
                                i.endQueryEXT(i.TIME_ELAPSED_EXT, n), setTimeout(() => {
                                    const r = i.getQueryObjectEXT(n, i.QUERY_RESULT_EXT) / 1e6;
                                    i.deleteQueryEXT(n), this.fire(new e.Event("gpu-timing-frame", {
                                        cpuTime: t,
                                        gpuTime: r
                                    }))
                                }, 50)
                            }
                            if (this.listens("gpu-timing-layer")) {
                                const t = this.painter.collectGpuTimers();
                                setTimeout(() => {
                                    const n = this.painter.queryGpuTimers(t);
                                    this.fire(new e.Event("gpu-timing-layer", {layerTimes: n}))
                                }, 50)
                            }
                            const l = this._sourcesDirty || this._styleDirty || this._placementDirty || o;
                            if (l || this._repaint) this.triggerRepaint(); else {
                                const t = !this.isMoving() && this.loaded();
                                if (t && (o = this._updateAverageElevation(r, !0)), o) this.triggerRepaint(); else if (this._triggerFrame(!1), t && (this.fire(new e.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                                    const t = this._calculateSpeedIndex();
                                    this.fire(new e.Event("speedindexcompleted", {speedIndex: t})), this.speedIndexTiming = !1
                                }
                            }
                            return !this._loaded || this._fullyLoaded || l || (this._fullyLoaded = !0, this._authenticate()), this
                        }

                        _forceMarkerUpdate() {
                            for (const e of this._markers) e._update()
                        }

                        _updateAverageElevation(e, t = !1) {
                            const n = e => (this.transform.averageElevation = e, this._update(!1), !0);
                            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && n(0);
                            if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                                const t = this.transform.averageElevation;
                                let i = this.transform.sampleAverageElevation();
                                isNaN(i) ? i = 0 : this._averageElevationLastSampledAt = e;
                                const r = Math.abs(t - i);
                                if (r > 1) {
                                    if (this._isInitialLoad) return this._averageElevation.jumpTo(i), n(i);
                                    this._averageElevation.easeTo(i, e, 300)
                                } else if (r > 1e-4) return this._averageElevation.jumpTo(i), n(i)
                            }
                            return !!this._averageElevation.isEasing(e) && n(this._averageElevation.getValue(e))
                        }

                        _authenticate() {
                            e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {
                                if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {
                                    const t = this.painter.context.gl;
                                    e.storeAuthState(t, !1), this._logoControl instanceof Dr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                                }
                            }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
                            })
                        }

                        _updateTerrain() {
                            this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming())
                        }

                        _calculateSpeedIndex() {
                            const e = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
                            t.timeStamps.push(performance.now());
                            const n = this.painter.context.gl, i = n.createFramebuffer();

                            function r(e) {
                                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0);
                                const t = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4);
                                return n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, t), t
                            }

                            return n.bindFramebuffer(n.FRAMEBUFFER, i), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps)
                        }

                        _canvasPixelComparison(e, t, n) {
                            let i = n[1] - n[0];
                            const r = e.length / 4;
                            for (let o = 0; o < t.length; o++) {
                                const a = t[o];
                                let s = 0;
                                for (let t = 0; t < a.length; t += 4) a[t] === e[t] && a[t + 1] === e[t + 1] && a[t + 2] === e[t + 2] && a[t + 3] === e[t + 3] && (s += 1);
                                i += (n[o + 2] - n[o + 1]) * (1 - s / r)
                            }
                            return i
                        }

                        remove() {
                            this._hash && this._hash.remove();
                            for (const e of this._controls) e.onRemove(this);
                            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, !1), e.window.removeEventListener("orientationchange", this._onWindowResize, !1), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.removeEventListener("online", this._onWindowOnline, !1));
                            const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
                            t && t.loseContext(), Fr(this._canvasContainer), Fr(this._controlContainer), Fr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event("remove"))
                        }

                        triggerRepaint() {
                            this._triggerFrame(!0)
                        }

                        _triggerFrame(t) {
                            this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {
                                const t = !!this._renderNextFrame;
                                this._frame = null, this._renderNextFrame = null, t && this._render(e)
                            }))
                        }

                        _preloadTiles(t) {
                            const n = this.style && Object.values(this.style._sourceCaches) || [];
                            return e.asyncAll(n, (e, n) => e._preloadTiles(t, n), () => {
                                this.triggerRepaint()
                            }), this
                        }

                        _onWindowOnline() {
                            this._update()
                        }

                        _onWindowResize(e) {
                            this._trackResize && this.resize({originalEvent: e})._update()
                        }

                        get showTileBoundaries() {
                            return !!this._showTileBoundaries
                        }

                        set showTileBoundaries(e) {
                            this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update())
                        }

                        get showTerrainWireframe() {
                            return !!this._showTerrainWireframe
                        }

                        set showTerrainWireframe(e) {
                            this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update())
                        }

                        get speedIndexTiming() {
                            return !!this._speedIndexTiming
                        }

                        set speedIndexTiming(e) {
                            this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update())
                        }

                        get showPadding() {
                            return !!this._showPadding
                        }

                        set showPadding(e) {
                            this._showPadding !== e && (this._showPadding = e, this._update())
                        }

                        get showCollisionBoxes() {
                            return !!this._showCollisionBoxes
                        }

                        set showCollisionBoxes(e) {
                            this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update())
                        }

                        get showOverdrawInspector() {
                            return !!this._showOverdrawInspector
                        }

                        set showOverdrawInspector(e) {
                            this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update())
                        }

                        get repaint() {
                            return !!this._repaint
                        }

                        set repaint(e) {
                            this._repaint !== e && (this._repaint = e, this.triggerRepaint())
                        }

                        get vertices() {
                            return !!this._vertices
                        }

                        set vertices(e) {
                            this._vertices = e, this._update()
                        }

                        _setCacheLimits(t, n) {
                            e.setCacheLimits(t, n)
                        }

                        get version() {
                            return e.version
                        }
                    },
                    NavigationControl: class {
                        constructor(t) {
                            this.options = e.extend({}, Br, t), this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", e => this._map.zoomIn({}, {originalEvent: e})), a.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", e => this._map.zoomOut({}, {originalEvent: e})), a.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", e => {
                                this.options.visualizePitch ? this._map.resetNorthPitch({}, {originalEvent: e}) : this._map.resetNorth({}, {originalEvent: e})
                            }), this._compassIcon = a.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0))
                        }

                        _updateZoomButtons() {
                            const e = this._map.getZoom(), t = e === this._map.getMaxZoom(),
                                n = e === this._map.getMinZoom();
                            this._zoomInButton.disabled = t, this._zoomOutButton.disabled = n, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", n.toString())
                        }

                        _rotateCompassArrow() {
                            const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
                            this._map._requestDomTask(() => {
                                this._compassIcon && (this._compassIcon.style.transform = e)
                            })
                        }

                        onAdd(e) {
                            return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new jr(this._map, this._compass, this.options.visualizePitch)), this._container
                        }

                        onRemove() {
                            this._container.remove(), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
                        }

                        _createButton(e, t) {
                            const n = a.create("button", e, this._container);
                            return n.type = "button", n.addEventListener("click", t), n
                        }

                        _setButtonTitle(e, t) {
                            const n = this._map._getUIString("NavigationControl." + t);
                            e.setAttribute("aria-label", n), e.firstElementChild && e.firstElementChild.setAttribute("title", n)
                        }
                    },
                    GeolocateControl: class extends e.Evented {
                        constructor(t) {
                            super(), this.options = e.extend({}, Hr, t), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation"], this), this._onDeviceOrientationListener = this._onDeviceOrientation.bind(this), this._updateMarkerRotationThrottled = Li(this._updateMarkerRotation, 20)
                        }

                        onAdd(t) {
                            var n;
                            return this._map = t, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), n = this._setupUI, void 0 !== Nr ? n(Nr) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({name: "geolocation"}).then(e => {
                                Nr = "denied" !== e.state, n(Nr)
                            }) : (Nr = !!e.window.navigator.geolocation, n(Nr)), this._container
                        }

                        onRemove() {
                            void 0 !== this._geolocationWatchID && (e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, Ur = 0, Wr = !1
                        }

                        _isOutOfMapMaxBounds(e) {
                            const t = this._map.getMaxBounds(), n = e.coords;
                            return t && (n.longitude < t.getWest() || n.longitude > t.getEast() || n.latitude < t.getSouth() || n.latitude > t.getNorth())
                        }

                        _setErrorState() {
                            switch (this._watchState) {
                                case"WAITING_ACTIVE":
                                    this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                    break;
                                case"ACTIVE_LOCK":
                                    this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                                    break;
                                case"BACKGROUND":
                                    this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                            }
                        }

                        _onSuccess(t) {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish();
                                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                                    case"WAITING_ACTIVE":
                                    case"ACTIVE_LOCK":
                                    case"ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                        break;
                                    case"BACKGROUND":
                                    case"BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                                }
                                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t)), this._finish()
                            }
                        }

                        _updateCamera(t) {
                            const n = new e.LngLat(t.coords.longitude, t.coords.latitude), i = t.coords.accuracy,
                                r = this._map.getBearing(), o = e.extend({bearing: r}, this.options.fitBoundsOptions);
                            this._map.fitBounds(n.toBounds(i), o, {geolocateSource: !0})
                        }

                        _updateMarker(t) {
                            if (t) {
                                const n = new e.LngLat(t.coords.longitude, t.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
                        }

                        _updateCircleRadius() {
                            const e = this._map._containerHeight / 2, t = this._map.unproject([0, e]),
                                n = this._map.unproject([100, e]), i = t.distanceTo(n) / 100,
                                r = Math.ceil(2 * this._accuracy / i);
                            this._circleElement.style.width = r + "px", this._circleElement.style.height = r + "px"
                        }

                        _onZoom() {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }

                        _updateMarkerRotation() {
                            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0))
                        }

                        _onError(t) {
                            if (this._map) {
                                if (this.options.trackUserLocation) if (1 === t.code) {
                                    this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                    const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch()
                                } else {
                                    if (3 === t.code && Wr) return;
                                    this._setErrorState()
                                }
                                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t)), this._finish()
                            }
                        }

                        _finish() {
                            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
                        }

                        _setupUI(t) {
                            if (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = a.create("button", "mapboxgl-ctrl-geolocate", this._container), a.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === t) {
                                e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                            } else {
                                const e = this._map._getUIString("GeolocateControl.FindMyLocation");
                                this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e)
                            }
                            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = a.create("div", "mapboxgl-user-location"), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Ar({
                                element: this._dotElement,
                                rotationAlignment: "map",
                                pitchAlignment: "map"
                            }), this._circleElement = a.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ar({
                                element: this._circleElement,
                                pitchAlignment: "map"
                            }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", t => {
                                t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")))
                            })
                        }

                        _onDeviceOrientation(e) {
                            this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled())
                        }

                        trigger() {
                            if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), !1;
                            if (this.options.trackUserLocation) {
                                switch (this._watchState) {
                                    case"OFF":
                                        this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                                        break;
                                    case"WAITING_ACTIVE":
                                    case"ACTIVE_LOCK":
                                    case"ACTIVE_ERROR":
                                    case"BACKGROUND_ERROR":
                                        Ur--, Wr = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                                        break;
                                    case"BACKGROUND":
                                        this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"))
                                }
                                switch (this._watchState) {
                                    case"WAITING_ACTIVE":
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                        break;
                                    case"ACTIVE_LOCK":
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                        break;
                                    case"ACTIVE_ERROR":
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                        break;
                                    case"BACKGROUND":
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                        break;
                                    case"BACKGROUND_ERROR":
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                                }
                                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch(); else if (void 0 === this._geolocationWatchID) {
                                    let t;
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ur++, Ur > 1 ? (t = {
                                        maximumAge: 6e5,
                                        timeout: 0
                                    }, Wr = !0) : (t = this.options.positionOptions, Wr = !1), this._geolocationWatchID = e.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t), this.options.showUserHeading && this._addDeviceOrientationListener()
                                }
                            } else e.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                            return !0
                        }

                        _addDeviceOrientationListener() {
                            const t = () => {
                                e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientationListener)
                            };
                            void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {
                                "granted" === e && t()
                            }).catch(console.error) : t()
                        }

                        _clearWatch() {
                            e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientationListener), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientationListener), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
                        }
                    },
                    AttributionControl: Sr,
                    ScaleControl: class {
                        constructor(t) {
                            this.options = e.extend({}, Vr, t), e.bindAll(["_onMove", "setUnit"], this)
                        }

                        getDefaultPosition() {
                            return "bottom-left"
                        }

                        _onMove() {
                            Gr(this._map, this._container, this.options)
                        }

                        onAdd(e) {
                            return this._map = e, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
                        }

                        onRemove() {
                            this._container.remove(), this._map.off("move", this._onMove), this._map = void 0
                        }

                        setUnit(e) {
                            this.options.unit = e, Gr(this._map, this._container, this.options)
                        }
                    },
                    FullscreenControl: class {
                        constructor(t) {
                            this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange")
                        }

                        onAdd(t) {
                            return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer
                        }

                        onRemove() {
                            this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon)
                        }

                        _checkFullscreenSupport() {
                            return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled)
                        }

                        _setupUI() {
                            const t = this._fullscreenButton = a.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                            a.create("span", "mapboxgl-ctrl-icon", t).setAttribute("aria-hidden", !0), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon)
                        }

                        _updateTitle() {
                            const e = this._getTitle();
                            this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e)
                        }

                        _getTitle() {
                            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                        }

                        _isFullscreen() {
                            return this._fullscreen
                        }

                        _changeIcon() {
                            (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle())
                        }

                        _onClickFullscreen() {
                            this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                        }
                    },
                    Popup: class extends e.Evented {
                        constructor(t) {
                            super(), this.options = e.extend(Object.create(Zr), t), e.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : [])
                        }

                        addTo(t) {
                            return this._map && this.remove(), this._map = t, this.options.closeOnClick && this._map.on("preclick", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.Event("open")), this
                        }

                        isOpen() {
                            return !!this._map
                        }

                        remove() {
                            return this._content && this._content.remove(), this._container && (this._container.remove(), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new e.Event("close")), this
                        }

                        getLngLat() {
                            return this._lngLat
                        }

                        setLngLat(t) {
                            return this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this
                        }

                        trackPointer() {
                            return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this
                        }

                        getElement() {
                            return this._container
                        }

                        setText(t) {
                            return this.setDOMContent(e.window.document.createTextNode(t))
                        }

                        setHTML(t) {
                            const n = e.window.document.createDocumentFragment(),
                                i = e.window.document.createElement("body");
                            let r;
                            for (i.innerHTML = t; r = i.firstChild, r;) n.appendChild(r);
                            return this.setDOMContent(n)
                        }

                        getMaxWidth() {
                            return this._container && this._container.style.maxWidth
                        }

                        setMaxWidth(e) {
                            return this.options.maxWidth = e, this._update(), this
                        }

                        setDOMContent(e) {
                            if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = a.create("div", "mapboxgl-popup-content", this._container);
                            return this._content.appendChild(e), this._createCloseButton(), this._update(), this._focusFirstElement(), this
                        }

                        addClassName(e) {
                            return this._classList.add(e), this._container && this._updateClassList(), this
                        }

                        removeClassName(e) {
                            return this._classList.delete(e), this._container && this._updateClassList(), this
                        }

                        setOffset(e) {
                            return this.options.offset = e, this._update(), this
                        }

                        toggleClassName(e) {
                            let t;
                            return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._container && this._updateClassList(), t
                        }

                        _createCloseButton() {
                            this.options.closeButton && (this._closeButton = a.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.setAttribute("aria-hidden", "true"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
                        }

                        _onMouseUp(e) {
                            this._update(e.point)
                        }

                        _onMouseMove(e) {
                            this._update(e.point)
                        }

                        _onDrag(e) {
                            this._update(e.point)
                        }

                        _getAnchor(e) {
                            if (this.options.anchor) return this.options.anchor;
                            const t = this._pos, n = this._container.offsetWidth, i = this._container.offsetHeight;
                            let r;
                            return r = t.y + e.bottom.y < i ? ["top"] : t.y > this._map.transform.height - i ? ["bottom"] : [], t.x < n / 2 ? r.push("left") : t.x > this._map.transform.width - n / 2 && r.push("right"), 0 === r.length ? "bottom" : r.join("-")
                        }

                        _updateClassList() {
                            const e = [...this._classList];
                            e.push("mapboxgl-popup"), this._anchor && e.push("mapboxgl-popup-anchor-" + this._anchor), this._trackPointer && e.push("mapboxgl-popup-track-pointer"), this._container.className = e.join(" ")
                        }

                        _update(t) {
                            if (this._map && (this._lngLat || this._trackPointer) && this._content) {
                                if (this._container || (this._container = a.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = a.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content)), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Er(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || t) {
                                    const n = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat),
                                        i = function (t) {
                                            if (t || (t = new e.pointGeometry(0, 0)), "number" == typeof t) {
                                                const n = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));
                                                return {
                                                    center: new e.pointGeometry(0, 0),
                                                    top: new e.pointGeometry(0, t),
                                                    "top-left": new e.pointGeometry(n, n),
                                                    "top-right": new e.pointGeometry(-n, n),
                                                    bottom: new e.pointGeometry(0, -t),
                                                    "bottom-left": new e.pointGeometry(n, -n),
                                                    "bottom-right": new e.pointGeometry(-n, -n),
                                                    left: new e.pointGeometry(t, 0),
                                                    right: new e.pointGeometry(-t, 0)
                                                }
                                            }
                                            if (t instanceof e.pointGeometry || Array.isArray(t)) {
                                                const n = e.pointGeometry.convert(t);
                                                return {
                                                    center: n,
                                                    top: n,
                                                    "top-left": n,
                                                    "top-right": n,
                                                    bottom: n,
                                                    "bottom-left": n,
                                                    "bottom-right": n,
                                                    left: n,
                                                    right: n
                                                }
                                            }
                                            return {
                                                center: e.pointGeometry.convert(t.center || [0, 0]),
                                                top: e.pointGeometry.convert(t.top || [0, 0]),
                                                "top-left": e.pointGeometry.convert(t["top-left"] || [0, 0]),
                                                "top-right": e.pointGeometry.convert(t["top-right"] || [0, 0]),
                                                bottom: e.pointGeometry.convert(t.bottom || [0, 0]),
                                                "bottom-left": e.pointGeometry.convert(t["bottom-left"] || [0, 0]),
                                                "bottom-right": e.pointGeometry.convert(t["bottom-right"] || [0, 0]),
                                                left: e.pointGeometry.convert(t.left || [0, 0]),
                                                right: e.pointGeometry.convert(t.right || [0, 0])
                                            }
                                        }(this.options.offset), r = this._anchor = this._getAnchor(i),
                                        o = n.add(i[r]).round();
                                    this._map._requestDomTask(() => {
                                        this._container && r && (this._container.style.transform = `${Cr[r]} translate(${o.x}px,${o.y}px)`)
                                    })
                                }
                                this._updateClassList()
                            }
                        }

                        _focusFirstElement() {
                            if (!this.options.focusAfterOpen || !this._container) return;
                            const e = this._container.querySelector($r);
                            e && e.focus()
                        }

                        _onClose() {
                            this.remove()
                        }

                        _setOpacity(e) {
                            this._content && (this._content.style.opacity = e), this._tip && (this._tip.style.opacity = e)
                        }
                    },
                    Marker: Ar,
                    Style: jt,
                    LngLat: e.LngLat,
                    LngLatBounds: e.LngLatBounds,
                    Point: e.pointGeometry,
                    MercatorCoordinate: e.MercatorCoordinate,
                    FreeCameraOptions: vi,
                    Evented: e.Evented,
                    config: e.config,
                    prewarm: function () {
                        Ie().acquire(Ee)
                    },
                    clearPrewarmedResources: function () {
                        const e = Ae;
                        e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Ee), Ae = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                    },
                    get accessToken() {
                        return e.config.ACCESS_TOKEN
                    },
                    set accessToken(t) {
                        e.config.ACCESS_TOKEN = t
                    },
                    get baseApiUrl() {
                        return e.config.API_URL
                    },
                    set baseApiUrl(t) {
                        e.config.API_URL = t
                    },
                    get workerCount() {
                        return Ce.workerCount
                    },
                    set workerCount(e) {
                        Ce.workerCount = e
                    },
                    get maxParallelImageRequests() {
                        return e.config.MAX_PARALLEL_IMAGE_REQUESTS
                    },
                    set maxParallelImageRequests(t) {
                        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t
                    },
                    clearStorage(t) {
                        e.clearTileCache(t)
                    },
                    workerUrl: "",
                    workerClass: null,
                    setNow: e.exported.setNow,
                    restoreNow: e.exported.restoreNow
                };
            return Xr
        })), n
    }()
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("af", {
            months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
            weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
            weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
            meridiemParse: /vm|nm/i,
            isPM: function (e) {
                return /^nm$/i.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 12 ? n ? "vm" : "VM" : n ? "nm" : "NM"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Vandag om] LT",
                nextDay: "[Mre om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[Gister om] LT",
                lastWeek: "[Laas] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oor %s",
                past: "%s gelede",
                s: "'n paar sekondes",
                ss: "%d sekondes",
                m: "'n minuut",
                mm: "%d minute",
                h: "'n uur",
                hh: "%d ure",
                d: "'n dag",
                dd: "%d dae",
                M: "'n maand",
                MM: "%d maande",
                y: "'n jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (e) {
                return e + (1 === e || 8 === e || e >= 20 ? "ste" : "de")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"},
            i = function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : 2 === e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
            }, r = {
                s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "]
            }, o = function (e) {
                return function (t, n, o, a) {
                    var s = i(t), l = r[e][i(t)];
                    return 2 === s && (l = l[n ? 0 : 1]), l.replace(/%d/i, t)
                }
            },
            a = ["", "", "", "", "", "", "", "", "", "", "", ""];
        e.defineLocale("ar", {
            months: a,
            monthsShort: a,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/M/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: o("s"),
                ss: o("s"),
                m: o("m"),
                mm: o("m"),
                h: o("h"),
                hh: o("h"),
                d: o("d"),
                dd: o("d"),
                M: o("M"),
                MM: o("M"),
                y: o("y"),
                yy: o("y")
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                })).replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                })).replace(/,/g, "")
            },
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : 2 === e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
            }, n = {
                s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "]
            }, i = function (e) {
                return function (i, r, o, a) {
                    var s = t(i), l = n[e][t(i)];
                    return 2 === s && (l = l[r ? 0 : 1]), l.replace(/%d/i, i)
                }
            },
            r = ["", "", "", "", "", "", "", "", "", "", "", ""];
        e.defineLocale("ar-dz", {
            months: r,
            monthsShort: r,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/M/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: i("s"),
                ss: i("s"),
                m: i("m"),
                mm: i("m"),
                h: i("h"),
                hh: i("h"),
                d: i("d"),
                dd: i("d"),
                M: i("M"),
                MM: i("M"),
                y: i("y"),
                yy: i("y")
            },
            postformat: function (e) {
                return e.replace(/,/g, "")
            },
            week: {dow: 0, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ar-kw", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            week: {dow: 0, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0"}, n = function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : 2 === e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
            }, i = {
                s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "],
                y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "]
            }, r = function (e) {
                return function (t, r, o, a) {
                    var s = n(t), l = i[e][n(t)];
                    return 2 === s && (l = l[r ? 0 : 1]), l.replace(/%d/i, t)
                }
            },
            o = ["", "", "", "", "", "", "", "", "", "", "", ""];
        e.defineLocale("ar-ly", {
            months: o,
            monthsShort: o,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/M/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: r("s"),
                ss: r("s"),
                m: r("m"),
                mm: r("m"),
                h: r("h"),
                hh: r("h"),
                d: r("d"),
                dd: r("d"),
                M: r("M"),
                MM: r("M"),
                y: r("y"),
                yy: r("y")
            },
            preparse: function (e) {
                return e.replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                })).replace(/,/g, "")
            },
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ar-ma", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("ar-sa", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                })).replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                })).replace(/,/g, "")
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ar-tn", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[  ] LT",
                nextDay: "[  ] LT",
                nextWeek: "dddd [ ] LT",
                lastDay: "[  ] LT",
                lastWeek: "dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            1: "-inci",
            5: "-inci",
            8: "-inci",
            70: "-inci",
            80: "-inci",
            2: "-nci",
            7: "-nci",
            20: "-nci",
            50: "-nci",
            3: "-nc",
            4: "-nc",
            100: "-nc",
            6: "-nc",
            9: "-uncu",
            10: "-uncu",
            30: "-uncu",
            60: "-nc",
            90: "-nc"
        };
        e.defineLocale("az", {
            months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
            monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
            weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split("_"),
            weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"),
            weekdaysMin: "Bz_BE_A__CA_C_".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugn saat] LT",
                nextDay: "[sabah saat] LT",
                nextWeek: "[gln hft] dddd [saat] LT",
                lastDay: "[dnn] LT",
                lastWeek: "[ken hft] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s vvl",
                s: "bir ne saniy",
                ss: "%d saniy",
                m: "bir dqiq",
                mm: "%d dqiq",
                h: "bir saat",
                hh: "%d saat",
                d: "bir gn",
                dd: "%d gn",
                M: "bir ay",
                MM: "%d ay",
                y: "bir il",
                yy: "%d il"
            },
            meridiemParse: /gec|shr|gndz|axam/,
            isPM: function (e) {
                return /^(gndz|axam)$/.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "gec" : e < 12 ? "shr" : e < 17 ? "gndz" : "axam"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
            ordinal: function (e) {
                if (0 === e) return e + "-nc";
                var n = e % 10;
                return e + (t[n] || t[e % 100 - n] || t[e >= 100 ? 100 : null])
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i, r;
            return "m" === n ? t ? "" : "" : "h" === n ? t ? "" : "" : e + " " + (i = +e, r = {
                ss: t ? "__" : "__",
                mm: t ? "__" : "__",
                hh: t ? "__" : "__",
                dd: "__",
                MM: "__",
                yy: "__"
            }[n].split("_"), i % 10 == 1 && i % 100 != 11 ? r[0] : i % 10 >= 2 && i % 10 <= 4 && (i % 100 < 10 || i % 100 >= 20) ? r[1] : r[2])
        }

        e.defineLocale("be", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: "___________".split("_"),
            weekdays: {
                format: "______".split("_"),
                standalone: "______".split("_"),
                isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
            },
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY .",
                LLL: "D MMMM YYYY ., HH:mm",
                LLLL: "dddd, D MMMM YYYY ., HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                lastDay: "[ ] LT",
                nextWeek: function () {
                    return "[] dddd [] LT"
                },
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return "[ ] dddd [] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[ ] dddd [] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: "",
                dd: t,
                M: "",
                MM: t,
                y: "",
                yy: t
            },
            meridiemParse: /|||/,
            isPM: function (e) {
                return /^(|)$/.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 12 ? "" : e < 17 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"M":
                    case"d":
                    case"DDD":
                    case"w":
                    case"W":
                        return e % 10 != 2 && e % 10 != 3 || e % 100 == 12 || e % 100 == 13 ? e + "-" : e + "-";
                    case"D":
                        return e + "-";
                    default:
                        return e
                }
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("bg", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return "[] dddd [] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[] dddd [] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: " ",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                w: "",
                ww: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
            ordinal: function (e) {
                var t = e % 10, n = e % 100;
                return 0 === e ? e + "-" : 0 === n ? e + "-" : n > 10 && n < 20 ? e + "-" : 1 === t ? e + "-" : 2 === t ? e + "-" : 7 === t || 8 === t ? e + "-" : e + "-"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("bm", {
            months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo".split("_"),
            monthsShort: "Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des".split("_"),
            weekdays: "Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
            weekdaysShort: "Kar_Nt_Tar_Ara_Ala_Jum_Sib".split("_"),
            weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "MMMM [tile] D [san] YYYY",
                LLL: "MMMM [tile] D [san] YYYY [lr] HH:mm",
                LLLL: "dddd MMMM [tile] D [san] YYYY [lr] HH:mm"
            },
            calendar: {
                sameDay: "[Bi lr] LT",
                nextDay: "[Sini lr] LT",
                nextWeek: "dddd [don lr] LT",
                lastDay: "[Kunu lr] LT",
                lastWeek: "dddd [tmnen lr] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s kn",
                past: "a b %s b",
                s: "sanga dama dama",
                ss: "sekondi %d",
                m: "miniti kelen",
                mm: "miniti %d",
                h: "lr kelen",
                hh: "lr %d",
                d: "tile kelen",
                dd: "tile %d",
                M: "kalo kelen",
                MM: "kalo %d",
                y: "san kelen",
                yy: "san %d"
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("bn", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t && e >= 4 || "" === t && e < 5 || "" === t ? e + 12 : e
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("bn-bd", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /||||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t || "" === t ? e : "" === t ? e >= 3 ? e : e + 12 : "" === t || "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 6 ? "" : e < 12 ? "" : e < 15 ? "" : e < 18 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("bo", {
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            monthsShortRegex: /^(\d{1,2})/,
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[], LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t && e >= 4 || "" === t && e < 5 || "" === t ? e + 12 : e
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            return e + " " + function (e, t) {
                return 2 === t ? function (e) {
                    var t = {m: "v", b: "v", d: "z"};
                    return void 0 === t[e.charAt(0)] ? e : t[e.charAt(0)] + e.substring(1)
                }(e) : e
            }({mm: "munutenn", MM: "miz", dd: "devezh"}[n], e)
        }

        var n = [/^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
            i = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            r = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
        e.defineLocale("br", {
            months: "Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
            monthsShort: "Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
            weekdays: "Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn".split("_"),
            weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
            weekdaysParse: r,
            fullWeekdaysParse: [/^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
            shortWeekdaysParse: [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
            minWeekdaysParse: r,
            monthsRegex: i,
            monthsShortRegex: i,
            monthsStrictRegex: /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
            monthsShortStrictRegex: /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            monthsParse: n,
            longMonthsParse: n,
            shortMonthsParse: n,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [a viz] MMMM YYYY",
                LLL: "D [a viz] MMMM YYYY HH:mm",
                LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hiziv da] LT",
                nextDay: "[Warchoazh da] LT",
                nextWeek: "dddd [da] LT",
                lastDay: "[Dech da] LT",
                lastWeek: "dddd [paset da] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "a-benn %s",
                past: "%s zo",
                s: "un nebeud segondenno",
                ss: "%d eilenn",
                m: "ur vunutenn",
                mm: t,
                h: "un eur",
                hh: "%d eur",
                d: "un devezh",
                dd: t,
                M: "ur miz",
                MM: t,
                y: "ur bloaz",
                yy: function (e) {
                    switch (function e(t) {
                        return t > 9 ? e(t % 10) : t
                    }(e)) {
                        case 1:
                        case 3:
                        case 4:
                        case 5:
                        case 9:
                            return e + " bloaz";
                        default:
                            return e + " vloaz"
                    }
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
            ordinal: function (e) {
                return e + (1 === e ? "a" : "vet")
            },
            week: {dow: 1, doy: 4},
            meridiemParse: /a.m.|g.m./,
            isPM: function (e) {
                return "g.m." === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "a.m." : "g.m."
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i = e + " ";
            switch (n) {
                case"ss":
                    return i += 1 === e ? "sekunda" : 2 === e || 3 === e || 4 === e ? "sekunde" : "sekundi";
                case"m":
                    return t ? "jedna minuta" : "jedne minute";
                case"mm":
                    return i += 1 === e ? "minuta" : 2 === e || 3 === e || 4 === e ? "minute" : "minuta";
                case"h":
                    return t ? "jedan sat" : "jednog sata";
                case"hh":
                    return i += 1 === e ? "sat" : 2 === e || 3 === e || 4 === e ? "sata" : "sati";
                case"dd":
                    return i += 1 === e ? "dan" : "dana";
                case"MM":
                    return i += 1 === e ? "mjesec" : 2 === e || 3 === e || 4 === e ? "mjeseca" : "mjeseci";
                case"yy":
                    return i += 1 === e ? "godina" : 2 === e || 3 === e || 4 === e ? "godine" : "godina"
            }
        }

        e.defineLocale("bs", {
            months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                }, lastDay: "[juer u] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                            return "[prolu] dddd [u] LT";
                        case 6:
                            return "[prole] [subote] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[proli] dddd [u] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: "dan",
                dd: t,
                M: "mjesec",
                MM: t,
                y: "godinu",
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ca", {
            months: {
                standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
                format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
                isFormat: /D[oD]?(\s)+MMMM/
            },
            monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
            weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
            weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [de] YYYY",
                ll: "D MMM YYYY",
                LLL: "D MMMM [de] YYYY [a les] H:mm",
                lll: "D MMM YYYY, H:mm",
                LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
                llll: "ddd D MMM YYYY, H:mm"
            },
            calendar: {
                sameDay: function () {
                    return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                }, nextDay: function () {
                    return "[dem a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                }, nextWeek: function () {
                    return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                }, lastDay: function () {
                    return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                }, lastWeek: function () {
                    return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "d'aqu %s",
                past: "fa %s",
                s: "uns segons",
                ss: "%d segons",
                m: "un minut",
                mm: "%d minuts",
                h: "una hora",
                hh: "%d hores",
                d: "un dia",
                dd: "%d dies",
                M: "un mes",
                MM: "%d mesos",
                y: "un any",
                yy: "%d anys"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
            ordinal: function (e, t) {
                var n = 1 === e ? "r" : 2 === e ? "n" : 3 === e ? "r" : 4 === e ? "t" : "";
                return "w" !== t && "W" !== t || (n = "a"), e + n
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split("_"),
            n = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_"),
            i = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i],
            r = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

        function o(e) {
            return e > 1 && e < 5 && 1 != ~~(e / 10)
        }

        function a(e, t, n, i) {
            var r = e + " ";
            switch (n) {
                case"s":
                    return t || i ? "pr sekund" : "pr sekundami";
                case"ss":
                    return t || i ? r + (o(e) ? "sekundy" : "sekund") : r + "sekundami";
                case"m":
                    return t ? "minuta" : i ? "minutu" : "minutou";
                case"mm":
                    return t || i ? r + (o(e) ? "minuty" : "minut") : r + "minutami";
                case"h":
                    return t ? "hodina" : i ? "hodinu" : "hodinou";
                case"hh":
                    return t || i ? r + (o(e) ? "hodiny" : "hodin") : r + "hodinami";
                case"d":
                    return t || i ? "den" : "dnem";
                case"dd":
                    return t || i ? r + (o(e) ? "dny" : "dn") : r + "dny";
                case"M":
                    return t || i ? "msc" : "mscem";
                case"MM":
                    return t || i ? r + (o(e) ? "msce" : "msc") : r + "msci";
                case"y":
                    return t || i ? "rok" : "rokem";
                case"yy":
                    return t || i ? r + (o(e) ? "roky" : "let") : r + "lety"
            }
        }

        e.defineLocale("cs", {
            months: t,
            monthsShort: n,
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
            monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"),
            weekdaysShort: "ne_po_t_st_t_p_so".split("_"),
            weekdaysMin: "ne_po_t_st_t_p_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd D. MMMM YYYY H:mm",
                l: "D. M. YYYY"
            },
            calendar: {
                sameDay: "[dnes v] LT", nextDay: "[ztra v] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[v nedli v] LT";
                        case 1:
                        case 2:
                            return "[v] dddd [v] LT";
                        case 3:
                            return "[ve stedu v] LT";
                        case 4:
                            return "[ve tvrtek v] LT";
                        case 5:
                            return "[v ptek v] LT";
                        case 6:
                            return "[v sobotu v] LT"
                    }
                }, lastDay: "[vera v] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[minulou nedli v] LT";
                        case 1:
                        case 2:
                            return "[minul] dddd [v] LT";
                        case 3:
                            return "[minulou stedu v] LT";
                        case 4:
                        case 5:
                            return "[minul] dddd [v] LT";
                        case 6:
                            return "[minulou sobotu v] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "ped %s",
                s: a,
                ss: a,
                m: a,
                mm: a,
                h: a,
                hh: a,
                d: a,
                dd: a,
                M: a,
                MM: a,
                y: a,
                yy: a
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("cv", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "YYYY [] MMMM [] D[-]",
                LLL: "YYYY [] MMMM [] D[-], HH:mm",
                LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm"
            },
            calendar: {
                sameDay: "[] LT []",
                nextDay: "[] LT []",
                lastDay: "[] LT []",
                nextWeek: "[] dddd LT []",
                lastWeek: "[] dddd LT []",
                sameElse: "L"
            },
            relativeTime: {
                future: function (e) {
                    return e + (/$/i.exec(e) ? "" : /$/i.exec(e) ? "" : "")
                },
                past: "%s ",
                s: "- ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}-/,
            ordinal: "%d-",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("cy", {
            months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
            monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
            weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
            weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Heddiw am] LT",
                nextDay: "[Yfory am] LT",
                nextWeek: "dddd [am] LT",
                lastDay: "[Ddoe am] LT",
                lastWeek: "dddd [diwethaf am] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "mewn %s",
                past: "%s yn l",
                s: "ychydig eiliadau",
                ss: "%d eiliad",
                m: "munud",
                mm: "%d munud",
                h: "awr",
                hh: "%d awr",
                d: "diwrnod",
                dd: "%d diwrnod",
                M: "mis",
                MM: "%d mis",
                y: "blwyddyn",
                yy: "%d flynedd"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
            ordinal: function (e) {
                var t = "";
                return e > 20 ? t = 40 === e || 50 === e || 60 === e || 80 === e || 100 === e ? "fed" : "ain" : e > 0 && (t = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"][e]), e + t
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("da", {
            months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
            weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"),
            weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "p dddd [kl.] LT",
                lastDay: "[i gr kl.] LT",
                lastWeek: "[i] dddd[s kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "f sekunder",
                ss: "%d sekunder",
                m: "et minut",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dage",
                M: "en mned",
                MM: "%d mneder",
                y: "et r",
                yy: "%d r"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [e + " Tage", e + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [e + " Monate", e + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [e + " Jahre", e + " Jahren"]
            };
            return t ? r[n][0] : r[n][1]
        }

        e.defineLocale("de", {
            months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: t,
                mm: "%d Minuten",
                h: t,
                hh: "%d Stunden",
                d: t,
                dd: t,
                w: t,
                ww: "%d Wochen",
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [e + " Tage", e + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [e + " Monate", e + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [e + " Jahre", e + " Jahren"]
            };
            return t ? r[n][0] : r[n][1]
        }

        e.defineLocale("de-at", {
            months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: t,
                mm: "%d Minuten",
                h: t,
                hh: "%d Stunden",
                d: t,
                dd: t,
                w: t,
                ww: "%d Wochen",
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [e + " Tage", e + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [e + " Monate", e + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [e + " Jahre", e + " Jahren"]
            };
            return t ? r[n][0] : r[n][1]
        }

        e.defineLocale("de-ch", {
            months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: t,
                mm: "%d Minuten",
                h: t,
                hh: "%d Stunden",
                d: t,
                dd: t,
                w: t,
                ww: "%d Wochen",
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = ["", "", "", "", "", "", "", "", "", "", "", ""],
            n = ["", "", "", "", "", "", ""];
        e.defineLocale("dv", {
            months: t,
            monthsShort: t,
            weekdays: n,
            weekdaysShort: n,
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/M/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: "",
                ss: "d% ",
                m: "",
                mm: " %d",
                h: "",
                hh: " %d",
                d: "",
                dd: " %d",
                M: "",
                MM: " %d",
                y: "",
                yy: " %d"
            },
            preparse: function (e) {
                return e.replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/,/g, "")
            },
            week: {dow: 7, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("el", {
            monthsNominativeEl: "___________".split("_"),
            monthsGenitiveEl: "___________".split("_"),
            months: function (e, t) {
                return e ? "string" == typeof t && /D/.test(t.substring(0, t.indexOf("MMMM"))) ? this._monthsGenitiveEl[e.month()] : this._monthsNominativeEl[e.month()] : this._monthsNominativeEl
            },
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            meridiem: function (e, t, n) {
                return e > 11 ? n ? "" : "" : n ? "" : ""
            },
            isPM: function (e) {
                return "" === (e + "").toLowerCase()[0]
            },
            meridiemParse: /[]\.??\.?/i,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendarEl: {
                sameDay: "[ {}] LT",
                nextDay: "[ {}] LT",
                nextWeek: "dddd [{}] LT",
                lastDay: "[ {}] LT",
                lastWeek: function () {
                    switch (this.day()) {
                        case 6:
                            return "[ ] dddd [{}] LT";
                        default:
                            return "[ ] dddd [{}] LT"
                    }
                },
                sameElse: "L"
            },
            calendar: function (e, t) {
                var n, i = this._calendarEl[e], r = t && t.hours();
                return n = i, ("undefined" != typeof Function && n instanceof Function || "[object Function]" === Object.prototype.toString.call(n)) && (i = i.apply(t)), i.replace("{}", r % 12 == 1 ? "" : "")
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-au", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 0, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-ca", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "YYYY-MM-DD",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-gb", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-ie", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-il", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-in", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-nz", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("en-sg", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("eo", {
            months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split("_"),
            monthsShort: "jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec".split("_"),
            weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"),
            weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"),
            weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "[la] D[-an de] MMMM, YYYY",
                LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
                LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
                llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
            },
            meridiemParse: /[ap]\.t\.m/i,
            isPM: function (e) {
                return "p" === e.charAt(0).toLowerCase()
            },
            meridiem: function (e, t, n) {
                return e > 11 ? n ? "p.t.m." : "P.T.M." : n ? "a.t.m." : "A.T.M."
            },
            calendar: {
                sameDay: "[Hodia je] LT",
                nextDay: "[Morga je] LT",
                nextWeek: "dddd[n je] LT",
                lastDay: "[Hiera je] LT",
                lastWeek: "[pasintan] dddd[n je] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "post %s",
                past: "anta %s",
                s: "kelkaj sekundoj",
                ss: "%d sekundoj",
                m: "unu minuto",
                mm: "%d minutoj",
                h: "unu horo",
                hh: "%d horoj",
                d: "unu tago",
                dd: "%d tagoj",
                M: "unu monato",
                MM: "%d monatoj",
                y: "unu jaro",
                yy: "%d jaroj"
            },
            dayOfMonthOrdinalParse: /\d{1,2}a/,
            ordinal: "%da",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            n = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            i = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            r = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        e.defineLocale("es", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
            weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function () {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextDay: function () {
                    return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextWeek: function () {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastDay: function () {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastWeek: function () {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un da",
                dd: "%d das",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un ao",
                yy: "%d aos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4},
            invalidDate: "Fecha invlida"
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            n = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            i = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            r = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        e.defineLocale("es-do", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
            weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY h:mm A",
                LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
            },
            calendar: {
                sameDay: function () {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextDay: function () {
                    return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextWeek: function () {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastDay: function () {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastWeek: function () {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un da",
                dd: "%d das",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un ao",
                yy: "%d aos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            n = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            i = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            r = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        e.defineLocale("es-mx", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
            weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function () {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextDay: function () {
                    return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextWeek: function () {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastDay: function () {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastWeek: function () {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un da",
                dd: "%d das",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un ao",
                yy: "%d aos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 0, doy: 4},
            invalidDate: "Fecha invlida"
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            n = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            i = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            r = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        e.defineLocale("es-us", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
            weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "MM/DD/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY h:mm A",
                LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
            },
            calendar: {
                sameDay: function () {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextDay: function () {
                    return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextWeek: function () {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastDay: function () {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, lastWeek: function () {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un da",
                dd: "%d das",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un ao",
                yy: "%d aos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                s: ["mne sekundi", "mni sekund", "paar sekundit"],
                ss: [e + "sekundi", e + "sekundit"],
                m: ["he minuti", "ks minut"],
                mm: [e + " minuti", e + " minutit"],
                h: ["he tunni", "tund aega", "ks tund"],
                hh: [e + " tunni", e + " tundi"],
                d: ["he peva", "ks pev"],
                M: ["kuu aja", "kuu aega", "ks kuu"],
                MM: [e + " kuu", e + " kuud"],
                y: ["he aasta", "aasta", "ks aasta"],
                yy: [e + " aasta", e + " aastat"]
            };
            return t ? r[n][2] ? r[n][2] : r[n][1] : i ? r[n][0] : r[n][1]
        }

        e.defineLocale("et", {
            months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
            monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
            weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split("_"),
            weekdaysShort: "P_E_T_K_N_R_L".split("_"),
            weekdaysMin: "P_E_T_K_N_R_L".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[Tna,] LT",
                nextDay: "[Homme,] LT",
                nextWeek: "[Jrgmine] dddd LT",
                lastDay: "[Eile,] LT",
                lastWeek: "[Eelmine] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s prast",
                past: "%s tagasi",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: "%d peva",
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("eu", {
            months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
            monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
            monthsParseExact: !0,
            weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
            weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
            weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY[ko] MMMM[ren] D[a]",
                LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
                LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
                l: "YYYY-M-D",
                ll: "YYYY[ko] MMM D[a]",
                lll: "YYYY[ko] MMM D[a] HH:mm",
                llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
            },
            calendar: {
                sameDay: "[gaur] LT[etan]",
                nextDay: "[bihar] LT[etan]",
                nextWeek: "dddd LT[etan]",
                lastDay: "[atzo] LT[etan]",
                lastWeek: "[aurreko] dddd LT[etan]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s barru",
                past: "duela %s",
                s: "segundo batzuk",
                ss: "%d segundo",
                m: "minutu bat",
                mm: "%d minutu",
                h: "ordu bat",
                hh: "%d ordu",
                d: "egun bat",
                dd: "%d egun",
                M: "hilabete bat",
                MM: "%d hilabete",
                y: "urte bat",
                yy: "%d urte"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("fa", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /  |  /,
            isPM: function (e) {
                return /  /.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "  " : "  "
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "dddd [] [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[-]/g, (function (e) {
                    return n[e]
                })).replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                })).replace(/,/g, "")
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(" "),
            n = ["nolla", "yhden", "kahden", "kolmen", "neljn", "viiden", "kuuden", t[7], t[8], t[9]];

        function i(e, i, r, o) {
            var a = "";
            switch (r) {
                case"s":
                    return o ? "muutaman sekunnin" : "muutama sekunti";
                case"ss":
                    a = o ? "sekunnin" : "sekuntia";
                    break;
                case"m":
                    return o ? "minuutin" : "minuutti";
                case"mm":
                    a = o ? "minuutin" : "minuuttia";
                    break;
                case"h":
                    return o ? "tunnin" : "tunti";
                case"hh":
                    a = o ? "tunnin" : "tuntia";
                    break;
                case"d":
                    return o ? "pivn" : "piv";
                case"dd":
                    a = o ? "pivn" : "piv";
                    break;
                case"M":
                    return o ? "kuukauden" : "kuukausi";
                case"MM":
                    a = o ? "kuukauden" : "kuukautta";
                    break;
                case"y":
                    return o ? "vuoden" : "vuosi";
                case"yy":
                    a = o ? "vuoden" : "vuotta"
            }
            return a = function (e, i) {
                return e < 10 ? i ? n[e] : t[e] : e
            }(e, o) + " " + a
        }

        e.defineLocale("fi", {
            months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
            monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split("_"),
            weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
            weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
            weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD.MM.YYYY",
                LL: "Do MMMM[ta] YYYY",
                LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
                LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
                l: "D.M.YYYY",
                ll: "Do MMM YYYY",
                lll: "Do MMM YYYY, [klo] HH.mm",
                llll: "ddd, Do MMM YYYY, [klo] HH.mm"
            },
            calendar: {
                sameDay: "[tnn] [klo] LT",
                nextDay: "[huomenna] [klo] LT",
                nextWeek: "dddd [klo] LT",
                lastDay: "[eilen] [klo] LT",
                lastWeek: "[viime] dddd[na] [klo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s pst",
                past: "%s sitten",
                s: i,
                ss: i,
                m: i,
                mm: i,
                h: i,
                hh: i,
                d: i,
                dd: i,
                M: i,
                MM: i,
                y: i,
                yy: i
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("fil", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY HH:mm",
                LLLL: "dddd, MMMM DD, YYYY HH:mm"
            },
            calendar: {
                sameDay: "LT [ngayong araw]",
                nextDay: "[Bukas ng] LT",
                nextWeek: "LT [sa susunod na] dddd",
                lastDay: "LT [kahapon]",
                lastWeek: "LT [noong nakaraang] dddd",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                ss: "%d segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (e) {
                return e
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("fo", {
            months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split("_"),
            weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"),
            weekdaysMin: "su_m_t_mi_h_fr_le".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D. MMMM, YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ dag kl.] LT",
                nextDay: "[ morgin kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[ gjr kl.] LT",
                lastWeek: "[sstu] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "um %s",
                past: "%s sani",
                s: "f sekund",
                ss: "%d sekundir",
                m: "ein minuttur",
                mm: "%d minuttir",
                h: "ein tmi",
                hh: "%d tmar",
                d: "ein dagur",
                dd: "%d dagar",
                M: "ein mnaur",
                MM: "%d mnair",
                y: "eitt r",
                yy: "%d r"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
            n = [/^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i];
        e.defineLocale("fr", {
            months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
            monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
            monthsRegex: t,
            monthsShortRegex: t,
            monthsStrictRegex: /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
            monthsShortStrictRegex: /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,
            monthsParse: n,
            longMonthsParse: n,
            shortMonthsParse: n,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourdhui ] LT",
                nextDay: "[Demain ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[Hier ] LT",
                lastWeek: "dddd [dernier ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                w: "une semaine",
                ww: "%d semaines",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"D":
                        return e + (1 === e ? "er" : "");
                    default:
                    case"M":
                    case"Q":
                    case"DDD":
                    case"d":
                        return e + (1 === e ? "er" : "e");
                    case"w":
                    case"W":
                        return e + (1 === e ? "re" : "e")
                }
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("fr-ca", {
            months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
            monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourdhui ] LT",
                nextDay: "[Demain ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[Hier ] LT",
                lastWeek: "dddd [dernier ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function (e, t) {
                switch (t) {
                    default:
                    case"M":
                    case"Q":
                    case"D":
                    case"DDD":
                    case"d":
                        return e + (1 === e ? "er" : "e");
                    case"w":
                    case"W":
                        return e + (1 === e ? "re" : "e")
                }
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("fr-ch", {
            months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
            monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourdhui ] LT",
                nextDay: "[Demain ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[Hier ] LT",
                lastWeek: "dddd [dernier ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function (e, t) {
                switch (t) {
                    default:
                    case"M":
                    case"Q":
                    case"D":
                    case"DDD":
                    case"d":
                        return e + (1 === e ? "er" : "e");
                    case"w":
                    case"W":
                        return e + (1 === e ? "re" : "e")
                }
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"),
            n = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
        e.defineLocale("fy", {
            months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsParseExact: !0,
            weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
            weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
            weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[hjoed om] LT",
                nextDay: "[moarn om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[juster om] LT",
                lastWeek: "[frne] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oer %s",
                past: "%s lyn",
                s: "in pear sekonden",
                ss: "%d sekonden",
                m: "ien mint",
                mm: "%d minuten",
                h: "ien oere",
                hh: "%d oeren",
                d: "ien dei",
                dd: "%d dagen",
                M: "ien moanne",
                MM: "%d moannen",
                y: "ien jier",
                yy: "%d jierren"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (e) {
                return e + (1 === e || 8 === e || e >= 20 ? "ste" : "de")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ga", {
            months: ["Eanir", "Feabhra", "Mrta", "Aibren", "Bealtaine", "Meitheamh", "Iil", "Lnasa", "Men Fmhair", "Deireadh Fmhair", "Samhain", "Nollaig"],
            monthsShort: ["Ean", "Feabh", "Mrt", "Aib", "Beal", "Meith", "Iil", "Ln", "M.F.", "D.F.", "Samh", "Noll"],
            monthsParseExact: !0,
            weekdays: ["D Domhnaigh", "D Luain", "D Mirt", "D Cadaoin", "Dardaoin", "D hAoine", "D Sathairn"],
            weekdaysShort: ["Domh", "Luan", "Mirt", "Cad", "Dar", "Aoine", "Sath"],
            weekdaysMin: ["Do", "Lu", "M", "C", "D", "A", "Sa"],
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Inniu ag] LT",
                nextDay: "[Amrach ag] LT",
                nextWeek: "dddd [ag] LT",
                lastDay: "[Inn ag] LT",
                lastWeek: "dddd [seo caite] [ag] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "i %s",
                past: "%s  shin",
                s: "cpla soicind",
                ss: "%d soicind",
                m: "nimad",
                mm: "%d nimad",
                h: "uair an chloig",
                hh: "%d uair an chloig",
                d: "l",
                dd: "%d l",
                M: "m",
                MM: "%d monna",
                y: "bliain",
                yy: "%d bliain"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function (e) {
                return e + (1 === e ? "d" : e % 10 == 2 ? "na" : "mh")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("gd", {
            months: ["Am Faoilleach", "An Gearran", "Am Mrt", "An Giblean", "An Citean", "An t-gmhios", "An t-Iuchar", "An Lnastal", "An t-Sultain", "An Dmhair", "An t-Samhain", "An Dbhlachd"],
            monthsShort: ["Faoi", "Gear", "Mrt", "Gibl", "Cit", "gmh", "Iuch", "Ln", "Sult", "Dmh", "Samh", "Dbh"],
            monthsParseExact: !0,
            weekdays: ["Didmhnaich", "Diluain", "Dimirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"],
            weekdaysShort: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
            weekdaysMin: ["D", "Lu", "M", "Ci", "Ar", "Ha", "Sa"],
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[An-diugh aig] LT",
                nextDay: "[A-mireach aig] LT",
                nextWeek: "dddd [aig] LT",
                lastDay: "[An-d aig] LT",
                lastWeek: "dddd [seo chaidh] [aig] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ann an %s",
                past: "bho chionn %s",
                s: "beagan diogan",
                ss: "%d diogan",
                m: "mionaid",
                mm: "%d mionaidean",
                h: "uair",
                hh: "%d uairean",
                d: "latha",
                dd: "%d latha",
                M: "mos",
                MM: "%d mosan",
                y: "bliadhna",
                yy: "%d bliadhna"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function (e) {
                return e + (1 === e ? "d" : e % 10 == 2 ? "na" : "mh")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("gl", {
            months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
            monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"),
            weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"),
            weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function () {
                    return "[hoxe " + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextDay: function () {
                    return "[ma " + (1 !== this.hours() ? "s" : "") + "] LT"
                }, nextWeek: function () {
                    return "dddd [" + (1 !== this.hours() ? "s" : "a") + "] LT"
                }, lastDay: function () {
                    return "[onte " + (1 !== this.hours() ? "" : "a") + "] LT"
                }, lastWeek: function () {
                    return "[o] dddd [pasado " + (1 !== this.hours() ? "s" : "a") + "] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: function (e) {
                    return 0 === e.indexOf("un") ? "n" + e : "en " + e
                },
                past: "hai %s",
                s: "uns segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "unha hora",
                hh: "%d horas",
                d: "un da",
                dd: "%d das",
                M: "un mes",
                MM: "%d meses",
                y: "un ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                s: [" ", " "],
                ss: [e + " ", e + " "],
                m: [" ", " "],
                mm: [e + " ", e + " "],
                h: [" ", " "],
                hh: [e + " ", e + " "],
                d: [" ", " "],
                dd: [e + " ", e + " "],
                M: [" ", " "],
                MM: [e + " ", e + " "],
                y: [" ", " "],
                yy: [e + " ", e + " "]
            };
            return i ? r[n][0] : r[n][1]
        }

        e.defineLocale("gom-deva", {
            months: {
                standalone: "___________".split("_"),
                format: "___________".split("_"),
                isFormat: /MMMM(\s)+D[oD]?/
            },
            monthsShort: "._.__.___._._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "._._._._._._.".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "A h:mm []",
                LTS: "A h:mm:ss []",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY A h:mm []",
                LLLL: "dddd, MMMM Do, YYYY, A h:mm []",
                llll: "ddd, D MMM YYYY, A h:mm []"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[] dddd[,] LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s ",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: t,
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}()/,
            ordinal: function (e, t) {
                switch (t) {
                    case"D":
                        return e + "";
                    default:
                    case"M":
                    case"Q":
                    case"DDD":
                    case"d":
                    case"w":
                    case"W":
                        return e
                }
            },
            week: {dow: 0, doy: 3},
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e > 12 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 12 ? "" : e < 16 ? "" : e < 20 ? "" : ""
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                s: ["thoddea sekondamni", "thodde sekond"],
                ss: [e + " sekondamni", e + " sekond"],
                m: ["eka mintan", "ek minut"],
                mm: [e + " mintamni", e + " mintam"],
                h: ["eka voran", "ek vor"],
                hh: [e + " voramni", e + " voram"],
                d: ["eka disan", "ek dis"],
                dd: [e + " disamni", e + " dis"],
                M: ["eka mhoinean", "ek mhoino"],
                MM: [e + " mhoineamni", e + " mhoine"],
                y: ["eka vorsan", "ek voros"],
                yy: [e + " vorsamni", e + " vorsam"]
            };
            return i ? r[n][0] : r[n][1]
        }

        e.defineLocale("gom-latn", {
            months: {
                standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
                format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
                isFormat: /MMMM(\s)+D[oD]?/
            },
            monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
            weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
            weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "A h:mm [vazta]",
                LTS: "A h:mm:ss [vazta]",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY A h:mm [vazta]",
                LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
                llll: "ddd, D MMM YYYY, A h:mm [vazta]"
            },
            calendar: {
                sameDay: "[Aiz] LT",
                nextDay: "[Faleam] LT",
                nextWeek: "[Fuddlo] dddd[,] LT",
                lastDay: "[Kal] LT",
                lastWeek: "[Fattlo] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s adim",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: t,
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"D":
                        return e + "er";
                    default:
                    case"M":
                    case"Q":
                    case"DDD":
                    case"d":
                    case"w":
                    case"W":
                        return e
                }
            },
            week: {dow: 0, doy: 3},
            meridiemParse: /rati|sokallim|donparam|sanje/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "rati" === t ? e < 4 ? e : e + 12 : "sokallim" === t ? e : "donparam" === t ? e > 12 ? e : e + 12 : "sanje" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "rati" : e < 12 ? "sokallim" : e < 16 ? "donparam" : e < 20 ? "sanje" : "rati"
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("gu", {
            months: "___________".split("_"),
            monthsShort: "._.__.___._._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("he", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D []MMMM YYYY",
                LLL: "D []MMMM YYYY HH:mm",
                LLLL: "dddd, D []MMMM YYYY HH:mm",
                l: "D/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd, D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ ]LT",
                nextDay: "[ ]LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ]LT",
                lastWeek: "[] dddd [ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: " ",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: function (e) {
                    return 2 === e ? "" : e + " "
                },
                d: "",
                dd: function (e) {
                    return 2 === e ? "" : e + " "
                },
                M: "",
                MM: function (e) {
                    return 2 === e ? "" : e + " "
                },
                y: "",
                yy: function (e) {
                    return 2 === e ? "" : e % 10 == 0 && 10 !== e ? e + " " : e + " "
                }
            },
            meridiemParse: /"|"| | | ||/i,
            isPM: function (e) {
                return /^("| |)$/.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 5 ? " " : e < 10 ? "" : e < 12 ? n ? '"' : " " : e < 18 ? n ? '"' : " " : ""
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"},
            i = [/^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i];
        e.defineLocale("hi", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: "._.__.___._._._._._.".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
            monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
            monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
            monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
            monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: "  ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i = e + " ";
            switch (n) {
                case"ss":
                    return i += 1 === e ? "sekunda" : 2 === e || 3 === e || 4 === e ? "sekunde" : "sekundi";
                case"m":
                    return t ? "jedna minuta" : "jedne minute";
                case"mm":
                    return i += 1 === e ? "minuta" : 2 === e || 3 === e || 4 === e ? "minute" : "minuta";
                case"h":
                    return t ? "jedan sat" : "jednog sata";
                case"hh":
                    return i += 1 === e ? "sat" : 2 === e || 3 === e || 4 === e ? "sata" : "sati";
                case"dd":
                    return i += 1 === e ? "dan" : "dana";
                case"MM":
                    return i += 1 === e ? "mjesec" : 2 === e || 3 === e || 4 === e ? "mjeseca" : "mjeseci";
                case"yy":
                    return i += 1 === e ? "godina" : 2 === e || 3 === e || 4 === e ? "godine" : "godina"
            }
        }

        e.defineLocale("hr", {
            months: {
                format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
                standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
            },
            monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "Do MMMM YYYY",
                LLL: "Do MMMM YYYY H:mm",
                LLLL: "dddd, Do MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                }, lastDay: "[juer u] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[prolu] [nedjelju] [u] LT";
                        case 3:
                            return "[prolu] [srijedu] [u] LT";
                        case 6:
                            return "[prole] [subote] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[proli] dddd [u] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: "dan",
                dd: t,
                M: "mjesec",
                MM: t,
                y: "godinu",
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");

        function n(e, t, n, i) {
            var r = e;
            switch (n) {
                case"s":
                    return i || t ? "nhny msodperc" : "nhny msodperce";
                case"ss":
                    return r + (i || t) ? " msodperc" : " msodperce";
                case"m":
                    return "egy" + (i || t ? " perc" : " perce");
                case"mm":
                    return r + (i || t ? " perc" : " perce");
                case"h":
                    return "egy" + (i || t ? " ra" : " rja");
                case"hh":
                    return r + (i || t ? " ra" : " rja");
                case"d":
                    return "egy" + (i || t ? " nap" : " napja");
                case"dd":
                    return r + (i || t ? " nap" : " napja");
                case"M":
                    return "egy" + (i || t ? " hnap" : " hnapja");
                case"MM":
                    return r + (i || t ? " hnap" : " hnapja");
                case"y":
                    return "egy" + (i || t ? " v" : " ve");
                case"yy":
                    return r + (i || t ? " v" : " ve")
            }
            return ""
        }

        function i(e) {
            return (e ? "" : "[mlt] ") + "[" + t[this.day()] + "] LT[-kor]"
        }

        e.defineLocale("hu", {
            months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split("_"),
            monthsShort: "jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"),
            weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"),
            weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY. MMMM D.",
                LLL: "YYYY. MMMM D. H:mm",
                LLLL: "YYYY. MMMM D., dddd H:mm"
            },
            meridiemParse: /de|du/i,
            isPM: function (e) {
                return "u" === e.charAt(1).toLowerCase()
            },
            meridiem: function (e, t, n) {
                return e < 12 ? !0 === n ? "de" : "DE" : !0 === n ? "du" : "DU"
            },
            calendar: {
                sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function () {
                    return i.call(this, !0)
                }, lastDay: "[tegnap] LT[-kor]", lastWeek: function () {
                    return i.call(this, !1)
                }, sameElse: "L"
            },
            relativeTime: {
                future: "%s mlva",
                past: "%s",
                s: n,
                ss: n,
                m: n,
                mm: n,
                h: n,
                hh: n,
                d: n,
                dd: n,
                M: n,
                MM: n,
                y: n,
                yy: n
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("hy-am", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY .",
                LLL: "D MMMM YYYY ., HH:mm",
                LLLL: "dddd, D MMMM YYYY ., HH:mm"
            },
            calendar: {
                sameDay: "[] LT", nextDay: "[] LT", lastDay: "[] LT", nextWeek: function () {
                    return "dddd [ ] LT"
                }, lastWeek: function () {
                    return "[] dddd [ ] LT"
                }, sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: "  ",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            meridiemParse: /|||/,
            isPM: function (e) {
                return /^(|)$/.test(e)
            },
            meridiem: function (e) {
                return e < 4 ? "" : e < 12 ? "" : e < 17 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"DDD":
                    case"w":
                    case"W":
                    case"DDDo":
                        return 1 === e ? e + "-" : e + "-";
                    default:
                        return e
                }
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("id", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|siang|sore|malam/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "pagi" === t ? e : "siang" === t ? e >= 11 ? e : e + 12 : "sore" === t || "malam" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 11 ? "pagi" : e < 15 ? "siang" : e < 19 ? "sore" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Besok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kemarin pukul] LT",
                lastWeek: "dddd [lalu pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lalu",
                s: "beberapa detik",
                ss: "%d detik",
                m: "semenit",
                mm: "%d menit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e) {
            return e % 100 == 11 || e % 10 != 1
        }

        function n(e, n, i, r) {
            var o = e + " ";
            switch (i) {
                case"s":
                    return n || r ? "nokkrar sekndur" : "nokkrum sekndum";
                case"ss":
                    return t(e) ? o + (n || r ? "sekndur" : "sekndum") : o + "seknda";
                case"m":
                    return n ? "mnta" : "mntu";
                case"mm":
                    return t(e) ? o + (n || r ? "mntur" : "mntum") : n ? o + "mnta" : o + "mntu";
                case"hh":
                    return t(e) ? o + (n || r ? "klukkustundir" : "klukkustundum") : o + "klukkustund";
                case"d":
                    return n ? "dagur" : r ? "dag" : "degi";
                case"dd":
                    return t(e) ? n ? o + "dagar" : o + (r ? "daga" : "dgum") : n ? o + "dagur" : o + (r ? "dag" : "degi");
                case"M":
                    return n ? "mnuur" : r ? "mnu" : "mnui";
                case"MM":
                    return t(e) ? n ? o + "mnuir" : o + (r ? "mnui" : "mnuum") : n ? o + "mnuur" : o + (r ? "mnu" : "mnui");
                case"y":
                    return n || r ? "r" : "ri";
                case"yy":
                    return t(e) ? o + (n || r ? "r" : "rum") : o + (n || r ? "r" : "ri")
            }
        }

        e.defineLocale("is", {
            months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"),
            weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split("_"),
            weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"),
            weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] H:mm",
                LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
            },
            calendar: {
                sameDay: "[ dag kl.] LT",
                nextDay: "[ morgun kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[ gr kl.] LT",
                lastWeek: "[sasta] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "eftir %s",
                past: "fyrir %s san",
                s: n,
                ss: n,
                m: n,
                mm: n,
                h: "klukkustund",
                hh: n,
                d: n,
                dd: n,
                M: n,
                MM: n,
                y: n,
                yy: n
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("it", {
            months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
            monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
            weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
            weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
            weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: function () {
                    return "[Oggi a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                }, nextDay: function () {
                    return "[Domani a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                }, nextWeek: function () {
                    return "dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                }, lastDay: function () {
                    return "[Ieri a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                }, lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        default:
                            return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "tra %s",
                past: "%s fa",
                s: "alcuni secondi",
                ss: "%d secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                w: "una settimana",
                ww: "%d settimane",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("it-ch", {
            months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
            monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
            weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
            weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
            weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Oggi alle] LT",
                nextDay: "[Domani alle] LT",
                nextWeek: "dddd [alle] LT",
                lastDay: "[Ieri alle] LT",
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[la scorsa] dddd [alle] LT";
                        default:
                            return "[lo scorso] dddd [alle] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function (e) {
                    return (/^[0-9].+$/.test(e) ? "tra" : "in") + " " + e
                },
                past: "%s fa",
                s: "alcuni secondi",
                ss: "%d secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ja", {
            eras: [{since: "2019-05-01", offset: 1, name: "", narrow: "", abbr: "R"}, {
                since: "1989-01-08",
                until: "2019-04-30",
                offset: 1,
                name: "",
                narrow: "",
                abbr: "H"
            }, {
                since: "1926-12-25",
                until: "1989-01-07",
                offset: 1,
                name: "",
                narrow: "",
                abbr: "S"
            }, {
                since: "1912-07-30",
                until: "1926-12-24",
                offset: 1,
                name: "",
                narrow: "",
                abbr: "T"
            }, {
                since: "1873-01-01",
                until: "1912-07-29",
                offset: 6,
                name: "",
                narrow: "",
                abbr: "M"
            }, {
                since: "0001-01-01",
                until: "1873-12-31",
                offset: 1,
                name: "",
                narrow: "AD",
                abbr: "AD"
            }, {since: "0000-12-31", until: -1 / 0, offset: 1, name: "", narrow: "BC", abbr: "BC"}],
            eraYearOrdinalRegex: /(|\d+)/,
            eraYearOrdinalParse: function (e, t) {
                return "" === t[1] ? 1 : parseInt(t[1] || e, 10)
            },
            months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMD dddd HH:mm",
                l: "YYYY/MM/DD",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMD(ddd) HH:mm"
            },
            meridiemParse: /|/i,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT", nextDay: "[] LT", nextWeek: function (e) {
                    return e.week() !== this.week() ? "[]dddd LT" : "dddd LT"
                }, lastDay: "[] LT", lastWeek: function (e) {
                    return this.week() !== e.week() ? "[]dddd LT" : "dddd LT"
                }, sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (e, t) {
                switch (t) {
                    case"y":
                        return 1 === e ? "" : e + "";
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    default:
                        return e
                }
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d",
                m: "1",
                mm: "%d",
                h: "1",
                hh: "%d",
                d: "1",
                dd: "%d",
                M: "1",
                MM: "%d",
                y: "1",
                yy: "%d"
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("jv", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
            weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /enjing|siyang|sonten|ndalu/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "enjing" === t ? e : "siyang" === t ? e >= 11 ? e : e + 12 : "sonten" === t || "ndalu" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 11 ? "enjing" : e < 15 ? "siyang" : e < 19 ? "sonten" : "ndalu"
            },
            calendar: {
                sameDay: "[Dinten puniko pukul] LT",
                nextDay: "[Mbenjang pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kala wingi pukul] LT",
                lastWeek: "dddd [kepengker pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "wonten ing %s",
                past: "%s ingkang kepengker",
                s: "sawetawis detik",
                ss: "%d detik",
                m: "setunggal menit",
                mm: "%d menit",
                h: "setunggal jam",
                hh: "%d jam",
                d: "sedinten",
                dd: "%d dinten",
                M: "sewulan",
                MM: "%d wulan",
                y: "setaun",
                yy: "%d taun"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ka", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: {
                standalone: "______".split("_"),
                format: "______".split("_"),
                isFormat: /(|)/
            },
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[] LT[-]",
                nextDay: "[] LT[-]",
                lastDay: "[] LT[-]",
                nextWeek: "[] dddd LT[-]",
                lastWeek: "[] dddd LT-",
                sameElse: "L"
            },
            relativeTime: {
                future: function (e) {
                    return e.replace(/(|||||)(|)/, (function (e, t, n) {
                        return "" === n ? t + "" : t + n + ""
                    }))
                },
                past: function (e) {
                    return /(||||)/.test(e) ? e.replace(/(|)$/, " ") : //.test(e) ? e.replace(/$/, " ") : e
                },
                s: " ",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
            ordinal: function (e) {
                return 0 === e ? e : 1 === e ? e + "-" : e < 20 || e <= 100 && e % 20 == 0 || e % 100 == 0 ? "-" + e : e + "-"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            0: "-",
            1: "-",
            2: "-",
            3: "-",
            4: "-",
            5: "-",
            6: "-",
            7: "-",
            8: "-",
            9: "-",
            10: "-",
            20: "-",
            30: "-",
            40: "-",
            50: "-",
            60: "-",
            70: "-",
            80: "-",
            90: "-",
            100: "-"
        };
        e.defineLocale("kk", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "[ ] dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
            ordinal: function (e) {
                return e + (t[e] || t[e % 10] || t[e >= 100 ? 100 : null])
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("km", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "dddd [] [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("kn", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}()/,
            ordinal: function (e) {
                return e + ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ko", {
            months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY MMMM D",
                LLL: "YYYY MMMM D A h:mm",
                LLLL: "YYYY MMMM D dddd A h:mm",
                l: "YYYY.MM.DD.",
                ll: "YYYY MMMM D",
                lll: "YYYY MMMM D A h:mm",
                llll: "YYYY MMMM D dddd A h:mm"
            },
            calendar: {
                sameDay: " LT",
                nextDay: " LT",
                nextWeek: "dddd LT",
                lastDay: " LT",
                lastWeek: " dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d",
                m: "1",
                mm: "%d",
                h: " ",
                hh: "%d",
                d: "",
                dd: "%d",
                M: " ",
                MM: "%d",
                y: " ",
                yy: "%d"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    case"M":
                        return e + "";
                    case"w":
                    case"W":
                        return e + "";
                    default:
                        return e
                }
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"},
            i = [" ", "", "", "", "", "", "", "", "", " ", " ", " "];
        e.defineLocale("ku", {
            months: i,
            monthsShort: i,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return //.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s",
                s: " ",
                ss: " %d",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                })).replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                })).replace(/,/g, "")
            },
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            0: "-",
            1: "-",
            2: "-",
            3: "-",
            4: "-",
            5: "-",
            6: "-",
            7: "-",
            8: "-",
            9: "-",
            10: "-",
            20: "-",
            30: "-",
            40: "-",
            50: "-",
            60: "-",
            70: "-",
            80: "-",
            90: "-",
            100: "-"
        };
        e.defineLocale("ky", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "[ ] dddd [] [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
            ordinal: function (e) {
                return e + (t[e] || t[e % 10] || t[e >= 100 ? 100 : null])
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                m: ["eng Minutt", "enger Minutt"],
                h: ["eng Stonn", "enger Stonn"],
                d: ["een Dag", "engem Dag"],
                M: ["ee Mount", "engem Mount"],
                y: ["ee Joer", "engem Joer"]
            };
            return t ? r[n][0] : r[n][1]
        }

        function n(e) {
            if (e = parseInt(e, 10), isNaN(e)) return !1;
            if (e < 0) return !0;
            if (e < 10) return 4 <= e && e <= 7;
            if (e < 100) {
                var t = e % 10;
                return n(0 === t ? e / 10 : t)
            }
            if (e < 1e4) {
                for (; e >= 10;) e /= 10;
                return n(e)
            }
            return n(e /= 1e3)
        }

        e.defineLocale("lb", {
            months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
            weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm [Auer]",
                LTS: "H:mm:ss [Auer]",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm [Auer]",
                LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
            },
            calendar: {
                sameDay: "[Haut um] LT",
                sameElse: "L",
                nextDay: "[Muer um] LT",
                nextWeek: "dddd [um] LT",
                lastDay: "[Gschter um] LT",
                lastWeek: function () {
                    switch (this.day()) {
                        case 2:
                        case 4:
                            return "[Leschten] dddd [um] LT";
                        default:
                            return "[Leschte] dddd [um] LT"
                    }
                }
            },
            relativeTime: {
                future: function (e) {
                    return n(e.substr(0, e.indexOf(" "))) ? "a " + e : "an " + e
                },
                past: function (e) {
                    return n(e.substr(0, e.indexOf(" "))) ? "viru " + e : "virun " + e
                },
                s: "e puer Sekonnen",
                ss: "%d Sekonnen",
                m: t,
                mm: "%d Minutten",
                h: t,
                hh: "%d Stonnen",
                d: t,
                dd: "%d Deeg",
                M: t,
                MM: "%d Mint",
                y: t,
                yy: "%d Joer"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("lo", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[]dddd[] LT",
                lastDay: "[] LT",
                lastWeek: "[]dddd[] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /()\d{1,2}/,
            ordinal: function (e) {
                return "" + e
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            ss: "sekund_sekundi_sekundes",
            m: "minut_minuts_minut",
            mm: "minuts_minui_minutes",
            h: "valanda_valandos_valand",
            hh: "valandos_valand_valandas",
            d: "diena_dienos_dien",
            dd: "dienos_dien_dienas",
            M: "mnuo_mnesio_mnes",
            MM: "mnesiai_mnesi_mnesius",
            y: "metai_met_metus",
            yy: "metai_met_metus"
        };

        function n(e, t, n, i) {
            return t ? r(n)[0] : i ? r(n)[1] : r(n)[2]
        }

        function i(e) {
            return e % 10 == 0 || e > 10 && e < 20
        }

        function r(e) {
            return t[e].split("_")
        }

        function o(e, t, o, a) {
            var s = e + " ";
            return 1 === e ? s + n(0, t, o[0], a) : t ? s + (i(e) ? r(o)[1] : r(o)[0]) : a ? s + r(o)[1] : s + (i(e) ? r(o)[1] : r(o)[2])
        }

        e.defineLocale("lt", {
            months: {
                format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split("_"),
                standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split("_"),
                isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
            },
            monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
            weekdays: {
                format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split("_"),
                standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split("_"),
                isFormat: /dddd HH:mm/
            },
            weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"),
            weekdaysMin: "S_P_A_T_K_Pn_".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY [m.] MMMM D [d.]",
                LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
                l: "YYYY-MM-DD",
                ll: "YYYY [m.] MMMM D [d.]",
                lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
            },
            calendar: {
                sameDay: "[iandien] LT",
                nextDay: "[Rytoj] LT",
                nextWeek: "dddd LT",
                lastDay: "[Vakar] LT",
                lastWeek: "[Prajus] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "po %s", past: "prie %s", s: function (e, t, n, i) {
                    return t ? "kelios sekunds" : i ? "keli sekundi" : "kelias sekundes"
                }, ss: o, m: n, mm: o, h: n, hh: o, d: n, dd: o, M: n, MM: o, y: n, yy: o
            },
            dayOfMonthOrdinalParse: /\d{1,2}-oji/,
            ordinal: function (e) {
                return e + "-oji"
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            ss: "sekundes_sekundm_sekunde_sekundes".split("_"),
            m: "mintes_mintm_minte_mintes".split("_"),
            mm: "mintes_mintm_minte_mintes".split("_"),
            h: "stundas_stundm_stunda_stundas".split("_"),
            hh: "stundas_stundm_stunda_stundas".split("_"),
            d: "dienas_dienm_diena_dienas".split("_"),
            dd: "dienas_dienm_diena_dienas".split("_"),
            M: "mnea_mneiem_mnesis_mnei".split("_"),
            MM: "mnea_mneiem_mnesis_mnei".split("_"),
            y: "gada_gadiem_gads_gadi".split("_"),
            yy: "gada_gadiem_gads_gadi".split("_")
        };

        function n(e, t, n) {
            return n ? t % 10 == 1 && t % 100 != 11 ? e[2] : e[3] : t % 10 == 1 && t % 100 != 11 ? e[0] : e[1]
        }

        function i(e, i, r) {
            return e + " " + n(t[r], e, i)
        }

        function r(e, i, r) {
            return n(t[r], e, i)
        }

        e.defineLocale("lv", {
            months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"),
            weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split("_"),
            weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY.",
                LL: "YYYY. [gada] D. MMMM",
                LLL: "YYYY. [gada] D. MMMM, HH:mm",
                LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
            },
            calendar: {
                sameDay: "[odien pulksten] LT",
                nextDay: "[Rt pulksten] LT",
                nextWeek: "dddd [pulksten] LT",
                lastDay: "[Vakar pulksten] LT",
                lastWeek: "[Pagju] dddd [pulksten] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "pc %s", past: "pirms %s", s: function (e, t) {
                    return t ? "daas sekundes" : "dam sekundm"
                }, ss: i, m: r, mm: i, h: r, hh: i, d: r, dd: i, M: r, MM: i, y: r, yy: i
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            words: {
                ss: ["sekund", "sekunda", "sekundi"],
                m: ["jedan minut", "jednog minuta"],
                mm: ["minut", "minuta", "minuta"],
                h: ["jedan sat", "jednog sata"],
                hh: ["sat", "sata", "sati"],
                dd: ["dan", "dana", "dana"],
                MM: ["mjesec", "mjeseca", "mjeseci"],
                yy: ["godina", "godine", "godina"]
            }, correctGrammaticalCase: function (e, t) {
                return 1 === e ? t[0] : e >= 2 && e <= 4 ? t[1] : t[2]
            }, translate: function (e, n, i) {
                var r = t.words[i];
                return 1 === i.length ? n ? r[0] : r[1] : e + " " + t.correctGrammaticalCase(e, r)
            }
        };
        e.defineLocale("me", {
            months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT", nextDay: "[sjutra u] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                }, lastDay: "[jue u] LT", lastWeek: function () {
                    return ["[prole] [nedjelje] [u] LT", "[prolog] [ponedjeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srijede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT"][this.day()]
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "nekoliko sekundi",
                ss: t.translate,
                m: t.translate,
                mm: t.translate,
                h: t.translate,
                hh: t.translate,
                d: "dan",
                dd: t.translate,
                M: "mjesec",
                MM: t.translate,
                y: "godinu",
                yy: t.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("mi", {
            months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split("_"),
            monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
            monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
            weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"),
            weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
            weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [i] HH:mm",
                LLLL: "dddd, D MMMM YYYY [i] HH:mm"
            },
            calendar: {
                sameDay: "[i teie mahana, i] LT",
                nextDay: "[apopo i] LT",
                nextWeek: "dddd [i] LT",
                lastDay: "[inanahi i] LT",
                lastWeek: "dddd [whakamutunga i] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "i roto i %s",
                past: "%s i mua",
                s: "te hkona ruarua",
                ss: "%d hkona",
                m: "he meneti",
                mm: "%d meneti",
                h: "te haora",
                hh: "%d haora",
                d: "he ra",
                dd: "%d ra",
                M: "he marama",
                MM: "%d marama",
                y: "he tau",
                yy: "%d tau"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("mk", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "e_o_____a".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "[] dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return "[] dddd [] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[] dddd [] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
            ordinal: function (e) {
                var t = e % 10, n = e % 100;
                return 0 === e ? e + "-" : 0 === n ? e + "-" : n > 10 && n < 20 ? e + "-" : 1 === t ? e + "-" : 2 === t ? e + "-" : 7 === t || 8 === t ? e + "-" : e + "-"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ml", {
            months: "___________".split("_"),
            monthsShort: "._._._.___._._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm -",
                LTS: "A h:mm:ss -",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm -",
                LLLL: "dddd, D MMMM YYYY, A h:mm -"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            meridiemParse: /|| ||/i,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t && e >= 4 || " " === t || "" === t ? e + 12 : e
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 12 ? "" : e < 17 ? " " : e < 20 ? "" : ""
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            switch (n) {
                case"s":
                    return t ? " " : " ";
                case"ss":
                    return e + (t ? " " : " ");
                case"m":
                case"mm":
                    return e + (t ? " " : " ");
                case"h":
                case"hh":
                    return e + (t ? " " : " ");
                case"d":
                case"dd":
                    return e + (t ? " " : " ");
                case"M":
                case"MM":
                    return e + (t ? " " : " ");
                case"y":
                case"yy":
                    return e + (t ? " " : " ");
                default:
                    return e
            }
        }

        e.defineLocale("mn", {
            months: " _ _ _ _ _ _ _ _ _ _  _  ".split("_"),
            monthsShort: "1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 ".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY  MMMM D",
                LLL: "YYYY  MMMM D HH:mm",
                LLLL: "dddd, YYYY  MMMM D HH:mm"
            },
            meridiemParse: /|/i,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[] dddd LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: t,
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2} /,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + " ";
                    default:
                        return e
                }
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};

        function i(e, t, n, i) {
            var r = "";
            if (t) switch (n) {
                case"s":
                    r = " ";
                    break;
                case"ss":
                    r = "%d ";
                    break;
                case"m":
                    r = " ";
                    break;
                case"mm":
                    r = "%d ";
                    break;
                case"h":
                    r = " ";
                    break;
                case"hh":
                    r = "%d ";
                    break;
                case"d":
                    r = " ";
                    break;
                case"dd":
                    r = "%d ";
                    break;
                case"M":
                    r = " ";
                    break;
                case"MM":
                    r = "%d ";
                    break;
                case"y":
                    r = " ";
                    break;
                case"yy":
                    r = "%d "
            } else switch (n) {
                case"s":
                    r = " ";
                    break;
                case"ss":
                    r = "%d ";
                    break;
                case"m":
                    r = " ";
                    break;
                case"mm":
                    r = "%d ";
                    break;
                case"h":
                    r = " ";
                    break;
                case"hh":
                    r = "%d ";
                    break;
                case"d":
                    r = " ";
                    break;
                case"dd":
                    r = "%d ";
                    break;
                case"M":
                    r = " ";
                    break;
                case"MM":
                    r = "%d ";
                    break;
                case"y":
                    r = " ";
                    break;
                case"yy":
                    r = "%d "
            }
            return r.replace(/%d/i, e)
        }

        e.defineLocale("mr", {
            months: "___________".split("_"),
            monthsShort: "._._._._._._._._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: i,
                ss: i,
                m: i,
                mm: i,
                h: i,
                hh: i,
                d: i,
                dd: i,
                M: i,
                MM: i,
                y: i,
                yy: i
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t || "" === t ? e : "" === t || "" === t || "" === t ? e >= 12 ? e : e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e >= 0 && e < 6 ? "" : e < 12 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ms", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "pagi" === t ? e : "tengahari" === t ? e >= 11 ? e : e + 12 : "petang" === t || "malam" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 11 ? "pagi" : e < 15 ? "tengahari" : e < 19 ? "petang" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                ss: "%d saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ms-my", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "pagi" === t ? e : "tengahari" === t ? e >= 11 ? e : e + 12 : "petang" === t || "malam" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 11 ? "pagi" : e < 15 ? "tengahari" : e < 19 ? "petang" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                ss: "%d saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("mt", {
            months: "Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru".split("_"),
            monthsShort: "Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di".split("_"),
            weekdays: "Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt".split("_"),
            weekdaysShort: "ad_Tne_Tli_Erb_am_im_Sib".split("_"),
            weekdaysMin: "a_Tn_Tl_Er_a_i_Si".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Illum fil-]LT",
                nextDay: "[Gada fil-]LT",
                nextWeek: "dddd [fil-]LT",
                lastDay: "[Il-biera fil-]LT",
                lastWeek: "dddd [li gadda] [fil-]LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "f %s",
                past: "%s ilu",
                s: "ftit sekondi",
                ss: "%d sekondi",
                m: "minuta",
                mm: "%d minuti",
                h: "siega",
                hh: "%d siegat",
                d: "urnata",
                dd: "%d ranet",
                M: "xahar",
                MM: "%d xhur",
                y: "sena",
                yy: "%d sni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("my", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[.] LT []",
                nextDay: "[] LT []",
                nextWeek: "dddd LT []",
                lastDay: "[.] LT []",
                lastWeek: "[] dddd LT []",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s ",
                past: " %s ",
                s: ".",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("nb", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
            weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"),
            weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] HH:mm",
                LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[i gr kl.] LT",
                lastWeek: "[forrige] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "noen sekunder",
                ss: "%d sekunder",
                m: "ett minutt",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dager",
                w: "en uke",
                ww: "%d uker",
                M: "en mned",
                MM: "%d mneder",
                y: "ett r",
                yy: "%d r"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("ne", {
            months: "___________".split("_"),
            monthsShort: "._.__.___._._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "._._._._._._.".split("_"),
            weekdaysMin: "._._._._._._.".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 3 ? "" : e < 12 ? "" : e < 16 ? "" : e < 20 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[] dddd[,] LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
            n = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
            i = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
            r = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
        e.defineLocale("nl", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                ss: "%d seconden",
                m: "n minuut",
                mm: "%d minuten",
                h: "n uur",
                hh: "%d uur",
                d: "n dag",
                dd: "%d dagen",
                w: "n week",
                ww: "%d weken",
                M: "n maand",
                MM: "%d maanden",
                y: "n jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (e) {
                return e + (1 === e || 8 === e || e >= 20 ? "ste" : "de")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
            n = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
            i = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
            r = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
        e.defineLocale("nl-be", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function (e, i) {
                return e ? /-MMM-/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsRegex: r,
            monthsShortRegex: r,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                ss: "%d seconden",
                m: "n minuut",
                mm: "%d minuten",
                h: "n uur",
                hh: "%d uur",
                d: "n dag",
                dd: "%d dagen",
                M: "n maand",
                MM: "%d maanden",
                y: "n jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (e) {
                return e + (1 === e || 8 === e || e >= 20 ? "ste" : "de")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("nn", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
            weekdaysShort: "su._m._ty._on._to._fr._lau.".split("_"),
            weekdaysMin: "su_m_ty_on_to_fr_la".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] H:mm",
                LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[I dag klokka] LT",
                nextDay: "[I morgon klokka] LT",
                nextWeek: "dddd [klokka] LT",
                lastDay: "[I gr klokka] LT",
                lastWeek: "[Fregande] dddd [klokka] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s sidan",
                s: "nokre sekund",
                ss: "%d sekund",
                m: "eit minutt",
                mm: "%d minutt",
                h: "ein time",
                hh: "%d timar",
                d: "ein dag",
                dd: "%d dagar",
                w: "ei veke",
                ww: "%d veker",
                M: "ein mnad",
                MM: "%d mnader",
                y: "eit r",
                yy: "%d r"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("oc-lnc", {
            months: {
                standalone: "genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre".split("_"),
                format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split("_"),
                isFormat: /D[oD]?(\s)+MMMM/
            },
            monthsShort: "gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte".split("_"),
            weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
            weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [de] YYYY",
                ll: "D MMM YYYY",
                LLL: "D MMMM [de] YYYY [a] H:mm",
                lll: "D MMM YYYY, H:mm",
                LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
                llll: "ddd D MMM YYYY, H:mm"
            },
            calendar: {
                sameDay: "[ui a] LT",
                nextDay: "[deman a] LT",
                nextWeek: "dddd [a] LT",
                lastDay: "[ir a] LT",
                lastWeek: "dddd [passat a] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "d'aqu %s",
                past: "fa %s",
                s: "unas segondas",
                ss: "%d segondas",
                m: "una minuta",
                mm: "%d minutas",
                h: "una ora",
                hh: "%d oras",
                d: "un jorn",
                dd: "%d jorns",
                M: "un mes",
                MM: "%d meses",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
            ordinal: function (e, t) {
                var n = 1 === e ? "r" : 2 === e ? "n" : 3 === e ? "r" : 4 === e ? "t" : "";
                return "w" !== t && "W" !== t || (n = "a"), e + n
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("pa-in", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm ",
                LTS: "A h:mm:ss ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ",
                LLLL: "dddd, D MMMM YYYY, A h:mm "
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[] dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"),
            n = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_"),
            i = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i];

        function r(e) {
            return e % 10 < 5 && e % 10 > 1 && ~~(e / 10) % 10 != 1
        }

        function o(e, t, n) {
            var i = e + " ";
            switch (n) {
                case"ss":
                    return i + (r(e) ? "sekundy" : "sekund");
                case"m":
                    return t ? "minuta" : "minut";
                case"mm":
                    return i + (r(e) ? "minuty" : "minut");
                case"h":
                    return t ? "godzina" : "godzin";
                case"hh":
                    return i + (r(e) ? "godziny" : "godzin");
                case"ww":
                    return i + (r(e) ? "tygodnie" : "tygodni");
                case"MM":
                    return i + (r(e) ? "miesice" : "miesicy");
                case"yy":
                    return i + (r(e) ? "lata" : "lat")
            }
        }

        e.defineLocale("pl", {
            months: function (e, i) {
                return e ? /D MMMM/.test(i) ? n[e.month()] : t[e.month()] : t
            },
            monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
            monthsParse: i,
            longMonthsParse: i,
            shortMonthsParse: i,
            weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
            weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
            weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Dzi o] LT", nextDay: "[Jutro o] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[W niedziel o] LT";
                        case 2:
                            return "[We wtorek o] LT";
                        case 3:
                            return "[W rod o] LT";
                        case 6:
                            return "[W sobot o] LT";
                        default:
                            return "[W] dddd [o] LT"
                    }
                }, lastDay: "[Wczoraj o] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[W zesz niedziel o] LT";
                        case 3:
                            return "[W zesz rod o] LT";
                        case 6:
                            return "[W zesz sobot o] LT";
                        default:
                            return "[W zeszy] dddd [o] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "%s temu",
                s: "kilka sekund",
                ss: o,
                m: o,
                mm: o,
                h: o,
                hh: o,
                d: "1 dzie",
                dd: "%d dni",
                w: "tydzie",
                ww: o,
                M: "miesic",
                MM: o,
                y: "rok",
                yy: o
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("pt", {
            months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),
            weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
            weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY HH:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hoje s] LT",
                nextDay: "[Amanh s] LT",
                nextWeek: "dddd [s] LT",
                lastDay: "[Ontem s] LT",
                lastWeek: function () {
                    return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "h %s",
                s: "segundos",
                ss: "%d segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                w: "uma semana",
                ww: "%d semanas",
                M: "um ms",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("pt-br", {
            months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"),
            weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
            weekdaysMin: "do_2_3_4_5_6_s".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
            },
            calendar: {
                sameDay: "[Hoje s] LT",
                nextDay: "[Amanh s] LT",
                nextWeek: "dddd [s] LT",
                lastDay: "[Ontem s] LT",
                lastWeek: function () {
                    return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "h %s",
                s: "poucos segundos",
                ss: "%d segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um ms",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            invalidDate: "Data invlida"
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i = " ";
            return (e % 100 >= 20 || e >= 100 && e % 100 == 0) && (i = " de "), e + i + {
                ss: "secunde",
                mm: "minute",
                hh: "ore",
                dd: "zile",
                ww: "sptmni",
                MM: "luni",
                yy: "ani"
            }[n]
        }

        e.defineLocale("ro", {
            months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
            monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"),
            weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"),
            weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[azi la] LT",
                nextDay: "[mine la] LT",
                nextWeek: "dddd [la] LT",
                lastDay: "[ieri la] LT",
                lastWeek: "[fosta] dddd [la] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "peste %s",
                past: "%s n urm",
                s: "cteva secunde",
                ss: t,
                m: "un minut",
                mm: t,
                h: "o or",
                hh: t,
                d: "o zi",
                dd: t,
                w: "o sptmn",
                ww: t,
                M: "o lun",
                MM: t,
                y: "un an",
                yy: t
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i, r;
            return "m" === n ? t ? "" : "" : e + " " + (i = +e, r = {
                ss: t ? "__" : "__",
                mm: t ? "__" : "__",
                hh: "__",
                dd: "__",
                ww: "__",
                MM: "__",
                yy: "__"
            }[n].split("_"), i % 10 == 1 && i % 100 != 11 ? r[0] : i % 10 >= 2 && i % 10 <= 4 && (i % 100 < 10 || i % 100 >= 20) ? r[1] : r[2])
        }

        var n = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
        e.defineLocale("ru", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: {
                format: "._._._.____._._._._.".split("_"),
                standalone: "._.__.____._._._._.".split("_")
            },
            weekdays: {
                standalone: "______".split("_"),
                format: "______".split("_"),
                isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
            },
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            monthsParse: n,
            longMonthsParse: n,
            shortMonthsParse: n,
            monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
            monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
            monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
            monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY .",
                LLL: "D MMMM YYYY ., H:mm",
                LLLL: "dddd, D MMMM YYYY ., H:mm"
            },
            calendar: {
                sameDay: "[, ] LT",
                nextDay: "[, ] LT",
                lastDay: "[, ] LT",
                nextWeek: function (e) {
                    if (e.week() === this.week()) return 2 === this.day() ? "[] dddd, [] LT" : "[] dddd, [] LT";
                    switch (this.day()) {
                        case 0:
                            return "[ ] dddd, [] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[ ] dddd, [] LT";
                        case 3:
                        case 5:
                        case 6:
                            return "[ ] dddd, [] LT"
                    }
                },
                lastWeek: function (e) {
                    if (e.week() === this.week()) return 2 === this.day() ? "[] dddd, [] LT" : "[] dddd, [] LT";
                    switch (this.day()) {
                        case 0:
                            return "[ ] dddd, [] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[ ] dddd, [] LT";
                        case 3:
                        case 5:
                        case 6:
                            return "[ ] dddd, [] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                ss: t,
                m: t,
                mm: t,
                h: "",
                hh: t,
                d: "",
                dd: t,
                w: "",
                ww: t,
                M: "",
                MM: t,
                y: "",
                yy: t
            },
            meridiemParse: /|||/i,
            isPM: function (e) {
                return /^(|)$/.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 12 ? "" : e < 17 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"M":
                    case"d":
                    case"DDD":
                        return e + "-";
                    case"D":
                        return e + "-";
                    case"w":
                    case"W":
                        return e + "-";
                    default:
                        return e
                }
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = ["", "", "", "", "", "", "", "", "", "", "", ""],
            n = ["", "", "", "", "", "", ""];
        e.defineLocale("sd", {
            months: t,
            monthsShort: t,
            weekdays: n,
            weekdaysShort: n,
            weekdaysMin: n,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd [  ] LT",
                lastDay: "[] LT",
                lastWeek: "[ ] dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/,/g, "")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("se", {
            months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split("_"),
            monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"),
            weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split("_"),
            weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"),
            weekdaysMin: "s_v_m_g_d_b_L".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "MMMM D. [b.] YYYY",
                LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
                LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
            },
            calendar: {
                sameDay: "[otne ti] LT",
                nextDay: "[ihttin ti] LT",
                nextWeek: "dddd [ti] LT",
                lastDay: "[ikte ti] LT",
                lastWeek: "[ovddit] dddd [ti] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s geaes",
                past: "mait %s",
                s: "moadde sekunddat",
                ss: "%d sekunddat",
                m: "okta minuhta",
                mm: "%d minuhtat",
                h: "okta diimmu",
                hh: "%d diimmut",
                d: "okta beaivi",
                dd: "%d beaivvit",
                M: "okta mnnu",
                MM: "%d mnut",
                y: "okta jahki",
                yy: "%d jagit"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("si", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "a h:mm",
                LTS: "a h:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY MMMM D",
                LLL: "YYYY MMMM D, a h:mm",
                LLLL: "YYYY MMMM D [] dddd, a h:mm:ss"
            },
            calendar: {
                sameDay: "[] LT[]",
                nextDay: "[] LT[]",
                nextWeek: "dddd LT[]",
                lastDay: "[] LT[]",
                lastWeek: "[] dddd LT[]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s ",
                s: " ",
                ss: " %d",
                m: "",
                mm: " %d",
                h: "",
                hh: " %d",
                d: "",
                dd: " %d",
                M: "",
                MM: " %d",
                y: "",
                yy: " %d"
            },
            dayOfMonthOrdinalParse: /\d{1,2} /,
            ordinal: function (e) {
                return e + " "
            },
            meridiemParse: / | |.|../,
            isPM: function (e) {
                return ".." === e || " " === e
            },
            meridiem: function (e, t, n) {
                return e > 11 ? n ? ".." : " " : n ? ".." : " "
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split("_"),
            n = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");

        function i(e) {
            return e > 1 && e < 5
        }

        function r(e, t, n, r) {
            var o = e + " ";
            switch (n) {
                case"s":
                    return t || r ? "pr seknd" : "pr sekundami";
                case"ss":
                    return t || r ? o + (i(e) ? "sekundy" : "seknd") : o + "sekundami";
                case"m":
                    return t ? "minta" : r ? "mintu" : "mintou";
                case"mm":
                    return t || r ? o + (i(e) ? "minty" : "mint") : o + "mintami";
                case"h":
                    return t ? "hodina" : r ? "hodinu" : "hodinou";
                case"hh":
                    return t || r ? o + (i(e) ? "hodiny" : "hodn") : o + "hodinami";
                case"d":
                    return t || r ? "de" : "dom";
                case"dd":
                    return t || r ? o + (i(e) ? "dni" : "dn") : o + "dami";
                case"M":
                    return t || r ? "mesiac" : "mesiacom";
                case"MM":
                    return t || r ? o + (i(e) ? "mesiace" : "mesiacov") : o + "mesiacmi";
                case"y":
                    return t || r ? "rok" : "rokom";
                case"yy":
                    return t || r ? o + (i(e) ? "roky" : "rokov") : o + "rokmi"
            }
        }

        e.defineLocale("sk", {
            months: t,
            monthsShort: n,
            weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"),
            weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"),
            weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[v nedeu o] LT";
                        case 1:
                        case 2:
                            return "[v] dddd [o] LT";
                        case 3:
                            return "[v stredu o] LT";
                        case 4:
                            return "[vo tvrtok o] LT";
                        case 5:
                            return "[v piatok o] LT";
                        case 6:
                            return "[v sobotu o] LT"
                    }
                }, lastDay: "[vera o] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[minul nedeu o] LT";
                        case 1:
                        case 2:
                            return "[minul] dddd [o] LT";
                        case 3:
                            return "[minul stredu o] LT";
                        case 4:
                        case 5:
                            return "[minul] dddd [o] LT";
                        case 6:
                            return "[minul sobotu o] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pred %s",
                s: r,
                ss: r,
                m: r,
                mm: r,
                h: r,
                hh: r,
                d: r,
                dd: r,
                M: r,
                MM: r,
                y: r,
                yy: r
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = e + " ";
            switch (n) {
                case"s":
                    return t || i ? "nekaj sekund" : "nekaj sekundami";
                case"ss":
                    return r += 1 === e ? t ? "sekundo" : "sekundi" : 2 === e ? t || i ? "sekundi" : "sekundah" : e < 5 ? t || i ? "sekunde" : "sekundah" : "sekund";
                case"m":
                    return t ? "ena minuta" : "eno minuto";
                case"mm":
                    return r += 1 === e ? t ? "minuta" : "minuto" : 2 === e ? t || i ? "minuti" : "minutama" : e < 5 ? t || i ? "minute" : "minutami" : t || i ? "minut" : "minutami";
                case"h":
                    return t ? "ena ura" : "eno uro";
                case"hh":
                    return r += 1 === e ? t ? "ura" : "uro" : 2 === e ? t || i ? "uri" : "urama" : e < 5 ? t || i ? "ure" : "urami" : t || i ? "ur" : "urami";
                case"d":
                    return t || i ? "en dan" : "enim dnem";
                case"dd":
                    return r += 1 === e ? t || i ? "dan" : "dnem" : 2 === e ? t || i ? "dni" : "dnevoma" : t || i ? "dni" : "dnevi";
                case"M":
                    return t || i ? "en mesec" : "enim mesecem";
                case"MM":
                    return r += 1 === e ? t || i ? "mesec" : "mesecem" : 2 === e ? t || i ? "meseca" : "mesecema" : e < 5 ? t || i ? "mesece" : "meseci" : t || i ? "mesecev" : "meseci";
                case"y":
                    return t || i ? "eno leto" : "enim letom";
                case"yy":
                    return r += 1 === e ? t || i ? "leto" : "letom" : 2 === e ? t || i ? "leti" : "letoma" : e < 5 ? t || i ? "leta" : "leti" : t || i ? "let" : "leti"
            }
        }

        e.defineLocale("sl", {
            months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"),
            weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"),
            weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[v] [nedeljo] [ob] LT";
                        case 3:
                            return "[v] [sredo] [ob] LT";
                        case 6:
                            return "[v] [soboto] [ob] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[v] dddd [ob] LT"
                    }
                }, lastDay: "[veraj ob] LT", lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[prejnjo] [nedeljo] [ob] LT";
                        case 3:
                            return "[prejnjo] [sredo] [ob] LT";
                        case 6:
                            return "[prejnjo] [soboto] [ob] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[prejnji] dddd [ob] LT"
                    }
                }, sameElse: "L"
            },
            relativeTime: {
                future: "ez %s",
                past: "pred %s",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: t,
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("sq", {
            months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split("_"),
            monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"),
            weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split("_"),
            weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"),
            weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"),
            weekdaysParseExact: !0,
            meridiemParse: /PD|MD/,
            isPM: function (e) {
                return "M" === e.charAt(0)
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "PD" : "MD"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Sot n] LT",
                nextDay: "[Nesr n] LT",
                nextWeek: "dddd [n] LT",
                lastDay: "[Dje n] LT",
                lastWeek: "dddd [e kaluar n] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "n %s",
                past: "%s m par",
                s: "disa sekonda",
                ss: "%d sekonda",
                m: "nj minut",
                mm: "%d minuta",
                h: "nj or",
                hh: "%d or",
                d: "nj dit",
                dd: "%d dit",
                M: "nj muaj",
                MM: "%d muaj",
                y: "nj vit",
                yy: "%d vite"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            words: {
                ss: ["sekunda", "sekunde", "sekundi"],
                m: ["jedan minut", "jedne minute"],
                mm: ["minut", "minute", "minuta"],
                h: ["jedan sat", "jednog sata"],
                hh: ["sat", "sata", "sati"],
                dd: ["dan", "dana", "dana"],
                MM: ["mesec", "meseca", "meseci"],
                yy: ["godina", "godine", "godina"]
            }, correctGrammaticalCase: function (e, t) {
                return 1 === e ? t[0] : e >= 2 && e <= 4 ? t[1] : t[2]
            }, translate: function (e, n, i) {
                var r = t.words[i];
                return 1 === i.length ? n ? r[0] : r[1] : e + " " + t.correctGrammaticalCase(e, r)
            }
        };
        e.defineLocale("sr", {
            months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D. M. YYYY.",
                LL: "D. MMMM YYYY.",
                LLL: "D. MMMM YYYY. H:mm",
                LLLL: "dddd, D. MMMM YYYY. H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedelju] [u] LT";
                        case 3:
                            return "[u] [sredu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                }, lastDay: "[jue u] LT", lastWeek: function () {
                    return ["[prole] [nedelje] [u] LT", "[prolog] [ponedeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT"][this.day()]
                }, sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pre %s",
                s: "nekoliko sekundi",
                ss: t.translate,
                m: t.translate,
                mm: t.translate,
                h: t.translate,
                hh: t.translate,
                d: "dan",
                dd: t.translate,
                M: "mesec",
                MM: t.translate,
                y: "godinu",
                yy: t.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            words: {
                ss: ["", "", ""],
                m: [" ", " "],
                mm: ["", "", ""],
                h: [" ", " "],
                hh: ["", "", ""],
                dd: ["", "", ""],
                MM: ["", "", ""],
                yy: ["", "", ""]
            }, correctGrammaticalCase: function (e, t) {
                return 1 === e ? t[0] : e >= 2 && e <= 4 ? t[1] : t[2]
            }, translate: function (e, n, i) {
                var r = t.words[i];
                return 1 === i.length ? n ? r[0] : r[1] : e + " " + t.correctGrammaticalCase(e, r)
            }
        };
        e.defineLocale("sr-cyrl", {
            months: "___________".split("_"),
            monthsShort: "._._._.____._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "._._._._._._.".split("_"),
            weekdaysMin: "______".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D. M. YYYY.",
                LL: "D. MMMM YYYY.",
                LLL: "D. MMMM YYYY. H:mm",
                LLLL: "dddd, D. MMMM YYYY. H:mm"
            },
            calendar: {
                sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return "[] [] [] LT";
                        case 3:
                            return "[] [] [] LT";
                        case 6:
                            return "[] [] [] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[] dddd [] LT"
                    }
                }, lastDay: "[ ] LT", lastWeek: function () {
                    return ["[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT"][this.day()]
                }, sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: " %s",
                s: " ",
                ss: t.translate,
                m: t.translate,
                mm: t.translate,
                h: t.translate,
                hh: t.translate,
                d: "",
                dd: t.translate,
                M: "",
                MM: t.translate,
                y: "",
                yy: t.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ss", {
            months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
            monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
            weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
            weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
            weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Namuhla nga] LT",
                nextDay: "[Kusasa nga] LT",
                nextWeek: "dddd [nga] LT",
                lastDay: "[Itolo nga] LT",
                lastWeek: "dddd [leliphelile] [nga] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "nga %s",
                past: "wenteka nga %s",
                s: "emizuzwana lomcane",
                ss: "%d mzuzwana",
                m: "umzuzu",
                mm: "%d emizuzu",
                h: "lihora",
                hh: "%d emahora",
                d: "lilanga",
                dd: "%d emalanga",
                M: "inyanga",
                MM: "%d tinyanga",
                y: "umnyaka",
                yy: "%d iminyaka"
            },
            meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
            meridiem: function (e, t, n) {
                return e < 11 ? "ekuseni" : e < 15 ? "emini" : e < 19 ? "entsambama" : "ebusuku"
            },
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "ekuseni" === t ? e : "emini" === t ? e >= 11 ? e : e + 12 : "entsambama" === t || "ebusuku" === t ? 0 === e ? 0 : e + 12 : void 0
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("sv", {
            months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"),
            weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"),
            weekdaysMin: "s_m_ti_on_to_fr_l".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [kl.] HH:mm",
                LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Idag] LT",
                nextDay: "[Imorgon] LT",
                lastDay: "[Igr] LT",
                nextWeek: "[P] dddd LT",
                lastWeek: "[I] dddd[s] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "fr %s sedan",
                s: "ngra sekunder",
                ss: "%d sekunder",
                m: "en minut",
                mm: "%d minuter",
                h: "en timme",
                hh: "%d timmar",
                d: "en dag",
                dd: "%d dagar",
                M: "en mnad",
                MM: "%d mnader",
                y: "ett r",
                yy: "%d r"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? ":e" : 1 === t || 2 === t ? ":a" : ":e")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("sw", {
            months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
            weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
            weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "hh:mm A",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[leo saa] LT",
                nextDay: "[kesho saa] LT",
                nextWeek: "[wiki ijayo] dddd [saat] LT",
                lastDay: "[jana] LT",
                lastWeek: "[wiki iliyopita] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s baadaye",
                past: "tokea %s",
                s: "hivi punde",
                ss: "sekunde %d",
                m: "dakika moja",
                mm: "dakika %d",
                h: "saa limoja",
                hh: "masaa %d",
                d: "siku moja",
                dd: "siku %d",
                M: "mwezi mmoja",
                MM: "miezi %d",
                y: "mwaka mmoja",
                yy: "miaka %d"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: ""},
            n = {"": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0"};
        e.defineLocale("ta", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, HH:mm",
                LLLL: "dddd, D MMMM YYYY, HH:mm"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[ ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: "  ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: "  ",
                hh: "%d  ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (e) {
                return e + ""
            },
            preparse: function (e) {
                return e.replace(/[]/g, (function (e) {
                    return n[e]
                }))
            },
            postformat: function (e) {
                return e.replace(/\d/g, (function (e) {
                    return t[e]
                }))
            },
            meridiemParse: /|||||/,
            meridiem: function (e, t, n) {
                return e < 2 ? " " : e < 6 ? " " : e < 10 ? " " : e < 14 ? " " : e < 18 ? " " : e < 22 ? " " : " "
            },
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 2 ? e : e + 12 : "" === t || "" === t || "" === t && e >= 10 ? e : e + 12
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("te", {
            months: "___________".split("_"),
            monthsShort: "._.__.____._._._._.".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "dddd, LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 10 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 10 ? "" : e < 17 ? "" : e < 20 ? "" : ""
            },
            week: {dow: 0, doy: 6}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("tet", {
            months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
            monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
            weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
            weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
            weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Ohin iha] LT",
                nextDay: "[Aban iha] LT",
                nextWeek: "dddd [iha] LT",
                lastDay: "[Horiseik iha] LT",
                lastWeek: "dddd [semana kotuk] [iha] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "iha %s",
                past: "%s liuba",
                s: "segundu balun",
                ss: "segundu %d",
                m: "minutu ida",
                mm: "minutu %d",
                h: "oras ida",
                hh: "oras %d",
                d: "loron ida",
                dd: "loron %d",
                M: "fulan ida",
                MM: "fulan %d",
                y: "tinan ida",
                yy: "tinan %d"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            0: "-",
            1: "-",
            2: "-",
            3: "-",
            4: "-",
            5: "-",
            6: "-",
            7: "-",
            8: "-",
            9: "-",
            10: "-",
            12: "-",
            13: "-",
            20: "-",
            30: "-",
            40: "-",
            50: "-",
            60: "-",
            70: "-",
            80: "-",
            90: "-",
            100: "-"
        };
        e.defineLocale("tg", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                lastDay: "[ ] LT",
                nextWeek: "dddd[] [  ] LT",
                lastWeek: "dddd[] [  ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            meridiemParse: /|||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t ? e < 4 ? e : e + 12 : "" === t ? e : "" === t ? e >= 11 ? e : e + 12 : "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 11 ? "" : e < 16 ? "" : e < 19 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
            ordinal: function (e) {
                return e + (t[e] || t[e % 10] || t[e >= 100 ? 100 : null])
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("th", {
            months: "___________".split("_"),
            monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split("_"),
            monthsParseExact: !0,
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "._._._._._._.".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY  H:mm",
                LLLL: "dddd D MMMM YYYY  H:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd[ ] LT",
                lastDay: "[ ] LT",
                lastWeek: "[]dddd[ ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                w: "1 ",
                ww: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            1: "'inji",
            5: "'inji",
            8: "'inji",
            70: "'inji",
            80: "'inji",
            2: "'nji",
            7: "'nji",
            20: "'nji",
            50: "'nji",
            3: "'nji",
            4: "'nji",
            100: "'nji",
            6: "'njy",
            9: "'unjy",
            10: "'unjy",
            30: "'unjy",
            60: "'ynjy",
            90: "'ynjy"
        };
        e.defineLocale("tk", {
            months: "anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr".split("_"),
            monthsShort: "an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek".split("_"),
            weekdays: "ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe".split("_"),
            weekdaysShort: "ek_Du_Si_ar_Pen_Ann_en".split("_"),
            weekdaysMin: "k_D_S_r_Pn_An_n".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugn sagat] LT",
                nextDay: "[ertir sagat] LT",
                nextWeek: "[indiki] dddd [sagat] LT",
                lastDay: "[dn] LT",
                lastWeek: "[geen] dddd [sagat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s so",
                past: "%s ",
                s: "birne sekunt",
                m: "bir minut",
                mm: "%d minut",
                h: "bir sagat",
                hh: "%d sagat",
                d: "bir gn",
                dd: "%d gn",
                M: "bir a",
                MM: "%d a",
                y: "bir yl",
                yy: "%d yl"
            },
            ordinal: function (e, n) {
                switch (n) {
                    case"d":
                    case"D":
                    case"Do":
                    case"DD":
                        return e;
                    default:
                        if (0 === e) return e + "'unjy";
                        var i = e % 10;
                        return e + (t[i] || t[e % 100 - i] || t[e >= 100 ? 100 : null])
                }
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("tl-ph", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY HH:mm",
                LLLL: "dddd, MMMM DD, YYYY HH:mm"
            },
            calendar: {
                sameDay: "LT [ngayong araw]",
                nextDay: "[Bukas ng] LT",
                nextWeek: "LT [sa susunod na] dddd",
                lastDay: "LT [kahapon]",
                lastWeek: "LT [noong nakaraang] dddd",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                ss: "%d segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (e) {
                return e
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");

        function n(e, n, i, r) {
            var o = function (e) {
                var n = Math.floor(e % 1e3 / 100), i = Math.floor(e % 100 / 10), r = e % 10, o = "";
                return n > 0 && (o += t[n] + "vatlh"), i > 0 && (o += ("" !== o ? " " : "") + t[i] + "maH"), r > 0 && (o += ("" !== o ? " " : "") + t[r]), "" === o ? "pagh" : o
            }(e);
            switch (i) {
                case"ss":
                    return o + " lup";
                case"mm":
                    return o + " tup";
                case"hh":
                    return o + " rep";
                case"dd":
                    return o + " jaj";
                case"MM":
                    return o + " jar";
                case"yy":
                    return o + " DIS"
            }
        }

        e.defineLocale("tlh", {
            months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split("_"),
            monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split("_"),
            monthsParseExact: !0,
            weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[DaHjaj] LT",
                nextDay: "[waleS] LT",
                nextWeek: "LLL",
                lastDay: "[waHu] LT",
                lastWeek: "LLL",
                sameElse: "L"
            },
            relativeTime: {
                future: function (e) {
                    var t = e;
                    return t = -1 !== e.indexOf("jaj") ? t.slice(0, -3) + "leS" : -1 !== e.indexOf("jar") ? t.slice(0, -3) + "waQ" : -1 !== e.indexOf("DIS") ? t.slice(0, -3) + "nem" : t + " pIq"
                },
                past: function (e) {
                    var t = e;
                    return t = -1 !== e.indexOf("jaj") ? t.slice(0, -3) + "Hu" : -1 !== e.indexOf("jar") ? t.slice(0, -3) + "wen" : -1 !== e.indexOf("DIS") ? t.slice(0, -3) + "ben" : t + " ret"
                },
                s: "puS lup",
                ss: n,
                m: "wa tup",
                mm: n,
                h: "wa rep",
                hh: n,
                d: "wa jaj",
                dd: n,
                M: "wa jar",
                MM: n,
                y: "wa DIS",
                yy: n
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",
            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",
            3: "'nc",
            4: "'nc",
            100: "'nc",
            6: "'nc",
            9: "'uncu",
            10: "'uncu",
            30: "'uncu",
            60: "'nc",
            90: "'nc"
        };
        e.defineLocale("tr", {
            months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"),
            monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
            weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"),
            weekdaysShort: "Paz_Pts_Sal_ar_Per_Cum_Cts".split("_"),
            weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
            meridiem: function (e, t, n) {
                return e < 12 ? n ? "" : "" : n ? "s" : "S"
            },
            meridiemParse: /||s|S/,
            isPM: function (e) {
                return "s" === e || "S" === e
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugn saat] LT",
                nextDay: "[yarn saat] LT",
                nextWeek: "[gelecek] dddd [saat] LT",
                lastDay: "[dn] LT",
                lastWeek: "[geen] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s nce",
                s: "birka saniye",
                ss: "%d saniye",
                m: "bir dakika",
                mm: "%d dakika",
                h: "bir saat",
                hh: "%d saat",
                d: "bir gn",
                dd: "%d gn",
                w: "bir hafta",
                ww: "%d hafta",
                M: "bir ay",
                MM: "%d ay",
                y: "bir yl",
                yy: "%d yl"
            },
            ordinal: function (e, n) {
                switch (n) {
                    case"d":
                    case"D":
                    case"Do":
                    case"DD":
                        return e;
                    default:
                        if (0 === e) return e + "'nc";
                        var i = e % 10;
                        return e + (t[i] || t[e % 100 - i] || t[e >= 100 ? 100 : null])
                }
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n, i) {
            var r = {
                s: ["viensas secunds", "'iensas secunds"],
                ss: [e + " secunds", e + " secunds"],
                m: ["'n mut", "'iens mut"],
                mm: [e + " muts", e + " muts"],
                h: ["'n ora", "'iensa ora"],
                hh: [e + " oras", e + " oras"],
                d: ["'n ziua", "'iensa ziua"],
                dd: [e + " ziuas", e + " ziuas"],
                M: ["'n mes", "'iens mes"],
                MM: [e + " mesen", e + " mesen"],
                y: ["'n ar", "'iens ar"],
                yy: [e + " ars", e + " ars"]
            };
            return i || t ? r[n][0] : r[n][1]
        }

        e.defineLocale("tzl", {
            months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split("_"),
            monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
            weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"),
            weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"),
            weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM [dallas] YYYY",
                LLL: "D. MMMM [dallas] YYYY HH.mm",
                LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
            },
            meridiemParse: /d\'o|d\'a/i,
            isPM: function (e) {
                return "d'o" === e.toLowerCase()
            },
            meridiem: function (e, t, n) {
                return e > 11 ? n ? "d'o" : "D'O" : n ? "d'a" : "D'A"
            },
            calendar: {
                sameDay: "[oxhi ] LT",
                nextDay: "[dem ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ieiri ] LT",
                lastWeek: "[sr el] dddd [lasteu ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "osprei %s",
                past: "ja%s",
                s: t,
                ss: t,
                m: t,
                mm: t,
                h: t,
                hh: t,
                d: t,
                dd: t,
                M: t,
                MM: t,
                y: t,
                yy: t
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("tzm", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[ ] LT",
                lastWeek: "dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "   %s",
                past: " %s",
                s: "",
                ss: "%d ",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d o",
                M: "o",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("tzm-latn", {
            months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
            monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
            weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
            weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
            weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[asdkh g] LT",
                nextDay: "[aska g] LT",
                nextWeek: "dddd [g] LT",
                lastDay: "[assant g] LT",
                lastWeek: "dddd [g] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dadkh s yan %s",
                past: "yan %s",
                s: "imik",
                ss: "%d imik",
                m: "minu",
                mm: "%d minu",
                h: "saa",
                hh: "%d tassain",
                d: "ass",
                dd: "%d ossan",
                M: "ayowr",
                MM: "%d iyyirn",
                y: "asgas",
                yy: "%d isgasn"
            },
            week: {dow: 6, doy: 12}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("ug-cn", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY-M-D-",
                LLL: "YYYY-M-D- HH:mm",
                LLLL: "dddd YYYY-M-D- HH:mm"
            },
            meridiemParse: / || || |/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), " " === t || "" === t || " " === t ? e : " " === t || "" === t ? e + 12 : e >= 11 ? e : e + 12
            },
            meridiem: function (e, t, n) {
                var i = 100 * e + t;
                return i < 600 ? " " : i < 900 ? "" : i < 1130 ? " " : i < 1230 ? "" : i < 1800 ? " " : ""
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "[] dddd [] LT",
                lastDay: "[] LT",
                lastWeek: "[] dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "-";
                    case"w":
                    case"W":
                        return e + "-";
                    default:
                        return e
                }
            },
            preparse: function (e) {
                return e.replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/,/g, "")
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";

//! moment.js locale configuration
        function t(e, t, n) {
            var i, r;
            return "m" === n ? t ? "" : "" : "h" === n ? t ? "" : "" : e + " " + (i = +e, r = {
                ss: t ? "__" : "__",
                mm: t ? "__" : "__",
                hh: t ? "__" : "__",
                dd: "__",
                MM: "__",
                yy: "__"
            }[n].split("_"), i % 10 == 1 && i % 100 != 11 ? r[0] : i % 10 >= 2 && i % 10 <= 4 && (i % 100 < 10 || i % 100 >= 20) ? r[1] : r[2])
        }

        function n(e) {
            return function () {
                return e + "" + (11 === this.hours() ? "" : "") + "] LT"
            }
        }

        e.defineLocale("uk", {
            months: {
                format: "___________".split("_"),
                standalone: "___________".split("_")
            },
            monthsShort: "___________".split("_"),
            weekdays: function (e, t) {
                var n = {
                    nominative: "______".split("_"),
                    accusative: "______".split("_"),
                    genitive: "______".split("_")
                };
                return !0 === e ? n.nominative.slice(1, 7).concat(n.nominative.slice(0, 1)) : e ? n[/(\[[]\]) ?dddd/.test(t) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(t) ? "genitive" : "nominative"][e.day()] : n.nominative
            },
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY .",
                LLL: "D MMMM YYYY ., HH:mm",
                LLLL: "dddd, D MMMM YYYY ., HH:mm"
            },
            calendar: {
                sameDay: n("[ "),
                nextDay: n("[ "),
                lastDay: n("[ "),
                nextWeek: n("[] dddd ["),
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return n("[] dddd [").call(this);
                        case 1:
                        case 2:
                        case 4:
                            return n("[] dddd [").call(this)
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: " %s",
                past: "%s ",
                s: " ",
                ss: t,
                m: t,
                mm: t,
                h: "",
                hh: t,
                d: "",
                dd: t,
                M: "",
                MM: t,
                y: "",
                yy: t
            },
            meridiemParse: /|||/,
            isPM: function (e) {
                return /^(|)$/.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 4 ? "" : e < 12 ? "" : e < 17 ? "" : ""
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"M":
                    case"d":
                    case"DDD":
                    case"w":
                    case"W":
                        return e + "-";
                    case"D":
                        return e + "-";
                    default:
                        return e
                }
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        var t = ["", "", "", "", "", "", "", "", "", "", "", ""],
            n = ["", "", "", "", "", "", ""];
        e.defineLocale("ur", {
            months: t,
            monthsShort: t,
            weekdays: n,
            weekdaysShort: n,
            weekdaysMin: n,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /|/,
            isPM: function (e) {
                return "" === e
            },
            meridiem: function (e, t, n) {
                return e < 12 ? "" : ""
            },
            calendar: {
                sameDay: "[ ] LT",
                nextDay: "[ ] LT",
                nextWeek: "dddd [] LT",
                lastDay: "[  ] LT",
                lastWeek: "[] dddd [] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            preparse: function (e) {
                return e.replace(//g, ",")
            },
            postformat: function (e) {
                return e.replace(/,/g, "")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("uz", {
            months: "___________".split("_"),
            monthsShort: "___________".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "D MMMM YYYY, dddd HH:mm"
            },
            calendar: {
                sameDay: "[ ] LT []",
                nextDay: "[] LT []",
                nextWeek: "dddd [ ] LT []",
                lastDay: "[ ] LT []",
                lastWeek: "[] dddd [ ] LT []",
                sameElse: "L"
            },
            relativeTime: {
                future: " %s ",
                past: "  %s ",
                s: "",
                ss: "%d ",
                m: " ",
                mm: "%d ",
                h: " ",
                hh: "%d ",
                d: " ",
                dd: "%d ",
                M: " ",
                MM: "%d ",
                y: " ",
                yy: "%d "
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("uz-latn", {
            months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
            monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
            weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
            weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
            weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "D MMMM YYYY, dddd HH:mm"
            },
            calendar: {
                sameDay: "[Bugun soat] LT [da]",
                nextDay: "[Ertaga] LT [da]",
                nextWeek: "dddd [kuni soat] LT [da]",
                lastDay: "[Kecha soat] LT [da]",
                lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
                sameElse: "L"
            },
            relativeTime: {
                future: "Yaqin %s ichida",
                past: "Bir necha %s oldin",
                s: "soniya",
                ss: "%d soniya",
                m: "bir daqiqa",
                mm: "%d daqiqa",
                h: "bir soat",
                hh: "%d soat",
                d: "bir kun",
                dd: "%d kun",
                M: "bir oy",
                MM: "%d oy",
                y: "bir yil",
                yy: "%d yil"
            },
            week: {dow: 1, doy: 7}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("vi", {
            months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"),
            monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
            monthsParseExact: !0,
            weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"),
            weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysParseExact: !0,
            meridiemParse: /sa|ch/i,
            isPM: function (e) {
                return /^ch$/i.test(e)
            },
            meridiem: function (e, t, n) {
                return e < 12 ? n ? "sa" : "SA" : n ? "ch" : "CH"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [nm] YYYY",
                LLL: "D MMMM [nm] YYYY HH:mm",
                LLLL: "dddd, D MMMM [nm] YYYY HH:mm",
                l: "DD/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd, D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hm nay lc] LT",
                nextDay: "[Ngy mai lc] LT",
                nextWeek: "dddd [tun ti lc] LT",
                lastDay: "[Hm qua lc] LT",
                lastWeek: "dddd [tun trc lc] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ti",
                past: "%s trc",
                s: "vi giy",
                ss: "%d giy",
                m: "mt pht",
                mm: "%d pht",
                h: "mt gi",
                hh: "%d gi",
                d: "mt ngy",
                dd: "%d ngy",
                w: "mt tun",
                ww: "%d tun",
                M: "mt thng",
                MM: "%d thng",
                y: "mt nm",
                yy: "%d nm"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (e) {
                return e
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("x-pseudo", {
            months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split("_"),
            monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split("_"),
            monthsParseExact: !0,
            weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split("_"),
            weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"),
            weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[T~d~ t] LT",
                nextDay: "[T~m~rr~w t] LT",
                nextWeek: "dddd [t] LT",
                lastDay: "[~st~rd~ t] LT",
                lastWeek: "[L~st] dddd [t] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "~ %s",
                past: "%s ~g",
                s: " ~fw ~sc~ds",
                ss: "%d s~c~ds",
                m: " ~m~t",
                mm: "%d m~~ts",
                h: "~ h~r",
                hh: "%d h~rs",
                d: " ~d",
                dd: "%d d~s",
                M: " ~m~th",
                MM: "%d m~t~hs",
                y: " ~r",
                yy: "%d ~rs"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (e) {
                var t = e % 10;
                return e + (1 == ~~(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("yo", {
            months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split("_"),
            monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"),
            weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"),
            weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"),
            weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Oni ni] LT",
                nextDay: "[la ni] LT",
                nextWeek: "dddd [s ton'b] [ni] LT",
                lastDay: "[Ana ni] LT",
                lastWeek: "dddd [s tol] [ni] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ni %s",
                past: "%s kja",
                s: "isju aaya die",
                ss: "aaya %d",
                m: "isju kan",
                mm: "isju %d",
                h: "wakati kan",
                hh: "wakati %d",
                d: "j kan",
                dd: "j %d",
                M: "osu kan",
                MM: "osu %d",
                y: "dun kan",
                yy: "dun %d"
            },
            dayOfMonthOrdinalParse: /j\s\d{1,2}/,
            ordinal: "j %d",
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("zh-cn", {
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMDAhmm",
                LLLL: "YYYYMDddddAhmm",
                l: "YYYY/M/D",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            meridiemParse: /|||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t || "" === t || "" === t ? e : "" === t || "" === t ? e + 12 : e >= 11 ? e : e + 12
            },
            meridiem: function (e, t, n) {
                var i = 100 * e + t;
                return i < 600 ? "" : i < 900 ? "" : i < 1130 ? "" : i < 1230 ? "" : i < 1800 ? "" : ""
            },
            calendar: {
                sameDay: "[]LT", nextDay: "[]LT", nextWeek: function (e) {
                    return e.week() !== this.week() ? "[]dddLT" : "[]dddLT"
                }, lastDay: "[]LT", lastWeek: function (e) {
                    return this.week() !== e.week() ? "[]dddLT" : "[]dddLT"
                }, sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    case"M":
                        return e + "";
                    case"w":
                    case"W":
                        return e + "";
                    default:
                        return e
                }
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                w: "1 ",
                ww: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            },
            week: {dow: 1, doy: 4}
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("zh-hk", {
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMDdddd HH:mm",
                l: "YYYY/M/D",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            meridiemParse: /|||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t || "" === t || "" === t ? e : "" === t ? e >= 11 ? e : e + 12 : "" === t || "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                var i = 100 * e + t;
                return i < 600 ? "" : i < 900 ? "" : i < 1200 ? "" : 1200 === i ? "" : i < 1800 ? "" : ""
            },
            calendar: {
                sameDay: "[]LT",
                nextDay: "[]LT",
                nextWeek: "[]ddddLT",
                lastDay: "[]LT",
                lastWeek: "[]ddddLT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    case"M":
                        return e + "";
                    case"w":
                    case"W":
                        return e + "";
                    default:
                        return e
                }
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("zh-mo", {
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMDdddd HH:mm",
                l: "D/M/YYYY",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            meridiemParse: /|||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t || "" === t || "" === t ? e : "" === t ? e >= 11 ? e : e + 12 : "" === t || "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                var i = 100 * e + t;
                return i < 600 ? "" : i < 900 ? "" : i < 1130 ? "" : i < 1230 ? "" : i < 1800 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[]dddd LT",
                lastDay: "[] LT",
                lastWeek: "[]dddd LT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    case"M":
                        return e + "";
                    case"w":
                    case"W":
                        return e + "";
                    default:
                        return e
                }
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            }
        })
    }(n(0))
}, function (e, t, n) {
    !function (e) {
        "use strict";
//! moment.js locale configuration
        e.defineLocale("zh-tw", {
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMDdddd HH:mm",
                l: "YYYY/M/D",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            meridiemParse: /|||||/,
            meridiemHour: function (e, t) {
                return 12 === e && (e = 0), "" === t || "" === t || "" === t ? e : "" === t ? e >= 11 ? e : e + 12 : "" === t || "" === t ? e + 12 : void 0
            },
            meridiem: function (e, t, n) {
                var i = 100 * e + t;
                return i < 600 ? "" : i < 900 ? "" : i < 1130 ? "" : i < 1230 ? "" : i < 1800 ? "" : ""
            },
            calendar: {
                sameDay: "[] LT",
                nextDay: "[] LT",
                nextWeek: "[]dddd LT",
                lastDay: "[] LT",
                lastWeek: "[]dddd LT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(||)/,
            ordinal: function (e, t) {
                switch (t) {
                    case"d":
                    case"D":
                    case"DDD":
                        return e + "";
                    case"M":
                        return e + "";
                    case"w":
                    case"W":
                        return e + "";
                    default:
                        return e
                }
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                ss: "%d ",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            }
        })
    }(n(0))
}, function (t, n, i) {
    "use strict";
    (function (n) {
        var i, r, o, a, s, l, c, u, d, h, p;
        t.exports = (o = function (e, t) {
            var n;
            if (e === t) return e;
            for (n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e
        }, a = function (e, t) {
            var n, i = Array.prototype.slice.call(arguments, 2), r = [], o = e.length;
            if (Array.prototype.map && e.map === Array.prototype.map) r = Array.prototype.map.call(e, (function (e) {
                var n = i.slice(0);
                return n.splice(0, 0, e), t.apply(this, n)
            })); else for (n = 0; n < o; n++) callback_params = i, callback_params.splice(0, 0, e[n]), r.push(t.apply(this, callback_params));
            return r
        }, s = function (e) {
            var t, n = [];
            for (t = 0; t < e.length; t++) n = n.concat(e[t]);
            return n
        }, l = function (e, t) {
            var n = e[0], i = e[1];
            return t && (n = e[1], i = e[0]), new google.maps.LatLng(n, i)
        }, c = function (e, t) {
            var n;
            for (n = 0; n < e.length; n++) e[n] instanceof google.maps.LatLng || (e[n].length > 0 && "object" == typeof e[n][0] ? e[n] = c(e[n], t) : e[n] = l(e[n], t));
            return e
        }, u = function (e, t) {
            var i = e.replace(".", "");
            return "jQuery" in this && t ? n("." + i, t)[0] : document.getElementsByClassName(i)[0]
        }, d = function (e, t) {
            return e = e.replace("#", ""), "jQuery" in window && t ? n("#" + e, t)[0] : document.getElementById(e)
        }, h = function (e) {
            var t = 0, n = 0;
            if (e.getBoundingClientRect) {
                var i = e.getBoundingClientRect(), r = -(window.scrollX ? window.scrollX : window.pageXOffset),
                    o = -(window.scrollY ? window.scrollY : window.pageYOffset);
                return [i.left - r, i.top - o]
            }
            if (e.offsetParent) do {
                t += e.offsetLeft, n += e.offsetTop
            } while (e = e.offsetParent);
            return [t, n]
        }, (p = function (e) {
            var t = document, n = function (e) {
                if ("object" != typeof window.google || !window.google.maps) return "object" == typeof window.console && window.console.error && console.error("Google Maps API is required. Please register the following JavaScript library https://maps.googleapis.com/maps/api/js."), function () {
                };
                if (!this) return new n(e);
                e.zoom = e.zoom || 15, e.mapType = e.mapType || "roadmap";
                var i, r = function (e, t) {
                        return void 0 === e ? t : e
                    }, a = this,
                    s = ["bounds_changed", "center_changed", "click", "dblclick", "drag", "dragend", "dragstart", "idle", "maptypeid_changed", "projection_changed", "resize", "tilesloaded", "zoom_changed"],
                    l = ["mousemove", "mouseout", "mouseover"],
                    c = ["el", "lat", "lng", "mapType", "width", "height", "markerClusterer", "enableNewStyle"],
                    p = e.el || e.div, f = e.markerClusterer, m = google.maps.MapTypeId[e.mapType.toUpperCase()],
                    _ = new google.maps.LatLng(e.lat, e.lng), g = r(e.zoomControl, !0),
                    y = e.zoomControlOpt || {style: "DEFAULT", position: "TOP_LEFT"}, v = y.style || "DEFAULT",
                    x = y.position || "TOP_LEFT", b = r(e.panControl, !0), w = r(e.mapTypeControl, !0),
                    M = r(e.scaleControl, !0), T = r(e.streetViewControl, !0), k = r(k, !0), S = {},
                    D = {zoom: this.zoom, center: _, mapTypeId: m}, L = {
                        panControl: b,
                        zoomControl: g,
                        zoomControlOptions: {
                            style: google.maps.ZoomControlStyle[v],
                            position: google.maps.ControlPosition[x]
                        },
                        mapTypeControl: w,
                        scaleControl: M,
                        streetViewControl: T,
                        overviewMapControl: k
                    };
                if ("string" == typeof e.el || "string" == typeof e.div ? p.indexOf("#") > -1 ? this.el = d(p, e.context) : this.el = u.apply(this, [p, e.context]) : this.el = p, void 0 === this.el || null === this.el) throw"No element defined.";
                for (window.context_menu = window.context_menu || {}, window.context_menu[a.el.id] = {}, this.controls = [], this.overlays = [], this.layers = [], this.singleLayers = {}, this.markers = [], this.polylines = [], this.routes = [], this.polygons = [], this.infoWindow = null, this.overlay_el = null, this.zoom = e.zoom, this.registered_events = {}, this.el.style.width = e.width || this.el.scrollWidth || this.el.offsetWidth, this.el.style.height = e.height || this.el.scrollHeight || this.el.offsetHeight, google.maps.visualRefresh = e.enableNewStyle, i = 0; i < c.length; i++) delete e[c[i]];
                for (1 != e.disableDefaultUI && (D = o(D, L)), S = o(D, e), i = 0; i < s.length; i++) delete S[s[i]];
                for (i = 0; i < l.length; i++) delete S[l[i]];
                this.map = new google.maps.Map(this.el, S), f && (this.markerClusterer = f.apply(this, [this.map]));
                var E = function (e, t) {
                    var n = "", i = window.context_menu[a.el.id][e];
                    for (var r in i) if (i.hasOwnProperty(r)) {
                        var o = i[r];
                        n += '<li><a id="' + e + "_" + r + '" href="#">' + o.title + "</a></li>"
                    }
                    if (d("gmaps_context_menu")) {
                        var s = d("gmaps_context_menu");
                        s.innerHTML = n;
                        var l = s.getElementsByTagName("a"), c = l.length;
                        for (r = 0; r < c; r++) {
                            var u = l[r];
                            google.maps.event.clearListeners(u, "click"), google.maps.event.addDomListenerOnce(u, "click", (function (n) {
                                n.preventDefault(), i[this.id.replace(e + "_", "")].action.apply(a, [t]), a.hideContextMenu()
                            }), !1)
                        }
                        var p = h.apply(this, [a.el]), f = p[0] + t.pixel.x - 15, m = p[1] + t.pixel.y - 15;
                        s.style.left = f + "px", s.style.top = m + "px"
                    }
                };
                this.buildContextMenu = function (e, t) {
                    if ("marker" === e) {
                        t.pixel = {};
                        var n = new google.maps.OverlayView;
                        n.setMap(a.map), n.draw = function () {
                            var i = n.getProjection(), r = t.marker.getPosition();
                            t.pixel = i.fromLatLngToContainerPixel(r), E(e, t)
                        }
                    } else E(e, t);
                    var i = d("gmaps_context_menu");
                    setTimeout((function () {
                        i.style.display = "block"
                    }), 0)
                }, this.setContextMenu = function (e) {
                    window.context_menu[a.el.id][e.control] = {};
                    var n, i = t.createElement("ul");
                    for (n in e.options) if (e.options.hasOwnProperty(n)) {
                        var r = e.options[n];
                        window.context_menu[a.el.id][e.control][r.name] = {title: r.title, action: r.action}
                    }
                    i.id = "gmaps_context_menu", i.style.display = "none", i.style.position = "absolute", i.style.minWidth = "100px", i.style.background = "white", i.style.listStyle = "none", i.style.padding = "8px", i.style.boxShadow = "2px 2px 6px #ccc", d("gmaps_context_menu") || t.body.appendChild(i);
                    var o = d("gmaps_context_menu");
                    google.maps.event.addDomListener(o, "mouseout", (function (e) {
                        e.relatedTarget && this.contains(e.relatedTarget) || window.setTimeout((function () {
                            o.style.display = "none"
                        }), 400)
                    }), !1)
                }, this.hideContextMenu = function () {
                    var e = d("gmaps_context_menu");
                    e && (e.style.display = "none")
                };
                var C = function (t, n) {
                    google.maps.event.addListener(t, n, (function (t) {
                        null == t && (t = this), e[n].apply(this, [t]), a.hideContextMenu()
                    }))
                };
                google.maps.event.addListener(this.map, "zoom_changed", this.hideContextMenu);
                for (var A = 0; A < s.length; A++) (I = s[A]) in e && C(this.map, I);
                for (A = 0; A < l.length; A++) {
                    var I;
                    (I = l[A]) in e && C(this.map, I)
                }
                google.maps.event.addListener(this.map, "rightclick", (function (t) {
                    e.rightclick && e.rightclick.apply(this, [t]), null != window.context_menu[a.el.id].map && a.buildContextMenu("map", t)
                })), this.refresh = function () {
                    google.maps.event.trigger(this.map, "resize")
                }, this.fitZoom = function () {
                    var e, t = [], n = this.markers.length;
                    for (e = 0; e < n; e++) "boolean" == typeof this.markers[e].visible && this.markers[e].visible && t.push(this.markers[e].getPosition());
                    this.fitLatLngBounds(t)
                }, this.fitLatLngBounds = function (e) {
                    var t, n = e.length, i = new google.maps.LatLngBounds;
                    for (t = 0; t < n; t++) i.extend(e[t]);
                    this.map.fitBounds(i)
                }, this.setCenter = function (e, t, n) {
                    this.map.panTo(new google.maps.LatLng(e, t)), n && n()
                }, this.getElement = function () {
                    return this.el
                }, this.zoomIn = function (e) {
                    e = e || 1, this.zoom = this.map.getZoom() + e, this.map.setZoom(this.zoom)
                }, this.zoomOut = function (e) {
                    e = e || 1, this.zoom = this.map.getZoom() - e, this.map.setZoom(this.zoom)
                };
                var P, R = [];
                for (P in this.map) "function" != typeof this.map[P] || this[P] || R.push(P);
                for (i = 0; i < R.length; i++) !function (e, t, n) {
                    e[n] = function () {
                        return t[n].apply(t, arguments)
                    }
                }(this, this.map, R[i])
            };
            return n
        }()).prototype.createControl = function (e) {
            var t = document.createElement("div");
            for (var n in t.style.cursor = "pointer", !0 !== e.disableDefaultStyles && (t.style.fontFamily = "Roboto, Arial, sans-serif", t.style.fontSize = "11px", t.style.boxShadow = "rgba(0, 0, 0, 0.298039) 0px 1px 4px -1px"), e.style) t.style[n] = e.style[n];
            for (var i in e.id && (t.id = e.id), e.title && (t.title = e.title), e.classes && (t.className = e.classes), e.content && ("string" == typeof e.content ? t.innerHTML = e.content : e.content instanceof HTMLElement && t.appendChild(e.content)), e.position && (t.position = google.maps.ControlPosition[e.position.toUpperCase()]), e.events) !function (t, n) {
                google.maps.event.addDomListener(t, n, (function () {
                    e.events[n].apply(this, [this])
                }))
            }(t, i);
            return t.index = 1, t
        }, p.prototype.addControl = function (e) {
            var t = this.createControl(e);
            return this.controls.push(t), this.map.controls[t.position].push(t), t
        }, p.prototype.removeControl = function (e) {
            var t, n = null;
            for (t = 0; t < this.controls.length; t++) this.controls[t] == e && (n = this.controls[t].position, this.controls.splice(t, 1));
            if (n) for (t = 0; t < this.map.controls.length; t++) {
                var i = this.map.controls[e.position];
                if (i.getAt(t) == e) {
                    i.removeAt(t);
                    break
                }
            }
            return e
        }, p.prototype.createMarker = function (e) {
            if (null == e.lat && null == e.lng && null == e.position) throw"No latitude or longitude defined.";
            var t = this, n = e.details, i = e.fences, r = e.outside,
                a = {position: new google.maps.LatLng(e.lat, e.lng), map: null}, s = o(a, e);
            delete s.lat, delete s.lng, delete s.fences, delete s.outside;
            var l = new google.maps.Marker(s);
            if (l.fences = i, e.infoWindow) {
                l.infoWindow = new google.maps.InfoWindow(e.infoWindow);
                for (var c = ["closeclick", "content_changed", "domready", "position_changed", "zindex_changed"], u = 0; u < c.length; u++) !function (t, n) {
                    e.infoWindow[n] && google.maps.event.addListener(t, n, (function (t) {
                        e.infoWindow[n].apply(this, [t])
                    }))
                }(l.infoWindow, c[u])
            }
            var d = ["animation_changed", "clickable_changed", "cursor_changed", "draggable_changed", "flat_changed", "icon_changed", "position_changed", "shadow_changed", "shape_changed", "title_changed", "visible_changed", "zindex_changed"],
                h = ["dblclick", "drag", "dragend", "dragstart", "mousedown", "mouseout", "mouseover", "mouseup"];
            for (u = 0; u < d.length; u++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function () {
                    e[n].apply(this, [this])
                }))
            }(l, d[u]);
            for (u = 0; u < h.length; u++) !function (t, n, i) {
                e[i] && google.maps.event.addListener(n, i, (function (n) {
                    n.pixel || (n.pixel = t.getProjection().fromLatLngToPoint(n.latLng)), e[i].apply(this, [n])
                }))
            }(this.map, l, h[u]);
            return google.maps.event.addListener(l, "click", (function () {
                this.details = n, e.click && e.click.apply(this, [this]), l.infoWindow && (t.hideInfoWindows(), l.infoWindow.open(t.map, l))
            })), google.maps.event.addListener(l, "rightclick", (function (n) {
                n.marker = this, e.rightclick && e.rightclick.apply(this, [n]), null != window.context_menu[t.el.id].marker && t.buildContextMenu("marker", n)
            })), l.fences && google.maps.event.addListener(l, "dragend", (function () {
                t.checkMarkerGeofence(l, (function (e, t) {
                    r(e, t)
                }))
            })), l
        }, p.prototype.addMarker = function (e) {
            var t;
            if (e.hasOwnProperty("gm_accessors_")) t = e; else {
                if (!(e.hasOwnProperty("lat") && e.hasOwnProperty("lng") || e.position)) throw"No latitude or longitude defined.";
                t = this.createMarker(e)
            }
            return t.setMap(this.map), this.markerClusterer && this.markerClusterer.addMarker(t), this.markers.push(t), p.fire("marker_added", t, this), t
        }, p.prototype.addMarkers = function (e) {
            for (var t, n = 0; t = e[n]; n++) this.addMarker(t);
            return this.markers
        }, p.prototype.hideInfoWindows = function () {
            for (var e, t = 0; e = this.markers[t]; t++) e.infoWindow && e.infoWindow.close()
        }, p.prototype.removeMarker = function (e) {
            for (var t = 0; t < this.markers.length; t++) if (this.markers[t] === e) {
                this.markers[t].setMap(null), this.markers.splice(t, 1), this.markerClusterer && this.markerClusterer.removeMarker(e), p.fire("marker_removed", e, this);
                break
            }
            return e
        }, p.prototype.removeMarkers = function (e) {
            var t = [];
            if (void 0 === e) {
                for (var n = 0; n < this.markers.length; n++) (r = this.markers[n]).setMap(null), p.fire("marker_removed", r, this);
                this.markerClusterer && this.markerClusterer.clearMarkers && this.markerClusterer.clearMarkers(), this.markers = t
            } else {
                for (n = 0; n < e.length; n++) {
                    var i = this.markers.indexOf(e[n]);
                    i > -1 && ((r = this.markers[i]).setMap(null), this.markerClusterer && this.markerClusterer.removeMarker(r), p.fire("marker_removed", r, this))
                }
                for (n = 0; n < this.markers.length; n++) {
                    var r;
                    null != (r = this.markers[n]).getMap() && t.push(r)
                }
                this.markers = t
            }
        }, p.prototype.drawOverlay = function (e) {
            var t = new google.maps.OverlayView, n = !0;
            return t.setMap(this.map), null != e.auto_show && (n = e.auto_show), t.onAdd = function () {
                var n = document.createElement("div");
                n.style.borderStyle = "none", n.style.borderWidth = "0px", n.style.position = "absolute", n.style.zIndex = 100, n.innerHTML = e.content, t.el = n, e.layer || (e.layer = "overlayLayer");
                var i, r, o = this.getPanes(), a = ["contextmenu", "DOMMouseScroll", "dblclick", "mousedown"];
                o[e.layer].appendChild(n);
                for (var s = 0; s < a.length; s++) i = n, r = a[s], google.maps.event.addDomListener(i, r, (function (e) {
                    -1 != navigator.userAgent.toLowerCase().indexOf("msie") && document.all ? (e.cancelBubble = !0, e.returnValue = !1) : e.stopPropagation()
                }));
                e.click && (o.overlayMouseTarget.appendChild(t.el), google.maps.event.addDomListener(t.el, "click", (function () {
                    e.click.apply(t, [t])
                }))), google.maps.event.trigger(this, "ready")
            }, t.draw = function () {
                var i = this.getProjection().fromLatLngToDivPixel(new google.maps.LatLng(e.lat, e.lng));
                e.horizontalOffset = e.horizontalOffset || 0, e.verticalOffset = e.verticalOffset || 0;
                var r = t.el, o = r.children[0], a = o.clientHeight, s = o.clientWidth;
                switch (e.verticalAlign) {
                    case"top":
                        r.style.top = i.y - a + e.verticalOffset + "px";
                        break;
                    default:
                    case"middle":
                        r.style.top = i.y - a / 2 + e.verticalOffset + "px";
                        break;
                    case"bottom":
                        r.style.top = i.y + e.verticalOffset + "px"
                }
                switch (e.horizontalAlign) {
                    case"left":
                        r.style.left = i.x - s + e.horizontalOffset + "px";
                        break;
                    default:
                    case"center":
                        r.style.left = i.x - s / 2 + e.horizontalOffset + "px";
                        break;
                    case"right":
                        r.style.left = i.x + e.horizontalOffset + "px"
                }
                r.style.display = n ? "block" : "none", n || e.show.apply(this, [r])
            }, t.onRemove = function () {
                var n = t.el;
                e.remove ? e.remove.apply(this, [n]) : (t.el.parentNode.removeChild(t.el), t.el = null)
            }, this.overlays.push(t), t
        }, p.prototype.removeOverlay = function (e) {
            for (var t = 0; t < this.overlays.length; t++) if (this.overlays[t] === e) {
                this.overlays[t].setMap(null), this.overlays.splice(t, 1);
                break
            }
        }, p.prototype.removeOverlays = function () {
            for (var e, t = 0; e = this.overlays[t]; t++) e.setMap(null);
            this.overlays = []
        }, p.prototype.drawPolyline = function (e) {
            var t = [], n = e.path;
            if (n.length) if (void 0 === n[0][0]) t = n; else for (var i, r = 0; i = n[r]; r++) t.push(new google.maps.LatLng(i[0], i[1]));
            var o = {
                map: this.map,
                path: t,
                strokeColor: e.strokeColor,
                strokeOpacity: e.strokeOpacity,
                strokeWeight: e.strokeWeight,
                geodesic: e.geodesic,
                clickable: !0,
                editable: !1,
                visible: !0
            };
            e.hasOwnProperty("clickable") && (o.clickable = e.clickable), e.hasOwnProperty("editable") && (o.editable = e.editable), e.hasOwnProperty("icons") && (o.icons = e.icons), e.hasOwnProperty("zIndex") && (o.zIndex = e.zIndex);
            for (var a = new google.maps.Polyline(o), s = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "rightclick"], l = 0; l < s.length; l++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function (t) {
                    e[n].apply(this, [t])
                }))
            }(a, s[l]);
            return this.polylines.push(a), p.fire("polyline_added", a, this), a
        }, p.prototype.removePolyline = function (e) {
            for (var t = 0; t < this.polylines.length; t++) if (this.polylines[t] === e) {
                this.polylines[t].setMap(null), this.polylines.splice(t, 1), p.fire("polyline_removed", e, this);
                break
            }
        }, p.prototype.removePolylines = function () {
            for (var e, t = 0; e = this.polylines[t]; t++) e.setMap(null);
            this.polylines = []
        }, p.prototype.drawCircle = function (e) {
            delete (e = o({map: this.map, center: new google.maps.LatLng(e.lat, e.lng)}, e)).lat, delete e.lng;
            for (var t = new google.maps.Circle(e), n = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "rightclick"], i = 0; i < n.length; i++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function (t) {
                    e[n].apply(this, [t])
                }))
            }(t, n[i]);
            return this.polygons.push(t), t
        }, p.prototype.drawRectangle = function (e) {
            e = o({map: this.map}, e);
            var t = new google.maps.LatLngBounds(new google.maps.LatLng(e.bounds[0][0], e.bounds[0][1]), new google.maps.LatLng(e.bounds[1][0], e.bounds[1][1]));
            e.bounds = t;
            for (var n = new google.maps.Rectangle(e), i = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "rightclick"], r = 0; r < i.length; r++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function (t) {
                    e[n].apply(this, [t])
                }))
            }(n, i[r]);
            return this.polygons.push(n), n
        }, p.prototype.drawPolygon = function (e) {
            var t = !1;
            e.hasOwnProperty("useGeoJSON") && (t = e.useGeoJSON), delete e.useGeoJSON, e = o({map: this.map}, e), 0 == t && (e.paths = [e.paths.slice(0)]), e.paths.length > 0 && e.paths[0].length > 0 && (e.paths = s(a(e.paths, c, t)));
            for (var n = new google.maps.Polygon(e), i = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "rightclick"], r = 0; r < i.length; r++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function (t) {
                    e[n].apply(this, [t])
                }))
            }(n, i[r]);
            return this.polygons.push(n), p.fire("polygon_added", n, this), n
        }, p.prototype.removePolygon = function (e) {
            for (var t = 0; t < this.polygons.length; t++) if (this.polygons[t] === e) {
                this.polygons[t].setMap(null), this.polygons.splice(t, 1), p.fire("polygon_removed", e, this);
                break
            }
        }, p.prototype.removePolygons = function () {
            for (var e, t = 0; e = this.polygons[t]; t++) e.setMap(null);
            this.polygons = []
        }, p.prototype.getFromFusionTables = function (e) {
            var t = e.events;
            delete e.events;
            var n = e, i = new google.maps.FusionTablesLayer(n);
            for (var r in t) !function (e, n) {
                google.maps.event.addListener(e, n, (function (e) {
                    t[n].apply(this, [e])
                }))
            }(i, r);
            return this.layers.push(i), i
        }, p.prototype.loadFromFusionTables = function (e) {
            var t = this.getFromFusionTables(e);
            return t.setMap(this.map), t
        }, p.prototype.getFromKML = function (e) {
            var t = e.url, n = e.events;
            delete e.url, delete e.events;
            var i = e, r = new google.maps.KmlLayer(t, i);
            for (var o in n) !function (e, t) {
                google.maps.event.addListener(e, t, (function (e) {
                    n[t].apply(this, [e])
                }))
            }(r, o);
            return this.layers.push(r), r
        }, p.prototype.loadFromKML = function (e) {
            var t = this.getFromKML(e);
            return t.setMap(this.map), t
        }, p.prototype.addLayer = function (e, t) {
            var n;
            switch (t = t || {}, e) {
                case"weather":
                    this.singleLayers.weather = n = new google.maps.weather.WeatherLayer;
                    break;
                case"clouds":
                    this.singleLayers.clouds = n = new google.maps.weather.CloudLayer;
                    break;
                case"traffic":
                    this.singleLayers.traffic = n = new google.maps.TrafficLayer;
                    break;
                case"transit":
                    this.singleLayers.transit = n = new google.maps.TransitLayer;
                    break;
                case"bicycling":
                    this.singleLayers.bicycling = n = new google.maps.BicyclingLayer;
                    break;
                case"panoramio":
                    this.singleLayers.panoramio = n = new google.maps.panoramio.PanoramioLayer, n.setTag(t.filter), delete t.filter, t.click && google.maps.event.addListener(n, "click", (function (e) {
                        t.click(e), delete t.click
                    }));
                    break;
                case"places":
                    if (this.singleLayers.places = n = new google.maps.places.PlacesService(this.map), t.search || t.nearbySearch || t.radarSearch) {
                        var i = {
                            bounds: t.bounds || null,
                            keyword: t.keyword || null,
                            location: t.location || null,
                            name: t.name || null,
                            radius: t.radius || null,
                            rankBy: t.rankBy || null,
                            types: t.types || null
                        };
                        t.radarSearch && n.radarSearch(i, t.radarSearch), t.search && n.search(i, t.search), t.nearbySearch && n.nearbySearch(i, t.nearbySearch)
                    }
                    if (t.textSearch) {
                        var r = {
                            bounds: t.bounds || null,
                            location: t.location || null,
                            query: t.query || null,
                            radius: t.radius || null
                        };
                        n.textSearch(r, t.textSearch)
                    }
            }
            if (void 0 !== n) return "function" == typeof n.setOptions && n.setOptions(t), "function" == typeof n.setMap && n.setMap(this.map), n
        }, p.prototype.removeLayer = function (e) {
            if ("string" == typeof e && void 0 !== this.singleLayers[e]) this.singleLayers[e].setMap(null), delete this.singleLayers[e]; else for (var t = 0; t < this.layers.length; t++) if (this.layers[t] === e) {
                this.layers[t].setMap(null), this.layers.splice(t, 1);
                break
            }
        }, p.prototype.getRoutes = function (e) {
            switch (e.travelMode) {
                case"bicycling":
                    i = google.maps.TravelMode.BICYCLING;
                    break;
                case"transit":
                    i = google.maps.TravelMode.TRANSIT;
                    break;
                case"driving":
                    i = google.maps.TravelMode.DRIVING;
                    break;
                default:
                    i = google.maps.TravelMode.WALKING
            }
            r = "imperial" === e.unitSystem ? google.maps.UnitSystem.IMPERIAL : google.maps.UnitSystem.METRIC;
            var t = o({avoidHighways: !1, avoidTolls: !1, optimizeWaypoints: !1, waypoints: []}, e);
            t.origin = /string/.test(typeof e.origin) ? e.origin : new google.maps.LatLng(e.origin[0], e.origin[1]), t.destination = /string/.test(typeof e.destination) ? e.destination : new google.maps.LatLng(e.destination[0], e.destination[1]), t.travelMode = i, t.unitSystem = r, delete t.callback, delete t.error;
            var n = [];
            (new google.maps.DirectionsService).route(t, (function (t, i) {
                if (i === google.maps.DirectionsStatus.OK) {
                    for (var r in t.routes) t.routes.hasOwnProperty(r) && n.push(t.routes[r]);
                    e.callback && e.callback(n, t, i)
                } else e.error && e.error(t, i)
            }))
        }, p.prototype.removeRoutes = function () {
            this.routes.length = 0
        }, p.prototype.getElevations = function (e) {
            (e = o({
                locations: [],
                path: !1,
                samples: 256
            }, e)).locations.length > 0 && e.locations[0].length > 0 && (e.locations = s(a([e.locations], c, !1)));
            var t = e.callback;
            delete e.callback;
            var n = new google.maps.ElevationService;
            if (e.path) {
                var i = {path: e.locations, samples: e.samples};
                n.getElevationAlongPath(i, (function (e, n) {
                    t && "function" == typeof t && t(e, n)
                }))
            } else delete e.path, delete e.samples, n.getElevationForLocations(e, (function (e, n) {
                t && "function" == typeof t && t(e, n)
            }))
        }, p.prototype.cleanRoute = p.prototype.removePolylines, p.prototype.renderRoute = function (e, t) {
            var n, i = "string" == typeof t.panel ? document.getElementById(t.panel.replace("#", "")) : t.panel;
            t.panel = i, t = o({map: this.map}, t), n = new google.maps.DirectionsRenderer(t), this.getRoutes({
                origin: e.origin,
                destination: e.destination,
                travelMode: e.travelMode,
                waypoints: e.waypoints,
                unitSystem: e.unitSystem,
                error: e.error,
                avoidHighways: e.avoidHighways,
                avoidTolls: e.avoidTolls,
                optimizeWaypoints: e.optimizeWaypoints,
                callback: function (e, t, i) {
                    i === google.maps.DirectionsStatus.OK && n.setDirections(t)
                }
            })
        }, p.prototype.drawRoute = function (e) {
            var t = this;
            this.getRoutes({
                origin: e.origin,
                destination: e.destination,
                travelMode: e.travelMode,
                waypoints: e.waypoints,
                unitSystem: e.unitSystem,
                error: e.error,
                avoidHighways: e.avoidHighways,
                avoidTolls: e.avoidTolls,
                optimizeWaypoints: e.optimizeWaypoints,
                callback: function (n) {
                    if (n.length > 0) {
                        var i = {
                            path: n[n.length - 1].overview_path,
                            strokeColor: e.strokeColor,
                            strokeOpacity: e.strokeOpacity,
                            strokeWeight: e.strokeWeight
                        };
                        e.hasOwnProperty("icons") && (i.icons = e.icons), t.drawPolyline(i), e.callback && e.callback(n[n.length - 1])
                    }
                }
            })
        }, p.prototype.travelRoute = function (e) {
            if (e.origin && e.destination) this.getRoutes({
                origin: e.origin,
                destination: e.destination,
                travelMode: e.travelMode,
                waypoints: e.waypoints,
                unitSystem: e.unitSystem,
                error: e.error,
                callback: function (t) {
                    if (t.length > 0 && e.start && e.start(t[t.length - 1]), t.length > 0 && e.step) {
                        var n = t[t.length - 1];
                        if (n.legs.length > 0) for (var i, r = n.legs[0].steps, o = 0; i = r[o]; o++) i.step_number = o, e.step(i, n.legs[0].steps.length - 1)
                    }
                    t.length > 0 && e.end && e.end(t[t.length - 1])
                }
            }); else if (e.route && e.route.legs.length > 0) for (var t, n = e.route.legs[0].steps, i = 0; t = n[i]; i++) t.step_number = i, e.step(t)
        }, p.prototype.drawSteppedRoute = function (e) {
            var t = this;
            if (e.origin && e.destination) this.getRoutes({
                origin: e.origin,
                destination: e.destination,
                travelMode: e.travelMode,
                waypoints: e.waypoints,
                error: e.error,
                callback: function (n) {
                    if (n.length > 0 && e.start && e.start(n[n.length - 1]), n.length > 0 && e.step) {
                        var i = n[n.length - 1];
                        if (i.legs.length > 0) for (var r, o = i.legs[0].steps, a = 0; r = o[a]; a++) {
                            r.step_number = a;
                            var s = {
                                path: r.path,
                                strokeColor: e.strokeColor,
                                strokeOpacity: e.strokeOpacity,
                                strokeWeight: e.strokeWeight
                            };
                            e.hasOwnProperty("icons") && (s.icons = e.icons), t.drawPolyline(s), e.step(r, i.legs[0].steps.length - 1)
                        }
                    }
                    n.length > 0 && e.end && e.end(n[n.length - 1])
                }
            }); else if (e.route && e.route.legs.length > 0) for (var n, i = e.route.legs[0].steps, r = 0; n = i[r]; r++) {
                n.step_number = r;
                var o = {
                    path: n.path,
                    strokeColor: e.strokeColor,
                    strokeOpacity: e.strokeOpacity,
                    strokeWeight: e.strokeWeight
                };
                e.hasOwnProperty("icons") && (o.icons = e.icons), t.drawPolyline(o), e.step(n)
            }
        }, p.Route = function (e) {
            this.origin = e.origin, this.destination = e.destination, this.waypoints = e.waypoints, this.map = e.map, this.route = e.route, this.step_count = 0, this.steps = this.route.legs[0].steps, this.steps_length = this.steps.length;
            var t = {
                path: new google.maps.MVCArray,
                strokeColor: e.strokeColor,
                strokeOpacity: e.strokeOpacity,
                strokeWeight: e.strokeWeight
            };
            e.hasOwnProperty("icons") && (t.icons = e.icons), this.polyline = this.map.drawPolyline(t).getPath()
        }, p.Route.prototype.getRoute = function (t) {
            var n = this;
            this.map.getRoutes({
                origin: this.origin,
                destination: this.destination,
                travelMode: t.travelMode,
                waypoints: this.waypoints || [],
                error: t.error,
                callback: function () {
                    n.route = e[0], t.callback && t.callback.call(n)
                }
            })
        }, p.Route.prototype.back = function () {
            if (this.step_count > 0) {
                this.step_count--;
                var e = this.route.legs[0].steps[this.step_count].path;
                for (var t in e) e.hasOwnProperty(t) && this.polyline.pop()
            }
        }, p.Route.prototype.forward = function () {
            if (this.step_count < this.steps_length) {
                var e = this.route.legs[0].steps[this.step_count].path;
                for (var t in e) e.hasOwnProperty(t) && this.polyline.push(e[t]);
                this.step_count++
            }
        }, p.prototype.checkGeofence = function (e, t, n) {
            return n.containsLatLng(new google.maps.LatLng(e, t))
        }, p.prototype.checkMarkerGeofence = function (e, t) {
            if (e.fences) for (var n, i = 0; n = e.fences[i]; i++) {
                var r = e.getPosition();
                this.checkGeofence(r.lat(), r.lng(), n) || t(e, n)
            }
        }, p.prototype.toImage = function (e) {
            e = e || {};
            var t = {};
            if (t.size = e.size || [this.el.clientWidth, this.el.clientHeight], t.lat = this.getCenter().lat(), t.lng = this.getCenter().lng(), this.markers.length > 0) {
                t.markers = [];
                for (var n = 0; n < this.markers.length; n++) t.markers.push({
                    lat: this.markers[n].getPosition().lat(),
                    lng: this.markers[n].getPosition().lng()
                })
            }
            if (this.polylines.length > 0) {
                var i = this.polylines[0];
                t.polyline = {}, t.polyline.path = google.maps.geometry.encoding.encodePath(i.getPath()), t.polyline.strokeColor = i.strokeColor, t.polyline.strokeOpacity = i.strokeOpacity, t.polyline.strokeWeight = i.strokeWeight
            }
            return p.staticMapURL(t)
        }, p.staticMapURL = function (e) {
            var t, n = [],
                i = ("file:" === location.protocol ? "http:" : location.protocol) + "//maps.googleapis.com/maps/api/staticmap";
            e.url && (i = e.url, delete e.url), i += "?";
            var r = e.markers;
            delete e.markers, !r && e.marker && (r = [e.marker], delete e.marker);
            var o = e.styles;
            delete e.styles;
            var a = e.polyline;
            if (delete e.polyline, e.center) n.push("center=" + e.center), delete e.center; else if (e.address) n.push("center=" + e.address), delete e.address; else if (e.lat) n.push(["center=", e.lat, ",", e.lng].join("")), delete e.lat, delete e.lng; else if (e.visible) {
                var s = encodeURI(e.visible.join("|"));
                n.push("visible=" + s)
            }
            var l = e.size;
            l ? (l.join && (l = l.join("x")), delete e.size) : l = "630x300", n.push("size=" + l), e.zoom || !1 === e.zoom || (e.zoom = 15);
            var c = !e.hasOwnProperty("sensor") || !!e.sensor;
            for (var u in delete e.sensor, n.push("sensor=" + c), e) e.hasOwnProperty(u) && n.push(u + "=" + e[u]);
            if (r) for (var d, h, p = 0; t = r[p]; p++) {
                for (var u in d = [], t.size && "normal" !== t.size ? (d.push("size:" + t.size), delete t.size) : t.icon && (d.push("icon:" + encodeURI(t.icon)), delete t.icon), t.color && (d.push("color:" + t.color.replace("#", "0x")), delete t.color), t.label && (d.push("label:" + t.label[0].toUpperCase()), delete t.label), h = t.address ? t.address : t.lat + "," + t.lng, delete t.address, delete t.lat, delete t.lng, t) t.hasOwnProperty(u) && d.push(u + ":" + t[u]);
                d.length || 0 === p ? (d.push(h), d = d.join("|"), n.push("markers=" + encodeURI(d))) : (d = n.pop() + encodeURI("|" + h), n.push(d))
            }
            if (o) for (p = 0; p < o.length; p++) {
                var f = [];
                o[p].featureType && f.push("feature:" + o[p].featureType.toLowerCase()), o[p].elementType && f.push("element:" + o[p].elementType.toLowerCase());
                for (var m = 0; m < o[p].stylers.length; m++) for (var _ in o[p].stylers[m]) {
                    var g = o[p].stylers[m][_];
                    "hue" != _ && "color" != _ || (g = "0x" + g.substring(1)), f.push(_ + ":" + g)
                }
                var y = f.join("|");
                "" != y && n.push("style=" + y)
            }

            function v(e, t) {
                if ("#" === e[0] && (e = e.replace("#", "0x"), t)) {
                    if (t = parseFloat(t), 0 === (t = Math.min(1, Math.max(t, 0)))) return "0x00000000";
                    1 === (t = (255 * t).toString(16)).length && (t += t), e = e.slice(0, 8) + t
                }
                return e
            }

            if (a) {
                if (t = a, a = [], t.strokeWeight && a.push("weight:" + parseInt(t.strokeWeight, 10)), t.strokeColor) {
                    var x = v(t.strokeColor, t.strokeOpacity);
                    a.push("color:" + x)
                }
                if (t.fillColor) {
                    var b = v(t.fillColor, t.fillOpacity);
                    a.push("fillcolor:" + b)
                }
                var w, M = t.path;
                if (M.join) for (m = 0; w = M[m]; m++) a.push(w.join(",")); else a.push("enc:" + M);
                a = a.join("|"), n.push("path=" + encodeURI(a))
            }
            var T = window.devicePixelRatio || 1;
            return n.push("scale=" + T), i + (n = n.join("&"))
        }, p.prototype.addMapType = function (e, t) {
            if (!t.hasOwnProperty("getTileUrl") || "function" != typeof t.getTileUrl) throw"'getTileUrl' function required.";
            t.tileSize = t.tileSize || new google.maps.Size(256, 256);
            var n = new google.maps.ImageMapType(t);
            this.map.mapTypes.set(e, n)
        }, p.prototype.addOverlayMapType = function (e) {
            if (!e.hasOwnProperty("getTile") || "function" != typeof e.getTile) throw"'getTile' function required.";
            var t = e.index;
            delete e.index, this.map.overlayMapTypes.insertAt(t, e)
        }, p.prototype.removeOverlayMapType = function (e) {
            this.map.overlayMapTypes.removeAt(e)
        }, p.prototype.addStyle = function (e) {
            var t = new google.maps.StyledMapType(e.styles, {name: e.styledMapName});
            this.map.mapTypes.set(e.mapTypeId, t)
        }, p.prototype.setStyle = function (e) {
            this.map.setMapTypeId(e)
        }, p.prototype.createPanorama = function (e) {
            return e.hasOwnProperty("lat") && e.hasOwnProperty("lng") || (e.lat = this.getCenter().lat(), e.lng = this.getCenter().lng()), this.panorama = p.createPanorama(e), this.map.setStreetView(this.panorama), this.panorama
        }, p.createPanorama = function (e) {
            var t = d(e.el, e.context);
            e.position = new google.maps.LatLng(e.lat, e.lng), delete e.el, delete e.context, delete e.lat, delete e.lng;
            for (var n = ["closeclick", "links_changed", "pano_changed", "position_changed", "pov_changed", "resize", "visible_changed"], i = o({visible: !0}, e), r = 0; r < n.length; r++) delete i[n[r]];
            var a = new google.maps.StreetViewPanorama(t, i);
            for (r = 0; r < n.length; r++) !function (t, n) {
                e[n] && google.maps.event.addListener(t, n, (function () {
                    e[n].apply(this)
                }))
            }(a, n[r]);
            return a
        }, p.prototype.on = function (e, t) {
            return p.on(e, this, t)
        }, p.prototype.off = function (e) {
            p.off(e, this)
        }, p.prototype.once = function (e, t) {
            return p.once(e, this, t)
        }, p.custom_events = ["marker_added", "marker_removed", "polyline_added", "polyline_removed", "polygon_added", "polygon_removed", "geolocated", "geolocation_failed"], p.on = function (e, t, n) {
            if (-1 == p.custom_events.indexOf(e)) return t instanceof p && (t = t.map), google.maps.event.addListener(t, e, n);
            var i = {handler: n, eventName: e};
            return t.registered_events[e] = t.registered_events[e] || [], t.registered_events[e].push(i), i
        }, p.off = function (e, t) {
            -1 == p.custom_events.indexOf(e) ? (t instanceof p && (t = t.map), google.maps.event.clearListeners(t, e)) : t.registered_events[e] = []
        }, p.once = function (e, t, n) {
            if (-1 == p.custom_events.indexOf(e)) return t instanceof p && (t = t.map), google.maps.event.addListenerOnce(t, e, n)
        }, p.fire = function (e, t, n) {
            if (-1 == p.custom_events.indexOf(e)) google.maps.event.trigger(t, e, Array.prototype.slice.apply(arguments).slice(2)); else if (e in n.registered_events) for (var i = n.registered_events[e], r = 0; r < i.length; r++) !function (e, t, n) {
                e.apply(t, [n])
            }(i[r].handler, n, t)
        }, p.geolocate = function (e) {
            var t = e.always || e.complete;
            navigator.geolocation ? navigator.geolocation.getCurrentPosition((function (n) {
                e.success(n), t && t()
            }), (function (n) {
                e.error(n), t && t()
            }), e.options) : (e.not_supported(), t && t())
        }, p.geocode = function (e) {
            this.geocoder = new google.maps.Geocoder;
            var t = e.callback;
            e.hasOwnProperty("lat") && e.hasOwnProperty("lng") && (e.latLng = new google.maps.LatLng(e.lat, e.lng)), delete e.lat, delete e.lng, delete e.callback, this.geocoder.geocode(e, (function (e, n) {
                t(e, n)
            }))
        }, "object" == typeof window.google && window.google.maps && (google.maps.Polygon.prototype.getBounds || (google.maps.Polygon.prototype.getBounds = function (e) {
            for (var t, n = new google.maps.LatLngBounds, i = this.getPaths(), r = 0; r < i.getLength(); r++) {
                t = i.getAt(r);
                for (var o = 0; o < t.getLength(); o++) n.extend(t.getAt(o))
            }
            return n
        }), google.maps.Polygon.prototype.containsLatLng || (google.maps.Polygon.prototype.containsLatLng = function (e) {
            var t = this.getBounds();
            if (null !== t && !t.contains(e)) return !1;
            for (var n = !1, i = this.getPaths().getLength(), r = 0; r < i; r++) for (var o = this.getPaths().getAt(r), a = o.getLength(), s = a - 1, l = 0; l < a; l++) {
                var c = o.getAt(l), u = o.getAt(s);
                (c.lng() < e.lng() && u.lng() >= e.lng() || u.lng() < e.lng() && c.lng() >= e.lng()) && c.lat() + (e.lng() - c.lng()) / (u.lng() - c.lng()) * (u.lat() - c.lat()) < e.lat() && (n = !n), s = l
            }
            return n
        }), google.maps.Circle.prototype.containsLatLng || (google.maps.Circle.prototype.containsLatLng = function (e) {
            return !google.maps.geometry || google.maps.geometry.spherical.computeDistanceBetween(this.getCenter(), e) <= this.getRadius()
        }), google.maps.Rectangle.prototype.containsLatLng = function (e) {
            return this.getBounds().contains(e)
        }, google.maps.LatLngBounds.prototype.containsLatLng = function (e) {
            return this.contains(e)
        }, google.maps.Marker.prototype.setFences = function (e) {
            this.fences = e
        }, google.maps.Marker.prototype.addFence = function (e) {
            this.fences.push(e)
        }, google.maps.Marker.prototype.getId = function () {
            return this.__gm_id
        }), Array.prototype.indexOf || (Array.prototype.indexOf = function (e) {
            if (null == this) throw new TypeError;
            var t = Object(this), n = t.length >>> 0;
            if (0 === n) return -1;
            var i = 0;
            if (arguments.length > 1 && ((i = Number(arguments[1])) != i ? i = 0 : 0 != i && i != 1 / 0 && i != -1 / 0 && (i = (i > 0 || -1) * Math.floor(Math.abs(i)))), i >= n) return -1;
            for (var r = i >= 0 ? i : Math.max(n - Math.abs(i), 0); r < n; r++) if (r in t && t[r] === e) return r;
            return -1
        }), p)
    }).call(this, i(1))
}, function (e, t, n) {
    n(153), n(144), n(145), n(147), n(154), n(148), e.exports = n(149)
}, function (e, t, n) {
    /*!
* metismenu https://github.com/onokumus/metismenu#readme
* A collapsible jQuery menu plugin
* @version 3.0.7
* @author Osman Nuri Okumus <onokumus@gmail.com> (https://github.com/onokumus)
* @license: MIT
*/
    e.exports = function (e) {
        "use strict";
        var t = function (e) {
            return e && "object" == typeof e && "default" in e ? e : {default: e}
        }(e);
        const n = (e => {
                const t = "transitionend", n = {
                    TRANSITION_END: "mmTransitionEnd", triggerTransitionEnd(n) {
                        e(n).trigger(t)
                    }, supportsTransitionEnd: () => Boolean(t)
                };
                return e.fn.mmEmulateTransitionEnd = function (t) {
                    let i = !1;
                    return e(this).one(n.TRANSITION_END, () => {
                        i = !0
                    }), setTimeout(() => {
                        i || n.triggerTransitionEnd(this)
                    }, t), this
                }, e.event.special[n.TRANSITION_END] = {
                    bindType: t, delegateType: t, handle(t) {
                        if (e(t.target).is(this)) return t.handleObj.handler.apply(this, arguments)
                    }
                }, n
            })(t.default), i = "metisMenu", r = "metisMenu", o = t.default.fn[i],
            a = {toggle: !0, preventDefault: !0, triggerElement: "a", parentTrigger: "li", subMenu: "ul"},
            s = "show.metisMenu", l = "shown.metisMenu", c = "hide.metisMenu", u = "hidden.metisMenu",
            d = "click.metisMenu.data-api", h = "mm-active", p = "mm-show", f = "mm-collapse", m = "mm-collapsing";

        class _ {
            constructor(e, t) {
                this.element = e, this.config = {...a, ...t}, this.transitioning = null, this.init()
            }

            init() {
                const e = this, n = this.config, i = t.default(this.element);
                i.addClass("metismenu"), i.find(`${n.parentTrigger}.${h}`).children(n.triggerElement).attr("aria-expanded", "true"), i.find(`${n.parentTrigger}.${h}`).parents(n.parentTrigger).addClass(h), i.find(`${n.parentTrigger}.${h}`).parents(n.parentTrigger).children(n.triggerElement).attr("aria-expanded", "true"), i.find(`${n.parentTrigger}.${h}`).has(n.subMenu).children(n.subMenu).addClass(`${f} ${p}`), i.find(n.parentTrigger).not("." + h).has(n.subMenu).children(n.subMenu).addClass(f), i.find(n.parentTrigger).children(n.triggerElement).on(d, (function (i) {
                    const r = t.default(this);
                    if ("true" === r.attr("aria-disabled")) return;
                    n.preventDefault && "#" === r.attr("href") && i.preventDefault();
                    const o = r.parent(n.parentTrigger), a = o.siblings(n.parentTrigger),
                        s = a.children(n.triggerElement);
                    o.hasClass(h) ? (r.attr("aria-expanded", "false"), e.removeActive(o)) : (r.attr("aria-expanded", "true"), e.setActive(o), n.toggle && (e.removeActive(a), s.attr("aria-expanded", "false"))), n.onTransitionStart && n.onTransitionStart(i)
                }))
            }

            setActive(e) {
                t.default(e).addClass(h);
                const n = t.default(e).children(this.config.subMenu);
                n.length > 0 && !n.hasClass(p) && this.show(n)
            }

            removeActive(e) {
                t.default(e).removeClass(h);
                const n = t.default(e).children(`${this.config.subMenu}.${p}`);
                n.length > 0 && this.hide(n)
            }

            show(e) {
                if (this.transitioning || t.default(e).hasClass(m)) return;
                const i = t.default(e), r = t.default.Event(s);
                if (i.trigger(r), !r.isDefaultPrevented()) {
                    if (i.parent(this.config.parentTrigger).addClass(h), this.config.toggle) {
                        const e = i.parent(this.config.parentTrigger).siblings().children(`${this.config.subMenu}.${p}`);
                        this.hide(e)
                    }
                    i.removeClass(f).addClass(m).height(0), this.setTransitioning(!0), i.height(e[0].scrollHeight).one(n.TRANSITION_END, () => {
                        this.config && this.element && (i.removeClass(m).addClass(`${f} ${p}`).height(""), this.setTransitioning(!1), i.trigger(l))
                    }).mmEmulateTransitionEnd(350)
                }
            }

            hide(e) {
                if (this.transitioning || !t.default(e).hasClass(p)) return;
                const i = t.default(e), r = t.default.Event(c);
                if (i.trigger(r), r.isDefaultPrevented()) return;
                i.parent(this.config.parentTrigger).removeClass(h), i.height(i.height())[0].offsetHeight, i.addClass(m).removeClass(f).removeClass(p), this.setTransitioning(!0);
                const o = () => {
                    this.config && this.element && (this.transitioning && this.config.onTransitionEnd && this.config.onTransitionEnd(), this.setTransitioning(!1), i.trigger(u), i.removeClass(m).addClass(f))
                };
                0 === i.height() || "none" === i.css("display") ? o() : i.height(0).one(n.TRANSITION_END, o).mmEmulateTransitionEnd(350)
            }

            setTransitioning(e) {
                this.transitioning = e
            }

            dispose() {
                t.default.removeData(this.element, r), t.default(this.element).find(this.config.parentTrigger).children(this.config.triggerElement).off(d), this.transitioning = null, this.config = null, this.element = null
            }

            static jQueryInterface(e) {
                return this.each((function () {
                    const n = t.default(this);
                    let i = n.data(r);
                    const o = {...a, ...n.data(), ..."object" == typeof e && e ? e : {}};
                    if (i || (i = new _(this, o), n.data(r, i)), "string" == typeof e) {
                        if (void 0 === i[e]) throw new Error(`No method named "${e}"`);
                        i[e]()
                    }
                }))
            }
        }

        return t.default.fn[i] = _.jQueryInterface, t.default.fn[i].Constructor = _, t.default.fn[i].noConflict = () => (t.default.fn[i] = o, _.jQueryInterface), _
    }(n(1))
}, function (e, t, n) {
    (function (e) {
        e(document).ready((function () {
            e(".btn-open-options").click((function () {
                e(".ui-theme-settings").toggleClass("settings-open")
            })), e(".close-sidebar-btn").click((function () {
                var t = e(this).attr("data-class");
                e(".app-container").toggleClass(t);
                var n = e(this);
                n.hasClass("is-active") ? n.removeClass("is-active") : n.addClass("is-active")
            })), e(".switch-container-class").on("click", (function () {
                var t = e(this).attr("data-class");
                e(".app-container").toggleClass(t), e(this).parent().find(".switch-container-class").removeClass("active"), e(this).addClass("active")
            })), e(".switch-theme-class").on("click", (function () {
                var t = e(this).attr("data-class");
                "body-tabs-line" == t && (e(".app-container").removeClass("body-tabs-shadow"), e(".app-container").addClass(t)), "body-tabs-shadow" == t && (e(".app-container").removeClass("body-tabs-line"), e(".app-container").addClass(t)), e(this).parent().find(".switch-theme-class").removeClass("active"), e(this).addClass("active")
            })), e(".switch-header-cs-class").on("click", (function () {
                var t = e(this).attr("data-class");
                e(".switch-header-cs-class").removeClass("active"), e(this).addClass("active"), e(".app-header").attr("class", "app-header"), e(".app-header").addClass("header-shadow " + t)
            })), e(".switch-sidebar-cs-class").on("click", (function () {
                var t = e(this).attr("data-class");
                e(".switch-sidebar-cs-class").removeClass("active"), e(this).addClass("active"), e(".app-sidebar").attr("class", "app-sidebar"), e(".app-sidebar").addClass("sidebar-shadow " + t)
            }))
        }))
    }).call(this, n(1))
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        var t = n(2), i = n.n(t);
        e(document).ready((function () {
            e((function () {
                var t, n = -1, r = 0;
                e("#closeButton").click((function () {
                    e(this).is(":checked") ? e("#addBehaviorOnToastCloseClick").prop("disabled", !1) : (e("#addBehaviorOnToastCloseClick").prop("disabled", !0), e("#addBehaviorOnToastCloseClick").prop("checked", !1))
                })), e("#showtoast").click((function () {
                    var o, a = e("#toastTypeGroup input:radio:checked").val(), s = e("#message").val(),
                        l = e("#title").val() || "", c = e("#showDuration"), u = e("#hideDuration"), d = e("#timeOut"),
                        h = e("#extendedTimeOut"), p = e("#showEasing"), f = e("#hideEasing"), m = e("#showMethod"),
                        _ = e("#hideMethod"), g = r++, y = e("#addClear").prop("checked");
                    i.a.options = {
                        closeButton: e("#closeButton").prop("checked"),
                        debug: e("#debugInfo").prop("checked"),
                        newestOnTop: e("#newestOnTop").prop("checked"),
                        progressBar: e("#progressBar").prop("checked"),
                        rtl: e("#rtl").prop("checked"),
                        positionClass: e("#positionGroup input:radio:checked").val() || "toast-top-right",
                        preventDuplicates: e("#preventDuplicates").prop("checked"),
                        onclick: null
                    }, e("#addBehaviorOnToastClick").prop("checked") && (i.a.options.onclick = function () {
                        alert("You can perform some custom action after a toast goes away")
                    }), e("#addBehaviorOnToastCloseClick").prop("checked") && (i.a.options.onCloseClick = function () {
                        alert("You can perform some custom action when the close button is clicked")
                    }), c.val().length && (i.a.options.showDuration = parseInt(c.val())), u.val().length && (i.a.options.hideDuration = parseInt(u.val())), d.val().length && (i.a.options.timeOut = y ? 0 : parseInt(d.val())), h.val().length && (i.a.options.extendedTimeOut = y ? 0 : parseInt(h.val())), p.val().length && (i.a.options.showEasing = p.val()), f.val().length && (i.a.options.hideEasing = f.val()), m.val().length && (i.a.options.showMethod = m.val()), _.val().length && (i.a.options.hideMethod = _.val()), y && (s = function (e) {
                        return e = e || "Clear itself?", e += '<br /><br /><button type="button" class="btn clear">Yes</button>'
                    }(s), i.a.options.tapToDismiss = !1), s || (++n === (o = ["My name is Inigo Montoya. You killed my father. Prepare to die!", '<div><input class="input-small" value="textbox"/>&nbsp;<a href="http://johnpapa.net" target="_blank">This is a hyperlink</a></div><div><button type="button" id="okBtn" class="btn btn-primary">Close me</button><button type="button" id="surpriseBtn" class="btn" style="margin: 0 8px 0 8px">Surprise me</button></div>', "Are you the six fingered man?", "Inconceivable!", "I do not think that means what you think it means.", "Have fun storming the castle!"]).length && (n = 0), s = o[n]), e("#toastrOptions").text('Command: toastr["' + a + '"]("' + s + (l ? '", "' + l : "") + '")\n\ntoastr.options = ' + JSON.stringify(i.a.options, null, 2));
                    var v = i.a[a](s, l);
                    t = v, void 0 !== v && (v.find("#okBtn").length && v.delegate("#okBtn", "click", (function () {
                        alert("you clicked me. i was toast #" + g + ". goodbye!"), v.remove()
                    })), v.find("#surpriseBtn").length && v.delegate("#surpriseBtn", "click", (function () {
                        alert("Surprise! you clicked me. i was toast #" + g + ". You could perform an action here.")
                    })), v.find(".clear").length && v.delegate(".clear", "click", (function () {
                        i.a.clear(v, {force: !0})
                    })))
                })), e("#clearlasttoast").click((function () {
                    i.a.clear(t)
                })), e("#cleartoasts").click((function () {
                    i.a.clear()
                }))
            })), e(".show-toastr-example").click((function () {
                i.a.options = {
                    closeButton: !0,
                    debug: !1,
                    newestOnTop: !0,
                    progressBar: !0,
                    positionClass: "toast-bottom-center",
                    preventDuplicates: !1,
                    onclick: null,
                    showDuration: "300",
                    hideDuration: "1000",
                    timeOut: "5000",
                    extendedTimeOut: "1000",
                    showEasing: "swing",
                    hideEasing: "linear",
                    showMethod: "fadeIn",
                    hideMethod: "fadeOut"
                }, i.a.info("You don't have any new items in your calendar today!", "Example Toastr")
            }))
        }))
    }.call(this, n(1))
}, function (e, t) {
    e.exports = function () {
        throw new Error("define cannot be used indirect")
    }
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        var t = n(4);
        e(document).ready((function () {
            setTimeout((function () {
                if (e(".scrollbar-container")[0]) {
                    e(".scrollbar-container").each((function () {
                        new t.a(e(this)[0], {wheelSpeed: 2, wheelPropagation: !1, minScrollbarLength: 20})
                    }));
                    new t.a(".scrollbar-sidebar", {wheelSpeed: 2, wheelPropagation: !1, minScrollbarLength: 20})
                }
            }), 1e3)
        }))
    }.call(this, n(1))
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        var t = n(5), i = n.n(t), r = n(141), o = n.n(r);
        e(document).ready((function () {
            if (document.getElementById("map")) {
                i.a.accessToken = "pk.eyJ1IjoiZGFzaGJvYXJlZHBhY2siLCJhIjoiY2s5bWlhZHRqMDAxazNsbnlpbXhhdDcwMSJ9.YU6cxTiRujREOAIVO6iLmA";
                new i.a.Map({
                    container: "map",
                    zoom: 9,
                    center: [137.9150899566626, 36.25956997955441],
                    style: "mapbox://styles/mapbox/satellite-v9"
                })
            }
            if (document.getElementById("gmap-example")) new o.a({
                el: "#gmap-example",
                lat: -12.043333,
                lng: -77.028333,
                width: "100%",
                height: "300px"
            })
        }))
    }.call(this, n(1))
}, function (e, t, n) {
    "use strict";
    n.r(t);
    var i = n(3), r = n.n(i), o = (n(152), function () {
            return Math.round(100 * Math.random())
        }), a = r.a.helpers.color,
        s = (a(window.chartColors.red).alpha(.5).rgbString(), window.chartColors.red, o(), o(), o(), o(), o(), o(), o(), a(window.chartColors.blue).alpha(.5).rgbString(), window.chartColors.blue, o(), o(), o(), o(), o(), o(), o()),
        l = {
            type: "pie",
            data: {
                datasets: [{
                    data: [o(), o(), o(), o(), o()],
                    backgroundColor: [window.chartColors.red, window.chartColors.orange, window.chartColors.yellow, window.chartColors.green, window.chartColors.blue],
                    label: "Dataset 1"
                }], labels: ["Red", "Orange", "Yellow", "Green", "Blue"]
            },
            options: {responsive: !0}
        }, c = (s = {
            labels: ["January", "February", "March", "April", "May", "June", "July"],
            datasets: [{
                label: "Dataset 1",
                backgroundColor: window.chartColors.red,
                data: [o(), o(), o(), o(), o(), o(), o()]
            }, {
                label: "Dataset 2",
                backgroundColor: window.chartColors.blue,
                data: [o(), o(), o(), o(), o(), o(), o()]
            }, {label: "Dataset 3", backgroundColor: window.chartColors.green, data: [o(), o(), o(), o(), o(), o(), o()]}]
        }, {
            type: "radar",
            data: {
                labels: [["Eating", "Dinner"], ["Drinking", "Water"], "Sleeping", ["Designing", "Graphics"], "Coding", "Cycling", "Running"],
                datasets: [{
                    label: "My First dataset",
                    backgroundColor: a(window.chartColors.red).alpha(.2).rgbString(),
                    borderColor: window.chartColors.red,
                    pointBackgroundColor: window.chartColors.red,
                    data: [o(), o(), o(), o(), o(), o(), o()]
                }, {
                    label: "My Second dataset",
                    backgroundColor: a(window.chartColors.blue).alpha(.2).rgbString(),
                    borderColor: window.chartColors.blue,
                    pointBackgroundColor: window.chartColors.blue,
                    data: [o(), o(), o(), o(), o(), o(), o()]
                }]
            },
            options: {
                legend: {position: "top"},
                title: {display: !1, text: "Chart.js Radar Chart"},
                scale: {ticks: {beginAtZero: !0}}
            }
        }), u = {
            type: "doughnut",
            data: {
                datasets: [{
                    data: [o(), o(), o(), o(), o()],
                    backgroundColor: [window.chartColors.red, window.chartColors.orange, window.chartColors.yellow, window.chartColors.green, window.chartColors.blue],
                    label: "Dataset 1"
                }], labels: ["Red", "Orange", "Yellow", "Green", "Blue"]
            },
            options: {
                responsive: !0,
                legend: {position: "top"},
                title: {display: !1, text: "Chart.js Doughnut Chart"},
                animation: {animateScale: !0, animateRotate: !0}
            }
        }, d = {
            type: "doughnut",
            data: {
                datasets: [{
                    data: [o(), o(), o(), o(), o()],
                    backgroundColor: [window.chartColors.red, window.chartColors.orange, window.chartColors.yellow, window.chartColors.green, window.chartColors.blue],
                    label: "Dataset 1"
                }], labels: ["Red", "Orange", "Yellow", "Green", "Blue"]
            },
            options: {
                responsive: !0,
                maintainAspectRatio: !1,
                legend: {display: !1},
                title: {display: !1, text: "Chart.js Doughnut Chart"},
                animation: {animateScale: !0, animateRotate: !0}
            }
        }, h = {
            data: {
                datasets: [{
                    data: [o(), o(), o(), o(), o()],
                    backgroundColor: [a(chartColors.red).alpha(.5).rgbString(), a(chartColors.orange).alpha(.5).rgbString(), a(chartColors.yellow).alpha(.5).rgbString(), a(chartColors.green).alpha(.5).rgbString(), a(chartColors.blue).alpha(.5).rgbString()],
                    label: "My dataset"
                }], labels: ["Red", "Orange", "Yellow", "Green", "Blue"]
            },
            options: {
                responsive: !0,
                legend: {position: "right"},
                title: {display: !1, text: "Chart.js Polar Area Chart"},
                scale: {ticks: {beginAtZero: !0}, reverse: !1},
                animation: {animateRotate: !1, animateScale: !0}
            }
        }, p = {
            type: "line",
            data: {
                labels: ["January", "February", "March", "April", "May", "June", "July"],
                datasets: [{
                    label: "My First dataset",
                    backgroundColor: window.chartColors.red,
                    borderColor: window.chartColors.red,
                    data: [o(), o(), o(), o(), o(), o(), o()],
                    fill: !1
                }, {
                    label: "My Second dataset",
                    fill: !1,
                    backgroundColor: window.chartColors.blue,
                    borderColor: window.chartColors.blue,
                    data: [o(), o(), o(), o(), o(), o(), o()]
                }]
            },
            options: {
                responsive: !0,
                maintainAspectRatio: !1,
                title: {display: !1, text: "Chart.js Line Chart"},
                legend: {display: !1},
                layout: {padding: {left: 10, right: 10, top: 10, bottom: 0}},
                tooltips: {mode: "index", intersect: !1},
                hover: {mode: "nearest", intersect: !0},
                pointBackgroundColor: "#fff",
                pointBorderColor: window.chartColors.blue,
                pointBorderWidth: "2",
                scales: {
                    xAxes: [{display: !1, scaleLabel: {display: !0, labelString: "Month"}}],
                    yAxes: [{display: !1, scaleLabel: {display: !0, labelString: "Value"}}]
                }
            }
        }, f = {
            labels: ["January", "February", "March", "April", "May", "June", "July"],
            datasets: [{
                label: "Dataset 1",
                backgroundColor: a(window.chartColors.red).alpha(.5).rgbString(),
                borderColor: window.chartColors.red,
                borderWidth: 1,
                data: [o(), o(), o(), o(), o(), o(), o()]
            }, {
                label: "Dataset 2",
                backgroundColor: a(window.chartColors.blue).alpha(.5).rgbString(),
                borderColor: window.chartColors.blue,
                data: [o(), o(), o(), o(), o(), o(), o()]
            }]
        };
    window.onload = function () {
        if (document.getElementById("canvas")) {
            var e = document.getElementById("canvas").getContext("2d");
            window.myBar = new r.a(e, {
                type: "bar",
                data: s,
                options: {responsive: !0, legend: {position: "top"}, title: {display: !1, text: "Chart.js Bar Chart"}}
            })
        }
        if (document.getElementById("chart-area")) {
            var t = document.getElementById("chart-area").getContext("2d");
            window.myPie = new r.a(t, l)
        }
        if (document.getElementById("doughnut-chart")) {
            var n = document.getElementById("doughnut-chart").getContext("2d");
            window.myDoughnut = new r.a(n, u)
        }
        if (document.getElementById("doughnut-chart-2")) {
            var i = document.getElementById("doughnut-chart-2").getContext("2d");
            window.myDoughnut = new r.a(i, d)
        }
        if (document.getElementById("doughnut-chart-3")) {
            var o = document.getElementById("doughnut-chart-3").getContext("2d");
            window.myDoughnut = new r.a(o, d)
        }
        if (document.getElementById("radar-chart") && (window.myRadar = new r.a(document.getElementById("radar-chart"), c)), document.getElementById("polar-chart")) {
            var a = document.getElementById("polar-chart");
            window.myPolarArea = r.a.PolarArea(a, h)
        }
        if (document.getElementById("line-chart")) {
            var m = document.getElementById("line-chart").getContext("2d");
            window.myLine = new r.a(m, p)
        }
        if (document.getElementById("chart-horiz-bar")) {
            var _ = document.getElementById("chart-horiz-bar").getContext("2d");
            window.myHorizontalBar = new r.a(_, {
                type: "horizontalBar",
                data: f,
                options: {
                    elements: {rectangle: {borderWidth: 2}},
                    responsive: !0,
                    legend: {position: "right"},
                    title: {display: !1, text: "Chart.js Horizontal Bar Chart"}
                }
            })
        }
        if (document.getElementById("stacked-bars-chart")) {
            var g = document.getElementById("stacked-bars-chart").getContext("2d");
            window.myBar = new r.a(g, {
                type: "bar",
                data: s,
                options: {
                    title: {display: !0, text: "Chart.js Bar Chart - Stacked"},
                    tooltips: {mode: "index", intersect: !1},
                    responsive: !0,
                    scales: {xAxes: [{stacked: !0}], yAxes: [{stacked: !0}]}
                }
            })
        }
    }
}, function (e, t) {
    e.exports = function (e) {
        return e.webpackPolyfill || (e.deprecate = function () {
        }, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function () {
                return e.l
            }
        }), Object.defineProperty(e, "id", {
            enumerable: !0, get: function () {
                return e.i
            }
        }), e.webpackPolyfill = 1), e
    }
}, function (e, t, n) {
    var i = {
        "./af": 6,
        "./af.js": 6,
        "./ar": 7,
        "./ar-dz": 8,
        "./ar-dz.js": 8,
        "./ar-kw": 9,
        "./ar-kw.js": 9,
        "./ar-ly": 10,
        "./ar-ly.js": 10,
        "./ar-ma": 11,
        "./ar-ma.js": 11,
        "./ar-sa": 12,
        "./ar-sa.js": 12,
        "./ar-tn": 13,
        "./ar-tn.js": 13,
        "./ar.js": 7,
        "./az": 14,
        "./az.js": 14,
        "./be": 15,
        "./be.js": 15,
        "./bg": 16,
        "./bg.js": 16,
        "./bm": 17,
        "./bm.js": 17,
        "./bn": 18,
        "./bn-bd": 19,
        "./bn-bd.js": 19,
        "./bn.js": 18,
        "./bo": 20,
        "./bo.js": 20,
        "./br": 21,
        "./br.js": 21,
        "./bs": 22,
        "./bs.js": 22,
        "./ca": 23,
        "./ca.js": 23,
        "./cs": 24,
        "./cs.js": 24,
        "./cv": 25,
        "./cv.js": 25,
        "./cy": 26,
        "./cy.js": 26,
        "./da": 27,
        "./da.js": 27,
        "./de": 28,
        "./de-at": 29,
        "./de-at.js": 29,
        "./de-ch": 30,
        "./de-ch.js": 30,
        "./de.js": 28,
        "./dv": 31,
        "./dv.js": 31,
        "./el": 32,
        "./el.js": 32,
        "./en-au": 33,
        "./en-au.js": 33,
        "./en-ca": 34,
        "./en-ca.js": 34,
        "./en-gb": 35,
        "./en-gb.js": 35,
        "./en-ie": 36,
        "./en-ie.js": 36,
        "./en-il": 37,
        "./en-il.js": 37,
        "./en-in": 38,
        "./en-in.js": 38,
        "./en-nz": 39,
        "./en-nz.js": 39,
        "./en-sg": 40,
        "./en-sg.js": 40,
        "./eo": 41,
        "./eo.js": 41,
        "./es": 42,
        "./es-do": 43,
        "./es-do.js": 43,
        "./es-mx": 44,
        "./es-mx.js": 44,
        "./es-us": 45,
        "./es-us.js": 45,
        "./es.js": 42,
        "./et": 46,
        "./et.js": 46,
        "./eu": 47,
        "./eu.js": 47,
        "./fa": 48,
        "./fa.js": 48,
        "./fi": 49,
        "./fi.js": 49,
        "./fil": 50,
        "./fil.js": 50,
        "./fo": 51,
        "./fo.js": 51,
        "./fr": 52,
        "./fr-ca": 53,
        "./fr-ca.js": 53,
        "./fr-ch": 54,
        "./fr-ch.js": 54,
        "./fr.js": 52,
        "./fy": 55,
        "./fy.js": 55,
        "./ga": 56,
        "./ga.js": 56,
        "./gd": 57,
        "./gd.js": 57,
        "./gl": 58,
        "./gl.js": 58,
        "./gom-deva": 59,
        "./gom-deva.js": 59,
        "./gom-latn": 60,
        "./gom-latn.js": 60,
        "./gu": 61,
        "./gu.js": 61,
        "./he": 62,
        "./he.js": 62,
        "./hi": 63,
        "./hi.js": 63,
        "./hr": 64,
        "./hr.js": 64,
        "./hu": 65,
        "./hu.js": 65,
        "./hy-am": 66,
        "./hy-am.js": 66,
        "./id": 67,
        "./id.js": 67,
        "./is": 68,
        "./is.js": 68,
        "./it": 69,
        "./it-ch": 70,
        "./it-ch.js": 70,
        "./it.js": 69,
        "./ja": 71,
        "./ja.js": 71,
        "./jv": 72,
        "./jv.js": 72,
        "./ka": 73,
        "./ka.js": 73,
        "./kk": 74,
        "./kk.js": 74,
        "./km": 75,
        "./km.js": 75,
        "./kn": 76,
        "./kn.js": 76,
        "./ko": 77,
        "./ko.js": 77,
        "./ku": 78,
        "./ku.js": 78,
        "./ky": 79,
        "./ky.js": 79,
        "./lb": 80,
        "./lb.js": 80,
        "./lo": 81,
        "./lo.js": 81,
        "./lt": 82,
        "./lt.js": 82,
        "./lv": 83,
        "./lv.js": 83,
        "./me": 84,
        "./me.js": 84,
        "./mi": 85,
        "./mi.js": 85,
        "./mk": 86,
        "./mk.js": 86,
        "./ml": 87,
        "./ml.js": 87,
        "./mn": 88,
        "./mn.js": 88,
        "./mr": 89,
        "./mr.js": 89,
        "./ms": 90,
        "./ms-my": 91,
        "./ms-my.js": 91,
        "./ms.js": 90,
        "./mt": 92,
        "./mt.js": 92,
        "./my": 93,
        "./my.js": 93,
        "./nb": 94,
        "./nb.js": 94,
        "./ne": 95,
        "./ne.js": 95,
        "./nl": 96,
        "./nl-be": 97,
        "./nl-be.js": 97,
        "./nl.js": 96,
        "./nn": 98,
        "./nn.js": 98,
        "./oc-lnc": 99,
        "./oc-lnc.js": 99,
        "./pa-in": 100,
        "./pa-in.js": 100,
        "./pl": 101,
        "./pl.js": 101,
        "./pt": 102,
        "./pt-br": 103,
        "./pt-br.js": 103,
        "./pt.js": 102,
        "./ro": 104,
        "./ro.js": 104,
        "./ru": 105,
        "./ru.js": 105,
        "./sd": 106,
        "./sd.js": 106,
        "./se": 107,
        "./se.js": 107,
        "./si": 108,
        "./si.js": 108,
        "./sk": 109,
        "./sk.js": 109,
        "./sl": 110,
        "./sl.js": 110,
        "./sq": 111,
        "./sq.js": 111,
        "./sr": 112,
        "./sr-cyrl": 113,
        "./sr-cyrl.js": 113,
        "./sr.js": 112,
        "./ss": 114,
        "./ss.js": 114,
        "./sv": 115,
        "./sv.js": 115,
        "./sw": 116,
        "./sw.js": 116,
        "./ta": 117,
        "./ta.js": 117,
        "./te": 118,
        "./te.js": 118,
        "./tet": 119,
        "./tet.js": 119,
        "./tg": 120,
        "./tg.js": 120,
        "./th": 121,
        "./th.js": 121,
        "./tk": 122,
        "./tk.js": 122,
        "./tl-ph": 123,
        "./tl-ph.js": 123,
        "./tlh": 124,
        "./tlh.js": 124,
        "./tr": 125,
        "./tr.js": 125,
        "./tzl": 126,
        "./tzl.js": 126,
        "./tzm": 127,
        "./tzm-latn": 128,
        "./tzm-latn.js": 128,
        "./tzm.js": 127,
        "./ug-cn": 129,
        "./ug-cn.js": 129,
        "./uk": 130,
        "./uk.js": 130,
        "./ur": 131,
        "./ur.js": 131,
        "./uz": 132,
        "./uz-latn": 133,
        "./uz-latn.js": 133,
        "./uz.js": 132,
        "./vi": 134,
        "./vi.js": 134,
        "./x-pseudo": 135,
        "./x-pseudo.js": 135,
        "./yo": 136,
        "./yo.js": 136,
        "./zh-cn": 137,
        "./zh-cn.js": 137,
        "./zh-hk": 138,
        "./zh-hk.js": 138,
        "./zh-mo": 139,
        "./zh-mo.js": 139,
        "./zh-tw": 140,
        "./zh-tw.js": 140
    };

    function r(e) {
        var t = o(e);
        return n(t)
    }

    function o(e) {
        if (!n.o(i, e)) {
            var t = new Error("Cannot find module '" + e + "'");
            throw t.code = "MODULE_NOT_FOUND", t
        }
        return i[e]
    }

    r.keys = function () {
        return Object.keys(i)
    }, r.resolve = o, e.exports = r, r.id = 151
}, function (e, t, n) {
    "use strict";
    var i, r, o, a, s, l, c, u, d, h, p;
    window.chartColors = {
        red: "#dc3545",
        orange: "#fd7e14",
        yellow: "#ffc107",
        green: "#28a745",
        blue: "#007bff",
        purple: "#6f42c1",
        grey: "#6c757d"
    }, u = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], d = ["#4dc9f6", "#f67019", "#f53794", "#537bc4", "#acc236", "#166a8f", "#00a950", "#58595b", "#8549ba"], h = (i = this).Samples || (i.Samples = {}), p = i.Color, h.utils = {
        srand: function (e) {
            this._seed = e
        }, rand: function (e, t) {
            var n = this._seed;
            return e = void 0 === e ? 0 : e, t = void 0 === t ? 1 : t, this._seed = (9301 * n + 49297) % 233280, e + this._seed / 233280 * (t - e)
        }, numbers: function (e) {
            var t, n, i = e || {}, r = i.min || 0, o = i.max || 1, a = i.from || [], s = i.count || 8,
                l = i.decimals || 8, c = i.continuity || 1, u = Math.pow(10, l) || 0, d = [];
            for (t = 0; t < s; ++t) n = (a[t] || 0) + this.rand(r, o), this.rand() <= c ? d.push(Math.round(u * n) / u) : d.push(null);
            return d
        }, labels: function (e) {
            var t, n = e || {}, i = n.min || 0, r = n.max || 100, o = (r - i) / (n.count || 8), a = n.decimals || 8,
                s = Math.pow(10, a) || 0, l = n.prefix || "", c = [];
            for (t = i; t < r; t += o) c.push(l + Math.round(s * t) / s);
            return c
        }, months: function (e) {
            var t, n, i = e || {}, r = i.count || 12, o = i.section, a = [];
            for (t = 0; t < r; ++t) n = u[Math.ceil(t) % 12], a.push(n.substring(0, o));
            return a
        }, color: function (e) {
            return d[e % d.length]
        }, transparentize: function (e, t) {
            var n = void 0 === t ? .5 : 1 - t;
            return p(e).alpha(n).rgbString()
        }
    }, window.randomScalingFactor = function () {
        return Math.round(h.utils.rand(-100, 100))
    }, h.utils.srand(Date.now()), document.location.hostname.match(/^(www\.)?chartjs\.org$/) && (r = window, o = document, a = "script", s = "ga", r.GoogleAnalyticsObject = s, r.ga = r.ga || function () {
        (r.ga.q = r.ga.q || []).push(arguments)
    }, r.ga.l = 1 * new Date, l = o.createElement(a), c = o.getElementsByTagName(a)[0], l.async = 1, l.src = "//www.google-analytics.com/analytics.js", c.parentNode.insertBefore(l, c), ga("create", "UA-28909194-3", "auto"), ga("send", "pageview"))
}, function (e, t, n) {
    "use strict";
    n.r(t);
    var i = {};
    n.r(i), n.d(i, "top", (function () {
        return a
    })), n.d(i, "bottom", (function () {
        return s
    })), n.d(i, "right", (function () {
        return l
    })), n.d(i, "left", (function () {
        return c
    })), n.d(i, "auto", (function () {
        return u
    })), n.d(i, "basePlacements", (function () {
        return d
    })), n.d(i, "start", (function () {
        return h
    })), n.d(i, "end", (function () {
        return p
    })), n.d(i, "clippingParents", (function () {
        return f
    })), n.d(i, "viewport", (function () {
        return m
    })), n.d(i, "popper", (function () {
        return _
    })), n.d(i, "reference", (function () {
        return g
    })), n.d(i, "variationPlacements", (function () {
        return y
    })), n.d(i, "placements", (function () {
        return v
    })), n.d(i, "beforeRead", (function () {
        return x
    })), n.d(i, "read", (function () {
        return b
    })), n.d(i, "afterRead", (function () {
        return w
    })), n.d(i, "beforeMain", (function () {
        return M
    })), n.d(i, "main", (function () {
        return T
    })), n.d(i, "afterMain", (function () {
        return k
    })), n.d(i, "beforeWrite", (function () {
        return S
    })), n.d(i, "write", (function () {
        return D
    })), n.d(i, "afterWrite", (function () {
        return L
    })), n.d(i, "modifierPhases", (function () {
        return E
    })), n.d(i, "applyStyles", (function () {
        return Y
    })), n.d(i, "arrow", (function () {
        return Q
    })), n.d(i, "computeStyles", (function () {
        return ie
    })), n.d(i, "eventListeners", (function () {
        return oe
    })), n.d(i, "flip", (function () {
        return ve
    })), n.d(i, "hide", (function () {
        return we
    })), n.d(i, "offset", (function () {
        return Me
    })), n.d(i, "popperOffsets", (function () {
        return Te
    })), n.d(i, "preventOverflow", (function () {
        return ke
    })), n.d(i, "popperGenerator", (function () {
        return Ce
    })), n.d(i, "detectOverflow", (function () {
        return ye
    })), n.d(i, "createPopperBase", (function () {
        return Ae
    })), n.d(i, "createPopper", (function () {
        return Ie
    })), n.d(i, "createPopperLite", (function () {
        return Pe
    }));
    var r = n(1), o = n.n(r), a = "top", s = "bottom", l = "right", c = "left", u = "auto", d = [a, s, l, c],
        h = "start", p = "end", f = "clippingParents", m = "viewport", _ = "popper", g = "reference",
        y = d.reduce((function (e, t) {
            return e.concat([t + "-" + h, t + "-" + p])
        }), []), v = [].concat(d, [u]).reduce((function (e, t) {
            return e.concat([t, t + "-" + h, t + "-" + p])
        }), []), x = "beforeRead", b = "read", w = "afterRead", M = "beforeMain", T = "main", k = "afterMain",
        S = "beforeWrite", D = "write", L = "afterWrite", E = [x, b, w, M, T, k, S, D, L];

    function C(e) {
        return e ? (e.nodeName || "").toLowerCase() : null
    }

    function A(e) {
        if (null == e) return window;
        if ("[object Window]" !== e.toString()) {
            var t = e.ownerDocument;
            return t && t.defaultView || window
        }
        return e
    }

    function I(e) {
        return e instanceof A(e).Element || e instanceof Element
    }

    function P(e) {
        return e instanceof A(e).HTMLElement || e instanceof HTMLElement
    }

    function R(e) {
        return "undefined" != typeof ShadowRoot && (e instanceof A(e).ShadowRoot || e instanceof ShadowRoot)
    }

    var Y = {
        name: "applyStyles", enabled: !0, phase: "write", fn: function (e) {
            var t = e.state;
            Object.keys(t.elements).forEach((function (e) {
                var n = t.styles[e] || {}, i = t.attributes[e] || {}, r = t.elements[e];
                P(r) && C(r) && (Object.assign(r.style, n), Object.keys(i).forEach((function (e) {
                    var t = i[e];
                    !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t)
                })))
            }))
        }, effect: function (e) {
            var t = e.state, n = {
                popper: {position: t.options.strategy, left: "0", top: "0", margin: "0"},
                arrow: {position: "absolute"},
                reference: {}
            };
            return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () {
                Object.keys(t.elements).forEach((function (e) {
                    var i = t.elements[e], r = t.attributes[e] || {},
                        o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function (e, t) {
                            return e[t] = "", e
                        }), {});
                    P(i) && C(i) && (Object.assign(i.style, o), Object.keys(r).forEach((function (e) {
                        i.removeAttribute(e)
                    })))
                }))
            }
        }, requires: ["computeStyles"]
    };

    function z(e) {
        return e.split("-")[0]
    }

    var O = Math.max, F = Math.min, B = Math.round;

    function j(e, t) {
        void 0 === t && (t = !1);
        var n = e.getBoundingClientRect(), i = 1, r = 1;
        if (P(e) && t) {
            var o = e.offsetHeight, a = e.offsetWidth;
            a > 0 && (i = B(n.width) / a || 1), o > 0 && (r = B(n.height) / o || 1)
        }
        return {
            width: n.width / i,
            height: n.height / r,
            top: n.top / r,
            right: n.right / i,
            bottom: n.bottom / r,
            left: n.left / i,
            x: n.left / i,
            y: n.top / r
        }
    }

    function H(e) {
        var t = j(e), n = e.offsetWidth, i = e.offsetHeight;
        return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
            x: e.offsetLeft,
            y: e.offsetTop,
            width: n,
            height: i
        }
    }

    function N(e, t) {
        var n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (n && R(n)) {
            var i = t;
            do {
                if (i && e.isSameNode(i)) return !0;
                i = i.parentNode || i.host
            } while (i)
        }
        return !1
    }

    function U(e) {
        return A(e).getComputedStyle(e)
    }

    function W(e) {
        return ["table", "td", "th"].indexOf(C(e)) >= 0
    }

    function V(e) {
        return ((I(e) ? e.ownerDocument : e.document) || window.document).documentElement
    }

    function G(e) {
        return "html" === C(e) ? e : e.assignedSlot || e.parentNode || (R(e) ? e.host : null) || V(e)
    }

    function q(e) {
        return P(e) && "fixed" !== U(e).position ? e.offsetParent : null
    }

    function Z(e) {
        for (var t = A(e), n = q(e); n && W(n) && "static" === U(n).position;) n = q(n);
        return n && ("html" === C(n) || "body" === C(n) && "static" === U(n).position) ? t : n || function (e) {
            var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
            if (-1 !== navigator.userAgent.indexOf("Trident") && P(e) && "fixed" === U(e).position) return null;
            var n = G(e);
            for (R(n) && (n = n.host); P(n) && ["html", "body"].indexOf(C(n)) < 0;) {
                var i = U(n);
                if ("none" !== i.transform || "none" !== i.perspective || "paint" === i.contain || -1 !== ["transform", "perspective"].indexOf(i.willChange) || t && "filter" === i.willChange || t && i.filter && "none" !== i.filter) return n;
                n = n.parentNode
            }
            return null
        }(e) || t
    }

    function $(e) {
        return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
    }

    function X(e, t, n) {
        return O(e, F(t, n))
    }

    function J(e) {
        return Object.assign({}, {top: 0, right: 0, bottom: 0, left: 0}, e)
    }

    function K(e, t) {
        return t.reduce((function (t, n) {
            return t[n] = e, t
        }), {})
    }

    var Q = {
        name: "arrow", enabled: !0, phase: "main", fn: function (e) {
            var t, n = e.state, i = e.name, r = e.options, o = n.elements.arrow, u = n.modifiersData.popperOffsets,
                h = z(n.placement), p = $(h), f = [c, l].indexOf(h) >= 0 ? "height" : "width";
            if (o && u) {
                var m = function (e, t) {
                        return J("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {placement: t.placement})) : e) ? e : K(e, d))
                    }(r.padding, n), _ = H(o), g = "y" === p ? a : c, y = "y" === p ? s : l,
                    v = n.rects.reference[f] + n.rects.reference[p] - u[p] - n.rects.popper[f],
                    x = u[p] - n.rects.reference[p], b = Z(o),
                    w = b ? "y" === p ? b.clientHeight || 0 : b.clientWidth || 0 : 0, M = v / 2 - x / 2, T = m[g],
                    k = w - _[f] - m[y], S = w / 2 - _[f] / 2 + M, D = X(T, S, k), L = p;
                n.modifiersData[i] = ((t = {})[L] = D, t.centerOffset = D - S, t)
            }
        }, effect: function (e) {
            var t = e.state, n = e.options.element, i = void 0 === n ? "[data-popper-arrow]" : n;
            null != i && ("string" != typeof i || (i = t.elements.popper.querySelector(i))) && N(t.elements.popper, i) && (t.elements.arrow = i)
        }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"]
    };

    function ee(e) {
        return e.split("-")[1]
    }

    var te = {top: "auto", right: "auto", bottom: "auto", left: "auto"};

    function ne(e) {
        var t, n = e.popper, i = e.popperRect, r = e.placement, o = e.variation, u = e.offsets, d = e.position,
            h = e.gpuAcceleration, f = e.adaptive, m = e.roundOffsets, _ = e.isFixed, g = u.x, y = void 0 === g ? 0 : g,
            v = u.y, x = void 0 === v ? 0 : v, b = "function" == typeof m ? m({x: y, y: x}) : {x: y, y: x};
        y = b.x, x = b.y;
        var w = u.hasOwnProperty("x"), M = u.hasOwnProperty("y"), T = c, k = a, S = window;
        if (f) {
            var D = Z(n), L = "clientHeight", E = "clientWidth";
            if (D === A(n) && "static" !== U(D = V(n)).position && "absolute" === d && (L = "scrollHeight", E = "scrollWidth"), D = D, r === a || (r === c || r === l) && o === p) k = s, x -= (_ && D === S && S.visualViewport ? S.visualViewport.height : D[L]) - i.height, x *= h ? 1 : -1;
            if (r === c || (r === a || r === s) && o === p) T = l, y -= (_ && D === S && S.visualViewport ? S.visualViewport.width : D[E]) - i.width, y *= h ? 1 : -1
        }
        var C, I = Object.assign({position: d}, f && te), P = !0 === m ? function (e) {
            var t = e.x, n = e.y, i = window.devicePixelRatio || 1;
            return {x: B(t * i) / i || 0, y: B(n * i) / i || 0}
        }({x: y, y: x}) : {x: y, y: x};
        return y = P.x, x = P.y, h ? Object.assign({}, I, ((C = {})[k] = M ? "0" : "", C[T] = w ? "0" : "", C.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + x + "px)" : "translate3d(" + y + "px, " + x + "px, 0)", C)) : Object.assign({}, I, ((t = {})[k] = M ? x + "px" : "", t[T] = w ? y + "px" : "", t.transform = "", t))
    }

    var ie = {
        name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) {
            var t = e.state, n = e.options, i = n.gpuAcceleration, r = void 0 === i || i, o = n.adaptive,
                a = void 0 === o || o, s = n.roundOffsets, l = void 0 === s || s, c = {
                    placement: z(t.placement),
                    variation: ee(t.placement),
                    popper: t.elements.popper,
                    popperRect: t.rects.popper,
                    gpuAcceleration: r,
                    isFixed: "fixed" === t.options.strategy
                };
            null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, ne(Object.assign({}, c, {
                offsets: t.modifiersData.popperOffsets,
                position: t.options.strategy,
                adaptive: a,
                roundOffsets: l
            })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, ne(Object.assign({}, c, {
                offsets: t.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: l
            })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {"data-popper-placement": t.placement})
        }, data: {}
    }, re = {passive: !0};
    var oe = {
        name: "eventListeners", enabled: !0, phase: "write", fn: function () {
        }, effect: function (e) {
            var t = e.state, n = e.instance, i = e.options, r = i.scroll, o = void 0 === r || r, a = i.resize,
                s = void 0 === a || a, l = A(t.elements.popper),
                c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
            return o && c.forEach((function (e) {
                e.addEventListener("scroll", n.update, re)
            })), s && l.addEventListener("resize", n.update, re), function () {
                o && c.forEach((function (e) {
                    e.removeEventListener("scroll", n.update, re)
                })), s && l.removeEventListener("resize", n.update, re)
            }
        }, data: {}
    }, ae = {left: "right", right: "left", bottom: "top", top: "bottom"};

    function se(e) {
        return e.replace(/left|right|bottom|top/g, (function (e) {
            return ae[e]
        }))
    }

    var le = {start: "end", end: "start"};

    function ce(e) {
        return e.replace(/start|end/g, (function (e) {
            return le[e]
        }))
    }

    function ue(e) {
        var t = A(e);
        return {scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset}
    }

    function de(e) {
        return j(V(e)).left + ue(e).scrollLeft
    }

    function he(e) {
        var t = U(e), n = t.overflow, i = t.overflowX, r = t.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + r + i)
    }

    function pe(e, t) {
        var n;
        void 0 === t && (t = []);
        var i = function e(t) {
                return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : P(t) && he(t) ? t : e(G(t))
            }(e), r = i === (null == (n = e.ownerDocument) ? void 0 : n.body), o = A(i),
            a = r ? [o].concat(o.visualViewport || [], he(i) ? i : []) : i, s = t.concat(a);
        return r ? s : s.concat(pe(G(a)))
    }

    function fe(e) {
        return Object.assign({}, e, {left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height})
    }

    function me(e, t) {
        return t === m ? fe(function (e) {
            var t = A(e), n = V(e), i = t.visualViewport, r = n.clientWidth, o = n.clientHeight, a = 0, s = 0;
            return i && (r = i.width, o = i.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = i.offsetLeft, s = i.offsetTop)), {
                width: r,
                height: o,
                x: a + de(e),
                y: s
            }
        }(e)) : I(t) ? function (e) {
            var t = j(e);
            return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
        }(t) : fe(function (e) {
            var t, n = V(e), i = ue(e), r = null == (t = e.ownerDocument) ? void 0 : t.body,
                o = O(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0),
                a = O(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0),
                s = -i.scrollLeft + de(e), l = -i.scrollTop;
            return "rtl" === U(r || n).direction && (s += O(n.clientWidth, r ? r.clientWidth : 0) - o), {
                width: o,
                height: a,
                x: s,
                y: l
            }
        }(V(e)))
    }

    function _e(e, t, n) {
        var i = "clippingParents" === t ? function (e) {
            var t = pe(G(e)), n = ["absolute", "fixed"].indexOf(U(e).position) >= 0 && P(e) ? Z(e) : e;
            return I(n) ? t.filter((function (e) {
                return I(e) && N(e, n) && "body" !== C(e)
            })) : []
        }(e) : [].concat(t), r = [].concat(i, [n]), o = r[0], a = r.reduce((function (t, n) {
            var i = me(e, n);
            return t.top = O(i.top, t.top), t.right = F(i.right, t.right), t.bottom = F(i.bottom, t.bottom), t.left = O(i.left, t.left), t
        }), me(e, o));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
    }

    function ge(e) {
        var t, n = e.reference, i = e.element, r = e.placement, o = r ? z(r) : null, u = r ? ee(r) : null,
            d = n.x + n.width / 2 - i.width / 2, f = n.y + n.height / 2 - i.height / 2;
        switch (o) {
            case a:
                t = {x: d, y: n.y - i.height};
                break;
            case s:
                t = {x: d, y: n.y + n.height};
                break;
            case l:
                t = {x: n.x + n.width, y: f};
                break;
            case c:
                t = {x: n.x - i.width, y: f};
                break;
            default:
                t = {x: n.x, y: n.y}
        }
        var m = o ? $(o) : null;
        if (null != m) {
            var _ = "y" === m ? "height" : "width";
            switch (u) {
                case h:
                    t[m] = t[m] - (n[_] / 2 - i[_] / 2);
                    break;
                case p:
                    t[m] = t[m] + (n[_] / 2 - i[_] / 2)
            }
        }
        return t
    }

    function ye(e, t) {
        void 0 === t && (t = {});
        var n = t, i = n.placement, r = void 0 === i ? e.placement : i, o = n.boundary, c = void 0 === o ? f : o,
            u = n.rootBoundary, h = void 0 === u ? m : u, p = n.elementContext, y = void 0 === p ? _ : p,
            v = n.altBoundary, x = void 0 !== v && v, b = n.padding, w = void 0 === b ? 0 : b,
            M = J("number" != typeof w ? w : K(w, d)), T = y === _ ? g : _, k = e.rects.popper,
            S = e.elements[x ? T : y], D = _e(I(S) ? S : S.contextElement || V(e.elements.popper), c, h),
            L = j(e.elements.reference), E = ge({reference: L, element: k, strategy: "absolute", placement: r}),
            C = fe(Object.assign({}, k, E)), A = y === _ ? C : L, P = {
                top: D.top - A.top + M.top,
                bottom: A.bottom - D.bottom + M.bottom,
                left: D.left - A.left + M.left,
                right: A.right - D.right + M.right
            }, R = e.modifiersData.offset;
        if (y === _ && R) {
            var Y = R[r];
            Object.keys(P).forEach((function (e) {
                var t = [l, s].indexOf(e) >= 0 ? 1 : -1, n = [a, s].indexOf(e) >= 0 ? "y" : "x";
                P[e] += Y[n] * t
            }))
        }
        return P
    }

    var ve = {
        name: "flip", enabled: !0, phase: "main", fn: function (e) {
            var t = e.state, n = e.options, i = e.name;
            if (!t.modifiersData[i]._skip) {
                for (var r = n.mainAxis, o = void 0 === r || r, p = n.altAxis, f = void 0 === p || p, m = n.fallbackPlacements, _ = n.padding, g = n.boundary, x = n.rootBoundary, b = n.altBoundary, w = n.flipVariations, M = void 0 === w || w, T = n.allowedAutoPlacements, k = t.options.placement, S = z(k), D = m || (S === k || !M ? [se(k)] : function (e) {
                    if (z(e) === u) return [];
                    var t = se(e);
                    return [ce(e), t, ce(t)]
                }(k)), L = [k].concat(D).reduce((function (e, n) {
                    return e.concat(z(n) === u ? function (e, t) {
                        void 0 === t && (t = {});
                        var n = t, i = n.placement, r = n.boundary, o = n.rootBoundary, a = n.padding,
                            s = n.flipVariations, l = n.allowedAutoPlacements, c = void 0 === l ? v : l, u = ee(i),
                            h = u ? s ? y : y.filter((function (e) {
                                return ee(e) === u
                            })) : d, p = h.filter((function (e) {
                                return c.indexOf(e) >= 0
                            }));
                        0 === p.length && (p = h);
                        var f = p.reduce((function (t, n) {
                            return t[n] = ye(e, {placement: n, boundary: r, rootBoundary: o, padding: a})[z(n)], t
                        }), {});
                        return Object.keys(f).sort((function (e, t) {
                            return f[e] - f[t]
                        }))
                    }(t, {
                        placement: n,
                        boundary: g,
                        rootBoundary: x,
                        padding: _,
                        flipVariations: M,
                        allowedAutoPlacements: T
                    }) : n)
                }), []), E = t.rects.reference, C = t.rects.popper, A = new Map, I = !0, P = L[0], R = 0; R < L.length; R++) {
                    var Y = L[R], O = z(Y), F = ee(Y) === h, B = [a, s].indexOf(O) >= 0, j = B ? "width" : "height",
                        H = ye(t, {placement: Y, boundary: g, rootBoundary: x, altBoundary: b, padding: _}),
                        N = B ? F ? l : c : F ? s : a;
                    E[j] > C[j] && (N = se(N));
                    var U = se(N), W = [];
                    if (o && W.push(H[O] <= 0), f && W.push(H[N] <= 0, H[U] <= 0), W.every((function (e) {
                        return e
                    }))) {
                        P = Y, I = !1;
                        break
                    }
                    A.set(Y, W)
                }
                if (I) for (var V = function (e) {
                    var t = L.find((function (t) {
                        var n = A.get(t);
                        if (n) return n.slice(0, e).every((function (e) {
                            return e
                        }))
                    }));
                    if (t) return P = t, "break"
                }, G = M ? 3 : 1; G > 0; G--) {
                    if ("break" === V(G)) break
                }
                t.placement !== P && (t.modifiersData[i]._skip = !0, t.placement = P, t.reset = !0)
            }
        }, requiresIfExists: ["offset"], data: {_skip: !1}
    };

    function xe(e, t, n) {
        return void 0 === n && (n = {x: 0, y: 0}), {
            top: e.top - t.height - n.y,
            right: e.right - t.width + n.x,
            bottom: e.bottom - t.height + n.y,
            left: e.left - t.width - n.x
        }
    }

    function be(e) {
        return [a, l, s, c].some((function (t) {
            return e[t] >= 0
        }))
    }

    var we = {
        name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) {
            var t = e.state, n = e.name, i = t.rects.reference, r = t.rects.popper, o = t.modifiersData.preventOverflow,
                a = ye(t, {elementContext: "reference"}), s = ye(t, {altBoundary: !0}), l = xe(a, i), c = xe(s, r, o),
                u = be(l), d = be(c);
            t.modifiersData[n] = {
                referenceClippingOffsets: l,
                popperEscapeOffsets: c,
                isReferenceHidden: u,
                hasPopperEscaped: d
            }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
                "data-popper-reference-hidden": u,
                "data-popper-escaped": d
            })
        }
    };
    var Me = {
        name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) {
            var t = e.state, n = e.options, i = e.name, r = n.offset, o = void 0 === r ? [0, 0] : r,
                s = v.reduce((function (e, n) {
                    return e[n] = function (e, t, n) {
                        var i = z(e), r = [c, a].indexOf(i) >= 0 ? -1 : 1,
                            o = "function" == typeof n ? n(Object.assign({}, t, {placement: e})) : n, s = o[0],
                            u = o[1];
                        return s = s || 0, u = (u || 0) * r, [c, l].indexOf(i) >= 0 ? {x: u, y: s} : {x: s, y: u}
                    }(n, t.rects, o), e
                }), {}), u = s[t.placement], d = u.x, h = u.y;
            null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += d, t.modifiersData.popperOffsets.y += h), t.modifiersData[i] = s
        }
    };
    var Te = {
        name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) {
            var t = e.state, n = e.name;
            t.modifiersData[n] = ge({
                reference: t.rects.reference,
                element: t.rects.popper,
                strategy: "absolute",
                placement: t.placement
            })
        }, data: {}
    };
    var ke = {
        name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) {
            var t = e.state, n = e.options, i = e.name, r = n.mainAxis, o = void 0 === r || r, u = n.altAxis,
                d = void 0 !== u && u, p = n.boundary, f = n.rootBoundary, m = n.altBoundary, _ = n.padding,
                g = n.tether, y = void 0 === g || g, v = n.tetherOffset, x = void 0 === v ? 0 : v,
                b = ye(t, {boundary: p, rootBoundary: f, padding: _, altBoundary: m}), w = z(t.placement),
                M = ee(t.placement), T = !M, k = $(w), S = "x" === k ? "y" : "x", D = t.modifiersData.popperOffsets,
                L = t.rects.reference, E = t.rects.popper,
                C = "function" == typeof x ? x(Object.assign({}, t.rects, {placement: t.placement})) : x,
                A = "number" == typeof C ? {mainAxis: C, altAxis: C} : Object.assign({mainAxis: 0, altAxis: 0}, C),
                I = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, P = {x: 0, y: 0};
            if (D) {
                if (o) {
                    var R, Y = "y" === k ? a : c, B = "y" === k ? s : l, j = "y" === k ? "height" : "width", N = D[k],
                        U = N + b[Y], W = N - b[B], V = y ? -E[j] / 2 : 0, G = M === h ? L[j] : E[j],
                        q = M === h ? -E[j] : -L[j], J = t.elements.arrow, K = y && J ? H(J) : {width: 0, height: 0},
                        Q = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, te = Q[Y], ne = Q[B], ie = X(0, L[j], K[j]),
                        re = T ? L[j] / 2 - V - ie - te - A.mainAxis : G - ie - te - A.mainAxis,
                        oe = T ? -L[j] / 2 + V + ie + ne + A.mainAxis : q + ie + ne + A.mainAxis,
                        ae = t.elements.arrow && Z(t.elements.arrow),
                        se = ae ? "y" === k ? ae.clientTop || 0 : ae.clientLeft || 0 : 0,
                        le = null != (R = null == I ? void 0 : I[k]) ? R : 0, ce = N + oe - le,
                        ue = X(y ? F(U, N + re - le - se) : U, N, y ? O(W, ce) : W);
                    D[k] = ue, P[k] = ue - N
                }
                if (d) {
                    var de, he = "x" === k ? a : c, pe = "x" === k ? s : l, fe = D[S],
                        me = "y" === S ? "height" : "width", _e = fe + b[he], ge = fe - b[pe],
                        ve = -1 !== [a, c].indexOf(w), xe = null != (de = null == I ? void 0 : I[S]) ? de : 0,
                        be = ve ? _e : fe - L[me] - E[me] - xe + A.altAxis,
                        we = ve ? fe + L[me] + E[me] - xe - A.altAxis : ge, Me = y && ve ? function (e, t, n) {
                            var i = X(e, t, n);
                            return i > n ? n : i
                        }(be, fe, we) : X(y ? be : _e, fe, y ? we : ge);
                    D[S] = Me, P[S] = Me - fe
                }
                t.modifiersData[i] = P
            }
        }, requiresIfExists: ["offset"]
    };

    function Se(e, t, n) {
        void 0 === n && (n = !1);
        var i, r, o = P(t), a = P(t) && function (e) {
            var t = e.getBoundingClientRect(), n = B(t.width) / e.offsetWidth || 1,
                i = B(t.height) / e.offsetHeight || 1;
            return 1 !== n || 1 !== i
        }(t), s = V(t), l = j(e, a), c = {scrollLeft: 0, scrollTop: 0}, u = {x: 0, y: 0};
        return (o || !o && !n) && (("body" !== C(t) || he(s)) && (c = (i = t) !== A(i) && P(i) ? {
            scrollLeft: (r = i).scrollLeft,
            scrollTop: r.scrollTop
        } : ue(i)), P(t) ? ((u = j(t, !0)).x += t.clientLeft, u.y += t.clientTop) : s && (u.x = de(s))), {
            x: l.left + c.scrollLeft - u.x,
            y: l.top + c.scrollTop - u.y,
            width: l.width,
            height: l.height
        }
    }

    function De(e) {
        var t = new Map, n = new Set, i = [];
        return e.forEach((function (e) {
            t.set(e.name, e)
        })), e.forEach((function (e) {
            n.has(e.name) || function e(r) {
                n.add(r.name), [].concat(r.requires || [], r.requiresIfExists || []).forEach((function (i) {
                    if (!n.has(i)) {
                        var r = t.get(i);
                        r && e(r)
                    }
                })), i.push(r)
            }(e)
        })), i
    }

    var Le = {placement: "bottom", modifiers: [], strategy: "absolute"};

    function Ee() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return !t.some((function (e) {
            return !(e && "function" == typeof e.getBoundingClientRect)
        }))
    }

    function Ce(e) {
        void 0 === e && (e = {});
        var t = e, n = t.defaultModifiers, i = void 0 === n ? [] : n, r = t.defaultOptions, o = void 0 === r ? Le : r;
        return function (e, t, n) {
            void 0 === n && (n = o);
            var r, a, s = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, Le, o),
                modifiersData: {},
                elements: {reference: e, popper: t},
                attributes: {},
                styles: {}
            }, l = [], c = !1, u = {
                state: s, setOptions: function (n) {
                    var r = "function" == typeof n ? n(s.options) : n;
                    d(), s.options = Object.assign({}, o, s.options, r), s.scrollParents = {
                        reference: I(e) ? pe(e) : e.contextElement ? pe(e.contextElement) : [],
                        popper: pe(t)
                    };
                    var a = function (e) {
                        var t = De(e);
                        return E.reduce((function (e, n) {
                            return e.concat(t.filter((function (e) {
                                return e.phase === n
                            })))
                        }), [])
                    }(function (e) {
                        var t = e.reduce((function (e, t) {
                            var n = e[t.name];
                            return e[t.name] = n ? Object.assign({}, n, t, {
                                options: Object.assign({}, n.options, t.options),
                                data: Object.assign({}, n.data, t.data)
                            }) : t, e
                        }), {});
                        return Object.keys(t).map((function (e) {
                            return t[e]
                        }))
                    }([].concat(i, s.options.modifiers)));
                    return s.orderedModifiers = a.filter((function (e) {
                        return e.enabled
                    })), s.orderedModifiers.forEach((function (e) {
                        var t = e.name, n = e.options, i = void 0 === n ? {} : n, r = e.effect;
                        if ("function" == typeof r) {
                            var o = r({state: s, name: t, instance: u, options: i});
                            l.push(o || function () {
                            })
                        }
                    })), u.update()
                }, forceUpdate: function () {
                    if (!c) {
                        var e = s.elements, t = e.reference, n = e.popper;
                        if (Ee(t, n)) {
                            s.rects = {
                                reference: Se(t, Z(n), "fixed" === s.options.strategy),
                                popper: H(n)
                            }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach((function (e) {
                                return s.modifiersData[e.name] = Object.assign({}, e.data)
                            }));
                            for (var i = 0; i < s.orderedModifiers.length; i++) if (!0 !== s.reset) {
                                var r = s.orderedModifiers[i], o = r.fn, a = r.options, l = void 0 === a ? {} : a,
                                    d = r.name;
                                "function" == typeof o && (s = o({state: s, options: l, name: d, instance: u}) || s)
                            } else s.reset = !1, i = -1
                        }
                    }
                }, update: (r = function () {
                    return new Promise((function (e) {
                        u.forceUpdate(), e(s)
                    }))
                }, function () {
                    return a || (a = new Promise((function (e) {
                        Promise.resolve().then((function () {
                            a = void 0, e(r())
                        }))
                    }))), a
                }), destroy: function () {
                    d(), c = !0
                }
            };
            if (!Ee(e, t)) return u;

            function d() {
                l.forEach((function (e) {
                    return e()
                })), l = []
            }

            return u.setOptions(n).then((function (e) {
                !c && n.onFirstUpdate && n.onFirstUpdate(e)
            })), u
        }
    }

    var Ae = Ce(), Ie = Ce({defaultModifiers: [oe, Te, ie, Y, Me, ve, ke, Q, we]}),
        Pe = Ce({defaultModifiers: [oe, Te, ie, Y]});
    /*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
    const Re = e => {
            let t = e.getAttribute("data-bs-target");
            if (!t || "#" === t) {
                let n = e.getAttribute("href");
                if (!n || !n.includes("#") && !n.startsWith(".")) return null;
                n.includes("#") && !n.startsWith("#") && (n = "#" + n.split("#")[1]), t = n && "#" !== n ? n.trim() : null
            }
            return t
        }, Ye = e => {
            const t = Re(e);
            return t && document.querySelector(t) ? t : null
        }, ze = e => {
            const t = Re(e);
            return t ? document.querySelector(t) : null
        }, Oe = e => {
            e.dispatchEvent(new Event("transitionend"))
        }, Fe = e => !(!e || "object" != typeof e) && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType),
        Be = e => Fe(e) ? e.jquery ? e[0] : e : "string" == typeof e && e.length > 0 ? document.querySelector(e) : null,
        je = (e, t, n) => {
            Object.keys(n).forEach(i => {
                const r = n[i], o = t[i],
                    a = o && Fe(o) ? "element" : null == (s = o) ? "" + s : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase();
                var s;
                if (!new RegExp(r).test(a)) throw new TypeError(`${e.toUpperCase()}: Option "${i}" provided type "${a}" but expected type "${r}".`)
            })
        },
        He = e => !(!Fe(e) || 0 === e.getClientRects().length) && "visible" === getComputedStyle(e).getPropertyValue("visibility"),
        Ne = e => !e || e.nodeType !== Node.ELEMENT_NODE || (!!e.classList.contains("disabled") || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled"))),
        Ue = e => {
            if (!document.documentElement.attachShadow) return null;
            if ("function" == typeof e.getRootNode) {
                const t = e.getRootNode();
                return t instanceof ShadowRoot ? t : null
            }
            return e instanceof ShadowRoot ? e : e.parentNode ? Ue(e.parentNode) : null
        }, We = () => {
        }, Ve = e => {
            e.offsetHeight
        }, Ge = () => {
            const {jQuery: e} = window;
            return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null
        }, qe = [], Ze = () => "rtl" === document.documentElement.dir, $e = e => {
            var t;
            t = () => {
                const t = Ge();
                if (t) {
                    const n = e.NAME, i = t.fn[n];
                    t.fn[n] = e.jQueryInterface, t.fn[n].Constructor = e, t.fn[n].noConflict = () => (t.fn[n] = i, e.jQueryInterface)
                }
            }, "loading" === document.readyState ? (qe.length || document.addEventListener("DOMContentLoaded", () => {
                qe.forEach(e => e())
            }), qe.push(t)) : t()
        }, Xe = e => {
            "function" == typeof e && e()
        }, Je = (e, t, n = !0) => {
            if (!n) return void Xe(e);
            const i = (e => {
                if (!e) return 0;
                let {transitionDuration: t, transitionDelay: n} = window.getComputedStyle(e);
                const i = Number.parseFloat(t), r = Number.parseFloat(n);
                return i || r ? (t = t.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(n))) : 0
            })(t) + 5;
            let r = !1;
            const o = ({target: n}) => {
                n === t && (r = !0, t.removeEventListener("transitionend", o), Xe(e))
            };
            t.addEventListener("transitionend", o), setTimeout(() => {
                r || Oe(t)
            }, i)
        }, Ke = (e, t, n, i) => {
            let r = e.indexOf(t);
            if (-1 === r) return e[!n && i ? e.length - 1 : 0];
            const o = e.length;
            return r += n ? 1 : -1, i && (r = (r + o) % o), e[Math.max(0, Math.min(r, o - 1))]
        }, Qe = /[^.]*(?=\..*)\.|.*/, et = /\..*/, tt = /::\d+$/, nt = {};
    let it = 1;
    const rt = {mouseenter: "mouseover", mouseleave: "mouseout"}, ot = /^(mouseenter|mouseleave)/i,
        at = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function st(e, t) {
        return t && `${t}::${it++}` || e.uidEvent || it++
    }

    function lt(e) {
        const t = st(e);
        return e.uidEvent = t, nt[t] = nt[t] || {}, nt[t]
    }

    function ct(e, t, n = null) {
        const i = Object.keys(e);
        for (let r = 0, o = i.length; r < o; r++) {
            const o = e[i[r]];
            if (o.originalHandler === t && o.delegationSelector === n) return o
        }
        return null
    }

    function ut(e, t, n) {
        const i = "string" == typeof t, r = i ? n : t;
        let o = pt(e);
        return at.has(o) || (o = e), [i, r, o]
    }

    function dt(e, t, n, i, r) {
        if ("string" != typeof t || !e) return;
        if (n || (n = i, i = null), ot.test(t)) {
            const e = e => function (t) {
                if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t)
            };
            i ? i = e(i) : n = e(n)
        }
        const [o, a, s] = ut(t, n, i), l = lt(e), c = l[s] || (l[s] = {}), u = ct(c, a, o ? n : null);
        if (u) return void (u.oneOff = u.oneOff && r);
        const d = st(a, t.replace(Qe, "")), h = o ? function (e, t, n) {
            return function i(r) {
                const o = e.querySelectorAll(t);
                for (let {target: a} = r; a && a !== this; a = a.parentNode) for (let s = o.length; s--;) if (o[s] === a) return r.delegateTarget = a, i.oneOff && ft.off(e, r.type, t, n), n.apply(a, [r]);
                return null
            }
        }(e, n, i) : function (e, t) {
            return function n(i) {
                return i.delegateTarget = e, n.oneOff && ft.off(e, i.type, t), t.apply(e, [i])
            }
        }(e, n);
        h.delegationSelector = o ? n : null, h.originalHandler = a, h.oneOff = r, h.uidEvent = d, c[d] = h, e.addEventListener(s, h, o)
    }

    function ht(e, t, n, i, r) {
        const o = ct(t[n], i, r);
        o && (e.removeEventListener(n, o, Boolean(r)), delete t[n][o.uidEvent])
    }

    function pt(e) {
        return e = e.replace(et, ""), rt[e] || e
    }

    const ft = {
        on(e, t, n, i) {
            dt(e, t, n, i, !1)
        }, one(e, t, n, i) {
            dt(e, t, n, i, !0)
        }, off(e, t, n, i) {
            if ("string" != typeof t || !e) return;
            const [r, o, a] = ut(t, n, i), s = a !== t, l = lt(e), c = t.startsWith(".");
            if (void 0 !== o) {
                if (!l || !l[a]) return;
                return void ht(e, l, a, o, r ? n : null)
            }
            c && Object.keys(l).forEach(n => {
                !function (e, t, n, i) {
                    const r = t[n] || {};
                    Object.keys(r).forEach(o => {
                        if (o.includes(i)) {
                            const i = r[o];
                            ht(e, t, n, i.originalHandler, i.delegationSelector)
                        }
                    })
                }(e, l, n, t.slice(1))
            });
            const u = l[a] || {};
            Object.keys(u).forEach(n => {
                const i = n.replace(tt, "");
                if (!s || t.includes(i)) {
                    const t = u[n];
                    ht(e, l, a, t.originalHandler, t.delegationSelector)
                }
            })
        }, trigger(e, t, n) {
            if ("string" != typeof t || !e) return null;
            const i = Ge(), r = pt(t), o = t !== r, a = at.has(r);
            let s, l = !0, c = !0, u = !1, d = null;
            return o && i && (s = i.Event(t, n), i(e).trigger(s), l = !s.isPropagationStopped(), c = !s.isImmediatePropagationStopped(), u = s.isDefaultPrevented()), a ? (d = document.createEvent("HTMLEvents"), d.initEvent(r, l, !0)) : d = new CustomEvent(t, {
                bubbles: l,
                cancelable: !0
            }), void 0 !== n && Object.keys(n).forEach(e => {
                Object.defineProperty(d, e, {get: () => n[e]})
            }), u && d.preventDefault(), c && e.dispatchEvent(d), d.defaultPrevented && void 0 !== s && s.preventDefault(), d
        }
    }, mt = new Map, _t = {
        set(e, t, n) {
            mt.has(e) || mt.set(e, new Map);
            const i = mt.get(e);
            i.has(t) || 0 === i.size ? i.set(t, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`)
        }, get: (e, t) => mt.has(e) && mt.get(e).get(t) || null, remove(e, t) {
            if (!mt.has(e)) return;
            const n = mt.get(e);
            n.delete(t), 0 === n.size && mt.delete(e)
        }
    };

    class gt {
        constructor(e) {
            (e = Be(e)) && (this._element = e, _t.set(this._element, this.constructor.DATA_KEY, this))
        }

        dispose() {
            _t.remove(this._element, this.constructor.DATA_KEY), ft.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(e => {
                this[e] = null
            })
        }

        _queueCallback(e, t, n = !0) {
            Je(e, t, n)
        }

        static getInstance(e) {
            return _t.get(Be(e), this.DATA_KEY)
        }

        static getOrCreateInstance(e, t = {}) {
            return this.getInstance(e) || new this(e, "object" == typeof t ? t : null)
        }

        static get VERSION() {
            return "5.1.3"
        }

        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }

        static get DATA_KEY() {
            return "bs." + this.NAME
        }

        static get EVENT_KEY() {
            return "." + this.DATA_KEY
        }
    }

    const yt = (e, t = "hide") => {
        const n = "click.dismiss" + e.EVENT_KEY, i = e.NAME;
        ft.on(document, n, `[data-bs-dismiss="${i}"]`, (function (n) {
            if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Ne(this)) return;
            const r = ze(this) || this.closest("." + i);
            e.getOrCreateInstance(r)[t]()
        }))
    };

    class vt extends gt {
        static get NAME() {
            return "alert"
        }

        close() {
            if (ft.trigger(this._element, "close.bs.alert").defaultPrevented) return;
            this._element.classList.remove("show");
            const e = this._element.classList.contains("fade");
            this._queueCallback(() => this._destroyElement(), this._element, e)
        }

        _destroyElement() {
            this._element.remove(), ft.trigger(this._element, "closed.bs.alert"), this.dispose()
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = vt.getOrCreateInstance(this);
                if ("string" == typeof e) {
                    if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`);
                    t[e](this)
                }
            }))
        }
    }

    yt(vt, "close"), $e(vt);

    class xt extends gt {
        static get NAME() {
            return "button"
        }

        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = xt.getOrCreateInstance(this);
                "toggle" === e && t[e]()
            }))
        }
    }

    function bt(e) {
        return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e)
    }

    function wt(e) {
        return e.replace(/[A-Z]/g, e => "-" + e.toLowerCase())
    }

    ft.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', e => {
        e.preventDefault();
        const t = e.target.closest('[data-bs-toggle="button"]');
        xt.getOrCreateInstance(t).toggle()
    }), $e(xt);
    const Mt = {
            setDataAttribute(e, t, n) {
                e.setAttribute("data-bs-" + wt(t), n)
            }, removeDataAttribute(e, t) {
                e.removeAttribute("data-bs-" + wt(t))
            }, getDataAttributes(e) {
                if (!e) return {};
                const t = {};
                return Object.keys(e.dataset).filter(e => e.startsWith("bs")).forEach(n => {
                    let i = n.replace(/^bs/, "");
                    i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = bt(e.dataset[n])
                }), t
            }, getDataAttribute: (e, t) => bt(e.getAttribute("data-bs-" + wt(t))), offset(e) {
                const t = e.getBoundingClientRect();
                return {top: t.top + window.pageYOffset, left: t.left + window.pageXOffset}
            }, position: e => ({top: e.offsetTop, left: e.offsetLeft})
        }, Tt = {
            find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)),
            findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e),
            children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)),
            parents(e, t) {
                const n = [];
                let i = e.parentNode;
                for (; i && i.nodeType === Node.ELEMENT_NODE && 3 !== i.nodeType;) i.matches(t) && n.push(i), i = i.parentNode;
                return n
            },
            prev(e, t) {
                let n = e.previousElementSibling;
                for (; n;) {
                    if (n.matches(t)) return [n];
                    n = n.previousElementSibling
                }
                return []
            },
            next(e, t) {
                let n = e.nextElementSibling;
                for (; n;) {
                    if (n.matches(t)) return [n];
                    n = n.nextElementSibling
                }
                return []
            },
            focusableChildren(e) {
                const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => e + ':not([tabindex^="-"])').join(", ");
                return this.find(t, e).filter(e => !Ne(e) && He(e))
            }
        }, kt = ".bs.carousel", St = {interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0}, Dt = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        }, Lt = "next", Et = "prev", Ct = "left", At = "right", It = {ArrowLeft: At, ArrowRight: Ct},
        Pt = `load${kt}.data-api`, Rt = `click${kt}.data-api`;

    class Yt extends gt {
        constructor(e, t) {
            super(e), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(t), this._indicatorsElement = Tt.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners()
        }

        static get Default() {
            return St
        }

        static get NAME() {
            return "carousel"
        }

        next() {
            this._slide(Lt)
        }

        nextWhenVisible() {
            !document.hidden && He(this._element) && this.next()
        }

        prev() {
            this._slide(Et)
        }

        pause(e) {
            e || (this._isPaused = !0), Tt.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (Oe(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
        }

        cycle(e) {
            e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
        }

        to(e) {
            this._activeElement = Tt.findOne(".active.carousel-item", this._element);
            const t = this._getItemIndex(this._activeElement);
            if (e > this._items.length - 1 || e < 0) return;
            if (this._isSliding) return void ft.one(this._element, "slid.bs.carousel", () => this.to(e));
            if (t === e) return this.pause(), void this.cycle();
            const n = e > t ? Lt : Et;
            this._slide(n, this._items[e])
        }

        _getConfig(e) {
            return e = {...St, ...Mt.getDataAttributes(this._element), ..."object" == typeof e ? e : {}}, je("carousel", e, Dt), e
        }

        _handleSwipe() {
            const e = Math.abs(this.touchDeltaX);
            if (e <= 40) return;
            const t = e / this.touchDeltaX;
            this.touchDeltaX = 0, t && this._slide(t > 0 ? At : Ct)
        }

        _addEventListeners() {
            this._config.keyboard && ft.on(this._element, "keydown.bs.carousel", e => this._keydown(e)), "hover" === this._config.pause && (ft.on(this._element, "mouseenter.bs.carousel", e => this.pause(e)), ft.on(this._element, "mouseleave.bs.carousel", e => this.cycle(e))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
        }

        _addTouchEventListeners() {
            const e = e => this._pointerEvent && ("pen" === e.pointerType || "touch" === e.pointerType), t = t => {
                e(t) ? this.touchStartX = t.clientX : this._pointerEvent || (this.touchStartX = t.touches[0].clientX)
            }, n = e => {
                this.touchDeltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this.touchStartX
            }, i = t => {
                e(t) && (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(e => this.cycle(e), 500 + this._config.interval))
            };
            Tt.find(".carousel-item img", this._element).forEach(e => {
                ft.on(e, "dragstart.bs.carousel", e => e.preventDefault())
            }), this._pointerEvent ? (ft.on(this._element, "pointerdown.bs.carousel", e => t(e)), ft.on(this._element, "pointerup.bs.carousel", e => i(e)), this._element.classList.add("pointer-event")) : (ft.on(this._element, "touchstart.bs.carousel", e => t(e)), ft.on(this._element, "touchmove.bs.carousel", e => n(e)), ft.on(this._element, "touchend.bs.carousel", e => i(e)))
        }

        _keydown(e) {
            if (/input|textarea/i.test(e.target.tagName)) return;
            const t = It[e.key];
            t && (e.preventDefault(), this._slide(t))
        }

        _getItemIndex(e) {
            return this._items = e && e.parentNode ? Tt.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e)
        }

        _getItemByOrder(e, t) {
            const n = e === Lt;
            return Ke(this._items, t, n, this._config.wrap)
        }

        _triggerSlideEvent(e, t) {
            const n = this._getItemIndex(e), i = this._getItemIndex(Tt.findOne(".active.carousel-item", this._element));
            return ft.trigger(this._element, "slide.bs.carousel", {relatedTarget: e, direction: t, from: i, to: n})
        }

        _setActiveIndicatorElement(e) {
            if (this._indicatorsElement) {
                const t = Tt.findOne(".active", this._indicatorsElement);
                t.classList.remove("active"), t.removeAttribute("aria-current");
                const n = Tt.find("[data-bs-target]", this._indicatorsElement);
                for (let t = 0; t < n.length; t++) if (Number.parseInt(n[t].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e)) {
                    n[t].classList.add("active"), n[t].setAttribute("aria-current", "true");
                    break
                }
            }
        }

        _updateInterval() {
            const e = this._activeElement || Tt.findOne(".active.carousel-item", this._element);
            if (!e) return;
            const t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
            t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval
        }

        _slide(e, t) {
            const n = this._directionToOrder(e), i = Tt.findOne(".active.carousel-item", this._element),
                r = this._getItemIndex(i), o = t || this._getItemByOrder(n, i), a = this._getItemIndex(o),
                s = Boolean(this._interval), l = n === Lt, c = l ? "carousel-item-start" : "carousel-item-end",
                u = l ? "carousel-item-next" : "carousel-item-prev", d = this._orderToDirection(n);
            if (o && o.classList.contains("active")) return void (this._isSliding = !1);
            if (this._isSliding) return;
            if (this._triggerSlideEvent(o, d).defaultPrevented) return;
            if (!i || !o) return;
            this._isSliding = !0, s && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;
            const h = () => {
                ft.trigger(this._element, "slid.bs.carousel", {relatedTarget: o, direction: d, from: r, to: a})
            };
            if (this._element.classList.contains("slide")) {
                o.classList.add(u), Ve(o), i.classList.add(c), o.classList.add(c);
                const e = () => {
                    o.classList.remove(c, u), o.classList.add("active"), i.classList.remove("active", u, c), this._isSliding = !1, setTimeout(h, 0)
                };
                this._queueCallback(e, i, !0)
            } else i.classList.remove("active"), o.classList.add("active"), this._isSliding = !1, h();
            s && this.cycle()
        }

        _directionToOrder(e) {
            return [At, Ct].includes(e) ? Ze() ? e === Ct ? Et : Lt : e === Ct ? Lt : Et : e
        }

        _orderToDirection(e) {
            return [Lt, Et].includes(e) ? Ze() ? e === Et ? Ct : At : e === Et ? At : Ct : e
        }

        static carouselInterface(e, t) {
            const n = Yt.getOrCreateInstance(e, t);
            let {_config: i} = n;
            "object" == typeof t && (i = {...i, ...t});
            const r = "string" == typeof t ? t : i.slide;
            if ("number" == typeof t) n.to(t); else if ("string" == typeof r) {
                if (void 0 === n[r]) throw new TypeError(`No method named "${r}"`);
                n[r]()
            } else i.interval && i.ride && (n.pause(), n.cycle())
        }

        static jQueryInterface(e) {
            return this.each((function () {
                Yt.carouselInterface(this, e)
            }))
        }

        static dataApiClickHandler(e) {
            const t = ze(this);
            if (!t || !t.classList.contains("carousel")) return;
            const n = {...Mt.getDataAttributes(t), ...Mt.getDataAttributes(this)},
                i = this.getAttribute("data-bs-slide-to");
            i && (n.interval = !1), Yt.carouselInterface(t, n), i && Yt.getInstance(t).to(i), e.preventDefault()
        }
    }

    ft.on(document, Rt, "[data-bs-slide], [data-bs-slide-to]", Yt.dataApiClickHandler), ft.on(window, Pt, () => {
        const e = Tt.find('[data-bs-ride="carousel"]');
        for (let t = 0, n = e.length; t < n; t++) Yt.carouselInterface(e[t], Yt.getInstance(e[t]))
    }), $e(Yt);
    const zt = {toggle: !0, parent: null}, Ot = {toggle: "boolean", parent: "(null|element)"};

    class Ft extends gt {
        constructor(e, t) {
            super(e), this._isTransitioning = !1, this._config = this._getConfig(t), this._triggerArray = [];
            const n = Tt.find('[data-bs-toggle="collapse"]');
            for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e], i = Ye(t), r = Tt.find(i).filter(e => e === this._element);
                null !== i && r.length && (this._selector = i, this._triggerArray.push(t))
            }
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
        }

        static get Default() {
            return zt
        }

        static get NAME() {
            return "collapse"
        }

        toggle() {
            this._isShown() ? this.hide() : this.show()
        }

        show() {
            if (this._isTransitioning || this._isShown()) return;
            let e, t = [];
            if (this._config.parent) {
                const e = Tt.find(":scope .collapse .collapse", this._config.parent);
                t = Tt.find(".collapse.show, .collapse.collapsing", this._config.parent).filter(t => !e.includes(t))
            }
            const n = Tt.findOne(this._selector);
            if (t.length) {
                const i = t.find(e => n !== e);
                if (e = i ? Ft.getInstance(i) : null, e && e._isTransitioning) return
            }
            if (ft.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
            t.forEach(t => {
                n !== t && Ft.getOrCreateInstance(t, {toggle: !1}).hide(), e || _t.set(t, "bs.collapse", null)
            });
            const i = this._getDimension();
            this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[i] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
            const r = "scroll" + (i[0].toUpperCase() + i.slice(1));
            this._queueCallback(() => {
                this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[i] = "", ft.trigger(this._element, "shown.bs.collapse")
            }, this._element, !0), this._element.style[i] = this._element[r] + "px"
        }

        hide() {
            if (this._isTransitioning || !this._isShown()) return;
            if (ft.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
            const e = this._getDimension();
            this._element.style[e] = this._element.getBoundingClientRect()[e] + "px", Ve(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
            const t = this._triggerArray.length;
            for (let e = 0; e < t; e++) {
                const t = this._triggerArray[e], n = ze(t);
                n && !this._isShown(n) && this._addAriaAndCollapsedClass([t], !1)
            }
            this._isTransitioning = !0;
            this._element.style[e] = "", this._queueCallback(() => {
                this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), ft.trigger(this._element, "hidden.bs.collapse")
            }, this._element, !0)
        }

        _isShown(e = this._element) {
            return e.classList.contains("show")
        }

        _getConfig(e) {
            return (e = {...zt, ...Mt.getDataAttributes(this._element), ...e}).toggle = Boolean(e.toggle), e.parent = Be(e.parent), je("collapse", e, Ot), e
        }

        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
        }

        _initializeChildren() {
            if (!this._config.parent) return;
            const e = Tt.find(":scope .collapse .collapse", this._config.parent);
            Tt.find('[data-bs-toggle="collapse"]', this._config.parent).filter(t => !e.includes(t)).forEach(e => {
                const t = ze(e);
                t && this._addAriaAndCollapsedClass([e], this._isShown(t))
            })
        }

        _addAriaAndCollapsedClass(e, t) {
            e.length && e.forEach(e => {
                t ? e.classList.remove("collapsed") : e.classList.add("collapsed"), e.setAttribute("aria-expanded", t)
            })
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = {};
                "string" == typeof e && /show|hide/.test(e) && (t.toggle = !1);
                const n = Ft.getOrCreateInstance(this, t);
                if ("string" == typeof e) {
                    if (void 0 === n[e]) throw new TypeError(`No method named "${e}"`);
                    n[e]()
                }
            }))
        }
    }

    ft.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function (e) {
        ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault();
        const t = Ye(this);
        Tt.find(t).forEach(e => {
            Ft.getOrCreateInstance(e, {toggle: !1}).toggle()
        })
    })), $e(Ft);
    const Bt = new RegExp("ArrowUp|ArrowDown|Escape"), jt = Ze() ? "top-end" : "top-start",
        Ht = Ze() ? "top-start" : "top-end", Nt = Ze() ? "bottom-end" : "bottom-start",
        Ut = Ze() ? "bottom-start" : "bottom-end", Wt = Ze() ? "left-start" : "right-start",
        Vt = Ze() ? "right-start" : "left-start", Gt = {
            offset: [0, 2],
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null,
            autoClose: !0
        }, qt = {
            offset: "(array|string|function)",
            boundary: "(string|element)",
            reference: "(string|element|object)",
            display: "string",
            popperConfig: "(null|object|function)",
            autoClose: "(boolean|string)"
        };

    class Zt extends gt {
        constructor(e, t) {
            super(e), this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar()
        }

        static get Default() {
            return Gt
        }

        static get DefaultType() {
            return qt
        }

        static get NAME() {
            return "dropdown"
        }

        toggle() {
            return this._isShown() ? this.hide() : this.show()
        }

        show() {
            if (Ne(this._element) || this._isShown(this._menu)) return;
            const e = {relatedTarget: this._element};
            if (ft.trigger(this._element, "show.bs.dropdown", e).defaultPrevented) return;
            const t = Zt.getParentFromElement(this._element);
            this._inNavbar ? Mt.setDataAttribute(this._menu, "popper", "none") : this._createPopper(t), "ontouchstart" in document.documentElement && !t.closest(".navbar-nav") && [].concat(...document.body.children).forEach(e => ft.on(e, "mouseover", We)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add("show"), this._element.classList.add("show"), ft.trigger(this._element, "shown.bs.dropdown", e)
        }

        hide() {
            if (Ne(this._element) || !this._isShown(this._menu)) return;
            const e = {relatedTarget: this._element};
            this._completeHide(e)
        }

        dispose() {
            this._popper && this._popper.destroy(), super.dispose()
        }

        update() {
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
        }

        _completeHide(e) {
            ft.trigger(this._element, "hide.bs.dropdown", e).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(e => ft.off(e, "mouseover", We)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), Mt.removeDataAttribute(this._menu, "popper"), ft.trigger(this._element, "hidden.bs.dropdown", e))
        }

        _getConfig(e) {
            if (e = {...this.constructor.Default, ...Mt.getDataAttributes(this._element), ...e}, je("dropdown", e, this.constructor.DefaultType), "object" == typeof e.reference && !Fe(e.reference) && "function" != typeof e.reference.getBoundingClientRect) throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
            return e
        }

        _createPopper(e) {
            if (void 0 === i) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let t = this._element;
            "parent" === this._config.reference ? t = e : Fe(this._config.reference) ? t = Be(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
            const n = this._getPopperConfig(), r = n.modifiers.find(e => "applyStyles" === e.name && !1 === e.enabled);
            this._popper = Ie(t, this._menu, n), r && Mt.setDataAttribute(this._menu, "popper", "static")
        }

        _isShown(e = this._element) {
            return e.classList.contains("show")
        }

        _getMenuElement() {
            return Tt.next(this._element, ".dropdown-menu")[0]
        }

        _getPlacement() {
            const e = this._element.parentNode;
            if (e.classList.contains("dropend")) return Wt;
            if (e.classList.contains("dropstart")) return Vt;
            const t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return e.classList.contains("dropup") ? t ? Ht : jt : t ? Ut : Nt
        }

        _detectNavbar() {
            return null !== this._element.closest(".navbar")
        }

        _getOffset() {
            const {offset: e} = this._config;
            return "string" == typeof e ? e.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof e ? t => e(t, this._element) : e
        }

        _getPopperConfig() {
            const e = {
                placement: this._getPlacement(),
                modifiers: [{name: "preventOverflow", options: {boundary: this._config.boundary}}, {
                    name: "offset",
                    options: {offset: this._getOffset()}
                }]
            };
            return "static" === this._config.display && (e.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]), {...e, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig}
        }

        _selectMenuItem({key: e, target: t}) {
            const n = Tt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(He);
            n.length && Ke(n, t, "ArrowDown" === e, !n.includes(t)).focus()
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = Zt.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e]()
                }
            }))
        }

        static clearMenus(e) {
            if (e && (2 === e.button || "keyup" === e.type && "Tab" !== e.key)) return;
            const t = Tt.find('[data-bs-toggle="dropdown"]');
            for (let n = 0, i = t.length; n < i; n++) {
                const i = Zt.getInstance(t[n]);
                if (!i || !1 === i._config.autoClose) continue;
                if (!i._isShown()) continue;
                const r = {relatedTarget: i._element};
                if (e) {
                    const t = e.composedPath(), n = t.includes(i._menu);
                    if (t.includes(i._element) || "inside" === i._config.autoClose && !n || "outside" === i._config.autoClose && n) continue;
                    if (i._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName))) continue;
                    "click" === e.type && (r.clickEvent = e)
                }
                i._completeHide(r)
            }
        }

        static getParentFromElement(e) {
            return ze(e) || e.parentNode
        }

        static dataApiKeydownHandler(e) {
            if (/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !Bt.test(e.key)) return;
            const t = this.classList.contains("show");
            if (!t && "Escape" === e.key) return;
            if (e.preventDefault(), e.stopPropagation(), Ne(this)) return;
            const n = this.matches('[data-bs-toggle="dropdown"]') ? this : Tt.prev(this, '[data-bs-toggle="dropdown"]')[0],
                i = Zt.getOrCreateInstance(n);
            if ("Escape" !== e.key) return "ArrowUp" === e.key || "ArrowDown" === e.key ? (t || i.show(), void i._selectMenuItem(e)) : void (t && "Space" !== e.key || Zt.clearMenus());
            i.hide()
        }
    }

    ft.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', Zt.dataApiKeydownHandler), ft.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", Zt.dataApiKeydownHandler), ft.on(document, "click.bs.dropdown.data-api", Zt.clearMenus), ft.on(document, "keyup.bs.dropdown.data-api", Zt.clearMenus), ft.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function (e) {
        e.preventDefault(), Zt.getOrCreateInstance(this).toggle()
    })), $e(Zt);

    class $t {
        constructor() {
            this._element = document.body
        }

        getWidth() {
            const e = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - e)
        }

        hide() {
            const e = this.getWidth();
            this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", t => t + e), this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", t => t + e), this._setElementAttributes(".sticky-top", "marginRight", t => t - e)
        }

        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
        }

        _setElementAttributes(e, t, n) {
            const i = this.getWidth();
            this._applyManipulationCallback(e, e => {
                if (e !== this._element && window.innerWidth > e.clientWidth + i) return;
                this._saveInitialAttribute(e, t);
                const r = window.getComputedStyle(e)[t];
                e.style[t] = n(Number.parseFloat(r)) + "px"
            })
        }

        reset() {
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), this._resetElementAttributes(".sticky-top", "marginRight")
        }

        _saveInitialAttribute(e, t) {
            const n = e.style[t];
            n && Mt.setDataAttribute(e, t, n)
        }

        _resetElementAttributes(e, t) {
            this._applyManipulationCallback(e, e => {
                const n = Mt.getDataAttribute(e, t);
                void 0 === n ? e.style.removeProperty(t) : (Mt.removeDataAttribute(e, t), e.style[t] = n)
            })
        }

        _applyManipulationCallback(e, t) {
            Fe(e) ? t(e) : Tt.find(e, this._element).forEach(t)
        }

        isOverflowing() {
            return this.getWidth() > 0
        }
    }

    const Xt = {className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null},
        Jt = {
            className: "string",
            isVisible: "boolean",
            isAnimated: "boolean",
            rootElement: "(element|string)",
            clickCallback: "(function|null)"
        };

    class Kt {
        constructor(e) {
            this._config = this._getConfig(e), this._isAppended = !1, this._element = null
        }

        show(e) {
            this._config.isVisible ? (this._append(), this._config.isAnimated && Ve(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => {
                Xe(e)
            })) : Xe(e)
        }

        hide(e) {
            this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
                this.dispose(), Xe(e)
            })) : Xe(e)
        }

        _getElement() {
            if (!this._element) {
                const e = document.createElement("div");
                e.className = this._config.className, this._config.isAnimated && e.classList.add("fade"), this._element = e
            }
            return this._element
        }

        _getConfig(e) {
            return (e = {...Xt, ..."object" == typeof e ? e : {}}).rootElement = Be(e.rootElement), je("backdrop", e, Jt), e
        }

        _append() {
            this._isAppended || (this._config.rootElement.append(this._getElement()), ft.on(this._getElement(), "mousedown.bs.backdrop", () => {
                Xe(this._config.clickCallback)
            }), this._isAppended = !0)
        }

        dispose() {
            this._isAppended && (ft.off(this._element, "mousedown.bs.backdrop"), this._element.remove(), this._isAppended = !1)
        }

        _emulateAnimation(e) {
            Je(e, this._getElement(), this._config.isAnimated)
        }
    }

    const Qt = {trapElement: null, autofocus: !0}, en = {trapElement: "element", autofocus: "boolean"};

    class tn {
        constructor(e) {
            this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null
        }

        activate() {
            const {trapElement: e, autofocus: t} = this._config;
            this._isActive || (t && e.focus(), ft.off(document, ".bs.focustrap"), ft.on(document, "focusin.bs.focustrap", e => this._handleFocusin(e)), ft.on(document, "keydown.tab.bs.focustrap", e => this._handleKeydown(e)), this._isActive = !0)
        }

        deactivate() {
            this._isActive && (this._isActive = !1, ft.off(document, ".bs.focustrap"))
        }

        _handleFocusin(e) {
            const {target: t} = e, {trapElement: n} = this._config;
            if (t === document || t === n || n.contains(t)) return;
            const i = Tt.focusableChildren(n);
            0 === i.length ? n.focus() : "backward" === this._lastTabNavDirection ? i[i.length - 1].focus() : i[0].focus()
        }

        _handleKeydown(e) {
            "Tab" === e.key && (this._lastTabNavDirection = e.shiftKey ? "backward" : "forward")
        }

        _getConfig(e) {
            return e = {...Qt, ..."object" == typeof e ? e : {}}, je("focustrap", e, en), e
        }
    }

    const nn = {backdrop: !0, keyboard: !0, focus: !0},
        rn = {backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean"};

    class on extends gt {
        constructor(e, t) {
            super(e), this._config = this._getConfig(t), this._dialog = Tt.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new $t
        }

        static get Default() {
            return nn
        }

        static get NAME() {
            return "modal"
        }

        toggle(e) {
            return this._isShown ? this.hide() : this.show(e)
        }

        show(e) {
            if (this._isShown || this._isTransitioning) return;
            ft.trigger(this._element, "show.bs.modal", {relatedTarget: e}).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), ft.on(this._dialog, "mousedown.dismiss.bs.modal", () => {
                ft.one(this._element, "mouseup.dismiss.bs.modal", e => {
                    e.target === this._element && (this._ignoreBackdropClick = !0)
                })
            }), this._showBackdrop(() => this._showElement(e)))
        }

        hide() {
            if (!this._isShown || this._isTransitioning) return;
            if (ft.trigger(this._element, "hide.bs.modal").defaultPrevented) return;
            this._isShown = !1;
            const e = this._isAnimated();
            e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove("show"), ft.off(this._element, "click.dismiss.bs.modal"), ft.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, e)
        }

        dispose() {
            [window, this._dialog].forEach(e => ft.off(e, ".bs.modal")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
        }

        handleUpdate() {
            this._adjustDialog()
        }

        _initializeBackDrop() {
            return new Kt({isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated()})
        }

        _initializeFocusTrap() {
            return new tn({trapElement: this._element})
        }

        _getConfig(e) {
            return e = {...nn, ...Mt.getDataAttributes(this._element), ..."object" == typeof e ? e : {}}, je("modal", e, rn), e
        }

        _showElement(e) {
            const t = this._isAnimated(), n = Tt.findOne(".modal-body", this._dialog);
            this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), t && Ve(this._element), this._element.classList.add("show");
            this._queueCallback(() => {
                this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, ft.trigger(this._element, "shown.bs.modal", {relatedTarget: e})
            }, this._dialog, t)
        }

        _setEscapeEvent() {
            this._isShown ? ft.on(this._element, "keydown.dismiss.bs.modal", e => {
                this._config.keyboard && "Escape" === e.key ? (e.preventDefault(), this.hide()) : this._config.keyboard || "Escape" !== e.key || this._triggerBackdropTransition()
            }) : ft.off(this._element, "keydown.dismiss.bs.modal")
        }

        _setResizeEvent() {
            this._isShown ? ft.on(window, "resize.bs.modal", () => this._adjustDialog()) : ft.off(window, "resize.bs.modal")
        }

        _hideModal() {
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
                document.body.classList.remove("modal-open"), this._resetAdjustments(), this._scrollBar.reset(), ft.trigger(this._element, "hidden.bs.modal")
            })
        }

        _showBackdrop(e) {
            ft.on(this._element, "click.dismiss.bs.modal", e => {
                this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : e.target === e.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition())
            }), this._backdrop.show(e)
        }

        _isAnimated() {
            return this._element.classList.contains("fade")
        }

        _triggerBackdropTransition() {
            if (ft.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
            const {classList: e, scrollHeight: t, style: n} = this._element,
                i = t > document.documentElement.clientHeight;
            !i && "hidden" === n.overflowY || e.contains("modal-static") || (i || (n.overflowY = "hidden"), e.add("modal-static"), this._queueCallback(() => {
                e.remove("modal-static"), i || this._queueCallback(() => {
                    n.overflowY = ""
                }, this._dialog)
            }, this._dialog), this._element.focus())
        }

        _adjustDialog() {
            const e = this._element.scrollHeight > document.documentElement.clientHeight,
                t = this._scrollBar.getWidth(), n = t > 0;
            (!n && e && !Ze() || n && !e && Ze()) && (this._element.style.paddingLeft = t + "px"), (n && !e && !Ze() || !n && e && Ze()) && (this._element.style.paddingRight = t + "px")
        }

        _resetAdjustments() {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
        }

        static jQueryInterface(e, t) {
            return this.each((function () {
                const n = on.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === n[e]) throw new TypeError(`No method named "${e}"`);
                    n[e](t)
                }
            }))
        }
    }

    ft.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (e) {
        const t = ze(this);
        ["A", "AREA"].includes(this.tagName) && e.preventDefault(), ft.one(t, "show.bs.modal", e => {
            e.defaultPrevented || ft.one(t, "hidden.bs.modal", () => {
                He(this) && this.focus()
            })
        });
        const n = Tt.findOne(".modal.show");
        n && on.getInstance(n).hide();
        on.getOrCreateInstance(t).toggle(this)
    })), yt(on), $e(on);
    const an = {backdrop: !0, keyboard: !0, scroll: !1},
        sn = {backdrop: "boolean", keyboard: "boolean", scroll: "boolean"};

    class ln extends gt {
        constructor(e, t) {
            super(e), this._config = this._getConfig(t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
        }

        static get NAME() {
            return "offcanvas"
        }

        static get Default() {
            return an
        }

        toggle(e) {
            return this._isShown ? this.hide() : this.show(e)
        }

        show(e) {
            if (this._isShown) return;
            if (ft.trigger(this._element, "show.bs.offcanvas", {relatedTarget: e}).defaultPrevented) return;
            this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (new $t).hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add("show");
            this._queueCallback(() => {
                this._config.scroll || this._focustrap.activate(), ft.trigger(this._element, "shown.bs.offcanvas", {relatedTarget: e})
            }, this._element, !0)
        }

        hide() {
            if (!this._isShown) return;
            if (ft.trigger(this._element, "hide.bs.offcanvas").defaultPrevented) return;
            this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove("show"), this._backdrop.hide();
            this._queueCallback(() => {
                this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || (new $t).reset(), ft.trigger(this._element, "hidden.bs.offcanvas")
            }, this._element, !0)
        }

        dispose() {
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
        }

        _getConfig(e) {
            return e = {...an, ...Mt.getDataAttributes(this._element), ..."object" == typeof e ? e : {}}, je("offcanvas", e, sn), e
        }

        _initializeBackDrop() {
            return new Kt({
                className: "offcanvas-backdrop",
                isVisible: this._config.backdrop,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: () => this.hide()
            })
        }

        _initializeFocusTrap() {
            return new tn({trapElement: this._element})
        }

        _addEventListeners() {
            ft.on(this._element, "keydown.dismiss.bs.offcanvas", e => {
                this._config.keyboard && "Escape" === e.key && this.hide()
            })
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = ln.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`);
                    t[e](this)
                }
            }))
        }
    }

    ft.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function (e) {
        const t = ze(this);
        if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), Ne(this)) return;
        ft.one(t, "hidden.bs.offcanvas", () => {
            He(this) && this.focus()
        });
        const n = Tt.findOne(".offcanvas.show");
        n && n !== t && ln.getInstance(n).hide();
        ln.getOrCreateInstance(t).toggle(this)
    })), ft.on(window, "load.bs.offcanvas.data-api", () => Tt.find(".offcanvas.show").forEach(e => ln.getOrCreateInstance(e).show())), yt(ln), $e(ln);
    const cn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        un = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
        dn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
        hn = (e, t) => {
            const n = e.nodeName.toLowerCase();
            if (t.includes(n)) return !cn.has(n) || Boolean(un.test(e.nodeValue) || dn.test(e.nodeValue));
            const i = t.filter(e => e instanceof RegExp);
            for (let e = 0, t = i.length; e < t; e++) if (i[e].test(n)) return !0;
            return !1
        }, pn = {
            "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
            a: ["target", "href", "title", "rel"],
            area: [],
            b: [],
            br: [],
            col: [],
            code: [],
            div: [],
            em: [],
            hr: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            i: [],
            img: ["src", "srcset", "alt", "title", "width", "height"],
            li: [],
            ol: [],
            p: [],
            pre: [],
            s: [],
            small: [],
            span: [],
            sub: [],
            sup: [],
            strong: [],
            u: [],
            ul: []
        };

    function fn(e, t, n) {
        if (!e.length) return e;
        if (n && "function" == typeof n) return n(e);
        const i = (new window.DOMParser).parseFromString(e, "text/html"),
            r = [].concat(...i.body.querySelectorAll("*"));
        for (let e = 0, n = r.length; e < n; e++) {
            const n = r[e], i = n.nodeName.toLowerCase();
            if (!Object.keys(t).includes(i)) {
                n.remove();
                continue
            }
            const o = [].concat(...n.attributes), a = [].concat(t["*"] || [], t[i] || []);
            o.forEach(e => {
                hn(e, a) || n.removeAttribute(e.nodeName)
            })
        }
        return i.body.innerHTML
    }

    const mn = new Set(["sanitize", "allowList", "sanitizeFn"]), _n = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            offset: "(array|string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "array",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object|function)"
        }, gn = {AUTO: "auto", TOP: "top", RIGHT: Ze() ? "left" : "right", BOTTOM: "bottom", LEFT: Ze() ? "right" : "left"},
        yn = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            selector: !1,
            placement: "top",
            offset: [0, 0],
            container: !1,
            fallbackPlacements: ["top", "right", "bottom", "left"],
            boundary: "clippingParents",
            customClass: "",
            sanitize: !0,
            sanitizeFn: null,
            allowList: pn,
            popperConfig: null
        }, vn = {
            HIDE: "hide.bs.tooltip",
            HIDDEN: "hidden.bs.tooltip",
            SHOW: "show.bs.tooltip",
            SHOWN: "shown.bs.tooltip",
            INSERTED: "inserted.bs.tooltip",
            CLICK: "click.bs.tooltip",
            FOCUSIN: "focusin.bs.tooltip",
            FOCUSOUT: "focusout.bs.tooltip",
            MOUSEENTER: "mouseenter.bs.tooltip",
            MOUSELEAVE: "mouseleave.bs.tooltip"
        };

    class xn extends gt {
        constructor(e, t) {
            if (void 0 === i) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(e), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(t), this.tip = null, this._setListeners()
        }

        static get Default() {
            return yn
        }

        static get NAME() {
            return "tooltip"
        }

        static get Event() {
            return vn
        }

        static get DefaultType() {
            return _n
        }

        enable() {
            this._isEnabled = !0
        }

        disable() {
            this._isEnabled = !1
        }

        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }

        toggle(e) {
            if (this._isEnabled) if (e) {
                const t = this._initializeOnDelegatedTarget(e);
                t._activeTrigger.click = !t._activeTrigger.click, t._isWithActiveTrigger() ? t._enter(null, t) : t._leave(null, t)
            } else {
                if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
                this._enter(null, this)
            }
        }

        dispose() {
            clearTimeout(this._timeout), ft.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose()
        }

        show() {
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
            if (!this.isWithContent() || !this._isEnabled) return;
            const e = ft.trigger(this._element, this.constructor.Event.SHOW), t = Ue(this._element),
                n = null === t ? this._element.ownerDocument.documentElement.contains(this._element) : t.contains(this._element);
            if (e.defaultPrevented || !n) return;
            "tooltip" === this.constructor.NAME && this.tip && this.getTitle() !== this.tip.querySelector(".tooltip-inner").innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
            const i = this.getTipElement(), r = (e => {
                do {
                    e += Math.floor(1e6 * Math.random())
                } while (document.getElementById(e));
                return e
            })(this.constructor.NAME);
            i.setAttribute("id", r), this._element.setAttribute("aria-describedby", r), this._config.animation && i.classList.add("fade");
            const o = "function" == typeof this._config.placement ? this._config.placement.call(this, i, this._element) : this._config.placement,
                a = this._getAttachment(o);
            this._addAttachmentClass(a);
            const {container: s} = this._config;
            _t.set(i, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), ft.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ie(this._element, i, this._getPopperConfig(a)), i.classList.add("show");
            const l = this._resolvePossibleFunction(this._config.customClass);
            l && i.classList.add(...l.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(e => {
                ft.on(e, "mouseover", We)
            });
            const c = this.tip.classList.contains("fade");
            this._queueCallback(() => {
                const e = this._hoverState;
                this._hoverState = null, ft.trigger(this._element, this.constructor.Event.SHOWN), "out" === e && this._leave(null, this)
            }, this.tip, c)
        }

        hide() {
            if (!this._popper) return;
            const e = this.getTipElement();
            if (ft.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;
            e.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(e => ft.off(e, "mouseover", We)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1;
            const t = this.tip.classList.contains("fade");
            this._queueCallback(() => {
                this._isWithActiveTrigger() || ("show" !== this._hoverState && e.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), ft.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper())
            }, this.tip, t), this._hoverState = ""
        }

        update() {
            null !== this._popper && this._popper.update()
        }

        isWithContent() {
            return Boolean(this.getTitle())
        }

        getTipElement() {
            if (this.tip) return this.tip;
            const e = document.createElement("div");
            e.innerHTML = this._config.template;
            const t = e.children[0];
            return this.setContent(t), t.classList.remove("fade", "show"), this.tip = t, this.tip
        }

        setContent(e) {
            this._sanitizeAndSetContent(e, this.getTitle(), ".tooltip-inner")
        }

        _sanitizeAndSetContent(e, t, n) {
            const i = Tt.findOne(n, e);
            t || !i ? this.setElementContent(i, t) : i.remove()
        }

        setElementContent(e, t) {
            if (null !== e) return Fe(t) ? (t = Be(t), void (this._config.html ? t.parentNode !== e && (e.innerHTML = "", e.append(t)) : e.textContent = t.textContent)) : void (this._config.html ? (this._config.sanitize && (t = fn(t, this._config.allowList, this._config.sanitizeFn)), e.innerHTML = t) : e.textContent = t)
        }

        getTitle() {
            const e = this._element.getAttribute("data-bs-original-title") || this._config.title;
            return this._resolvePossibleFunction(e)
        }

        updateAttachment(e) {
            return "right" === e ? "end" : "left" === e ? "start" : e
        }

        _initializeOnDelegatedTarget(e, t) {
            return t || this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig())
        }

        _getOffset() {
            const {offset: e} = this._config;
            return "string" == typeof e ? e.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof e ? t => e(t, this._element) : e
        }

        _resolvePossibleFunction(e) {
            return "function" == typeof e ? e.call(this._element) : e
        }

        _getPopperConfig(e) {
            const t = {
                placement: e,
                modifiers: [{
                    name: "flip",
                    options: {fallbackPlacements: this._config.fallbackPlacements}
                }, {name: "offset", options: {offset: this._getOffset()}}, {
                    name: "preventOverflow",
                    options: {boundary: this._config.boundary}
                }, {name: "arrow", options: {element: `.${this.constructor.NAME}-arrow`}}, {
                    name: "onChange",
                    enabled: !0,
                    phase: "afterWrite",
                    fn: e => this._handlePopperPlacementChange(e)
                }],
                onFirstUpdate: e => {
                    e.options.placement !== e.placement && this._handlePopperPlacementChange(e)
                }
            };
            return {...t, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig}
        }

        _addAttachmentClass(e) {
            this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(e)}`)
        }

        _getAttachment(e) {
            return gn[e.toUpperCase()]
        }

        _setListeners() {
            this._config.trigger.split(" ").forEach(e => {
                if ("click" === e) ft.on(this._element, this.constructor.Event.CLICK, this._config.selector, e => this.toggle(e)); else if ("manual" !== e) {
                    const t = "hover" === e ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,
                        n = "hover" === e ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                    ft.on(this._element, t, this._config.selector, e => this._enter(e)), ft.on(this._element, n, this._config.selector, e => this._leave(e))
                }
            }), this._hideModalHandler = () => {
                this._element && this.hide()
            }, ft.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = {
                ...this._config,
                trigger: "manual",
                selector: ""
            } : this._fixTitle()
        }

        _fixTitle() {
            const e = this._element.getAttribute("title"),
                t = typeof this._element.getAttribute("data-bs-original-title");
            (e || "string" !== t) && (this._element.setAttribute("data-bs-original-title", e || ""), !e || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.setAttribute("title", ""))
        }

        _enter(e, t) {
            t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger["focusin" === e.type ? "focus" : "hover"] = !0), t.getTipElement().classList.contains("show") || "show" === t._hoverState ? t._hoverState = "show" : (clearTimeout(t._timeout), t._hoverState = "show", t._config.delay && t._config.delay.show ? t._timeout = setTimeout(() => {
                "show" === t._hoverState && t.show()
            }, t._config.delay.show) : t.show())
        }

        _leave(e, t) {
            t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger["focusout" === e.type ? "focus" : "hover"] = t._element.contains(e.relatedTarget)), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = "out", t._config.delay && t._config.delay.hide ? t._timeout = setTimeout(() => {
                "out" === t._hoverState && t.hide()
            }, t._config.delay.hide) : t.hide())
        }

        _isWithActiveTrigger() {
            for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0;
            return !1
        }

        _getConfig(e) {
            const t = Mt.getDataAttributes(this._element);
            return Object.keys(t).forEach(e => {
                mn.has(e) && delete t[e]
            }), (e = {...this.constructor.Default, ...t, ..."object" == typeof e && e ? e : {}}).container = !1 === e.container ? document.body : Be(e.container), "number" == typeof e.delay && (e.delay = {
                show: e.delay,
                hide: e.delay
            }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), je("tooltip", e, this.constructor.DefaultType), e.sanitize && (e.template = fn(e.template, e.allowList, e.sanitizeFn)), e
        }

        _getDelegateConfig() {
            const e = {};
            for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]);
            return e
        }

        _cleanTipClass() {
            const e = this.getTipElement(), t = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"),
                n = e.getAttribute("class").match(t);
            null !== n && n.length > 0 && n.map(e => e.trim()).forEach(t => e.classList.remove(t))
        }

        _getBasicClassPrefix() {
            return "bs-tooltip"
        }

        _handlePopperPlacementChange(e) {
            const {state: t} = e;
            t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement)))
        }

        _disposePopper() {
            this._popper && (this._popper.destroy(), this._popper = null)
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = xn.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e]()
                }
            }))
        }
    }

    $e(xn);
    const bn = {
        ...xn.Default,
        placement: "right",
        offset: [0, 8],
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
    }, wn = {...xn.DefaultType, content: "(string|element|function)"}, Mn = {
        HIDE: "hide.bs.popover",
        HIDDEN: "hidden.bs.popover",
        SHOW: "show.bs.popover",
        SHOWN: "shown.bs.popover",
        INSERTED: "inserted.bs.popover",
        CLICK: "click.bs.popover",
        FOCUSIN: "focusin.bs.popover",
        FOCUSOUT: "focusout.bs.popover",
        MOUSEENTER: "mouseenter.bs.popover",
        MOUSELEAVE: "mouseleave.bs.popover"
    };

    class Tn extends xn {
        static get Default() {
            return bn
        }

        static get NAME() {
            return "popover"
        }

        static get Event() {
            return Mn
        }

        static get DefaultType() {
            return wn
        }

        isWithContent() {
            return this.getTitle() || this._getContent()
        }

        setContent(e) {
            this._sanitizeAndSetContent(e, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(e, this._getContent(), ".popover-body")
        }

        _getContent() {
            return this._resolvePossibleFunction(this._config.content)
        }

        _getBasicClassPrefix() {
            return "bs-popover"
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = Tn.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e]()
                }
            }))
        }
    }

    $e(Tn);
    const kn = {offset: 10, method: "auto", target: ""},
        Sn = {offset: "number", method: "string", target: "(string|element)"},
        Dn = ".nav-link, .list-group-item, .dropdown-item";

    class Ln extends gt {
        constructor(e, t) {
            super(e), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(t), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, ft.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process()
        }

        static get Default() {
            return kn
        }

        static get NAME() {
            return "scrollspy"
        }

        refresh() {
            const e = this._scrollElement === this._scrollElement.window ? "offset" : "position",
                t = "auto" === this._config.method ? e : this._config.method,
                n = "position" === t ? this._getScrollTop() : 0;
            this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight();
            Tt.find(Dn, this._config.target).map(e => {
                const i = Ye(e), r = i ? Tt.findOne(i) : null;
                if (r) {
                    const e = r.getBoundingClientRect();
                    if (e.width || e.height) return [Mt[t](r).top + n, i]
                }
                return null
            }).filter(e => e).sort((e, t) => e[0] - t[0]).forEach(e => {
                this._offsets.push(e[0]), this._targets.push(e[1])
            })
        }

        dispose() {
            ft.off(this._scrollElement, ".bs.scrollspy"), super.dispose()
        }

        _getConfig(e) {
            return (e = {...kn, ...Mt.getDataAttributes(this._element), ..."object" == typeof e && e ? e : {}}).target = Be(e.target) || document.documentElement, je("scrollspy", e, Sn), e
        }

        _getScrollTop() {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
        }

        _getScrollHeight() {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
        }

        _getOffsetHeight() {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
        }

        _process() {
            const e = this._getScrollTop() + this._config.offset, t = this._getScrollHeight(),
                n = this._config.offset + t - this._getOffsetHeight();
            if (this._scrollHeight !== t && this.refresh(), e >= n) {
                const e = this._targets[this._targets.length - 1];
                this._activeTarget !== e && this._activate(e)
            } else {
                if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
                for (let t = this._offsets.length; t--;) {
                    this._activeTarget !== this._targets[t] && e >= this._offsets[t] && (void 0 === this._offsets[t + 1] || e < this._offsets[t + 1]) && this._activate(this._targets[t])
                }
            }
        }

        _activate(e) {
            this._activeTarget = e, this._clear();
            const t = Dn.split(",").map(t => `${t}[data-bs-target="${e}"],${t}[href="${e}"]`),
                n = Tt.findOne(t.join(","), this._config.target);
            n.classList.add("active"), n.classList.contains("dropdown-item") ? Tt.findOne(".dropdown-toggle", n.closest(".dropdown")).classList.add("active") : Tt.parents(n, ".nav, .list-group").forEach(e => {
                Tt.prev(e, ".nav-link, .list-group-item").forEach(e => e.classList.add("active")), Tt.prev(e, ".nav-item").forEach(e => {
                    Tt.children(e, ".nav-link").forEach(e => e.classList.add("active"))
                })
            }), ft.trigger(this._scrollElement, "activate.bs.scrollspy", {relatedTarget: e})
        }

        _clear() {
            Tt.find(Dn, this._config.target).filter(e => e.classList.contains("active")).forEach(e => e.classList.remove("active"))
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = Ln.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e]()
                }
            }))
        }
    }

    ft.on(window, "load.bs.scrollspy.data-api", () => {
        Tt.find('[data-bs-spy="scroll"]').forEach(e => new Ln(e))
    }), $e(Ln);

    class En extends gt {
        static get NAME() {
            return "tab"
        }

        show() {
            if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active")) return;
            let e;
            const t = ze(this._element), n = this._element.closest(".nav, .list-group");
            if (n) {
                const t = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active";
                e = Tt.find(t, n), e = e[e.length - 1]
            }
            const i = e ? ft.trigger(e, "hide.bs.tab", {relatedTarget: this._element}) : null;
            if (ft.trigger(this._element, "show.bs.tab", {relatedTarget: e}).defaultPrevented || null !== i && i.defaultPrevented) return;
            this._activate(this._element, n);
            const r = () => {
                ft.trigger(e, "hidden.bs.tab", {relatedTarget: this._element}), ft.trigger(this._element, "shown.bs.tab", {relatedTarget: e})
            };
            t ? this._activate(t, t.parentNode, r) : r()
        }

        _activate(e, t, n) {
            const i = (!t || "UL" !== t.nodeName && "OL" !== t.nodeName ? Tt.children(t, ".active") : Tt.find(":scope > li > .active", t))[0],
                r = n && i && i.classList.contains("fade"), o = () => this._transitionComplete(e, i, n);
            i && r ? (i.classList.remove("show"), this._queueCallback(o, e, !0)) : o()
        }

        _transitionComplete(e, t, n) {
            if (t) {
                t.classList.remove("active");
                const e = Tt.findOne(":scope > .dropdown-menu .active", t.parentNode);
                e && e.classList.remove("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !1)
            }
            e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), Ve(e), e.classList.contains("fade") && e.classList.add("show");
            let i = e.parentNode;
            if (i && "LI" === i.nodeName && (i = i.parentNode), i && i.classList.contains("dropdown-menu")) {
                const t = e.closest(".dropdown");
                t && Tt.find(".dropdown-toggle", t).forEach(e => e.classList.add("active")), e.setAttribute("aria-expanded", !0)
            }
            n && n()
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = En.getOrCreateInstance(this);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e]()
                }
            }))
        }
    }

    ft.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function (e) {
        if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), Ne(this)) return;
        En.getOrCreateInstance(this).show()
    })), $e(En);
    const Cn = {animation: "boolean", autohide: "boolean", delay: "number"},
        An = {animation: !0, autohide: !0, delay: 5e3};

    class In extends gt {
        constructor(e, t) {
            super(e), this._config = this._getConfig(t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
        }

        static get DefaultType() {
            return Cn
        }

        static get Default() {
            return An
        }

        static get NAME() {
            return "toast"
        }

        show() {
            if (ft.trigger(this._element, "show.bs.toast").defaultPrevented) return;
            this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
            this._element.classList.remove("hide"), Ve(this._element), this._element.classList.add("show"), this._element.classList.add("showing"), this._queueCallback(() => {
                this._element.classList.remove("showing"), ft.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
            }, this._element, this._config.animation)
        }

        hide() {
            if (!this._element.classList.contains("show")) return;
            if (ft.trigger(this._element, "hide.bs.toast").defaultPrevented) return;
            this._element.classList.add("showing"), this._queueCallback(() => {
                this._element.classList.add("hide"), this._element.classList.remove("showing"), this._element.classList.remove("show"), ft.trigger(this._element, "hidden.bs.toast")
            }, this._element, this._config.animation)
        }

        dispose() {
            this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose()
        }

        _getConfig(e) {
            return e = {...An, ...Mt.getDataAttributes(this._element), ..."object" == typeof e && e ? e : {}}, je("toast", e, this.constructor.DefaultType), e
        }

        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
                this.hide()
            }, this._config.delay)))
        }

        _onInteraction(e, t) {
            switch (e.type) {
                case"mouseover":
                case"mouseout":
                    this._hasMouseInteraction = t;
                    break;
                case"focusin":
                case"focusout":
                    this._hasKeyboardInteraction = t
            }
            if (t) return void this._clearTimeout();
            const n = e.relatedTarget;
            this._element === n || this._element.contains(n) || this._maybeScheduleHide()
        }

        _setListeners() {
            ft.on(this._element, "mouseover.bs.toast", e => this._onInteraction(e, !0)), ft.on(this._element, "mouseout.bs.toast", e => this._onInteraction(e, !1)), ft.on(this._element, "focusin.bs.toast", e => this._onInteraction(e, !0)), ft.on(this._element, "focusout.bs.toast", e => this._onInteraction(e, !1))
        }

        _clearTimeout() {
            clearTimeout(this._timeout), this._timeout = null
        }

        static jQueryInterface(e) {
            return this.each((function () {
                const t = In.getOrCreateInstance(this, e);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
                    t[e](this)
                }
            }))
        }
    }

    yt(In), $e(In);
    n(143), n(158);
    o()(document).ready((function () {
        setTimeout((function () {
            o()(".vertical-nav-menu").metisMenu()
        }), 100), o()(".search-icon").click((function () {
            o()(this).parent().parent().addClass("active")
        })), o()(".search-wrapper .btn-close").click((function () {
            o()(this).parent().removeClass("active")
        })), o()(".dropdown-menu").on("click", (function (e) {
            var t = o.a._data(document, "events") || {};
            t = t.click || [];
            for (var n = 0; n < t.length; n++) t[n].selector && (o()(e.target).is(t[n].selector) && t[n].handler.call(e.target, e), o()(e.target).parents(t[n].selector).each((function () {
                t[n].handler.call(this, e)
            })));
            e.stopPropagation()
        }));
        [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]')).map((function (e) {
            return new Tn(e)
        })), [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map((function (e) {
            return new xn(e)
        }));
        o()(".mobile-toggle-nav").click((function () {
            o()(this).toggleClass("is-active"), o()(".app-container").toggleClass("sidebar-mobile-open")
        })), o()(".mobile-toggle-header-nav").click((function () {
            o()(this).toggleClass("active"), o()(".app-header__content").toggleClass("header-mobile-open")
        }));
        var e = function () {
            document.body.clientWidth < 1250 ? o()(".app-container").addClass("closed-sidebar-mobile closed-sidebar") : o()(".app-container").removeClass("closed-sidebar-mobile closed-sidebar")
        };
        o()(window).on("resize", (function () {
            e()
        })), e()
    }))
}, function (e, t, n) {
    "use strict";
    n.r(t);
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    var i = function (e, t) {
        return (i = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
        })(e, t)
    };

    function r(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

        function n() {
            this.constructor = e
        }

        i(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    var o = function () {
        return (o = Object.assign || function (e) {
            for (var t, n = 1, i = arguments.length; n < i; n++) for (var r in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            return e
        }).apply(this, arguments)
    };
    Object.create;

    function a(e, t, n) {
        if (n || 2 === arguments.length) for (var i, r = 0, o = t.length; r < o; r++) !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
        return e.concat(i || Array.prototype.slice.call(t))
    }

    Object.create;
    var s, l, c, u, d, h, p, f = {}, m = [], _ = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function g(e, t) {
        for (var n in t) e[n] = t[n];
        return e
    }

    function y(e) {
        var t = e.parentNode;
        t && t.removeChild(e)
    }

    function v(e, t, n) {
        var i, r, o, a = {};
        for (o in t) "key" == o ? i = t[o] : "ref" == o ? r = t[o] : a[o] = t[o];
        if (arguments.length > 2 && (a.children = arguments.length > 3 ? s.call(arguments, 2) : n), "function" == typeof e && null != e.defaultProps) for (o in e.defaultProps) void 0 === a[o] && (a[o] = e.defaultProps[o]);
        return x(e, a, i, r, null)
    }

    function x(e, t, n, i, r) {
        var o = {
            type: e,
            props: t,
            key: n,
            ref: i,
            __k: null,
            __: null,
            __b: 0,
            __e: null,
            __d: void 0,
            __c: null,
            __h: null,
            constructor: void 0,
            __v: null == r ? ++c : r
        };
        return null == r && null != l.vnode && l.vnode(o), o
    }

    function b() {
        return {current: null}
    }

    function w(e) {
        return e.children
    }

    function M(e, t) {
        this.props = e, this.context = t
    }

    function T(e, t) {
        if (null == t) return e.__ ? T(e.__, e.__.__k.indexOf(e) + 1) : null;
        for (var n; t < e.__k.length; t++) if (null != (n = e.__k[t]) && null != n.__e) return n.__e;
        return "function" == typeof e.type ? T(e) : null
    }

    function k(e) {
        var t, n;
        if (null != (e = e.__) && null != e.__c) {
            for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++) if (null != (n = e.__k[t]) && null != n.__e) {
                e.__e = e.__c.base = n.__e;
                break
            }
            return k(e)
        }
    }

    function S(e) {
        (!e.__d && (e.__d = !0) && u.push(e) && !D.__r++ || h !== l.debounceRendering) && ((h = l.debounceRendering) || d)(D)
    }

    function D() {
        for (var e; D.__r = u.length;) e = u.sort((function (e, t) {
            return e.__v.__b - t.__v.__b
        })), u = [], e.some((function (e) {
            var t, n, i, r, o, a;
            e.__d && (o = (r = (t = e).__v).__e, (a = t.__P) && (n = [], (i = g({}, r)).__v = r.__v + 1, z(a, r, i, t.__n, void 0 !== a.ownerSVGElement, null != r.__h ? [o] : null, n, null == o ? T(r) : o, r.__h), O(n, r), r.__e != o && k(r)))
        }))
    }

    function L(e, t, n, i, r, o, a, s, l, c) {
        var u, d, h, p, _, g, y, v = i && i.__k || m, b = v.length;
        for (n.__k = [], u = 0; u < t.length; u++) if (null != (p = n.__k[u] = null == (p = t[u]) || "boolean" == typeof p ? null : "string" == typeof p || "number" == typeof p || "bigint" == typeof p ? x(null, p, null, null, p) : Array.isArray(p) ? x(w, {children: p}, null, null, null) : p.__b > 0 ? x(p.type, p.props, p.key, null, p.__v) : p)) {
            if (p.__ = n, p.__b = n.__b + 1, null === (h = v[u]) || h && p.key == h.key && p.type === h.type) v[u] = void 0; else for (d = 0; d < b; d++) {
                if ((h = v[d]) && p.key == h.key && p.type === h.type) {
                    v[d] = void 0;
                    break
                }
                h = null
            }
            z(e, p, h = h || f, r, o, a, s, l, c), _ = p.__e, (d = p.ref) && h.ref != d && (y || (y = []), h.ref && y.push(h.ref, null, p), y.push(d, p.__c || _, p)), null != _ ? (null == g && (g = _), "function" == typeof p.type && p.__k === h.__k ? p.__d = l = E(p, l, e) : l = A(e, p, h, v, _, l), "function" == typeof n.type && (n.__d = l)) : l && h.__e == l && l.parentNode != e && (l = T(h))
        }
        for (n.__e = g, u = b; u--;) null != v[u] && ("function" == typeof n.type && null != v[u].__e && v[u].__e == n.__d && (n.__d = T(i, u + 1)), j(v[u], v[u]));
        if (y) for (u = 0; u < y.length; u++) B(y[u], y[++u], y[++u])
    }

    function E(e, t, n) {
        for (var i, r = e.__k, o = 0; r && o < r.length; o++) (i = r[o]) && (i.__ = e, t = "function" == typeof i.type ? E(i, t, n) : A(n, i, i, r, i.__e, t));
        return t
    }

    function C(e, t) {
        return t = t || [], null == e || "boolean" == typeof e || (Array.isArray(e) ? e.some((function (e) {
            C(e, t)
        })) : t.push(e)), t
    }

    function A(e, t, n, i, r, o) {
        var a, s, l;
        if (void 0 !== t.__d) a = t.__d, t.__d = void 0; else if (null == n || r != o || null == r.parentNode) e:if (null == o || o.parentNode !== e) e.appendChild(r), a = null; else {
            for (s = o, l = 0; (s = s.nextSibling) && l < i.length; l += 2) if (s == r) break e;
            e.insertBefore(r, o), a = o
        }
        return void 0 !== a ? a : r.nextSibling
    }

    function I(e, t, n) {
        "-" === t[0] ? e.setProperty(t, n) : e[t] = null == n ? "" : "number" != typeof n || _.test(t) ? n : n + "px"
    }

    function P(e, t, n, i, r) {
        var o;
        e:if ("style" === t) if ("string" == typeof n) e.style.cssText = n; else {
            if ("string" == typeof i && (e.style.cssText = i = ""), i) for (t in i) n && t in n || I(e.style, t, "");
            if (n) for (t in n) i && n[t] === i[t] || I(e.style, t, n[t])
        } else if ("o" === t[0] && "n" === t[1]) o = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + o] = n, n ? i || e.addEventListener(t, o ? Y : R, o) : e.removeEventListener(t, o ? Y : R, o); else if ("dangerouslySetInnerHTML" !== t) {
            if (r) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if ("href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try {
                e[t] = null == n ? "" : n;
                break e
            } catch (e) {
            }
            "function" == typeof n || (null != n && (!1 !== n || "a" === t[0] && "r" === t[1]) ? e.setAttribute(t, n) : e.removeAttribute(t))
        }
    }

    function R(e) {
        this.l[e.type + !1](l.event ? l.event(e) : e)
    }

    function Y(e) {
        this.l[e.type + !0](l.event ? l.event(e) : e)
    }

    function z(e, t, n, i, r, o, a, s, c) {
        var u, d, h, p, f, m, _, y, v, x, b, T = t.type;
        if (void 0 !== t.constructor) return null;
        null != n.__h && (c = n.__h, s = t.__e = n.__e, t.__h = null, o = [s]), (u = l.__b) && u(t);
        try {
            e:if ("function" == typeof T) {
                if (y = t.props, v = (u = T.contextType) && i[u.__c], x = u ? v ? v.props.value : u.__ : i, n.__c ? _ = (d = t.__c = n.__c).__ = d.__E : ("prototype" in T && T.prototype.render ? t.__c = d = new T(y, x) : (t.__c = d = new M(y, x), d.constructor = T, d.render = H), v && v.sub(d), d.props = y, d.state || (d.state = {}), d.context = x, d.__n = i, h = d.__d = !0, d.__h = []), null == d.__s && (d.__s = d.state), null != T.getDerivedStateFromProps && (d.__s == d.state && (d.__s = g({}, d.__s)), g(d.__s, T.getDerivedStateFromProps(y, d.__s))), p = d.props, f = d.state, h) null == T.getDerivedStateFromProps && null != d.componentWillMount && d.componentWillMount(), null != d.componentDidMount && d.__h.push(d.componentDidMount); else {
                    if (null == T.getDerivedStateFromProps && y !== p && null != d.componentWillReceiveProps && d.componentWillReceiveProps(y, x), !d.__e && null != d.shouldComponentUpdate && !1 === d.shouldComponentUpdate(y, d.__s, x) || t.__v === n.__v) {
                        d.props = y, d.state = d.__s, t.__v !== n.__v && (d.__d = !1), d.__v = t, t.__e = n.__e, t.__k = n.__k, t.__k.forEach((function (e) {
                            e && (e.__ = t)
                        })), d.__h.length && a.push(d);
                        break e
                    }
                    null != d.componentWillUpdate && d.componentWillUpdate(y, d.__s, x), null != d.componentDidUpdate && d.__h.push((function () {
                        d.componentDidUpdate(p, f, m)
                    }))
                }
                d.context = x, d.props = y, d.state = d.__s, (u = l.__r) && u(t), d.__d = !1, d.__v = t, d.__P = e, u = d.render(d.props, d.state, d.context), d.state = d.__s, null != d.getChildContext && (i = g(g({}, i), d.getChildContext())), h || null == d.getSnapshotBeforeUpdate || (m = d.getSnapshotBeforeUpdate(p, f)), b = null != u && u.type === w && null == u.key ? u.props.children : u, L(e, Array.isArray(b) ? b : [b], t, n, i, r, o, a, s, c), d.base = t.__e, t.__h = null, d.__h.length && a.push(d), _ && (d.__E = d.__ = null), d.__e = !1
            } else null == o && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = F(n.__e, t, n, i, r, o, a, c);
            (u = l.diffed) && u(t)
        } catch (e) {
            t.__v = null, (c || null != o) && (t.__e = s, t.__h = !!c, o[o.indexOf(s)] = null), l.__e(e, t, n)
        }
    }

    function O(e, t) {
        l.__c && l.__c(t, e), e.some((function (t) {
            try {
                e = t.__h, t.__h = [], e.some((function (e) {
                    e.call(t)
                }))
            } catch (e) {
                l.__e(e, t.__v)
            }
        }))
    }

    function F(e, t, n, i, r, o, a, l) {
        var c, u, d, h = n.props, p = t.props, m = t.type, _ = 0;
        if ("svg" === m && (r = !0), null != o) for (; _ < o.length; _++) if ((c = o[_]) && "setAttribute" in c == !!m && (m ? c.localName === m : 3 === c.nodeType)) {
            e = c, o[_] = null;
            break
        }
        if (null == e) {
            if (null === m) return document.createTextNode(p);
            e = r ? document.createElementNS("http://www.w3.org/2000/svg", m) : document.createElement(m, p.is && p), o = null, l = !1
        }
        if (null === m) h === p || l && e.data === p || (e.data = p); else {
            if (o = o && s.call(e.childNodes), u = (h = n.props || f).dangerouslySetInnerHTML, d = p.dangerouslySetInnerHTML, !l) {
                if (null != o) for (h = {}, _ = 0; _ < e.attributes.length; _++) h[e.attributes[_].name] = e.attributes[_].value;
                (d || u) && (d && (u && d.__html == u.__html || d.__html === e.innerHTML) || (e.innerHTML = d && d.__html || ""))
            }
            if (function (e, t, n, i, r) {
                var o;
                for (o in n) "children" === o || "key" === o || o in t || P(e, o, null, n[o], i);
                for (o in t) r && "function" != typeof t[o] || "children" === o || "key" === o || "value" === o || "checked" === o || n[o] === t[o] || P(e, o, t[o], n[o], i)
            }(e, p, h, r, l), d) t.__k = []; else if (_ = t.props.children, L(e, Array.isArray(_) ? _ : [_], t, n, i, r && "foreignObject" !== m, o, a, o ? o[0] : n.__k && T(n, 0), l), null != o) for (_ = o.length; _--;) null != o[_] && y(o[_]);
            l || ("value" in p && void 0 !== (_ = p.value) && (_ !== e.value || "progress" === m && !_ || "option" === m && _ !== h.value) && P(e, "value", _, h.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== e.checked && P(e, "checked", _, h.checked, !1))
        }
        return e
    }

    function B(e, t, n) {
        try {
            "function" == typeof e ? e(t) : e.current = t
        } catch (e) {
            l.__e(e, n)
        }
    }

    function j(e, t, n) {
        var i, r;
        if (l.unmount && l.unmount(e), (i = e.ref) && (i.current && i.current !== e.__e || B(i, null, t)), null != (i = e.__c)) {
            if (i.componentWillUnmount) try {
                i.componentWillUnmount()
            } catch (e) {
                l.__e(e, t)
            }
            i.base = i.__P = null
        }
        if (i = e.__k) for (r = 0; r < i.length; r++) i[r] && j(i[r], t, "function" != typeof e.type);
        n || null == e.__e || y(e.__e), e.__e = e.__d = void 0
    }

    function H(e, t, n) {
        return this.constructor(e, n)
    }

    function N(e, t, n) {
        var i, r, o;
        l.__ && l.__(e, t), r = (i = "function" == typeof n) ? null : n && n.__k || t.__k, o = [], z(t, e = (!i && n || t).__k = v(w, null, [e]), r || f, f, void 0 !== t.ownerSVGElement, !i && n ? [n] : r ? null : t.firstChild ? s.call(t.childNodes) : null, o, !i && n ? n : r ? r.__e : t.firstChild, i), O(o, e)
    }

    function U(e, t) {
        var n = {
            __c: t = "__cC" + p++, __: e, Consumer: function (e, t) {
                return e.children(t)
            }, Provider: function (e) {
                var n, i;
                return this.getChildContext || (n = [], (i = {})[t] = this, this.getChildContext = function () {
                    return i
                }, this.shouldComponentUpdate = function (e) {
                    this.props.value !== e.value && n.some(S)
                }, this.sub = function (e) {
                    n.push(e);
                    var t = e.componentWillUnmount;
                    e.componentWillUnmount = function () {
                        n.splice(n.indexOf(e), 1), t && t.call(e)
                    }
                }), e.children
            }
        };
        return n.Provider.__ = n.Consumer.contextType = n
    }

    s = m.slice, l = {
        __e: function (e, t, n, i) {
            for (var r, o, a; t = t.__;) if ((r = t.__c) && !r.__) try {
                if ((o = r.constructor) && null != o.getDerivedStateFromError && (r.setState(o.getDerivedStateFromError(e)), a = r.__d), null != r.componentDidCatch && (r.componentDidCatch(e, i || {}), a = r.__d), a) return r.__E = r
            } catch (t) {
                e = t
            }
            throw e
        }
    }, c = 0, M.prototype.setState = function (e, t) {
        var n;
        n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = g({}, this.state), "function" == typeof e && (e = e(g({}, n), this.props)), e && g(n, e), null != e && this.__v && (t && this.__h.push(t), S(this))
    }, M.prototype.forceUpdate = function (e) {
        this.__v && (this.__e = !0, e && this.__h.push(e), S(this))
    }, M.prototype.render = w, u = [], d = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, D.__r = 0, p = 0;
    var W, V, G = [], q = l.__b, Z = l.__r, $ = l.diffed, X = l.__c, J = l.unmount;

    function K() {
        for (var e; e = G.shift();) if (e.__P) try {
            e.__H.__h.forEach(ee), e.__H.__h.forEach(te), e.__H.__h = []
        } catch (t) {
            e.__H.__h = [], l.__e(t, e.__v)
        }
    }

    l.__b = function (e) {
        W = null, q && q(e)
    }, l.__r = function (e) {
        Z && Z(e), 0;
        var t = (W = e.__c).__H;
        t && (t.__h.forEach(ee), t.__h.forEach(te), t.__h = [])
    }, l.diffed = function (e) {
        $ && $(e);
        var t = e.__c;
        t && t.__H && t.__H.__h.length && (1 !== G.push(t) && V === l.requestAnimationFrame || ((V = l.requestAnimationFrame) || function (e) {
            var t, n = function () {
                clearTimeout(i), Q && cancelAnimationFrame(t), setTimeout(e)
            }, i = setTimeout(n, 100);
            Q && (t = requestAnimationFrame(n))
        })(K)), W = null
    }, l.__c = function (e, t) {
        t.some((function (e) {
            try {
                e.__h.forEach(ee), e.__h = e.__h.filter((function (e) {
                    return !e.__ || te(e)
                }))
            } catch (n) {
                t.some((function (e) {
                    e.__h && (e.__h = [])
                })), t = [], l.__e(n, e.__v)
            }
        })), X && X(e, t)
    }, l.unmount = function (e) {
        J && J(e);
        var t, n = e.__c;
        n && n.__H && (n.__H.__.forEach((function (e) {
            try {
                ee(e)
            } catch (e) {
                t = e
            }
        })), t && l.__e(t, n.__v))
    };
    var Q = "function" == typeof requestAnimationFrame;

    function ee(e) {
        var t = W, n = e.__c;
        "function" == typeof n && (e.__c = void 0, n()), W = t
    }

    function te(e) {
        var t = W;
        e.__c = e.__(), W = t
    }

    function ne(e, t) {
        for (var n in t) e[n] = t[n];
        return e
    }

    function ie(e, t) {
        for (var n in e) if ("__source" !== n && !(n in t)) return !0;
        for (var i in t) if ("__source" !== i && e[i] !== t[i]) return !0;
        return !1
    }

    function re(e) {
        this.props = e
    }

    (re.prototype = new M).isPureReactComponent = !0, re.prototype.shouldComponentUpdate = function (e, t) {
        return ie(this.props, e) || ie(this.state, t)
    };
    var oe = l.__b;
    l.__b = function (e) {
        e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), oe && oe(e)
    };
    "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref");
    var ae = l.__e;
    l.__e = function (e, t, n, i) {
        if (e.then) for (var r, o = t; o = o.__;) if ((r = o.__c) && r.__c) return null == t.__e && (t.__e = n.__e, t.__k = n.__k), r.__c(e, t);
        ae(e, t, n, i)
    };
    var se = l.unmount;

    function le() {
        this.__u = 0, this.t = null, this.__b = null
    }

    function ce(e) {
        var t = e.__.__c;
        return t && t.__e && t.__e(e)
    }

    function ue() {
        this.u = null, this.o = null
    }

    l.unmount = function (e) {
        var t = e.__c;
        t && t.__R && t.__R(), t && !0 === e.__h && (e.type = null), se && se(e)
    }, (le.prototype = new M).__c = function (e, t) {
        var n = t.__c, i = this;
        null == i.t && (i.t = []), i.t.push(n);
        var r = ce(i.__v), o = !1, a = function () {
            o || (o = !0, n.__R = null, r ? r(s) : s())
        };
        n.__R = a;
        var s = function () {
            if (!--i.__u) {
                if (i.state.__e) {
                    var e = i.state.__e;
                    i.__v.__k[0] = function e(t, n, i) {
                        return t && (t.__v = null, t.__k = t.__k && t.__k.map((function (t) {
                            return e(t, n, i)
                        })), t.__c && t.__c.__P === n && (t.__e && i.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = i)), t
                    }(e, e.__c.__P, e.__c.__O)
                }
                var t;
                for (i.setState({__e: i.__b = null}); t = i.t.pop();) t.forceUpdate()
            }
        }, l = !0 === t.__h;
        i.__u++ || l || i.setState({__e: i.__b = i.__v.__k[0]}), e.then(a, a)
    }, le.prototype.componentWillUnmount = function () {
        this.t = []
    }, le.prototype.render = function (e, t) {
        if (this.__b) {
            if (this.__v.__k) {
                var n = document.createElement("div"), i = this.__v.__k[0].__c;
                this.__v.__k[0] = function e(t, n, i) {
                    return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach((function (e) {
                        "function" == typeof e.__c && e.__c()
                    })), t.__c.__H = null), null != (t = ne({}, t)).__c && (t.__c.__P === i && (t.__c.__P = n), t.__c = null), t.__k = t.__k && t.__k.map((function (t) {
                        return e(t, n, i)
                    }))), t
                }(this.__b, n, i.__O = i.__P)
            }
            this.__b = null
        }
        var r = t.__e && v(w, null, e.fallback);
        return r && (r.__h = null), [v(w, null, t.__e ? null : e.children), r]
    };
    var de = function (e, t, n) {
        if (++n[1] === n[0] && e.o.delete(t), e.props.revealOrder && ("t" !== e.props.revealOrder[0] || !e.o.size)) for (n = e.u; n;) {
            for (; n.length > 3;) n.pop()();
            if (n[1] < n[0]) break;
            e.u = n = n[2]
        }
    };

    function he(e) {
        return this.getChildContext = function () {
            return e.context
        }, e.children
    }

    function pe(e) {
        var t = this, n = e.i;
        t.componentWillUnmount = function () {
            N(null, t.l), t.l = null, t.i = null
        }, t.i && t.i !== n && t.componentWillUnmount(), e.__v ? (t.l || (t.i = n, t.l = {
            nodeType: 1,
            parentNode: n,
            childNodes: [],
            appendChild: function (e) {
                this.childNodes.push(e), t.i.appendChild(e)
            },
            insertBefore: function (e, n) {
                this.childNodes.push(e), t.i.appendChild(e)
            },
            removeChild: function (e) {
                this.childNodes.splice(this.childNodes.indexOf(e) >>> 1, 1), t.i.removeChild(e)
            }
        }), N(v(he, {context: t.context}, e.__v), t.l)) : t.l && t.componentWillUnmount()
    }

    function fe(e, t) {
        return v(pe, {__v: e, i: t})
    }

    (ue.prototype = new M).__e = function (e) {
        var t = this, n = ce(t.__v), i = t.o.get(e);
        return i[0]++, function (r) {
            var o = function () {
                t.props.revealOrder ? (i.push(r), de(t, e, i)) : r()
            };
            n ? n(o) : o()
        }
    }, ue.prototype.render = function (e) {
        this.u = null, this.o = new Map;
        var t = C(e.children);
        e.revealOrder && "b" === e.revealOrder[0] && t.reverse();
        for (var n = t.length; n--;) this.o.set(t[n], this.u = [1, 0, this.u]);
        return e.children
    }, ue.prototype.componentDidUpdate = ue.prototype.componentDidMount = function () {
        var e = this;
        this.o.forEach((function (t, n) {
            de(e, n, t)
        }))
    };
    var me = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        _e = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        ge = "undefined" != typeof document, ye = function (e) {
            return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(e)
        };
    M.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach((function (e) {
        Object.defineProperty(M.prototype, e, {
            configurable: !0, get: function () {
                return this["UNSAFE_" + e]
            }, set: function (t) {
                Object.defineProperty(this, e, {configurable: !0, writable: !0, value: t})
            }
        })
    }));
    var ve = l.event;

    function xe() {
    }

    function be() {
        return this.cancelBubble
    }

    function we() {
        return this.defaultPrevented
    }

    l.event = function (e) {
        return ve && (e = ve(e)), e.persist = xe, e.isPropagationStopped = be, e.isDefaultPrevented = we, e.nativeEvent = e
    };
    var Me = {
        configurable: !0, get: function () {
            return this.class
        }
    }, Te = l.vnode;
    l.vnode = function (e) {
        var t = e.type, n = e.props, i = n;
        if ("string" == typeof t) {
            var r = -1 === t.indexOf("-");
            for (var o in i = {}, n) {
                var a = n[o];
                ge && "children" === o && "noscript" === t || "value" === o && "defaultValue" in n && null == a || ("defaultValue" === o && "value" in n && null == n.value ? o = "value" : "download" === o && !0 === a ? a = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !ye(n.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : r && _e.test(o) ? o = o.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === a && (a = void 0), i[o] = a)
            }
            "select" == t && i.multiple && Array.isArray(i.value) && (i.value = C(n.children).forEach((function (e) {
                e.props.selected = -1 != i.value.indexOf(e.props.value)
            }))), "select" == t && null != i.defaultValue && (i.value = C(n.children).forEach((function (e) {
                e.props.selected = i.multiple ? -1 != i.defaultValue.indexOf(e.props.value) : i.defaultValue == e.props.value
            }))), e.props = i, n.class != n.className && (Me.enumerable = "className" in n, null != n.className && (i.class = n.className), Object.defineProperty(i, "className", Me))
        }
        e.$$typeof = me, Te && Te(e)
    };
    var ke = l.__r;
    l.__r = function (e) {
        ke && ke(e), e.__c
    };
    var Se = "undefined" != typeof globalThis ? globalThis : window;
    Se.FullCalendarVDom ? console.warn("FullCalendar VDOM already loaded") : Se.FullCalendarVDom = {
        Component: M,
        createElement: v,
        render: N,
        createRef: b,
        Fragment: w,
        createContext: function (e) {
            var t = U(e), n = t.Provider;
            return t.Provider = function () {
                var e = this, t = !this.getChildContext, i = n.apply(this, arguments);
                if (t) {
                    var r = [];
                    this.shouldComponentUpdate = function (t) {
                        e.props.value !== t.value && r.forEach((function (e) {
                            e.context = t.value, e.forceUpdate()
                        }))
                    }, this.sub = function (e) {
                        r.push(e);
                        var t = e.componentWillUnmount;
                        e.componentWillUnmount = function () {
                            r.splice(r.indexOf(e), 1), t && t.call(e)
                        }
                    }
                }
                return i
            }, t
        },
        createPortal: fe,
        flushToDom: function () {
            var e = l.debounceRendering, t = [];
            l.debounceRendering = function (e) {
                t.push(e)
            }, N(v(De, {}), document.createElement("div"));
            for (; t.length;) t.shift()();
            l.debounceRendering = e
        },
        unmountComponentAtNode: function (e) {
            N(null, e)
        }
    };
    var De = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            return v("div", {})
        }, t.prototype.componentDidMount = function () {
            this.setState({})
        }, t
    }(M);
    n(173);
    if ("undefined" == typeof FullCalendarVDom) throw new Error("Please import the top-level fullcalendar lib before attempting to import a plugin.");
    var Le = FullCalendarVDom.Component, Ee = FullCalendarVDom.createElement, Ce = FullCalendarVDom.render,
        Ae = FullCalendarVDom.createRef, Ie = FullCalendarVDom.Fragment, Pe = FullCalendarVDom.createContext,
        Re = FullCalendarVDom.createPortal, Ye = FullCalendarVDom.flushToDom,
        ze = FullCalendarVDom.unmountComponentAtNode, Oe = function () {
            function e(e, t) {
                this.context = e, this.internalEventSource = t
            }

            return e.prototype.remove = function () {
                this.context.dispatch({type: "REMOVE_EVENT_SOURCE", sourceId: this.internalEventSource.sourceId})
            }, e.prototype.refetch = function () {
                this.context.dispatch({
                    type: "FETCH_EVENT_SOURCES",
                    sourceIds: [this.internalEventSource.sourceId],
                    isRefetch: !0
                })
            }, Object.defineProperty(e.prototype, "id", {
                get: function () {
                    return this.internalEventSource.publicId
                }, enumerable: !1, configurable: !0
            }), Object.defineProperty(e.prototype, "url", {
                get: function () {
                    return this.internalEventSource.meta.url
                }, enumerable: !1, configurable: !0
            }), Object.defineProperty(e.prototype, "format", {
                get: function () {
                    return this.internalEventSource.meta.format
                }, enumerable: !1, configurable: !0
            }), e
        }();

    function Fe(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }

    function Be(e, t) {
        if (e.closest) return e.closest(t);
        if (!document.documentElement.contains(e)) return null;
        do {
            if (je(e, t)) return e;
            e = e.parentElement || e.parentNode
        } while (null !== e && 1 === e.nodeType);
        return null
    }

    function je(e, t) {
        return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t)
    }

    var He = /(top|left|right|bottom|width|height)$/i;

    function Ne(e, t) {
        for (var n in t) Ue(e, n, t[n])
    }

    function Ue(e, t, n) {
        null == n ? e.style[t] = "" : "number" == typeof n && He.test(t) ? e.style[t] = n + "px" : e.style[t] = n
    }

    function We(e) {
        var t, n;
        return null !== (n = null === (t = e.composedPath) || void 0 === t ? void 0 : t.call(e)[0]) && void 0 !== n ? n : e.target
    }

    function Ve(e) {
        return e.getRootNode ? e.getRootNode() : document
    }

    var Ge = 0;

    function qe() {
        return "fc-dom-" + (Ge += 1)
    }

    function Ze(e) {
        e.preventDefault()
    }

    function $e(e, t, n, i) {
        var r = function (e, t) {
            return function (n) {
                var i = Be(n.target, e);
                i && t.call(i, n, i)
            }
        }(n, i);
        return e.addEventListener(t, r), function () {
            e.removeEventListener(t, r)
        }
    }

    var Xe = ["webkitTransitionEnd", "otransitionend", "oTransitionEnd", "msTransitionEnd", "transitionend"];

    function Je(e) {
        return o({onClick: e}, Ke(e))
    }

    function Ke(e) {
        return {
            tabIndex: 0, onKeyDown: function (t) {
                "Enter" !== t.key && " " !== t.key || (e(t), t.preventDefault())
            }
        }
    }

    var Qe = 0;

    function et() {
        return String(Qe += 1)
    }

    function tt() {
        document.body.classList.add("fc-not-allowed")
    }

    function nt() {
        document.body.classList.remove("fc-not-allowed")
    }

    function it(e, t, n) {
        return n.func ? n.func(e, t) : function (e, t) {
            if (!e && !t) return 0;
            if (null == t) return -1;
            if (null == e) return 1;
            if ("string" == typeof e || "string" == typeof t) return String(e).localeCompare(String(t));
            return e - t
        }(e[n.field], t[n.field]) * (n.order || 1)
    }

    function rt(e, t) {
        var n = String(e);
        return "000".substr(0, t - n.length) + n
    }

    function ot(e, t, n) {
        return "function" == typeof e ? e.apply(void 0, t) : "string" == typeof e ? t.reduce((function (e, t, n) {
            return e.replace("$" + n, t || "")
        }), e) : n
    }

    function at(e, t) {
        return e - t
    }

    function st(e) {
        return e % 1 == 0
    }

    function lt(e) {
        var t = e.querySelector(".fc-scrollgrid-shrink-frame"), n = e.querySelector(".fc-scrollgrid-shrink-cushion");
        if (!t) throw new Error("needs fc-scrollgrid-shrink-frame className");
        if (!n) throw new Error("needs fc-scrollgrid-shrink-cushion className");
        return e.getBoundingClientRect().width - t.getBoundingClientRect().width + n.getBoundingClientRect().width
    }

    var ct = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

    function ut(e, t) {
        var n = xt(e);
        return n[2] += 7 * t, bt(n)
    }

    function dt(e, t) {
        var n = xt(e);
        return n[2] += t, bt(n)
    }

    function ht(e, t) {
        var n = xt(e);
        return n[6] += t, bt(n)
    }

    function pt(e, t) {
        return (t.valueOf() - e.valueOf()) / 864e5
    }

    function ft(e, t) {
        return Mt(e) === Mt(t) ? Math.round(pt(e, t)) : null
    }

    function mt(e) {
        return bt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()])
    }

    function _t(e, t, n, i) {
        var r = bt([t, 0, 1 + gt(t, n, i)]), o = mt(e), a = Math.round(pt(r, o));
        return Math.floor(a / 7) + 1
    }

    function gt(e, t, n) {
        var i = 7 + t - n;
        return -((7 + bt([e, 0, i]).getUTCDay() - t) % 7) + i - 1
    }

    function yt(e) {
        return [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()]
    }

    function vt(e) {
        return new Date(e[0], e[1] || 0, null == e[2] ? 1 : e[2], e[3] || 0, e[4] || 0, e[5] || 0)
    }

    function xt(e) {
        return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()]
    }

    function bt(e) {
        return 1 === e.length && (e = e.concat([0])), new Date(Date.UTC.apply(Date, e))
    }

    function wt(e) {
        return !isNaN(e.valueOf())
    }

    function Mt(e) {
        return 1e3 * e.getUTCHours() * 60 * 60 + 1e3 * e.getUTCMinutes() * 60 + 1e3 * e.getUTCSeconds() + e.getUTCMilliseconds()
    }

    function Tt(e, t, n, i) {
        return {
            instanceId: et(),
            defId: e,
            range: t,
            forcedStartTzo: null == n ? null : n,
            forcedEndTzo: null == i ? null : i
        }
    }

    var kt = Object.prototype.hasOwnProperty;

    function St(e, t) {
        var n = {};
        if (t) for (var i in t) {
            for (var r = [], o = e.length - 1; o >= 0; o -= 1) {
                var a = e[o][i];
                if ("object" == typeof a && a) r.unshift(a); else if (void 0 !== a) {
                    n[i] = a;
                    break
                }
            }
            r.length && (n[i] = St(r))
        }
        for (o = e.length - 1; o >= 0; o -= 1) {
            var s = e[o];
            for (var l in s) l in n || (n[l] = s[l])
        }
        return n
    }

    function Dt(e, t) {
        var n = {};
        for (var i in e) t(e[i], i) && (n[i] = e[i]);
        return n
    }

    function Lt(e, t) {
        var n = {};
        for (var i in e) n[i] = t(e[i], i);
        return n
    }

    function Et(e) {
        for (var t = {}, n = 0, i = e; n < i.length; n++) {
            t[i[n]] = !0
        }
        return t
    }

    function Ct(e) {
        var t = [];
        for (var n in e) t.push(e[n]);
        return t
    }

    function At(e, t) {
        if (e === t) return !0;
        for (var n in e) if (kt.call(e, n) && !(n in t)) return !1;
        for (var n in t) if (kt.call(t, n) && e[n] !== t[n]) return !1;
        return !0
    }

    function It(e, t) {
        var n = [];
        for (var i in e) kt.call(e, i) && (i in t || n.push(i));
        for (var i in t) kt.call(t, i) && e[i] !== t[i] && n.push(i);
        return n
    }

    function Pt(e, t, n) {
        if (void 0 === n && (n = {}), e === t) return !0;
        for (var i in t) if (!(i in e) || !Rt(e[i], t[i], n[i])) return !1;
        for (var i in e) if (!(i in t)) return !1;
        return !0
    }

    function Rt(e, t, n) {
        return e === t || !0 === n || !!n && n(e, t)
    }

    function Yt(e, t, n) {
        var i = n.dateEnv, r = n.pluginHooks, o = n.options, a = e.defs, s = e.instances;
        for (var l in s = Dt(s, (function (e) {
            return !a[e.defId].recurringDef
        })), a) {
            var c = a[l];
            if (c.recurringDef) {
                var u = c.recurringDef.duration;
                u || (u = c.allDay ? o.defaultAllDayEventDuration : o.defaultTimedEventDuration);
                for (var d = 0, h = zt(c, u, t, i, r.recurringTypes); d < h.length; d++) {
                    var p = h[d], f = Tt(l, {start: p, end: i.add(p, u)});
                    s[f.instanceId] = f
                }
            }
        }
        return {defs: a, instances: s}
    }

    function zt(e, t, n, i, r) {
        var o = r[e.recurringDef.typeId].expand(e.recurringDef.typeData, {
            start: i.subtract(n.start, t),
            end: n.end
        }, i);
        return e.allDay && (o = o.map(mt)), o
    }

    var Ot = ["years", "months", "days", "milliseconds"],
        Ft = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;

    function Bt(e, t) {
        var n;
        return "string" == typeof e ? function (e) {
            var t = Ft.exec(e);
            if (t) {
                var n = t[1] ? -1 : 1;
                return {
                    years: 0,
                    months: 0,
                    days: n * (t[2] ? parseInt(t[2], 10) : 0),
                    milliseconds: n * (60 * (t[3] ? parseInt(t[3], 10) : 0) * 60 * 1e3 + 60 * (t[4] ? parseInt(t[4], 10) : 0) * 1e3 + 1e3 * (t[5] ? parseInt(t[5], 10) : 0) + (t[6] ? parseInt(t[6], 10) : 0))
                }
            }
            return null
        }(e) : "object" == typeof e && e ? jt(e) : "number" == typeof e ? jt(((n = {})[t || "milliseconds"] = e, n)) : null
    }

    function jt(e) {
        var t = {
            years: e.years || e.year || 0,
            months: e.months || e.month || 0,
            days: e.days || e.day || 0,
            milliseconds: 60 * (e.hours || e.hour || 0) * 60 * 1e3 + 60 * (e.minutes || e.minute || 0) * 1e3 + 1e3 * (e.seconds || e.second || 0) + (e.milliseconds || e.millisecond || e.ms || 0)
        }, n = e.weeks || e.week;
        return n && (t.days += 7 * n, t.specifiedWeeks = !0), t
    }

    function Ht(e, t) {
        return {
            years: e.years + t.years,
            months: e.months + t.months,
            days: e.days + t.days,
            milliseconds: e.milliseconds + t.milliseconds
        }
    }

    function Nt(e) {
        return Ut(e) / 864e5
    }

    function Ut(e) {
        return 31536e6 * e.years + 2592e6 * e.months + 864e5 * e.days + e.milliseconds
    }

    function Wt(e, t) {
        for (var n = null, i = 0; i < Ot.length; i += 1) {
            var r = Ot[i];
            if (t[r]) {
                var o = e[r] / t[r];
                if (!st(o) || null !== n && n !== o) return null;
                n = o
            } else if (e[r]) return null
        }
        return n
    }

    function Vt(e) {
        var t = e.milliseconds;
        if (t) {
            if (t % 1e3 != 0) return {unit: "millisecond", value: t};
            if (t % 6e4 != 0) return {unit: "second", value: t / 1e3};
            if (t % 36e5 != 0) return {unit: "minute", value: t / 6e4};
            if (t) return {unit: "hour", value: t / 36e5}
        }
        return e.days ? e.specifiedWeeks && e.days % 7 == 0 ? {unit: "week", value: e.days / 7} : {
            unit: "day",
            value: e.days
        } : e.months ? {unit: "month", value: e.months} : e.years ? {
            unit: "year",
            value: e.years
        } : {unit: "millisecond", value: 0}
    }

    function Gt(e, t, n) {
        void 0 === n && (n = !1);
        var i = e.toISOString();
        return i = i.replace(".000", ""), n && (i = i.replace("T00:00:00Z", "")), i.length > 10 && (null == t ? i = i.replace("Z", "") : 0 !== t && (i = i.replace("Z", Zt(t, !0)))), i
    }

    function qt(e) {
        return e.toISOString().replace(/T.*$/, "")
    }

    function Zt(e, t) {
        void 0 === t && (t = !1);
        var n = e < 0 ? "-" : "+", i = Math.abs(e), r = Math.floor(i / 60), o = Math.round(i % 60);
        return t ? n + rt(r, 2) + ":" + rt(o, 2) : "GMT" + n + r + (o ? ":" + rt(o, 2) : "")
    }

    function $t(e, t, n) {
        if (e === t) return !0;
        var i, r = e.length;
        if (r !== t.length) return !1;
        for (i = 0; i < r; i += 1) if (!(n ? n(e[i], t[i]) : e[i] === t[i])) return !1;
        return !0
    }

    function Xt(e, t, n) {
        var i, r;
        return function () {
            for (var o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];
            if (i) {
                if (!$t(i, o)) {
                    n && n(r);
                    var s = e.apply(this, o);
                    t && t(s, r) || (r = s)
                }
            } else r = e.apply(this, o);
            return i = o, r
        }
    }

    function Jt(e, t, n) {
        var i, r, o = this;
        return function (a) {
            if (i) {
                if (!At(i, a)) {
                    n && n(r);
                    var s = e.call(o, a);
                    t && t(s, r) || (r = s)
                }
            } else r = e.call(o, a);
            return i = a, r
        }
    }

    var Kt = {week: 3, separator: 0, omitZeroMinute: 0, meridiem: 0, omitCommas: 0},
        Qt = {timeZoneName: 7, era: 6, year: 5, month: 4, day: 2, weekday: 2, hour: 1, minute: 1, second: 1},
        en = /\s*([ap])\.?m\.?/i, tn = /,/g, nn = /\s+/g, rn = /\u200e/g, on = /UTC|GMT/, an = function () {
            function e(e) {
                var t = {}, n = {}, i = 0;
                for (var r in e) r in Kt ? (n[r] = e[r], i = Math.max(Kt[r], i)) : (t[r] = e[r], r in Qt && (i = Math.max(Qt[r], i)));
                this.standardDateProps = t, this.extendedSettings = n, this.severity = i, this.buildFormattingFunc = Xt(sn)
            }

            return e.prototype.format = function (e, t) {
                return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, t)(e)
            }, e.prototype.formatRange = function (e, t, n, i) {
                var r = this.standardDateProps, o = this.extendedSettings, a = function (e, t, n) {
                    if (n.getMarkerYear(e) !== n.getMarkerYear(t)) return 5;
                    if (n.getMarkerMonth(e) !== n.getMarkerMonth(t)) return 4;
                    if (n.getMarkerDay(e) !== n.getMarkerDay(t)) return 2;
                    if (Mt(e) !== Mt(t)) return 1;
                    return 0
                }(e.marker, t.marker, n.calendarSystem);
                if (!a) return this.format(e, n);
                var s = a;
                !(s > 1) || "numeric" !== r.year && "2-digit" !== r.year || "numeric" !== r.month && "2-digit" !== r.month || "numeric" !== r.day && "2-digit" !== r.day || (s = 1);
                var l = this.format(e, n), c = this.format(t, n);
                if (l === c) return l;
                var u = sn(function (e, t) {
                    var n = {};
                    for (var i in e) (!(i in Qt) || Qt[i] <= t) && (n[i] = e[i]);
                    return n
                }(r, s), o, n), d = u(e), h = u(t), p = function (e, t, n, i) {
                    var r = 0;
                    for (; r < e.length;) {
                        var o = e.indexOf(t, r);
                        if (-1 === o) break;
                        var a = e.substr(0, o);
                        r = o + t.length;
                        for (var s = e.substr(r), l = 0; l < n.length;) {
                            var c = n.indexOf(i, l);
                            if (-1 === c) break;
                            var u = n.substr(0, c);
                            l = c + i.length;
                            var d = n.substr(l);
                            if (a === u && s === d) return {before: a, after: s}
                        }
                    }
                    return null
                }(l, d, c, h), f = o.separator || i || n.defaultSeparator || "";
                return p ? p.before + d + f + h + p.after : l + f + c
            }, e.prototype.getLargestUnit = function () {
                switch (this.severity) {
                    case 7:
                    case 6:
                    case 5:
                        return "year";
                    case 4:
                        return "month";
                    case 3:
                        return "week";
                    case 2:
                        return "day";
                    default:
                        return "time"
                }
            }, e
        }();

    function sn(e, t, n) {
        var i = Object.keys(e).length;
        return 1 === i && "short" === e.timeZoneName ? function (e) {
            return Zt(e.timeZoneOffset)
        } : 0 === i && t.week ? function (e) {
            return function (e, t, n, i, r) {
                var o = [];
                "long" === r ? o.push(n) : "short" !== r && "narrow" !== r || o.push(t);
                "long" !== r && "short" !== r || o.push(" ");
                o.push(i.simpleNumberFormat.format(e)), "rtl" === i.options.direction && o.reverse();
                return o.join("")
            }(n.computeWeekNumber(e.marker), n.weekText, n.weekTextLong, n.locale, t.week)
        } : function (e, t, n) {
            e = o({}, e), t = o({}, t), function (e, t) {
                e.timeZoneName && (e.hour || (e.hour = "2-digit"), e.minute || (e.minute = "2-digit"));
                "long" === e.timeZoneName && (e.timeZoneName = "short");
                t.omitZeroMinute && (e.second || e.millisecond) && delete t.omitZeroMinute
            }(e, t), e.timeZone = "UTC";
            var i, r = new Intl.DateTimeFormat(n.locale.codes, e);
            if (t.omitZeroMinute) {
                var a = o({}, e);
                delete a.minute, i = new Intl.DateTimeFormat(n.locale.codes, a)
            }
            return function (o) {
                var a = o.marker;
                return function (e, t, n, i, r) {
                    e = e.replace(rn, ""), "short" === n.timeZoneName && (e = function (e, t) {
                        var n = !1;
                        e = e.replace(on, (function () {
                            return n = !0, t
                        })), n || (e += " " + t);
                        return e
                    }(e, "UTC" === r.timeZone || null == t.timeZoneOffset ? "UTC" : Zt(t.timeZoneOffset)));
                    i.omitCommas && (e = e.replace(tn, "").trim());
                    i.omitZeroMinute && (e = e.replace(":00", ""));
                    !1 === i.meridiem ? e = e.replace(en, "").trim() : "narrow" === i.meridiem ? e = e.replace(en, (function (e, t) {
                        return t.toLocaleLowerCase()
                    })) : "short" === i.meridiem ? e = e.replace(en, (function (e, t) {
                        return t.toLocaleLowerCase() + "m"
                    })) : "lowercase" === i.meridiem && (e = e.replace(en, (function (e) {
                        return e.toLocaleLowerCase()
                    })));
                    return e = (e = e.replace(nn, " ")).trim()
                }((i && !a.getUTCMinutes() ? i : r).format(a), o, e, t, n)
            }
        }(e, t, n)
    }

    function ln(e, t) {
        var n = t.markerToArray(e.marker);
        return {
            marker: e.marker,
            timeZoneOffset: e.timeZoneOffset,
            array: n,
            year: n[0],
            month: n[1],
            day: n[2],
            hour: n[3],
            minute: n[4],
            second: n[5],
            millisecond: n[6]
        }
    }

    function cn(e, t, n, i) {
        var r = ln(e, n.calendarSystem);
        return {
            date: r,
            start: r,
            end: t ? ln(t, n.calendarSystem) : null,
            timeZone: n.timeZone,
            localeCodes: n.locale.codes,
            defaultSeparator: i || n.defaultSeparator
        }
    }

    var un = function () {
        function e(e) {
            this.cmdStr = e
        }

        return e.prototype.format = function (e, t, n) {
            return t.cmdFormatter(this.cmdStr, cn(e, null, t, n))
        }, e.prototype.formatRange = function (e, t, n, i) {
            return n.cmdFormatter(this.cmdStr, cn(e, t, n, i))
        }, e
    }(), dn = function () {
        function e(e) {
            this.func = e
        }

        return e.prototype.format = function (e, t, n) {
            return this.func(cn(e, null, t, n))
        }, e.prototype.formatRange = function (e, t, n, i) {
            return this.func(cn(e, t, n, i))
        }, e
    }();

    function hn(e) {
        return "object" == typeof e && e ? new an(e) : "string" == typeof e ? new un(e) : "function" == typeof e ? new dn(e) : null
    }

    var pn = {
            navLinkDayClick: wn,
            navLinkWeekClick: wn,
            duration: Bt,
            bootstrapFontAwesome: wn,
            buttonIcons: wn,
            customButtons: wn,
            defaultAllDayEventDuration: Bt,
            defaultTimedEventDuration: Bt,
            nextDayThreshold: Bt,
            scrollTime: Bt,
            scrollTimeReset: Boolean,
            slotMinTime: Bt,
            slotMaxTime: Bt,
            dayPopoverFormat: hn,
            slotDuration: Bt,
            snapDuration: Bt,
            headerToolbar: wn,
            footerToolbar: wn,
            defaultRangeSeparator: String,
            titleRangeSeparator: String,
            forceEventDuration: Boolean,
            dayHeaders: Boolean,
            dayHeaderFormat: hn,
            dayHeaderClassNames: wn,
            dayHeaderContent: wn,
            dayHeaderDidMount: wn,
            dayHeaderWillUnmount: wn,
            dayCellClassNames: wn,
            dayCellContent: wn,
            dayCellDidMount: wn,
            dayCellWillUnmount: wn,
            initialView: String,
            aspectRatio: Number,
            weekends: Boolean,
            weekNumberCalculation: wn,
            weekNumbers: Boolean,
            weekNumberClassNames: wn,
            weekNumberContent: wn,
            weekNumberDidMount: wn,
            weekNumberWillUnmount: wn,
            editable: Boolean,
            viewClassNames: wn,
            viewDidMount: wn,
            viewWillUnmount: wn,
            nowIndicator: Boolean,
            nowIndicatorClassNames: wn,
            nowIndicatorContent: wn,
            nowIndicatorDidMount: wn,
            nowIndicatorWillUnmount: wn,
            showNonCurrentDates: Boolean,
            lazyFetching: Boolean,
            startParam: String,
            endParam: String,
            timeZoneParam: String,
            timeZone: String,
            locales: wn,
            locale: wn,
            themeSystem: String,
            dragRevertDuration: Number,
            dragScroll: Boolean,
            allDayMaintainDuration: Boolean,
            unselectAuto: Boolean,
            dropAccept: wn,
            eventOrder: function (e) {
                var t, n, i = [], r = [];
                for ("string" == typeof e ? r = e.split(/\s*,\s*/) : "function" == typeof e ? r = [e] : Array.isArray(e) && (r = e), t = 0; t < r.length; t += 1) "string" == typeof (n = r[t]) ? i.push("-" === n.charAt(0) ? {
                    field: n.substring(1),
                    order: -1
                } : {field: n, order: 1}) : "function" == typeof n && i.push({func: n});
                return i
            },
            eventOrderStrict: Boolean,
            handleWindowResize: Boolean,
            windowResizeDelay: Number,
            longPressDelay: Number,
            eventDragMinDistance: Number,
            expandRows: Boolean,
            height: wn,
            contentHeight: wn,
            direction: String,
            weekNumberFormat: hn,
            eventResizableFromStart: Boolean,
            displayEventTime: Boolean,
            displayEventEnd: Boolean,
            weekText: String,
            weekTextLong: String,
            progressiveEventRendering: Boolean,
            businessHours: wn,
            initialDate: wn,
            now: wn,
            eventDataTransform: wn,
            stickyHeaderDates: wn,
            stickyFooterScrollbar: wn,
            viewHeight: wn,
            defaultAllDay: Boolean,
            eventSourceFailure: wn,
            eventSourceSuccess: wn,
            eventDisplay: String,
            eventStartEditable: Boolean,
            eventDurationEditable: Boolean,
            eventOverlap: wn,
            eventConstraint: wn,
            eventAllow: wn,
            eventBackgroundColor: String,
            eventBorderColor: String,
            eventTextColor: String,
            eventColor: String,
            eventClassNames: wn,
            eventContent: wn,
            eventDidMount: wn,
            eventWillUnmount: wn,
            selectConstraint: wn,
            selectOverlap: wn,
            selectAllow: wn,
            droppable: Boolean,
            unselectCancel: String,
            slotLabelFormat: wn,
            slotLaneClassNames: wn,
            slotLaneContent: wn,
            slotLaneDidMount: wn,
            slotLaneWillUnmount: wn,
            slotLabelClassNames: wn,
            slotLabelContent: wn,
            slotLabelDidMount: wn,
            slotLabelWillUnmount: wn,
            dayMaxEvents: wn,
            dayMaxEventRows: wn,
            dayMinWidth: Number,
            slotLabelInterval: Bt,
            allDayText: String,
            allDayClassNames: wn,
            allDayContent: wn,
            allDayDidMount: wn,
            allDayWillUnmount: wn,
            slotMinWidth: Number,
            navLinks: Boolean,
            eventTimeFormat: hn,
            rerenderDelay: Number,
            moreLinkText: wn,
            moreLinkHint: wn,
            selectMinDistance: Number,
            selectable: Boolean,
            selectLongPressDelay: Number,
            eventLongPressDelay: Number,
            selectMirror: Boolean,
            eventMaxStack: Number,
            eventMinHeight: Number,
            eventMinWidth: Number,
            eventShortHeight: Number,
            slotEventOverlap: Boolean,
            plugins: wn,
            firstDay: Number,
            dayCount: Number,
            dateAlignment: String,
            dateIncrement: Bt,
            hiddenDays: wn,
            monthMode: Boolean,
            fixedWeekCount: Boolean,
            validRange: wn,
            visibleRange: wn,
            titleFormat: wn,
            eventInteractive: Boolean,
            noEventsText: String,
            viewHint: wn,
            navLinkHint: wn,
            closeHint: String,
            timeHint: String,
            eventHint: String,
            moreLinkClick: wn,
            moreLinkClassNames: wn,
            moreLinkContent: wn,
            moreLinkDidMount: wn,
            moreLinkWillUnmount: wn
        }, fn = {
            eventDisplay: "auto",
            defaultRangeSeparator: " - ",
            titleRangeSeparator: "  ",
            defaultTimedEventDuration: "01:00:00",
            defaultAllDayEventDuration: {day: 1},
            forceEventDuration: !1,
            nextDayThreshold: "00:00:00",
            dayHeaders: !0,
            initialView: "",
            aspectRatio: 1.35,
            headerToolbar: {start: "title", center: "", end: "today prev,next"},
            weekends: !0,
            weekNumbers: !1,
            weekNumberCalculation: "local",
            editable: !1,
            nowIndicator: !1,
            scrollTime: "06:00:00",
            scrollTimeReset: !0,
            slotMinTime: "00:00:00",
            slotMaxTime: "24:00:00",
            showNonCurrentDates: !0,
            lazyFetching: !0,
            startParam: "start",
            endParam: "end",
            timeZoneParam: "timeZone",
            timeZone: "local",
            locales: [],
            locale: "",
            themeSystem: "standard",
            dragRevertDuration: 500,
            dragScroll: !0,
            allDayMaintainDuration: !1,
            unselectAuto: !0,
            dropAccept: "*",
            eventOrder: "start,-duration,allDay,title",
            dayPopoverFormat: {month: "long", day: "numeric", year: "numeric"},
            handleWindowResize: !0,
            windowResizeDelay: 100,
            longPressDelay: 1e3,
            eventDragMinDistance: 5,
            expandRows: !1,
            navLinks: !1,
            selectable: !1,
            eventMinHeight: 15,
            eventMinWidth: 30,
            eventShortHeight: 30
        }, mn = {
            datesSet: wn,
            eventsSet: wn,
            eventAdd: wn,
            eventChange: wn,
            eventRemove: wn,
            windowResize: wn,
            eventClick: wn,
            eventMouseEnter: wn,
            eventMouseLeave: wn,
            select: wn,
            unselect: wn,
            loading: wn,
            _unmount: wn,
            _beforeprint: wn,
            _afterprint: wn,
            _noEventDrop: wn,
            _noEventResize: wn,
            _resize: wn,
            _scrollRequest: wn
        }, _n = {buttonText: wn, buttonHints: wn, views: wn, plugins: wn, initialEvents: wn, events: wn, eventSources: wn},
        gn = {headerToolbar: yn, footerToolbar: yn, buttonText: yn, buttonHints: yn, buttonIcons: yn};

    function yn(e, t) {
        return "object" == typeof e && "object" == typeof t && e && t ? At(e, t) : e === t
    }

    var vn = {
        type: String,
        component: wn,
        buttonText: String,
        buttonTextKey: String,
        dateProfileGeneratorClass: wn,
        usesMinMaxTime: Boolean,
        classNames: wn,
        content: wn,
        didMount: wn,
        willUnmount: wn
    };

    function xn(e) {
        return St(e, gn)
    }

    function bn(e, t) {
        var n = {}, i = {};
        for (var r in t) r in e && (n[r] = t[r](e[r]));
        for (var r in e) r in t || (i[r] = e[r]);
        return {refined: n, extra: i}
    }

    function wn(e) {
        return e
    }

    function Mn(e, t, n, i) {
        for (var r = {defs: {}, instances: {}}, o = Bn(n), a = 0, s = e; a < s.length; a++) {
            var l = On(s[a], t, n, i, o);
            l && Tn(l, r)
        }
        return r
    }

    function Tn(e, t) {
        return void 0 === t && (t = {
            defs: {},
            instances: {}
        }), t.defs[e.def.defId] = e.def, e.instance && (t.instances[e.instance.instanceId] = e.instance), t
    }

    function kn(e, t) {
        var n = e.instances[t];
        if (n) {
            var i = e.defs[n.defId], r = Dn(e, (function (e) {
                return t = i, n = e, Boolean(t.groupId && t.groupId === n.groupId);
                var t, n
            }));
            return r.defs[i.defId] = i, r.instances[n.instanceId] = n, r
        }
        return {defs: {}, instances: {}}
    }

    function Sn(e, t) {
        return {defs: o(o({}, e.defs), t.defs), instances: o(o({}, e.instances), t.instances)}
    }

    function Dn(e, t) {
        var n = Dt(e.defs, t), i = Dt(e.instances, (function (e) {
            return n[e.defId]
        }));
        return {defs: n, instances: i}
    }

    function Ln(e) {
        return Array.isArray(e) ? e : "string" == typeof e ? e.split(/\s+/) : []
    }

    var En = {
        display: String,
        editable: Boolean,
        startEditable: Boolean,
        durationEditable: Boolean,
        constraint: wn,
        overlap: wn,
        allow: wn,
        className: Ln,
        classNames: Ln,
        color: String,
        backgroundColor: String,
        borderColor: String,
        textColor: String
    }, Cn = {
        display: null,
        startEditable: null,
        durationEditable: null,
        constraints: [],
        overlap: null,
        allows: [],
        backgroundColor: "",
        borderColor: "",
        textColor: "",
        classNames: []
    };

    function An(e, t) {
        var n = function (e, t) {
            return Array.isArray(e) ? Mn(e, null, t, !0) : "object" == typeof e && e ? Mn([e], null, t, !0) : null != e ? String(e) : null
        }(e.constraint, t);
        return {
            display: e.display || null,
            startEditable: null != e.startEditable ? e.startEditable : e.editable,
            durationEditable: null != e.durationEditable ? e.durationEditable : e.editable,
            constraints: null != n ? [n] : [],
            overlap: null != e.overlap ? e.overlap : null,
            allows: null != e.allow ? [e.allow] : [],
            backgroundColor: e.backgroundColor || e.color || "",
            borderColor: e.borderColor || e.color || "",
            textColor: e.textColor || "",
            classNames: (e.className || []).concat(e.classNames || [])
        }
    }

    function In(e) {
        return e.reduce(Pn, Cn)
    }

    function Pn(e, t) {
        return {
            display: null != t.display ? t.display : e.display,
            startEditable: null != t.startEditable ? t.startEditable : e.startEditable,
            durationEditable: null != t.durationEditable ? t.durationEditable : e.durationEditable,
            constraints: e.constraints.concat(t.constraints),
            overlap: "boolean" == typeof t.overlap ? t.overlap : e.overlap,
            allows: e.allows.concat(t.allows),
            backgroundColor: t.backgroundColor || e.backgroundColor,
            borderColor: t.borderColor || e.borderColor,
            textColor: t.textColor || e.textColor,
            classNames: e.classNames.concat(t.classNames)
        }
    }

    var Rn = {id: String, groupId: String, title: String, url: String, interactive: Boolean},
        Yn = {start: wn, end: wn, date: wn, allDay: Boolean}, zn = o(o(o({}, Rn), Yn), {extendedProps: wn});

    function On(e, t, n, i, r) {
        void 0 === r && (r = Bn(n));
        var o = Fn(e, n, r), a = o.refined, s = o.extra, l = function (e, t) {
            var n = null;
            e && (n = e.defaultAllDay);
            null == n && (n = t.options.defaultAllDay);
            return n
        }(t, n), c = function (e, t, n, i) {
            for (var r = 0; r < i.length; r += 1) {
                var o = i[r].parse(e, n);
                if (o) {
                    var a = e.allDay;
                    return null == a && null == (a = t) && null == (a = o.allDayGuess) && (a = !1), {
                        allDay: a,
                        duration: o.duration,
                        typeData: o.typeData,
                        typeId: r
                    }
                }
            }
            return null
        }(a, l, n.dateEnv, n.pluginHooks.recurringTypes);
        if (c) return (u = jn(a, s, t ? t.sourceId : "", c.allDay, Boolean(c.duration), n)).recurringDef = {
            typeId: c.typeId,
            typeData: c.typeData,
            duration: c.duration
        }, {def: u, instance: null};
        var u, d = function (e, t, n, i) {
            var r, o, a = e.allDay, s = null, l = !1, c = null, u = null != e.start ? e.start : e.date;
            if (r = n.dateEnv.createMarkerMeta(u)) s = r.marker; else if (!i) return null;
            null != e.end && (o = n.dateEnv.createMarkerMeta(e.end));
            null == a && (a = null != t ? t : (!r || r.isTimeUnspecified) && (!o || o.isTimeUnspecified));
            a && s && (s = mt(s));
            o && (c = o.marker, a && (c = mt(c)), s && c <= s && (c = null));
            c ? l = !0 : i || (l = n.options.forceEventDuration || !1, c = n.dateEnv.add(s, a ? n.options.defaultAllDayEventDuration : n.options.defaultTimedEventDuration));
            return {
                allDay: a,
                hasEnd: l,
                range: {start: s, end: c},
                forcedStartTzo: r ? r.forcedTzo : null,
                forcedEndTzo: o ? o.forcedTzo : null
            }
        }(a, l, n, i);
        return d ? {
            def: u = jn(a, s, t ? t.sourceId : "", d.allDay, d.hasEnd, n),
            instance: Tt(u.defId, d.range, d.forcedStartTzo, d.forcedEndTzo)
        } : null
    }

    function Fn(e, t, n) {
        return void 0 === n && (n = Bn(t)), bn(e, n)
    }

    function Bn(e) {
        return o(o(o({}, En), zn), e.pluginHooks.eventRefiners)
    }

    function jn(e, t, n, i, r, a) {
        for (var s = {
            title: e.title || "",
            groupId: e.groupId || "",
            publicId: e.id || "",
            url: e.url || "",
            recurringDef: null,
            defId: et(),
            sourceId: n,
            allDay: i,
            hasEnd: r,
            interactive: e.interactive,
            ui: An(e, a),
            extendedProps: o(o({}, e.extendedProps || {}), t)
        }, l = 0, c = a.pluginHooks.eventDefMemberAdders; l < c.length; l++) {
            var u = c[l];
            o(s, u(e))
        }
        return Object.freeze(s.ui.classNames), Object.freeze(s.extendedProps), s
    }

    function Hn(e) {
        var t = Math.floor(pt(e.start, e.end)) || 1, n = mt(e.start);
        return {start: n, end: dt(n, t)}
    }

    function Nn(e, t) {
        void 0 === t && (t = Bt(0));
        var n = null, i = null;
        if (e.end) {
            i = mt(e.end);
            var r = e.end.valueOf() - i.valueOf();
            r && r >= Ut(t) && (i = dt(i, 1))
        }
        return e.start && (n = mt(e.start), i && i <= n && (i = dt(n, 1))), {start: n, end: i}
    }

    function Un(e, t, n, i) {
        return "year" === i ? Bt(n.diffWholeYears(e, t), "year") : "month" === i ? Bt(n.diffWholeMonths(e, t), "month") : (o = t, a = mt(r = e), s = mt(o), {
            years: 0,
            months: 0,
            days: Math.round(pt(a, s)),
            milliseconds: o.valueOf() - s.valueOf() - (r.valueOf() - a.valueOf())
        });
        var r, o, a, s
    }

    function Wn(e, t) {
        var n, i, r = [], o = t.start;
        for (e.sort(Vn), n = 0; n < e.length; n += 1) (i = e[n]).start > o && r.push({
            start: o,
            end: i.start
        }), i.end > o && (o = i.end);
        return o < t.end && r.push({start: o, end: t.end}), r
    }

    function Vn(e, t) {
        return e.start.valueOf() - t.start.valueOf()
    }

    function Gn(e, t) {
        var n = e.start, i = e.end, r = null;
        return null !== t.start && (n = null === n ? t.start : new Date(Math.max(n.valueOf(), t.start.valueOf()))), null != t.end && (i = null === i ? t.end : new Date(Math.min(i.valueOf(), t.end.valueOf()))), (null === n || null === i || n < i) && (r = {
            start: n,
            end: i
        }), r
    }

    function qn(e, t) {
        return (null === e.end || null === t.start || e.end > t.start) && (null === e.start || null === t.end || e.start < t.end)
    }

    function Zn(e, t) {
        return (null === e.start || null !== t.start && t.start >= e.start) && (null === e.end || null !== t.end && t.end <= e.end)
    }

    function $n(e, t) {
        return (null === e.start || t >= e.start) && (null === e.end || t < e.end)
    }

    function Xn(e, t, n, i) {
        var r = {}, o = {}, a = {}, s = [], l = [], c = Qn(e.defs, t);
        for (var u in e.defs) {
            "inverse-background" === (p = c[(x = e.defs[u]).defId]).display && (x.groupId ? (r[x.groupId] = [], a[x.groupId] || (a[x.groupId] = x)) : o[u] = [])
        }
        for (var d in e.instances) {
            var h = e.instances[d], p = c[(x = e.defs[h.defId]).defId], f = h.range, m = !x.allDay && i ? Nn(f, i) : f,
                _ = Gn(m, n);
            _ && ("inverse-background" === p.display ? x.groupId ? r[x.groupId].push(_) : o[h.defId].push(_) : "none" !== p.display && ("background" === p.display ? s : l).push({
                def: x,
                ui: p,
                instance: h,
                range: _,
                isStart: m.start && m.start.valueOf() === _.start.valueOf(),
                isEnd: m.end && m.end.valueOf() === _.end.valueOf()
            }))
        }
        for (var g in r) for (var y = 0, v = Wn(r[g], n); y < v.length; y++) {
            var x, b = v[y];
            p = c[(x = a[g]).defId];
            s.push({def: x, ui: p, instance: null, range: b, isStart: !1, isEnd: !1})
        }
        for (var u in o) for (var w = 0, M = Wn(o[u], n); w < M.length; w++) {
            b = M[w];
            s.push({def: e.defs[u], ui: c[u], instance: null, range: b, isStart: !1, isEnd: !1})
        }
        return {bg: s, fg: l}
    }

    function Jn(e, t) {
        e.fcSeg = t
    }

    function Kn(e) {
        return e.fcSeg || e.parentNode.fcSeg || null
    }

    function Qn(e, t) {
        return Lt(e, (function (e) {
            return ei(e, t)
        }))
    }

    function ei(e, t) {
        var n = [];
        return t[""] && n.push(t[""]), t[e.defId] && n.push(t[e.defId]), n.push(e.ui), In(n)
    }

    function ti(e, t) {
        var n = e.map(ni);
        return n.sort((function (e, n) {
            return function (e, t, n) {
                var i, r;
                for (i = 0; i < n.length; i += 1) if (r = it(e, t, n[i])) return r;
                return 0
            }(e, n, t)
        })), n.map((function (e) {
            return e._seg
        }))
    }

    function ni(e) {
        var t = e.eventRange, n = t.def, i = t.instance ? t.instance.range : t.range,
            r = i.start ? i.start.valueOf() : 0, a = i.end ? i.end.valueOf() : 0;
        return o(o(o({}, n.extendedProps), n), {
            id: n.publicId,
            start: r,
            end: a,
            duration: a - r,
            allDay: Number(n.allDay),
            _seg: e
        })
    }

    function ii(e, t) {
        for (var n = t.pluginHooks.isDraggableTransformers, i = e.eventRange, r = i.def, o = i.ui, a = o.startEditable, s = 0, l = n; s < l.length; s++) {
            a = (0, l[s])(a, r, o, t)
        }
        return a
    }

    function ri(e, t) {
        return e.isStart && e.eventRange.ui.durationEditable && t.options.eventResizableFromStart
    }

    function oi(e, t) {
        return e.isEnd && e.eventRange.ui.durationEditable
    }

    function ai(e, t, n, i, r, o, a) {
        var s = n.dateEnv, l = n.options, c = l.displayEventTime, u = l.displayEventEnd, d = e.eventRange.def,
            h = e.eventRange.instance;
        null == c && (c = !1 !== i), null == u && (u = !1 !== r);
        var p = h.range.start, f = h.range.end, m = o || e.start || e.eventRange.range.start,
            _ = a || e.end || e.eventRange.range.end, g = mt(p).valueOf() === mt(m).valueOf(),
            y = mt(ht(f, -1)).valueOf() === mt(ht(_, -1)).valueOf();
        return c && !d.allDay && (g || y) ? (m = g ? p : m, _ = y ? f : _, u && d.hasEnd ? s.formatRange(m, _, t, {
            forcedStartTzo: o ? null : h.forcedStartTzo,
            forcedEndTzo: a ? null : h.forcedEndTzo
        }) : s.format(m, t, {forcedTzo: o ? null : h.forcedStartTzo})) : ""
    }

    function si(e, t, n) {
        var i = e.eventRange.range;
        return {isPast: i.end < (n || t.start), isFuture: i.start >= (n || t.end), isToday: t && $n(t, i.start)}
    }

    function li(e) {
        return e.instance ? e.instance.instanceId : e.def.defId + ":" + e.range.start.toISOString()
    }

    function ci(e, t) {
        var n = e.eventRange, i = n.def, r = n.instance, o = i.url;
        if (o) return {href: o};
        var a = t.emitter, s = t.options.eventInteractive;
        return null == s && null == (s = i.interactive) && (s = Boolean(a.hasHandlers("eventClick"))), s ? Ke((function (e) {
            a.trigger("eventClick", {el: e.target, event: new Di(t, i, r), jsEvent: e, view: t.viewApi})
        })) : {}
    }

    var ui = {start: wn, end: wn, allDay: Boolean};

    function di(e, t, n) {
        var i = function (e, t) {
            var n = bn(e, ui), i = n.refined, r = n.extra, a = i.start ? t.createMarkerMeta(i.start) : null,
                s = i.end ? t.createMarkerMeta(i.end) : null, l = i.allDay;
            null == l && (l = a && a.isTimeUnspecified && (!s || s.isTimeUnspecified));
            return o({range: {start: a ? a.marker : null, end: s ? s.marker : null}, allDay: l}, r)
        }(e, t), r = i.range;
        if (!r.start) return null;
        if (!r.end) {
            if (null == n) return null;
            r.end = t.add(r.start, n)
        }
        return i
    }

    function hi(e, t, n) {
        return o(o({}, pi(e, t, n)), {timeZone: t.timeZone})
    }

    function pi(e, t, n) {
        return {
            start: t.toDate(e.start),
            end: t.toDate(e.end),
            startStr: t.formatIso(e.start, {omitTime: n}),
            endStr: t.formatIso(e.end, {omitTime: n})
        }
    }

    function fi(e, t, n) {
        var i = Fn({editable: !1}, n), r = jn(i.refined, i.extra, "", e.allDay, !0, n);
        return {def: r, ui: ei(r, t), instance: Tt(r.defId, e.range), range: e.range, isStart: !0, isEnd: !0}
    }

    function mi(e, t, n) {
        n.emitter.trigger("select", o(o({}, _i(e, n)), {
            jsEvent: t ? t.origEvent : null,
            view: n.viewApi || n.calendarApi.view
        }))
    }

    function _i(e, t) {
        for (var n, i, r = {}, a = 0, s = t.pluginHooks.dateSpanTransforms; a < s.length; a++) {
            var l = s[a];
            o(r, l(e, t))
        }
        return o(r, (n = e, i = t.dateEnv, o(o({}, pi(n.range, i, n.allDay)), {allDay: n.allDay}))), r
    }

    function gi(e, t, n) {
        var i = n.dateEnv, r = n.options, o = t;
        return e ? (o = mt(o), o = i.add(o, r.defaultAllDayEventDuration)) : o = i.add(o, r.defaultTimedEventDuration), o
    }

    function yi(e, t, n, i) {
        var r = Qn(e.defs, t), o = {defs: {}, instances: {}};
        for (var a in e.defs) {
            var s = e.defs[a];
            o.defs[a] = vi(s, r[a], n, i)
        }
        for (var l in e.instances) {
            var c = e.instances[l];
            s = o.defs[c.defId];
            o.instances[l] = xi(c, s, r[c.defId], n, i)
        }
        return o
    }

    function vi(e, t, n, i) {
        var r = n.standardProps || {};
        null == r.hasEnd && t.durationEditable && (n.startDelta || n.endDelta) && (r.hasEnd = !0);
        var a = o(o(o({}, e), r), {ui: o(o({}, e.ui), r.ui)});
        n.extendedProps && (a.extendedProps = o(o({}, a.extendedProps), n.extendedProps));
        for (var s = 0, l = i.pluginHooks.eventDefMutationAppliers; s < l.length; s++) {
            (0, l[s])(a, n, i)
        }
        return !a.hasEnd && i.options.forceEventDuration && (a.hasEnd = !0), a
    }

    function xi(e, t, n, i, r) {
        var a = r.dateEnv, s = i.standardProps && !0 === i.standardProps.allDay,
            l = i.standardProps && !1 === i.standardProps.hasEnd, c = o({}, e);
        return s && (c.range = Hn(c.range)), i.datesDelta && n.startEditable && (c.range = {
            start: a.add(c.range.start, i.datesDelta),
            end: a.add(c.range.end, i.datesDelta)
        }), i.startDelta && n.durationEditable && (c.range = {
            start: a.add(c.range.start, i.startDelta),
            end: c.range.end
        }), i.endDelta && n.durationEditable && (c.range = {
            start: c.range.start,
            end: a.add(c.range.end, i.endDelta)
        }), l && (c.range = {
            start: c.range.start,
            end: gi(t.allDay, c.range.start, r)
        }), t.allDay && (c.range = {
            start: mt(c.range.start),
            end: mt(c.range.end)
        }), c.range.end < c.range.start && (c.range.end = gi(t.allDay, c.range.start, r)), c
    }

    var bi = function () {
        function e(e, t, n) {
            this.type = e, this.getCurrentData = t, this.dateEnv = n
        }

        return Object.defineProperty(e.prototype, "calendar", {
            get: function () {
                return this.getCurrentData().calendarApi
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "title", {
            get: function () {
                return this.getCurrentData().viewTitle
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "activeStart", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start)
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "activeEnd", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end)
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "currentStart", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start)
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "currentEnd", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end)
            }, enumerable: !1, configurable: !0
        }), e.prototype.getOption = function (e) {
            return this.getCurrentData().options[e]
        }, e
    }(), wi = {
        id: String,
        defaultAllDay: Boolean,
        url: String,
        format: String,
        events: wn,
        eventDataTransform: wn,
        success: wn,
        failure: wn
    };

    function Mi(e, t, n) {
        var i;
        if (void 0 === n && (n = Ti(t)), "string" == typeof e ? i = {url: e} : "function" == typeof e || Array.isArray(e) ? i = {events: e} : "object" == typeof e && e && (i = e), i) {
            var r = bn(i, n), o = r.refined, a = r.extra, s = function (e, t) {
                for (var n = t.pluginHooks.eventSourceDefs, i = n.length - 1; i >= 0; i -= 1) {
                    var r = n[i].parseMeta(e);
                    if (r) return {sourceDefId: i, meta: r}
                }
                return null
            }(o, t);
            if (s) return {
                _raw: e,
                isFetching: !1,
                latestFetchId: "",
                fetchRange: null,
                defaultAllDay: o.defaultAllDay,
                eventDataTransform: o.eventDataTransform,
                success: o.success,
                failure: o.failure,
                publicId: o.id || "",
                sourceId: et(),
                sourceDefId: s.sourceDefId,
                meta: s.meta,
                ui: An(o, t),
                extendedProps: a
            }
        }
        return null
    }

    function Ti(e) {
        return o(o(o({}, En), wi), e.pluginHooks.eventSourceRefiners)
    }

    function ki(e, t) {
        return "function" == typeof e && (e = e()), null == e ? t.createNowMarker() : t.createMarker(e)
    }

    var Si = function () {
        function e() {
        }

        return e.prototype.getCurrentData = function () {
            return this.currentDataManager.getCurrentData()
        }, e.prototype.dispatch = function (e) {
            return this.currentDataManager.dispatch(e)
        }, Object.defineProperty(e.prototype, "view", {
            get: function () {
                return this.getCurrentData().viewApi
            }, enumerable: !1, configurable: !0
        }), e.prototype.batchRendering = function (e) {
            e()
        }, e.prototype.updateSize = function () {
            this.trigger("_resize", !0)
        }, e.prototype.setOption = function (e, t) {
            this.dispatch({type: "SET_OPTION", optionName: e, rawOptionValue: t})
        }, e.prototype.getOption = function (e) {
            return this.currentDataManager.currentCalendarOptionsInput[e]
        }, e.prototype.getAvailableLocaleCodes = function () {
            return Object.keys(this.getCurrentData().availableRawLocales)
        }, e.prototype.on = function (e, t) {
            var n = this.currentDataManager;
            n.currentCalendarOptionsRefiners[e] ? n.emitter.on(e, t) : console.warn("Unknown listener name '" + e + "'")
        }, e.prototype.off = function (e, t) {
            this.currentDataManager.emitter.off(e, t)
        }, e.prototype.trigger = function (e) {
            for (var t, n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
            (t = this.currentDataManager.emitter).trigger.apply(t, a([e], n))
        }, e.prototype.changeView = function (e, t) {
            var n = this;
            this.batchRendering((function () {
                if (n.unselect(), t) if (t.start && t.end) n.dispatch({
                    type: "CHANGE_VIEW_TYPE",
                    viewType: e
                }), n.dispatch({type: "SET_OPTION", optionName: "visibleRange", rawOptionValue: t}); else {
                    var i = n.getCurrentData().dateEnv;
                    n.dispatch({type: "CHANGE_VIEW_TYPE", viewType: e, dateMarker: i.createMarker(t)})
                } else n.dispatch({type: "CHANGE_VIEW_TYPE", viewType: e})
            }))
        }, e.prototype.zoomTo = function (e, t) {
            var n;
            t = t || "day", n = this.getCurrentData().viewSpecs[t] || this.getUnitViewSpec(t), this.unselect(), n ? this.dispatch({
                type: "CHANGE_VIEW_TYPE",
                viewType: n.type,
                dateMarker: e
            }) : this.dispatch({type: "CHANGE_DATE", dateMarker: e})
        }, e.prototype.getUnitViewSpec = function (e) {
            var t, n, i = this.getCurrentData(), r = i.viewSpecs, o = i.toolbarConfig,
                a = [].concat(o.header ? o.header.viewsWithButtons : [], o.footer ? o.footer.viewsWithButtons : []);
            for (var s in r) a.push(s);
            for (t = 0; t < a.length; t += 1) if ((n = r[a[t]]) && n.singleUnit === e) return n;
            return null
        }, e.prototype.prev = function () {
            this.unselect(), this.dispatch({type: "PREV"})
        }, e.prototype.next = function () {
            this.unselect(), this.dispatch({type: "NEXT"})
        }, e.prototype.prevYear = function () {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, -1)})
        }, e.prototype.nextYear = function () {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, 1)})
        }, e.prototype.today = function () {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({type: "CHANGE_DATE", dateMarker: ki(e.calendarOptions.now, e.dateEnv)})
        }, e.prototype.gotoDate = function (e) {
            var t = this.getCurrentData();
            this.unselect(), this.dispatch({type: "CHANGE_DATE", dateMarker: t.dateEnv.createMarker(e)})
        }, e.prototype.incrementDate = function (e) {
            var t = this.getCurrentData(), n = Bt(e);
            n && (this.unselect(), this.dispatch({type: "CHANGE_DATE", dateMarker: t.dateEnv.add(t.currentDate, n)}))
        }, e.prototype.getDate = function () {
            var e = this.getCurrentData();
            return e.dateEnv.toDate(e.currentDate)
        }, e.prototype.formatDate = function (e, t) {
            var n = this.getCurrentData().dateEnv;
            return n.format(n.createMarker(e), hn(t))
        }, e.prototype.formatRange = function (e, t, n) {
            var i = this.getCurrentData().dateEnv;
            return i.formatRange(i.createMarker(e), i.createMarker(t), hn(n), n)
        }, e.prototype.formatIso = function (e, t) {
            var n = this.getCurrentData().dateEnv;
            return n.formatIso(n.createMarker(e), {omitTime: t})
        }, e.prototype.select = function (e, t) {
            var n;
            n = null == t ? null != e.start ? e : {start: e, end: null} : {start: e, end: t};
            var i = this.getCurrentData(), r = di(n, i.dateEnv, Bt({days: 1}));
            r && (this.dispatch({type: "SELECT_DATES", selection: r}), mi(r, null, i))
        }, e.prototype.unselect = function (e) {
            var t = this.getCurrentData();
            t.dateSelection && (this.dispatch({type: "UNSELECT_DATES"}), function (e, t) {
                t.emitter.trigger("unselect", {jsEvent: e ? e.origEvent : null, view: t.viewApi || t.calendarApi.view})
            }(e, t))
        }, e.prototype.addEvent = function (e, t) {
            if (e instanceof Di) {
                var n = e._def, i = e._instance;
                return this.getCurrentData().eventStore.defs[n.defId] || (this.dispatch({
                    type: "ADD_EVENTS",
                    eventStore: Tn({def: n, instance: i})
                }), this.triggerEventAdd(e)), e
            }
            var r, o = this.getCurrentData();
            if (t instanceof Oe) r = t.internalEventSource; else if ("boolean" == typeof t) t && (r = Ct(o.eventSources)[0]); else if (null != t) {
                var a = this.getEventSourceById(t);
                if (!a) return console.warn('Could not find an event source with ID "' + t + '"'), null;
                r = a.internalEventSource
            }
            var s = On(e, r, o, !1);
            if (s) {
                var l = new Di(o, s.def, s.def.recurringDef ? null : s.instance);
                return this.dispatch({type: "ADD_EVENTS", eventStore: Tn(s)}), this.triggerEventAdd(l), l
            }
            return null
        }, e.prototype.triggerEventAdd = function (e) {
            var t = this;
            this.getCurrentData().emitter.trigger("eventAdd", {
                event: e, relatedEvents: [], revert: function () {
                    t.dispatch({type: "REMOVE_EVENTS", eventStore: Li(e)})
                }
            })
        }, e.prototype.getEventById = function (e) {
            var t = this.getCurrentData(), n = t.eventStore, i = n.defs, r = n.instances;
            for (var o in e = String(e), i) {
                var a = i[o];
                if (a.publicId === e) {
                    if (a.recurringDef) return new Di(t, a, null);
                    for (var s in r) {
                        var l = r[s];
                        if (l.defId === a.defId) return new Di(t, a, l)
                    }
                }
            }
            return null
        }, e.prototype.getEvents = function () {
            var e = this.getCurrentData();
            return Ei(e.eventStore, e)
        }, e.prototype.removeAllEvents = function () {
            this.dispatch({type: "REMOVE_ALL_EVENTS"})
        }, e.prototype.getEventSources = function () {
            var e = this.getCurrentData(), t = e.eventSources, n = [];
            for (var i in t) n.push(new Oe(e, t[i]));
            return n
        }, e.prototype.getEventSourceById = function (e) {
            var t = this.getCurrentData(), n = t.eventSources;
            for (var i in e = String(e), n) if (n[i].publicId === e) return new Oe(t, n[i]);
            return null
        }, e.prototype.addEventSource = function (e) {
            var t = this.getCurrentData();
            if (e instanceof Oe) return t.eventSources[e.internalEventSource.sourceId] || this.dispatch({
                type: "ADD_EVENT_SOURCES",
                sources: [e.internalEventSource]
            }), e;
            var n = Mi(e, t);
            return n ? (this.dispatch({type: "ADD_EVENT_SOURCES", sources: [n]}), new Oe(t, n)) : null
        }, e.prototype.removeAllEventSources = function () {
            this.dispatch({type: "REMOVE_ALL_EVENT_SOURCES"})
        }, e.prototype.refetchEvents = function () {
            this.dispatch({type: "FETCH_EVENT_SOURCES", isRefetch: !0})
        }, e.prototype.scrollToTime = function (e) {
            var t = Bt(e);
            t && this.trigger("_scrollRequest", {time: t})
        }, e
    }(), Di = function () {
        function e(e, t, n) {
            this._context = e, this._def = t, this._instance = n || null
        }

        return e.prototype.setProp = function (e, t) {
            var n, i;
            if (e in Yn) console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead."); else if ("id" === e) t = Rn[e](t), this.mutate({standardProps: {publicId: t}}); else if (e in Rn) t = Rn[e](t), this.mutate({standardProps: (n = {}, n[e] = t, n)}); else if (e in En) {
                var r = En[e](t);
                "color" === e ? r = {backgroundColor: t, borderColor: t} : "editable" === e ? r = {
                    startEditable: t,
                    durationEditable: t
                } : ((i = {})[e] = t, r = i), this.mutate({standardProps: {ui: r}})
            } else console.warn("Could not set prop '" + e + "'. Use setExtendedProp instead.")
        }, e.prototype.setExtendedProp = function (e, t) {
            var n;
            this.mutate({extendedProps: (n = {}, n[e] = t, n)})
        }, e.prototype.setStart = function (e, t) {
            void 0 === t && (t = {});
            var n = this._context.dateEnv, i = n.createMarker(e);
            if (i && this._instance) {
                var r = Un(this._instance.range.start, i, n, t.granularity);
                t.maintainDuration ? this.mutate({datesDelta: r}) : this.mutate({startDelta: r})
            }
        }, e.prototype.setEnd = function (e, t) {
            void 0 === t && (t = {});
            var n, i = this._context.dateEnv;
            if ((null == e || (n = i.createMarker(e))) && this._instance) if (n) {
                var r = Un(this._instance.range.end, n, i, t.granularity);
                this.mutate({endDelta: r})
            } else this.mutate({standardProps: {hasEnd: !1}})
        }, e.prototype.setDates = function (e, t, n) {
            void 0 === n && (n = {});
            var i, r, o, a = this._context.dateEnv, s = {allDay: n.allDay}, l = a.createMarker(e);
            if (l && ((null == t || (i = a.createMarker(t))) && this._instance)) {
                var c = this._instance.range;
                !0 === n.allDay && (c = Hn(c));
                var u = Un(c.start, l, a, n.granularity);
                if (i) {
                    var d = Un(c.end, i, a, n.granularity);
                    o = d, (r = u).years === o.years && r.months === o.months && r.days === o.days && r.milliseconds === o.milliseconds ? this.mutate({
                        datesDelta: u,
                        standardProps: s
                    }) : this.mutate({startDelta: u, endDelta: d, standardProps: s})
                } else s.hasEnd = !1, this.mutate({datesDelta: u, standardProps: s})
            }
        }, e.prototype.moveStart = function (e) {
            var t = Bt(e);
            t && this.mutate({startDelta: t})
        }, e.prototype.moveEnd = function (e) {
            var t = Bt(e);
            t && this.mutate({endDelta: t})
        }, e.prototype.moveDates = function (e) {
            var t = Bt(e);
            t && this.mutate({datesDelta: t})
        }, e.prototype.setAllDay = function (e, t) {
            void 0 === t && (t = {});
            var n = {allDay: e}, i = t.maintainDuration;
            null == i && (i = this._context.options.allDayMaintainDuration), this._def.allDay !== e && (n.hasEnd = i), this.mutate({standardProps: n})
        }, e.prototype.formatRange = function (e) {
            var t = this._context.dateEnv, n = this._instance, i = hn(e);
            return this._def.hasEnd ? t.formatRange(n.range.start, n.range.end, i, {
                forcedStartTzo: n.forcedStartTzo,
                forcedEndTzo: n.forcedEndTzo
            }) : t.format(n.range.start, i, {forcedTzo: n.forcedStartTzo})
        }, e.prototype.mutate = function (t) {
            var n = this._instance;
            if (n) {
                var i = this._def, r = this._context, o = r.getCurrentData().eventStore, a = kn(o, n.instanceId);
                a = yi(a, {
                    "": {
                        display: "",
                        startEditable: !0,
                        durationEditable: !0,
                        constraints: [],
                        overlap: null,
                        allows: [],
                        backgroundColor: "",
                        borderColor: "",
                        textColor: "",
                        classNames: []
                    }
                }, t, r);
                var s = new e(r, i, n);
                this._def = a.defs[i.defId], this._instance = a.instances[n.instanceId], r.dispatch({
                    type: "MERGE_EVENTS",
                    eventStore: a
                }), r.emitter.trigger("eventChange", {
                    oldEvent: s,
                    event: this,
                    relatedEvents: Ei(a, r, n),
                    revert: function () {
                        r.dispatch({type: "RESET_EVENTS", eventStore: o})
                    }
                })
            }
        }, e.prototype.remove = function () {
            var e = this._context, t = Li(this);
            e.dispatch({type: "REMOVE_EVENTS", eventStore: t}), e.emitter.trigger("eventRemove", {
                event: this,
                relatedEvents: [],
                revert: function () {
                    e.dispatch({type: "MERGE_EVENTS", eventStore: t})
                }
            })
        }, Object.defineProperty(e.prototype, "source", {
            get: function () {
                var e = this._def.sourceId;
                return e ? new Oe(this._context, this._context.getCurrentData().eventSources[e]) : null
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "start", {
            get: function () {
                return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "end", {
            get: function () {
                return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "startStr", {
            get: function () {
                var e = this._instance;
                return e ? this._context.dateEnv.formatIso(e.range.start, {
                    omitTime: this._def.allDay,
                    forcedTzo: e.forcedStartTzo
                }) : ""
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "endStr", {
            get: function () {
                var e = this._instance;
                return e && this._def.hasEnd ? this._context.dateEnv.formatIso(e.range.end, {
                    omitTime: this._def.allDay,
                    forcedTzo: e.forcedEndTzo
                }) : ""
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "id", {
            get: function () {
                return this._def.publicId
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "groupId", {
            get: function () {
                return this._def.groupId
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "allDay", {
            get: function () {
                return this._def.allDay
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "title", {
            get: function () {
                return this._def.title
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "url", {
            get: function () {
                return this._def.url
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "display", {
            get: function () {
                return this._def.ui.display || "auto"
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "startEditable", {
            get: function () {
                return this._def.ui.startEditable
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "durationEditable", {
            get: function () {
                return this._def.ui.durationEditable
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "constraint", {
            get: function () {
                return this._def.ui.constraints[0] || null
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "overlap", {
            get: function () {
                return this._def.ui.overlap
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "allow", {
            get: function () {
                return this._def.ui.allows[0] || null
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "backgroundColor", {
            get: function () {
                return this._def.ui.backgroundColor
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "borderColor", {
            get: function () {
                return this._def.ui.borderColor
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "textColor", {
            get: function () {
                return this._def.ui.textColor
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "classNames", {
            get: function () {
                return this._def.ui.classNames
            }, enumerable: !1, configurable: !0
        }), Object.defineProperty(e.prototype, "extendedProps", {
            get: function () {
                return this._def.extendedProps
            }, enumerable: !1, configurable: !0
        }), e.prototype.toPlainObject = function (e) {
            void 0 === e && (e = {});
            var t = this._def, n = t.ui, i = this.startStr, r = this.endStr, a = {};
            return t.title && (a.title = t.title), i && (a.start = i), r && (a.end = r), t.publicId && (a.id = t.publicId), t.groupId && (a.groupId = t.groupId), t.url && (a.url = t.url), n.display && "auto" !== n.display && (a.display = n.display), e.collapseColor && n.backgroundColor && n.backgroundColor === n.borderColor ? a.color = n.backgroundColor : (n.backgroundColor && (a.backgroundColor = n.backgroundColor), n.borderColor && (a.borderColor = n.borderColor)), n.textColor && (a.textColor = n.textColor), n.classNames.length && (a.classNames = n.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? o(a, t.extendedProps) : a.extendedProps = t.extendedProps), a
        }, e.prototype.toJSON = function () {
            return this.toPlainObject()
        }, e
    }();

    function Li(e) {
        var t, n, i = e._def, r = e._instance;
        return {defs: (t = {}, t[i.defId] = i, t), instances: r ? (n = {}, n[r.instanceId] = r, n) : {}}
    }

    function Ei(e, t, n) {
        var i = e.defs, r = e.instances, o = [], a = n ? n.instanceId : "";
        for (var s in r) {
            var l = r[s], c = i[l.defId];
            l.instanceId !== a && o.push(new Di(t, c, l))
        }
        return o
    }

    var Ci = {};
    var Ai, Ii = function () {
        function e() {
        }

        return e.prototype.getMarkerYear = function (e) {
            return e.getUTCFullYear()
        }, e.prototype.getMarkerMonth = function (e) {
            return e.getUTCMonth()
        }, e.prototype.getMarkerDay = function (e) {
            return e.getUTCDate()
        }, e.prototype.arrayToMarker = function (e) {
            return bt(e)
        }, e.prototype.markerToArray = function (e) {
            return xt(e)
        }, e
    }();
    Ai = Ii, Ci["gregory"] = Ai;
    var Pi = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
    var Ri = function () {
        function e(e) {
            var t = this.timeZone = e.timeZone, n = "local" !== t && "UTC" !== t;
            e.namedTimeZoneImpl && n && (this.namedTimeZoneImpl = new e.namedTimeZoneImpl(t)), this.canComputeOffset = Boolean(!n || this.namedTimeZoneImpl), this.calendarSystem = function (e) {
                return new Ci[e]
            }(e.calendarSystem), this.locale = e.locale, this.weekDow = e.locale.week.dow, this.weekDoy = e.locale.week.doy, "ISO" === e.weekNumberCalculation && (this.weekDow = 1, this.weekDoy = 4), "number" == typeof e.firstDay && (this.weekDow = e.firstDay), "function" == typeof e.weekNumberCalculation && (this.weekNumberFunc = e.weekNumberCalculation), this.weekText = null != e.weekText ? e.weekText : e.locale.options.weekText, this.weekTextLong = (null != e.weekTextLong ? e.weekTextLong : e.locale.options.weekTextLong) || this.weekText, this.cmdFormatter = e.cmdFormatter, this.defaultSeparator = e.defaultSeparator
        }

        return e.prototype.createMarker = function (e) {
            var t = this.createMarkerMeta(e);
            return null === t ? null : t.marker
        }, e.prototype.createNowMarker = function () {
            return this.canComputeOffset ? this.timestampToMarker((new Date).valueOf()) : bt(yt(new Date))
        }, e.prototype.createMarkerMeta = function (e) {
            if ("string" == typeof e) return this.parse(e);
            var t = null;
            return "number" == typeof e ? t = this.timestampToMarker(e) : e instanceof Date ? (e = e.valueOf(), isNaN(e) || (t = this.timestampToMarker(e))) : Array.isArray(e) && (t = bt(e)), null !== t && wt(t) ? {
                marker: t,
                isTimeUnspecified: !1,
                forcedTzo: null
            } : null
        }, e.prototype.parse = function (e) {
            var t = function (e) {
                var t = Pi.exec(e);
                if (t) {
                    var n = new Date(Date.UTC(Number(t[1]), t[3] ? Number(t[3]) - 1 : 0, Number(t[5] || 1), Number(t[7] || 0), Number(t[8] || 0), Number(t[10] || 0), t[12] ? 1e3 * Number("0." + t[12]) : 0));
                    if (wt(n)) {
                        var i = null;
                        return t[13] && (i = ("-" === t[15] ? -1 : 1) * (60 * Number(t[16] || 0) + Number(t[18] || 0))), {
                            marker: n,
                            isTimeUnspecified: !t[6],
                            timeZoneOffset: i
                        }
                    }
                }
                return null
            }(e);
            if (null === t) return null;
            var n = t.marker, i = null;
            return null !== t.timeZoneOffset && (this.canComputeOffset ? n = this.timestampToMarker(n.valueOf() - 60 * t.timeZoneOffset * 1e3) : i = t.timeZoneOffset), {
                marker: n,
                isTimeUnspecified: t.isTimeUnspecified,
                forcedTzo: i
            }
        }, e.prototype.getYear = function (e) {
            return this.calendarSystem.getMarkerYear(e)
        }, e.prototype.getMonth = function (e) {
            return this.calendarSystem.getMarkerMonth(e)
        }, e.prototype.add = function (e, t) {
            var n = this.calendarSystem.markerToArray(e);
            return n[0] += t.years, n[1] += t.months, n[2] += t.days, n[6] += t.milliseconds, this.calendarSystem.arrayToMarker(n)
        }, e.prototype.subtract = function (e, t) {
            var n = this.calendarSystem.markerToArray(e);
            return n[0] -= t.years, n[1] -= t.months, n[2] -= t.days, n[6] -= t.milliseconds, this.calendarSystem.arrayToMarker(n)
        }, e.prototype.addYears = function (e, t) {
            var n = this.calendarSystem.markerToArray(e);
            return n[0] += t, this.calendarSystem.arrayToMarker(n)
        }, e.prototype.addMonths = function (e, t) {
            var n = this.calendarSystem.markerToArray(e);
            return n[1] += t, this.calendarSystem.arrayToMarker(n)
        }, e.prototype.diffWholeYears = function (e, t) {
            var n = this.calendarSystem;
            return Mt(e) === Mt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) && n.getMarkerMonth(e) === n.getMarkerMonth(t) ? n.getMarkerYear(t) - n.getMarkerYear(e) : null
        }, e.prototype.diffWholeMonths = function (e, t) {
            var n = this.calendarSystem;
            return Mt(e) === Mt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) ? n.getMarkerMonth(t) - n.getMarkerMonth(e) + 12 * (n.getMarkerYear(t) - n.getMarkerYear(e)) : null
        }, e.prototype.greatestWholeUnit = function (e, t) {
            var n = this.diffWholeYears(e, t);
            return null !== n ? {unit: "year", value: n} : null !== (n = this.diffWholeMonths(e, t)) ? {
                unit: "month",
                value: n
            } : null !== (n = function (e, t) {
                var n = ft(e, t);
                return null !== n && n % 7 == 0 ? n / 7 : null
            }(e, t)) ? {unit: "week", value: n} : null !== (n = ft(e, t)) ? {
                unit: "day",
                value: n
            } : st(n = function (e, t) {
                return (t.valueOf() - e.valueOf()) / 36e5
            }(e, t)) ? {unit: "hour", value: n} : st(n = function (e, t) {
                return (t.valueOf() - e.valueOf()) / 6e4
            }(e, t)) ? {unit: "minute", value: n} : st(n = function (e, t) {
                return (t.valueOf() - e.valueOf()) / 1e3
            }(e, t)) ? {unit: "second", value: n} : {unit: "millisecond", value: t.valueOf() - e.valueOf()}
        }, e.prototype.countDurationsBetween = function (e, t, n) {
            var i;
            return n.years && null !== (i = this.diffWholeYears(e, t)) ? i / (Nt(n) / 365) : n.months && null !== (i = this.diffWholeMonths(e, t)) ? i / function (e) {
                return Nt(e) / 30
            }(n) : n.days && null !== (i = ft(e, t)) ? i / Nt(n) : (t.valueOf() - e.valueOf()) / Ut(n)
        }, e.prototype.startOf = function (e, t) {
            return "year" === t ? this.startOfYear(e) : "month" === t ? this.startOfMonth(e) : "week" === t ? this.startOfWeek(e) : "day" === t ? mt(e) : "hour" === t ? function (e) {
                return bt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours()])
            }(e) : "minute" === t ? function (e) {
                return bt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes()])
            }(e) : "second" === t ? function (e) {
                return bt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds()])
            }(e) : null
        }, e.prototype.startOfYear = function (e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e)])
        }, e.prototype.startOfMonth = function (e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e)])
        }, e.prototype.startOfWeek = function (e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e), e.getUTCDate() - (e.getUTCDay() - this.weekDow + 7) % 7])
        }, e.prototype.computeWeekNumber = function (e) {
            return this.weekNumberFunc ? this.weekNumberFunc(this.toDate(e)) : function (e, t, n) {
                var i = e.getUTCFullYear(), r = _t(e, i, t, n);
                if (r < 1) return _t(e, i - 1, t, n);
                var o = _t(e, i + 1, t, n);
                return o >= 1 ? Math.min(r, o) : r
            }(e, this.weekDow, this.weekDoy)
        }, e.prototype.format = function (e, t, n) {
            return void 0 === n && (n = {}), t.format({
                marker: e,
                timeZoneOffset: null != n.forcedTzo ? n.forcedTzo : this.offsetForMarker(e)
            }, this)
        }, e.prototype.formatRange = function (e, t, n, i) {
            return void 0 === i && (i = {}), i.isEndExclusive && (t = ht(t, -1)), n.formatRange({
                marker: e,
                timeZoneOffset: null != i.forcedStartTzo ? i.forcedStartTzo : this.offsetForMarker(e)
            }, {
                marker: t,
                timeZoneOffset: null != i.forcedEndTzo ? i.forcedEndTzo : this.offsetForMarker(t)
            }, this, i.defaultSeparator)
        }, e.prototype.formatIso = function (e, t) {
            void 0 === t && (t = {});
            var n = null;
            return t.omitTimeZoneOffset || (n = null != t.forcedTzo ? t.forcedTzo : this.offsetForMarker(e)), Gt(e, n, t.omitTime)
        }, e.prototype.timestampToMarker = function (e) {
            return "local" === this.timeZone ? bt(yt(new Date(e))) : "UTC" !== this.timeZone && this.namedTimeZoneImpl ? bt(this.namedTimeZoneImpl.timestampToArray(e)) : new Date(e)
        }, e.prototype.offsetForMarker = function (e) {
            return "local" === this.timeZone ? -vt(xt(e)).getTimezoneOffset() : "UTC" === this.timeZone ? 0 : this.namedTimeZoneImpl ? this.namedTimeZoneImpl.offsetForArray(xt(e)) : null
        }, e.prototype.toDate = function (e, t) {
            return "local" === this.timeZone ? vt(xt(e)) : "UTC" === this.timeZone ? new Date(e.valueOf()) : this.namedTimeZoneImpl ? new Date(e.valueOf() - 1e3 * this.namedTimeZoneImpl.offsetForArray(xt(e)) * 60) : new Date(e.valueOf() - (t || 0))
        }, e
    }(), Yi = [], zi = {
        code: "en",
        week: {dow: 0, doy: 4},
        direction: "ltr",
        buttonText: {
            prev: "prev",
            next: "next",
            prevYear: "prev year",
            nextYear: "next year",
            year: "year",
            today: "today",
            month: "month",
            week: "week",
            day: "day",
            list: "list"
        },
        weekText: "W",
        weekTextLong: "Week",
        closeHint: "Close",
        timeHint: "Time",
        eventHint: "Event",
        allDayText: "all-day",
        moreLinkText: "more",
        noEventsText: "No events to display"
    }, Oi = o(o({}, zi), {
        buttonHints: {
            prev: "Previous $0", next: "Next $0", today: function (e, t) {
                return "day" === t ? "Today" : "This " + e
            }
        }, viewHint: "$0 view", navLinkHint: "Go to $0", moreLinkHint: function (e) {
            return "Show " + e + " more event" + (1 === e ? "" : "s")
        }
    });

    function Fi(e) {
        for (var t = e.length > 0 ? e[0].code : "en", n = Yi.concat(e), i = {en: Oi}, r = 0, o = n; r < o.length; r++) {
            var a = o[r];
            i[a.code] = a
        }
        return {map: i, defaultCode: t}
    }

    function Bi(e, t) {
        return "object" != typeof e || Array.isArray(e) ? function (e, t) {
            var n = [].concat(e || []), i = function (e, t) {
                for (var n = 0; n < e.length; n += 1) for (var i = e[n].toLocaleLowerCase().split("-"), r = i.length; r > 0; r -= 1) {
                    var o = i.slice(0, r).join("-");
                    if (t[o]) return t[o]
                }
                return null
            }(n, t) || Oi;
            return ji(e, n, i)
        }(e, t) : ji(e.code, [e.code], e)
    }

    function ji(e, t, n) {
        var i = St([zi, n], ["buttonText"]);
        delete i.code;
        var r = i.week;
        return delete i.week, {codeArg: e, codes: t, week: r, simpleNumberFormat: new Intl.NumberFormat(e), options: i}
    }

    var Hi, Ni = {
        startTime: "09:00",
        endTime: "17:00",
        daysOfWeek: [1, 2, 3, 4, 5],
        display: "inverse-background",
        classNames: "fc-non-business",
        groupId: "_businessHours"
    };

    function Ui(e, t) {
        return Mn(function (e) {
            var t;
            t = !0 === e ? [{}] : Array.isArray(e) ? e.filter((function (e) {
                return e.daysOfWeek
            })) : "object" == typeof e && e ? [e] : [];
            return t = t.map((function (e) {
                return o(o({}, Ni), e)
            }))
        }(e), null, t)
    }

    function Wi(e, t) {
        return e.left >= t.left && e.left < t.right && e.top >= t.top && e.top < t.bottom
    }

    function Vi(e, t) {
        var n = {
            left: Math.max(e.left, t.left),
            right: Math.min(e.right, t.right),
            top: Math.max(e.top, t.top),
            bottom: Math.min(e.bottom, t.bottom)
        };
        return n.left < n.right && n.top < n.bottom && n
    }

    function Gi() {
        return null == Hi && (Hi = function () {
            if ("undefined" == typeof document) return !0;
            var e = document.createElement("div");
            e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.innerHTML = "<table><tr><td><div></div></td></tr></table>", e.querySelector("table").style.height = "100px", e.querySelector("div").style.height = "100%", document.body.appendChild(e);
            var t = e.querySelector("div").offsetHeight > 0;
            return document.body.removeChild(e), t
        }()), Hi
    }

    var qi = {defs: {}, instances: {}}, Zi = function () {
        function e() {
            this.getKeysForEventDefs = Xt(this._getKeysForEventDefs), this.splitDateSelection = Xt(this._splitDateSpan), this.splitEventStore = Xt(this._splitEventStore), this.splitIndividualUi = Xt(this._splitIndividualUi), this.splitEventDrag = Xt(this._splitInteraction), this.splitEventResize = Xt(this._splitInteraction), this.eventUiBuilders = {}
        }

        return e.prototype.splitProps = function (e) {
            var t = this, n = this.getKeyInfo(e), i = this.getKeysForEventDefs(e.eventStore),
                r = this.splitDateSelection(e.dateSelection), o = this.splitIndividualUi(e.eventUiBases, i),
                a = this.splitEventStore(e.eventStore, i), s = this.splitEventDrag(e.eventDrag),
                l = this.splitEventResize(e.eventResize), c = {};
            for (var u in this.eventUiBuilders = Lt(n, (function (e, n) {
                return t.eventUiBuilders[n] || Xt($i)
            })), n) {
                var d = n[u], h = a[u] || qi, p = this.eventUiBuilders[u];
                c[u] = {
                    businessHours: d.businessHours || e.businessHours,
                    dateSelection: r[u] || null,
                    eventStore: h,
                    eventUiBases: p(e.eventUiBases[""], d.ui, o[u]),
                    eventSelection: h.instances[e.eventSelection] ? e.eventSelection : "",
                    eventDrag: s[u] || null,
                    eventResize: l[u] || null
                }
            }
            return c
        }, e.prototype._splitDateSpan = function (e) {
            var t = {};
            if (e) for (var n = 0, i = this.getKeysForDateSpan(e); n < i.length; n++) {
                t[i[n]] = e
            }
            return t
        }, e.prototype._getKeysForEventDefs = function (e) {
            var t = this;
            return Lt(e.defs, (function (e) {
                return t.getKeysForEventDef(e)
            }))
        }, e.prototype._splitEventStore = function (e, t) {
            var n = e.defs, i = e.instances, r = {};
            for (var o in n) for (var a = 0, s = t[o]; a < s.length; a++) {
                r[h = s[a]] || (r[h] = {defs: {}, instances: {}}), r[h].defs[o] = n[o]
            }
            for (var l in i) for (var c = i[l], u = 0, d = t[c.defId]; u < d.length; u++) {
                var h;
                r[h = d[u]] && (r[h].instances[l] = c)
            }
            return r
        }, e.prototype._splitIndividualUi = function (e, t) {
            var n = {};
            for (var i in e) if (i) for (var r = 0, o = t[i]; r < o.length; r++) {
                var a = o[r];
                n[a] || (n[a] = {}), n[a][i] = e[i]
            }
            return n
        }, e.prototype._splitInteraction = function (e) {
            var t = {};
            if (e) {
                var n = this._splitEventStore(e.affectedEvents, this._getKeysForEventDefs(e.affectedEvents)),
                    i = this._getKeysForEventDefs(e.mutatedEvents), r = this._splitEventStore(e.mutatedEvents, i),
                    o = function (i) {
                        t[i] || (t[i] = {affectedEvents: n[i] || qi, mutatedEvents: r[i] || qi, isEvent: e.isEvent})
                    };
                for (var a in n) o(a);
                for (var a in r) o(a)
            }
            return t
        }, e
    }();

    function $i(e, t, n) {
        var i = [];
        e && i.push(e), t && i.push(t);
        var r = {"": In(i)};
        return n && o(r, n), r
    }

    function Xi(e, t, n, i) {
        return {
            dow: e.getUTCDay(),
            isDisabled: Boolean(i && !$n(i.activeRange, e)),
            isOther: Boolean(i && !$n(i.currentRange, e)),
            isToday: Boolean(t && $n(t, e)),
            isPast: Boolean(n ? e < n : !!t && e < t.start),
            isFuture: Boolean(n ? e > n : !!t && e >= t.end)
        }
    }

    function Ji(e, t) {
        var n = ["fc-day", "fc-day-" + ct[e.dow]];
        return e.isDisabled ? n.push("fc-day-disabled") : (e.isToday && (n.push("fc-day-today"), n.push(t.getClass("today"))), e.isPast && n.push("fc-day-past"), e.isFuture && n.push("fc-day-future"), e.isOther && n.push("fc-day-other")), n
    }

    var Ki = hn({year: "numeric", month: "long", day: "numeric"}), Qi = hn({week: "long"});

    function er(e, t, n, i) {
        void 0 === n && (n = "day"), void 0 === i && (i = !0);
        var r = e.dateEnv, a = e.options, s = e.calendarApi, l = r.format(t, "week" === n ? Qi : Ki);
        if (a.navLinks) {
            var c = r.toDate(t), u = function (e) {
                var i = "day" === n ? a.navLinkDayClick : "week" === n ? a.navLinkWeekClick : null;
                "function" == typeof i ? i.call(s, r.toDate(t), e) : ("string" == typeof i && (n = i), s.zoomTo(t, n))
            };
            return o({title: ot(a.navLinkHint, [l, c], l), "data-navlink": ""}, i ? Je(u) : {onClick: u})
        }
        return {"aria-label": l}
    }

    var tr, nr = null;

    function ir() {
        return null === nr && (nr = function () {
            var e = document.createElement("div");
            Ne(e, {
                position: "absolute",
                top: -1e3,
                left: 0,
                border: 0,
                padding: 0,
                overflow: "scroll",
                direction: "rtl"
            }), e.innerHTML = "<div></div>", document.body.appendChild(e);
            var t = e.firstChild.getBoundingClientRect().left > e.getBoundingClientRect().left;
            return Fe(e), t
        }()), nr
    }

    function rr() {
        return tr || (tr = function () {
            var e = document.createElement("div");
            e.style.overflow = "scroll", e.style.position = "absolute", e.style.top = "-9999px", e.style.left = "-9999px", document.body.appendChild(e);
            var t = or(e);
            return document.body.removeChild(e), t
        }()), tr
    }

    function or(e) {
        return {x: e.offsetHeight - e.clientHeight, y: e.offsetWidth - e.clientWidth}
    }

    function ar(e, t, n) {
        void 0 === t && (t = !1);
        var i = n ? e.getBoundingClientRect() : sr(e), r = function (e, t) {
            void 0 === t && (t = !1);
            var n = window.getComputedStyle(e), i = parseInt(n.borderLeftWidth, 10) || 0,
                r = parseInt(n.borderRightWidth, 10) || 0, o = parseInt(n.borderTopWidth, 10) || 0,
                a = parseInt(n.borderBottomWidth, 10) || 0, s = or(e), l = s.y - i - r, c = {
                    borderLeft: i,
                    borderRight: r,
                    borderTop: o,
                    borderBottom: a,
                    scrollbarBottom: s.x - o - a,
                    scrollbarLeft: 0,
                    scrollbarRight: 0
                };
            return ir() && "rtl" === n.direction ? c.scrollbarLeft = l : c.scrollbarRight = l, t && (c.paddingLeft = parseInt(n.paddingLeft, 10) || 0, c.paddingRight = parseInt(n.paddingRight, 10) || 0, c.paddingTop = parseInt(n.paddingTop, 10) || 0, c.paddingBottom = parseInt(n.paddingBottom, 10) || 0), c
        }(e, t), o = {
            left: i.left + r.borderLeft + r.scrollbarLeft,
            right: i.right - r.borderRight - r.scrollbarRight,
            top: i.top + r.borderTop,
            bottom: i.bottom - r.borderBottom - r.scrollbarBottom
        };
        return t && (o.left += r.paddingLeft, o.right -= r.paddingRight, o.top += r.paddingTop, o.bottom -= r.paddingBottom), o
    }

    function sr(e) {
        var t = e.getBoundingClientRect();
        return {
            left: t.left + window.pageXOffset,
            top: t.top + window.pageYOffset,
            right: t.right + window.pageXOffset,
            bottom: t.bottom + window.pageYOffset
        }
    }

    function lr(e) {
        for (var t = []; e instanceof HTMLElement;) {
            var n = window.getComputedStyle(e);
            if ("fixed" === n.position) break;
            /(auto|scroll)/.test(n.overflow + n.overflowY + n.overflowX) && t.push(e), e = e.parentNode
        }
        return t
    }

    var cr = function () {
        function e() {
            this.handlers = {}, this.thisContext = null
        }

        return e.prototype.setThisContext = function (e) {
            this.thisContext = e
        }, e.prototype.setOptions = function (e) {
            this.options = e
        }, e.prototype.on = function (e, t) {
            !function (e, t, n) {
                (e[t] || (e[t] = [])).push(n)
            }(this.handlers, e, t)
        }, e.prototype.off = function (e, t) {
            !function (e, t, n) {
                n ? e[t] && (e[t] = e[t].filter((function (e) {
                    return e !== n
                }))) : delete e[t]
            }(this.handlers, e, t)
        }, e.prototype.trigger = function (e) {
            for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            for (var i = this.handlers[e] || [], r = this.options && this.options[e], o = [].concat(r || [], i), a = 0, s = o; a < s.length; a++) {
                var l = s[a];
                l.apply(this.thisContext, t)
            }
        }, e.prototype.hasHandlers = function (e) {
            return Boolean(this.handlers[e] && this.handlers[e].length || this.options && this.options[e])
        }, e
    }();
    var ur = function () {
        function e(e, t, n, i) {
            this.els = t;
            var r = this.originClientRect = e.getBoundingClientRect();
            n && this.buildElHorizontals(r.left), i && this.buildElVerticals(r.top)
        }

        return e.prototype.buildElHorizontals = function (e) {
            for (var t = [], n = [], i = 0, r = this.els; i < r.length; i++) {
                var o = r[i].getBoundingClientRect();
                t.push(o.left - e), n.push(o.right - e)
            }
            this.lefts = t, this.rights = n
        }, e.prototype.buildElVerticals = function (e) {
            for (var t = [], n = [], i = 0, r = this.els; i < r.length; i++) {
                var o = r[i].getBoundingClientRect();
                t.push(o.top - e), n.push(o.bottom - e)
            }
            this.tops = t, this.bottoms = n
        }, e.prototype.leftToIndex = function (e) {
            var t, n = this.lefts, i = this.rights, r = n.length;
            for (t = 0; t < r; t += 1) if (e >= n[t] && e < i[t]) return t
        }, e.prototype.topToIndex = function (e) {
            var t, n = this.tops, i = this.bottoms, r = n.length;
            for (t = 0; t < r; t += 1) if (e >= n[t] && e < i[t]) return t
        }, e.prototype.getWidth = function (e) {
            return this.rights[e] - this.lefts[e]
        }, e.prototype.getHeight = function (e) {
            return this.bottoms[e] - this.tops[e]
        }, e
    }(), dr = function () {
        function e() {
        }

        return e.prototype.getMaxScrollTop = function () {
            return this.getScrollHeight() - this.getClientHeight()
        }, e.prototype.getMaxScrollLeft = function () {
            return this.getScrollWidth() - this.getClientWidth()
        }, e.prototype.canScrollVertically = function () {
            return this.getMaxScrollTop() > 0
        }, e.prototype.canScrollHorizontally = function () {
            return this.getMaxScrollLeft() > 0
        }, e.prototype.canScrollUp = function () {
            return this.getScrollTop() > 0
        }, e.prototype.canScrollDown = function () {
            return this.getScrollTop() < this.getMaxScrollTop()
        }, e.prototype.canScrollLeft = function () {
            return this.getScrollLeft() > 0
        }, e.prototype.canScrollRight = function () {
            return this.getScrollLeft() < this.getMaxScrollLeft()
        }, e
    }(), hr = function (e) {
        function t(t) {
            var n = e.call(this) || this;
            return n.el = t, n
        }

        return r(t, e), t.prototype.getScrollTop = function () {
            return this.el.scrollTop
        }, t.prototype.getScrollLeft = function () {
            return this.el.scrollLeft
        }, t.prototype.setScrollTop = function (e) {
            this.el.scrollTop = e
        }, t.prototype.setScrollLeft = function (e) {
            this.el.scrollLeft = e
        }, t.prototype.getScrollWidth = function () {
            return this.el.scrollWidth
        }, t.prototype.getScrollHeight = function () {
            return this.el.scrollHeight
        }, t.prototype.getClientHeight = function () {
            return this.el.clientHeight
        }, t.prototype.getClientWidth = function () {
            return this.el.clientWidth
        }, t
    }(dr), pr = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.getScrollTop = function () {
            return window.pageYOffset
        }, t.prototype.getScrollLeft = function () {
            return window.pageXOffset
        }, t.prototype.setScrollTop = function (e) {
            window.scroll(window.pageXOffset, e)
        }, t.prototype.setScrollLeft = function (e) {
            window.scroll(e, window.pageYOffset)
        }, t.prototype.getScrollWidth = function () {
            return document.documentElement.scrollWidth
        }, t.prototype.getScrollHeight = function () {
            return document.documentElement.scrollHeight
        }, t.prototype.getClientHeight = function () {
            return document.documentElement.clientHeight
        }, t.prototype.getClientWidth = function () {
            return document.documentElement.clientWidth
        }, t
    }(dr), fr = function () {
        function e(e) {
            this.iconOverrideOption && this.setIconOverride(e[this.iconOverrideOption])
        }

        return e.prototype.setIconOverride = function (e) {
            var t, n;
            if ("object" == typeof e && e) {
                for (n in t = o({}, this.iconClasses), e) t[n] = this.applyIconOverridePrefix(e[n]);
                this.iconClasses = t
            } else !1 === e && (this.iconClasses = {})
        }, e.prototype.applyIconOverridePrefix = function (e) {
            var t = this.iconOverridePrefix;
            return t && 0 !== e.indexOf(t) && (e = t + e), e
        }, e.prototype.getClass = function (e) {
            return this.classes[e] || ""
        }, e.prototype.getIconClass = function (e, t) {
            var n;
            return (n = t && this.rtlIconClasses && this.rtlIconClasses[e] || this.iconClasses[e]) ? this.baseIconClass + " " + n : ""
        }, e.prototype.getCustomButtonIconClass = function (e) {
            var t;
            return this.iconOverrideCustomButtonOption && (t = e[this.iconOverrideCustomButtonOption]) ? this.baseIconClass + " " + this.applyIconOverridePrefix(t) : ""
        }, e
    }();
    fr.prototype.classes = {}, fr.prototype.iconClasses = {}, fr.prototype.baseIconClass = "", fr.prototype.iconOverridePrefix = "";
    var mr = function () {
        function e(e, t, n, i) {
            var r = this;
            this.execFunc = e, this.emitter = t, this.scrollTime = n, this.scrollTimeReset = i, this.handleScrollRequest = function (e) {
                r.queuedRequest = o({}, r.queuedRequest || {}, e), r.drain()
            }, t.on("_scrollRequest", this.handleScrollRequest), this.fireInitialScroll()
        }

        return e.prototype.detach = function () {
            this.emitter.off("_scrollRequest", this.handleScrollRequest)
        }, e.prototype.update = function (e) {
            e && this.scrollTimeReset ? this.fireInitialScroll() : this.drain()
        }, e.prototype.fireInitialScroll = function () {
            this.handleScrollRequest({time: this.scrollTime})
        }, e.prototype.drain = function () {
            this.queuedRequest && this.execFunc(this.queuedRequest) && (this.queuedRequest = null)
        }, e
    }(), _r = Pe({});

    function gr(e, t, n, i, r, o, a, s, l, c, u, d, h) {
        return {
            dateEnv: r,
            options: n,
            pluginHooks: a,
            emitter: c,
            dispatch: s,
            getCurrentData: l,
            calendarApi: u,
            viewSpec: e,
            viewApi: t,
            dateProfileGenerator: i,
            theme: o,
            isRtl: "rtl" === n.direction,
            addResizeHandler: function (e) {
                c.on("_resize", e)
            },
            removeResizeHandler: function (e) {
                c.off("_resize", e)
            },
            createScrollResponder: function (e) {
                return new mr(e, c, Bt(n.scrollTime), n.scrollTimeReset)
            },
            registerInteractiveComponent: d,
            unregisterInteractiveComponent: h
        }
    }

    var yr = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.shouldComponentUpdate = function (e, t) {
            return this.debug && console.log(It(e, this.props), It(t, this.state)), !Pt(this.props, e, this.propEquality) || !Pt(this.state, t, this.stateEquality)
        }, t.addPropsEquality = xr, t.addStateEquality = br, t.contextType = _r, t
    }(Le);
    yr.prototype.propEquality = {}, yr.prototype.stateEquality = {};
    var vr = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.contextType = _r, t
    }(yr);

    function xr(e) {
        var t = Object.create(this.prototype.propEquality);
        o(t, e), this.prototype.propEquality = t
    }

    function br(e) {
        var t = Object.create(this.prototype.stateEquality);
        o(t, e), this.prototype.stateEquality = t
    }

    function wr(e, t) {
        "function" == typeof e ? e(t) : e && (e.current = t)
    }

    var Mr = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.uid = et(), t
        }

        return r(t, e), t.prototype.prepareHits = function () {
        }, t.prototype.queryHit = function (e, t, n, i) {
            return null
        }, t.prototype.isValidSegDownEl = function (e) {
            return !this.props.eventDrag && !this.props.eventResize && !Be(e, ".fc-event-mirror")
        }, t.prototype.isValidDateDownEl = function (e) {
            return !(Be(e, ".fc-event:not(.fc-bg-event)") || Be(e, ".fc-more-link") || Be(e, "a[data-navlink]") || Be(e, ".fc-popover"))
        }, t
    }(vr);

    function Tr(e) {
        return {
            id: et(),
            deps: e.deps || [],
            reducers: e.reducers || [],
            isLoadingFuncs: e.isLoadingFuncs || [],
            contextInit: [].concat(e.contextInit || []),
            eventRefiners: e.eventRefiners || {},
            eventDefMemberAdders: e.eventDefMemberAdders || [],
            eventSourceRefiners: e.eventSourceRefiners || {},
            isDraggableTransformers: e.isDraggableTransformers || [],
            eventDragMutationMassagers: e.eventDragMutationMassagers || [],
            eventDefMutationAppliers: e.eventDefMutationAppliers || [],
            dateSelectionTransformers: e.dateSelectionTransformers || [],
            datePointTransforms: e.datePointTransforms || [],
            dateSpanTransforms: e.dateSpanTransforms || [],
            views: e.views || {},
            viewPropsTransformers: e.viewPropsTransformers || [],
            isPropsValid: e.isPropsValid || null,
            externalDefTransforms: e.externalDefTransforms || [],
            viewContainerAppends: e.viewContainerAppends || [],
            eventDropTransformers: e.eventDropTransformers || [],
            componentInteractions: e.componentInteractions || [],
            calendarInteractions: e.calendarInteractions || [],
            themeClasses: e.themeClasses || {},
            eventSourceDefs: e.eventSourceDefs || [],
            cmdFormatter: e.cmdFormatter,
            recurringTypes: e.recurringTypes || [],
            namedTimeZonedImpl: e.namedTimeZonedImpl,
            initialView: e.initialView || "",
            elementDraggingImpl: e.elementDraggingImpl,
            optionChangeHandlers: e.optionChangeHandlers || {},
            scrollGridImpl: e.scrollGridImpl || null,
            contentTypeHandlers: e.contentTypeHandlers || {},
            listenerRefiners: e.listenerRefiners || {},
            optionRefiners: e.optionRefiners || {},
            propSetHandlers: e.propSetHandlers || {}
        }
    }

    function kr() {
        var e, t = [], n = [];
        return function (i, r) {
            return e && $t(i, t) && $t(r, n) || (e = function (e, t) {
                var n = {}, i = {
                    reducers: [],
                    isLoadingFuncs: [],
                    contextInit: [],
                    eventRefiners: {},
                    eventDefMemberAdders: [],
                    eventSourceRefiners: {},
                    isDraggableTransformers: [],
                    eventDragMutationMassagers: [],
                    eventDefMutationAppliers: [],
                    dateSelectionTransformers: [],
                    datePointTransforms: [],
                    dateSpanTransforms: [],
                    views: {},
                    viewPropsTransformers: [],
                    isPropsValid: null,
                    externalDefTransforms: [],
                    viewContainerAppends: [],
                    eventDropTransformers: [],
                    componentInteractions: [],
                    calendarInteractions: [],
                    themeClasses: {},
                    eventSourceDefs: [],
                    cmdFormatter: null,
                    recurringTypes: [],
                    namedTimeZonedImpl: null,
                    initialView: "",
                    elementDraggingImpl: null,
                    optionChangeHandlers: {},
                    scrollGridImpl: null,
                    contentTypeHandlers: {},
                    listenerRefiners: {},
                    optionRefiners: {},
                    propSetHandlers: {}
                };

                function r(e) {
                    for (var t = 0, a = e; t < a.length; t++) {
                        var s = a[t];
                        n[s.id] || (n[s.id] = !0, r(s.deps), c = s, i = {
                            reducers: (l = i).reducers.concat(c.reducers),
                            isLoadingFuncs: l.isLoadingFuncs.concat(c.isLoadingFuncs),
                            contextInit: l.contextInit.concat(c.contextInit),
                            eventRefiners: o(o({}, l.eventRefiners), c.eventRefiners),
                            eventDefMemberAdders: l.eventDefMemberAdders.concat(c.eventDefMemberAdders),
                            eventSourceRefiners: o(o({}, l.eventSourceRefiners), c.eventSourceRefiners),
                            isDraggableTransformers: l.isDraggableTransformers.concat(c.isDraggableTransformers),
                            eventDragMutationMassagers: l.eventDragMutationMassagers.concat(c.eventDragMutationMassagers),
                            eventDefMutationAppliers: l.eventDefMutationAppliers.concat(c.eventDefMutationAppliers),
                            dateSelectionTransformers: l.dateSelectionTransformers.concat(c.dateSelectionTransformers),
                            datePointTransforms: l.datePointTransforms.concat(c.datePointTransforms),
                            dateSpanTransforms: l.dateSpanTransforms.concat(c.dateSpanTransforms),
                            views: o(o({}, l.views), c.views),
                            viewPropsTransformers: l.viewPropsTransformers.concat(c.viewPropsTransformers),
                            isPropsValid: c.isPropsValid || l.isPropsValid,
                            externalDefTransforms: l.externalDefTransforms.concat(c.externalDefTransforms),
                            viewContainerAppends: l.viewContainerAppends.concat(c.viewContainerAppends),
                            eventDropTransformers: l.eventDropTransformers.concat(c.eventDropTransformers),
                            calendarInteractions: l.calendarInteractions.concat(c.calendarInteractions),
                            componentInteractions: l.componentInteractions.concat(c.componentInteractions),
                            themeClasses: o(o({}, l.themeClasses), c.themeClasses),
                            eventSourceDefs: l.eventSourceDefs.concat(c.eventSourceDefs),
                            cmdFormatter: c.cmdFormatter || l.cmdFormatter,
                            recurringTypes: l.recurringTypes.concat(c.recurringTypes),
                            namedTimeZonedImpl: c.namedTimeZonedImpl || l.namedTimeZonedImpl,
                            initialView: l.initialView || c.initialView,
                            elementDraggingImpl: l.elementDraggingImpl || c.elementDraggingImpl,
                            optionChangeHandlers: o(o({}, l.optionChangeHandlers), c.optionChangeHandlers),
                            scrollGridImpl: c.scrollGridImpl || l.scrollGridImpl,
                            contentTypeHandlers: o(o({}, l.contentTypeHandlers), c.contentTypeHandlers),
                            listenerRefiners: o(o({}, l.listenerRefiners), c.listenerRefiners),
                            optionRefiners: o(o({}, l.optionRefiners), c.optionRefiners),
                            propSetHandlers: o(o({}, l.propSetHandlers), c.propSetHandlers)
                        })
                    }
                    var l, c
                }

                return e && r(e), r(t), i
            }(i, r)), t = i, n = r, e
        }
    }

    var Sr = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t
    }(fr);

    function Dr(e, t, n, i) {
        if (t[e]) return t[e];
        var r = function (e, t, n, i) {
            var r = n[e], a = i[e], s = function (e) {
                return r && null !== r[e] ? r[e] : a && null !== a[e] ? a[e] : null
            }, l = s("component"), c = s("superType"), u = null;
            if (c) {
                if (c === e) throw new Error("Can't have a custom view type that references itself");
                u = Dr(c, t, n, i)
            }
            !l && u && (l = u.component);
            if (!l) return null;
            return {
                type: e,
                component: l,
                defaults: o(o({}, u ? u.defaults : {}), r ? r.rawOptions : {}),
                overrides: o(o({}, u ? u.overrides : {}), a ? a.rawOptions : {})
            }
        }(e, t, n, i);
        return r && (t[e] = r), r
    }

    Sr.prototype.classes = {
        root: "fc-theme-standard",
        tableCellShaded: "fc-cell-shaded",
        buttonGroup: "fc-button-group",
        button: "fc-button fc-button-primary",
        buttonActive: "fc-button-active"
    }, Sr.prototype.baseIconClass = "fc-icon", Sr.prototype.iconClasses = {
        close: "fc-icon-x",
        prev: "fc-icon-chevron-left",
        next: "fc-icon-chevron-right",
        prevYear: "fc-icon-chevrons-left",
        nextYear: "fc-icon-chevrons-right"
    }, Sr.prototype.rtlIconClasses = {
        prev: "fc-icon-chevron-right",
        next: "fc-icon-chevron-left",
        prevYear: "fc-icon-chevrons-right",
        nextYear: "fc-icon-chevrons-left"
    }, Sr.prototype.iconOverrideOption = "buttonIcons", Sr.prototype.iconOverrideCustomButtonOption = "icon", Sr.prototype.iconOverridePrefix = "fc-icon-";
    var Lr = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.rootElRef = Ae(), t.handleRootEl = function (e) {
                wr(t.rootElRef, e), t.props.elRef && wr(t.props.elRef, e)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = t.hookProps;
            return Ee(Ir, {
                hookProps: n,
                didMount: t.didMount,
                willUnmount: t.willUnmount,
                elRef: this.handleRootEl
            }, (function (i) {
                return Ee(Cr, {
                    hookProps: n,
                    content: t.content,
                    defaultContent: t.defaultContent,
                    backupElRef: e.rootElRef
                }, (function (e, r) {
                    return t.children(i, Rr(t.classNames, n), e, r)
                }))
            }))
        }, t
    }(vr), Er = Pe(0);

    function Cr(e) {
        return Ee(Er.Consumer, null, (function (t) {
            return Ee(Ar, o({renderId: t}, e))
        }))
    }

    var Ar = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.innerElRef = Ae(), t
        }

        return r(t, e), t.prototype.render = function () {
            return this.props.children(this.innerElRef, this.renderInnerContent())
        }, t.prototype.componentDidMount = function () {
            this.updateCustomContent()
        }, t.prototype.componentDidUpdate = function () {
            this.updateCustomContent()
        }, t.prototype.componentWillUnmount = function () {
            this.customContentInfo && this.customContentInfo.destroy && this.customContentInfo.destroy()
        }, t.prototype.renderInnerContent = function () {
            var e = this.customContentInfo, t = this.getInnerContent(), n = this.getContentMeta(t);
            return e && e.contentKey === n.contentKey ? e && (e.contentVal = t[n.contentKey]) : (e && (e.destroy && e.destroy(), e = this.customContentInfo = null), n.contentKey && (e = this.customContentInfo = o({
                contentKey: n.contentKey,
                contentVal: t[n.contentKey]
            }, n.buildLifecycleFuncs()))), e ? [] : t
        }, t.prototype.getInnerContent = function () {
            var e = this.props, t = Yr(e.content, e.hookProps);
            return void 0 === t && (t = Yr(e.defaultContent, e.hookProps)), null == t ? null : t
        }, t.prototype.getContentMeta = function (e) {
            var t = this.context.pluginHooks.contentTypeHandlers, n = "", i = null;
            if (e) for (var r in t) if (void 0 !== e[r]) {
                n = r, i = t[r];
                break
            }
            return {contentKey: n, buildLifecycleFuncs: i}
        }, t.prototype.updateCustomContent = function () {
            this.customContentInfo && this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal)
        }, t
    }(vr), Ir = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.handleRootEl = function (e) {
                t.rootEl = e, t.props.elRef && wr(t.props.elRef, e)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            return this.props.children(this.handleRootEl)
        }, t.prototype.componentDidMount = function () {
            var e = this.props.didMount;
            e && e(o(o({}, this.props.hookProps), {el: this.rootEl}))
        }, t.prototype.componentWillUnmount = function () {
            var e = this.props.willUnmount;
            e && e(o(o({}, this.props.hookProps), {el: this.rootEl}))
        }, t
    }(vr);

    function Pr() {
        var e, t, n = [];
        return function (i, r) {
            return t && At(t, r) && i === e || (e = i, t = r, n = Rr(i, r)), n
        }
    }

    function Rr(e, t) {
        return "function" == typeof e && (e = e(t)), Ln(e)
    }

    function Yr(e, t) {
        return "function" == typeof e ? e(t, Ee) : e
    }

    var zr = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.normalizeClassNames = Pr(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options, i = {view: t.viewApi},
                r = this.normalizeClassNames(n.viewClassNames, i);
            return Ee(Ir, {
                hookProps: i,
                didMount: n.viewDidMount,
                willUnmount: n.viewWillUnmount,
                elRef: e.elRef
            }, (function (t) {
                return e.children(t, ["fc-" + e.viewSpec.type + "-view", "fc-view"].concat(r))
            }))
        }, t
    }(vr);

    function Or(e) {
        return Lt(e, Fr)
    }

    function Fr(e) {
        var t, n = "function" == typeof e ? {component: e} : e, i = n.component;
        return n.content && (t = n, i = function (e) {
            return Ee(_r.Consumer, null, (function (n) {
                return Ee(zr, {viewSpec: n.viewSpec}, (function (i, r) {
                    var a = o(o({}, e), {nextDayThreshold: n.options.nextDayThreshold});
                    return Ee(Lr, {
                        hookProps: a,
                        classNames: t.classNames,
                        content: t.content,
                        didMount: t.didMount,
                        willUnmount: t.willUnmount,
                        elRef: i
                    }, (function (e, t, n, i) {
                        return Ee("div", {className: r.concat(t).join(" "), ref: e}, i)
                    }))
                }))
            }))
        }), {superType: n.type, component: i, rawOptions: n}
    }

    function Br(e, t, n, i) {
        var r = Or(e), a = Or(t.views);
        return Lt(function (e, t) {
            var n, i = {};
            for (n in e) Dr(n, i, e, t);
            for (n in t) Dr(n, i, e, t);
            return i
        }(r, a), (function (e) {
            return function (e, t, n, i, r) {
                var a = e.overrides.duration || e.defaults.duration || i.duration || n.duration, s = null, l = "",
                    c = "", u = {};
                if (a && (s = function (e) {
                    var t = JSON.stringify(e), n = jr[t];
                    void 0 === n && (n = Bt(e), jr[t] = n);
                    return n
                }(a))) {
                    var d = Vt(s);
                    l = d.unit, 1 === d.value && (c = l, u = t[l] ? t[l].rawOptions : {})
                }
                var h = function (t) {
                    var n = t.buttonText || {}, i = e.defaults.buttonTextKey;
                    return null != i && null != n[i] ? n[i] : null != n[e.type] ? n[e.type] : null != n[c] ? n[c] : null
                }, p = function (t) {
                    var n = t.buttonHints || {}, i = e.defaults.buttonTextKey;
                    return null != i && null != n[i] ? n[i] : null != n[e.type] ? n[e.type] : null != n[c] ? n[c] : null
                };
                return {
                    type: e.type,
                    component: e.component,
                    duration: s,
                    durationUnit: l,
                    singleUnit: c,
                    optionDefaults: e.defaults,
                    optionOverrides: o(o({}, u), e.overrides),
                    buttonTextOverride: h(i) || h(n) || e.overrides.buttonText,
                    buttonTextDefault: h(r) || e.defaults.buttonText || h(fn) || e.type,
                    buttonTitleOverride: p(i) || p(n) || e.overrides.buttonHint,
                    buttonTitleDefault: p(r) || e.defaults.buttonHint || p(fn)
                }
            }(e, a, t, n, i)
        }))
    }

    var jr = {};
    var Hr = function () {
        function e(e) {
            this.props = e, this.nowDate = ki(e.nowInput, e.dateEnv), this.initHiddenDays()
        }

        return e.prototype.buildPrev = function (e, t, n) {
            var i = this.props.dateEnv, r = i.subtract(i.startOf(t, e.currentRangeUnit), e.dateIncrement);
            return this.build(r, -1, n)
        }, e.prototype.buildNext = function (e, t, n) {
            var i = this.props.dateEnv, r = i.add(i.startOf(t, e.currentRangeUnit), e.dateIncrement);
            return this.build(r, 1, n)
        }, e.prototype.build = function (e, t, n) {
            void 0 === n && (n = !0);
            var i, r, o, a, s, l, c, u, d = this.props;
            return i = this.buildValidRange(), i = this.trimHiddenDays(i), n && (c = e, e = null != (u = i).start && c < u.start ? u.start : null != u.end && c >= u.end ? new Date(u.end.valueOf() - 1) : c), r = this.buildCurrentRangeInfo(e, t), o = /^(year|month|week|day)$/.test(r.unit), a = this.buildRenderRange(this.trimHiddenDays(r.range), r.unit, o), s = a = this.trimHiddenDays(a), d.showNonCurrentDates || (s = Gn(s, r.range)), s = Gn(s = this.adjustActiveRange(s), i), l = qn(r.range, i), {
                validRange: i,
                currentRange: r.range,
                currentRangeUnit: r.unit,
                isRangeAllDay: o,
                activeRange: s,
                renderRange: a,
                slotMinTime: d.slotMinTime,
                slotMaxTime: d.slotMaxTime,
                isValid: l,
                dateIncrement: this.buildDateIncrement(r.duration)
            }
        }, e.prototype.buildValidRange = function () {
            var e = this.props.validRangeInput,
                t = "function" == typeof e ? e.call(this.props.calendarApi, this.nowDate) : e;
            return this.refineRange(t) || {start: null, end: null}
        }, e.prototype.buildCurrentRangeInfo = function (e, t) {
            var n, i = this.props, r = null, o = null, a = null;
            return i.duration ? (r = i.duration, o = i.durationUnit, a = this.buildRangeFromDuration(e, t, r, o)) : (n = this.props.dayCount) ? (o = "day", a = this.buildRangeFromDayCount(e, t, n)) : (a = this.buildCustomVisibleRange(e)) ? o = i.dateEnv.greatestWholeUnit(a.start, a.end).unit : (o = Vt(r = this.getFallbackDuration()).unit, a = this.buildRangeFromDuration(e, t, r, o)), {
                duration: r,
                unit: o,
                range: a
            }
        }, e.prototype.getFallbackDuration = function () {
            return Bt({day: 1})
        }, e.prototype.adjustActiveRange = function (e) {
            var t = this.props, n = t.dateEnv, i = t.usesMinMaxTime, r = t.slotMinTime, o = t.slotMaxTime, a = e.start,
                s = e.end;
            return i && (Nt(r) < 0 && (a = mt(a), a = n.add(a, r)), Nt(o) > 1 && (s = dt(s = mt(s), -1), s = n.add(s, o))), {
                start: a,
                end: s
            }
        }, e.prototype.buildRangeFromDuration = function (e, t, n, i) {
            var r, o, a, s = this.props, l = s.dateEnv, c = s.dateAlignment;
            if (!c) {
                var u = this.props.dateIncrement;
                c = u && Ut(u) < Ut(n) ? Vt(u).unit : i
            }

            function d() {
                r = l.startOf(e, c), o = l.add(r, n), a = {start: r, end: o}
            }

            return Nt(n) <= 1 && this.isHiddenDay(r) && (r = mt(r = this.skipHiddenDays(r, t))), d(), this.trimHiddenDays(a) || (e = this.skipHiddenDays(e, t), d()), a
        }, e.prototype.buildRangeFromDayCount = function (e, t, n) {
            var i, r = this.props, o = r.dateEnv, a = r.dateAlignment, s = 0, l = e;
            a && (l = o.startOf(l, a)), l = mt(l), i = l = this.skipHiddenDays(l, t);
            do {
                i = dt(i, 1), this.isHiddenDay(i) || (s += 1)
            } while (s < n);
            return {start: l, end: i}
        }, e.prototype.buildCustomVisibleRange = function (e) {
            var t = this.props, n = t.visibleRangeInput,
                i = "function" == typeof n ? n.call(t.calendarApi, t.dateEnv.toDate(e)) : n, r = this.refineRange(i);
            return !r || null != r.start && null != r.end ? r : null
        }, e.prototype.buildRenderRange = function (e, t, n) {
            return e
        }, e.prototype.buildDateIncrement = function (e) {
            var t, n = this.props.dateIncrement;
            return n || ((t = this.props.dateAlignment) ? Bt(1, t) : e || Bt({days: 1}))
        }, e.prototype.refineRange = function (e) {
            if (e) {
                var t = (n = e, i = this.props.dateEnv, r = null, o = null, n.start && (r = i.createMarker(n.start)), n.end && (o = i.createMarker(n.end)), r || o ? r && o && o < r ? null : {
                    start: r,
                    end: o
                } : null);
                return t && (t = Nn(t)), t
            }
            var n, i, r, o;
            return null
        }, e.prototype.initHiddenDays = function () {
            var e, t = this.props.hiddenDays || [], n = [], i = 0;
            for (!1 === this.props.weekends && t.push(0, 6), e = 0; e < 7; e += 1) (n[e] = -1 !== t.indexOf(e)) || (i += 1);
            if (!i) throw new Error("invalid hiddenDays");
            this.isHiddenDayHash = n
        }, e.prototype.trimHiddenDays = function (e) {
            var t = e.start, n = e.end;
            return t && (t = this.skipHiddenDays(t)), n && (n = this.skipHiddenDays(n, -1, !0)), null == t || null == n || t < n ? {
                start: t,
                end: n
            } : null
        }, e.prototype.isHiddenDay = function (e) {
            return e instanceof Date && (e = e.getUTCDay()), this.isHiddenDayHash[e]
        }, e.prototype.skipHiddenDays = function (e, t, n) {
            for (void 0 === t && (t = 1), void 0 === n && (n = !1); this.isHiddenDayHash[(e.getUTCDay() + (n ? t : 0) + 7) % 7];) e = dt(e, t);
            return e
        }, e
    }();

    function Nr(e, t, n) {
        var i = t ? t.activeRange : null;
        return Vr({}, function (e, t) {
            var n = Ti(t), i = [].concat(e.eventSources || []), r = [];
            e.initialEvents && i.unshift(e.initialEvents);
            e.events && i.unshift(e.events);
            for (var o = 0, a = i; o < a.length; o++) {
                var s = Mi(a[o], t, n);
                s && r.push(s)
            }
            return r
        }(e, n), i, n)
    }

    function Ur(e, t, n, i) {
        var r, a, s = n ? n.activeRange : null;
        switch (t.type) {
            case"ADD_EVENT_SOURCES":
                return Vr(e, t.sources, s, i);
            case"REMOVE_EVENT_SOURCE":
                return r = e, a = t.sourceId, Dt(r, (function (e) {
                    return e.sourceId !== a
                }));
            case"PREV":
            case"NEXT":
            case"CHANGE_DATE":
            case"CHANGE_VIEW_TYPE":
                return n ? Gr(e, s, i) : e;
            case"FETCH_EVENT_SOURCES":
                return qr(e, t.sourceIds ? Et(t.sourceIds) : $r(e, i), s, t.isRefetch || !1, i);
            case"RECEIVE_EVENTS":
            case"RECEIVE_EVENT_ERROR":
                return function (e, t, n, i) {
                    var r, a = e[t];
                    if (a && n === a.latestFetchId) return o(o({}, e), ((r = {})[t] = o(o({}, a), {
                        isFetching: !1,
                        fetchRange: i
                    }), r));
                    return e
                }(e, t.sourceId, t.fetchId, t.fetchRange);
            case"REMOVE_ALL_EVENT_SOURCES":
                return {};
            default:
                return e
        }
    }

    function Wr(e) {
        for (var t in e) if (e[t].isFetching) return !0;
        return !1
    }

    function Vr(e, t, n, i) {
        for (var r = {}, a = 0, s = t; a < s.length; a++) {
            var l = s[a];
            r[l.sourceId] = l
        }
        return n && (r = Gr(r, n, i)), o(o({}, e), r)
    }

    function Gr(e, t, n) {
        return qr(e, Dt(e, (function (e) {
            return function (e, t, n) {
                if (!Xr(e, n)) return !e.latestFetchId;
                return !n.options.lazyFetching || !e.fetchRange || e.isFetching || t.start < e.fetchRange.start || t.end > e.fetchRange.end
            }(e, t, n)
        })), t, !1, n)
    }

    function qr(e, t, n, i, r) {
        var o = {};
        for (var a in e) {
            var s = e[a];
            t[a] ? o[a] = Zr(s, n, i, r) : o[a] = s
        }
        return o
    }

    function Zr(e, t, n, i) {
        var r = i.options, a = i.calendarApi, s = i.pluginHooks.eventSourceDefs[e.sourceDefId], l = et();
        return s.fetch({eventSource: e, range: t, isRefetch: n, context: i}, (function (n) {
            var o = n.rawEvents;
            r.eventSourceSuccess && (o = r.eventSourceSuccess.call(a, o, n.xhr) || o), e.success && (o = e.success.call(a, o, n.xhr) || o), i.dispatch({
                type: "RECEIVE_EVENTS",
                sourceId: e.sourceId,
                fetchId: l,
                fetchRange: t,
                rawEvents: o
            })
        }), (function (n) {
            console.warn(n.message, n), r.eventSourceFailure && r.eventSourceFailure.call(a, n), e.failure && e.failure(n), i.dispatch({
                type: "RECEIVE_EVENT_ERROR",
                sourceId: e.sourceId,
                fetchId: l,
                fetchRange: t,
                error: n
            })
        })), o(o({}, e), {isFetching: !0, latestFetchId: l})
    }

    function $r(e, t) {
        return Dt(e, (function (e) {
            return Xr(e, t)
        }))
    }

    function Xr(e, t) {
        return !t.pluginHooks.eventSourceDefs[e.sourceDefId].ignoreRange
    }

    function Jr(e, t, n, i, r) {
        switch (t.type) {
            case"RECEIVE_EVENTS":
                return function (e, t, n, i, r, o) {
                    if (t && n === t.latestFetchId) {
                        var a = Mn(function (e, t, n) {
                            var i = n.options.eventDataTransform, r = t ? t.eventDataTransform : null;
                            r && (e = Kr(e, r));
                            i && (e = Kr(e, i));
                            return e
                        }(r, t, o), t, o);
                        return i && (a = Yt(a, i, o)), Sn(Qr(e, t.sourceId), a)
                    }
                    return e
                }(e, n[t.sourceId], t.fetchId, t.fetchRange, t.rawEvents, r);
            case"ADD_EVENTS":
                return function (e, t, n, i) {
                    n && (t = Yt(t, n, i));
                    return Sn(e, t)
                }(e, t.eventStore, i ? i.activeRange : null, r);
            case"RESET_EVENTS":
                return t.eventStore;
            case"MERGE_EVENTS":
                return Sn(e, t.eventStore);
            case"PREV":
            case"NEXT":
            case"CHANGE_DATE":
            case"CHANGE_VIEW_TYPE":
                return i ? Yt(e, i.activeRange, r) : e;
            case"REMOVE_EVENTS":
                return function (e, t) {
                    var n = e.defs, i = e.instances, r = {}, o = {};
                    for (var a in n) t.defs[a] || (r[a] = n[a]);
                    for (var s in i) !t.instances[s] && r[i[s].defId] && (o[s] = i[s]);
                    return {defs: r, instances: o}
                }(e, t.eventStore);
            case"REMOVE_EVENT_SOURCE":
                return Qr(e, t.sourceId);
            case"REMOVE_ALL_EVENT_SOURCES":
                return Dn(e, (function (e) {
                    return !e.sourceId
                }));
            case"REMOVE_ALL_EVENTS":
                return {defs: {}, instances: {}};
            default:
                return e
        }
    }

    function Kr(e, t) {
        var n;
        if (t) {
            n = [];
            for (var i = 0, r = e; i < r.length; i++) {
                var o = r[i], a = t(o);
                a ? n.push(a) : null == a && n.push(o)
            }
        } else n = e;
        return n
    }

    function Qr(e, t) {
        return Dn(e, (function (e) {
            return e.sourceId !== t
        }))
    }

    function eo(e, t) {
        switch (t.type) {
            case"UNSELECT_DATES":
                return null;
            case"SELECT_DATES":
                return t.selection;
            default:
                return e
        }
    }

    function to(e, t) {
        switch (t.type) {
            case"UNSELECT_EVENT":
                return "";
            case"SELECT_EVENT":
                return t.eventInstanceId;
            default:
                return e
        }
    }

    function no(e, t) {
        var n;
        switch (t.type) {
            case"UNSET_EVENT_DRAG":
                return null;
            case"SET_EVENT_DRAG":
                return {
                    affectedEvents: (n = t.state).affectedEvents,
                    mutatedEvents: n.mutatedEvents,
                    isEvent: n.isEvent
                };
            default:
                return e
        }
    }

    function io(e, t) {
        var n;
        switch (t.type) {
            case"UNSET_EVENT_RESIZE":
                return null;
            case"SET_EVENT_RESIZE":
                return {
                    affectedEvents: (n = t.state).affectedEvents,
                    mutatedEvents: n.mutatedEvents,
                    isEvent: n.isEvent
                };
            default:
                return e
        }
    }

    function ro(e, t, n, i, r) {
        return {
            header: e.headerToolbar ? oo(e.headerToolbar, e, t, n, i, r) : null,
            footer: e.footerToolbar ? oo(e.footerToolbar, e, t, n, i, r) : null
        }
    }

    function oo(e, t, n, i, r, o) {
        var a = {}, s = [], l = !1;
        for (var c in e) {
            var u = ao(e[c], t, n, i, r, o);
            a[c] = u.widgets, s.push.apply(s, u.viewsWithButtons), l = l || u.hasTitle
        }
        return {sectionWidgets: a, viewsWithButtons: s, hasTitle: l}
    }

    function ao(e, t, n, i, r, o) {
        var a = "rtl" === t.direction, s = t.customButtons || {}, l = n.buttonText || {}, c = t.buttonText || {},
            u = n.buttonHints || {}, d = t.buttonHints || {}, h = e ? e.split(" ") : [], p = [], f = !1;
        return {
            widgets: h.map((function (e) {
                return e.split(",").map((function (e) {
                    if ("title" === e) return f = !0, {buttonName: e};
                    var n, h, m, _, g, y;
                    if (n = s[e]) m = function (e) {
                        n.click && n.click.call(e.target, e, e.target)
                    }, (_ = i.getCustomButtonIconClass(n)) || (_ = i.getIconClass(e, a)) || (g = n.text), y = n.hint || n.text; else if (h = r[e]) {
                        p.push(e), m = function () {
                            o.changeView(e)
                        }, (g = h.buttonTextOverride) || (_ = i.getIconClass(e, a)) || (g = h.buttonTextDefault);
                        var v = h.buttonTextOverride || h.buttonTextDefault;
                        y = ot(h.buttonTitleOverride || h.buttonTitleDefault || t.viewHint, [v, e], v)
                    } else if (o[e]) if (m = function () {
                        o[e]()
                    }, (g = l[e]) || (_ = i.getIconClass(e, a)) || (g = c[e]), "prevYear" === e || "nextYear" === e) {
                        var x = "prevYear" === e ? "prev" : "next";
                        y = ot(u[x] || d[x], [c.year || "year", "year"], c[e])
                    } else y = function (t) {
                        return ot(u[e] || d[e], [c[t] || t, t], c[e])
                    };
                    return {buttonName: e, buttonClick: m, buttonIcon: _, buttonText: g, buttonHint: y}
                }))
            })), viewsWithButtons: p, hasTitle: f
        }
    }

    function so(e, t, n, i, r) {
        var o = null;
        "GET" === (e = e.toUpperCase()) ? t = function (e, t) {
            return e + (-1 === e.indexOf("?") ? "?" : "&") + lo(t)
        }(t, n) : o = lo(n);
        var a = new XMLHttpRequest;
        a.open(e, t, !0), "GET" !== e && a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.onload = function () {
            if (a.status >= 200 && a.status < 400) {
                var e = !1, t = void 0;
                try {
                    t = JSON.parse(a.responseText), e = !0
                } catch (e) {
                }
                e ? i(t, a) : r("Failure parsing JSON", a)
            } else r("Request failed", a)
        }, a.onerror = function () {
            r("Request failed", a)
        }, a.send(o)
    }

    function lo(e) {
        var t = [];
        for (var n in e) t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
        return t.join("&")
    }

    function co(e, t) {
        for (var n = Ct(t.getCurrentData().eventSources), i = [], r = 0, o = e; r < o.length; r++) {
            for (var a = o[r], s = !1, l = 0; l < n.length; l += 1) if (n[l]._raw === a) {
                n.splice(l, 1), s = !0;
                break
            }
            s || i.push(a)
        }
        for (var c = 0, u = n; c < u.length; c++) {
            var d = u[c];
            t.dispatch({type: "REMOVE_EVENT_SOURCE", sourceId: d.sourceId})
        }
        for (var h = 0, p = i; h < p.length; h++) {
            var f = p[h];
            t.calendarApi.addEventSource(f)
        }
    }

    var uo = [Tr({
        eventSourceDefs: [{
            ignoreRange: !0, parseMeta: function (e) {
                return Array.isArray(e.events) ? e.events : null
            }, fetch: function (e, t) {
                t({rawEvents: e.eventSource.meta})
            }
        }]
    }), Tr({
        eventSourceDefs: [{
            parseMeta: function (e) {
                return "function" == typeof e.events ? e.events : null
            }, fetch: function (e, t, n) {
                var i = e.context.dateEnv;
                !function (e, t, n) {
                    var i = !1, r = function () {
                        i || (i = !0, t.apply(this, arguments))
                    }, o = function () {
                        i || (i = !0, n && n.apply(this, arguments))
                    }, a = e(r, o);
                    a && "function" == typeof a.then && a.then(r, o)
                }(e.eventSource.meta.bind(null, hi(e.range, i)), (function (e) {
                    t({rawEvents: e})
                }), n)
            }
        }]
    }), Tr({
        eventSourceRefiners: {
            method: String,
            extraParams: wn,
            startParam: String,
            endParam: String,
            timeZoneParam: String
        }, eventSourceDefs: [{
            parseMeta: function (e) {
                return !e.url || "json" !== e.format && e.format ? null : {
                    url: e.url,
                    format: "json",
                    method: (e.method || "GET").toUpperCase(),
                    extraParams: e.extraParams,
                    startParam: e.startParam,
                    endParam: e.endParam,
                    timeZoneParam: e.timeZoneParam
                }
            }, fetch: function (e, t, n) {
                var i = e.eventSource.meta, r = function (e, t, n) {
                    var i, r, a, s, l = n.dateEnv, c = n.options, u = {};
                    null == (i = e.startParam) && (i = c.startParam);
                    null == (r = e.endParam) && (r = c.endParam);
                    null == (a = e.timeZoneParam) && (a = c.timeZoneParam);
                    s = "function" == typeof e.extraParams ? e.extraParams() : e.extraParams || {};
                    o(u, s), u[i] = l.formatIso(t.start), u[r] = l.formatIso(t.end), "local" !== l.timeZone && (u[a] = l.timeZone);
                    return u
                }(i, e.range, e.context);
                so(i.method, i.url, r, (function (e, n) {
                    t({rawEvents: e, xhr: n})
                }), (function (e, t) {
                    n({message: e, xhr: t})
                }))
            }
        }]
    }), Tr({
        recurringTypes: [{
            parse: function (e, t) {
                if (e.daysOfWeek || e.startTime || e.endTime || e.startRecur || e.endRecur) {
                    var n = {
                        daysOfWeek: e.daysOfWeek || null,
                        startTime: e.startTime || null,
                        endTime: e.endTime || null,
                        startRecur: e.startRecur ? t.createMarker(e.startRecur) : null,
                        endRecur: e.endRecur ? t.createMarker(e.endRecur) : null
                    }, i = void 0;
                    return e.duration && (i = e.duration), !i && e.startTime && e.endTime && (r = e.endTime, o = e.startTime, i = {
                        years: r.years - o.years,
                        months: r.months - o.months,
                        days: r.days - o.days,
                        milliseconds: r.milliseconds - o.milliseconds
                    }), {allDayGuess: Boolean(!e.startTime && !e.endTime), duration: i, typeData: n}
                }
                var r, o;
                return null
            }, expand: function (e, t, n) {
                var i = Gn(t, {start: e.startRecur, end: e.endRecur});
                return i ? function (e, t, n, i) {
                    var r = e ? Et(e) : null, o = mt(n.start), a = n.end, s = [];
                    for (; o < a;) {
                        var l = void 0;
                        r && !r[o.getUTCDay()] || (l = t ? i.add(o, t) : o, s.push(l)), o = dt(o, 1)
                    }
                    return s
                }(e.daysOfWeek, e.startTime, i, n) : []
            }
        }], eventRefiners: {daysOfWeek: wn, startTime: Bt, endTime: Bt, duration: Bt, startRecur: wn, endRecur: wn}
    }), Tr({
        optionChangeHandlers: {
            events: function (e, t) {
                co([e], t)
            }, eventSources: co
        }
    }), Tr({
        isLoadingFuncs: [function (e) {
            return Wr(e.eventSources)
        }], contentTypeHandlers: {
            html: function () {
                var e = null, t = "";
                return {
                    render: function (n, i) {
                        n === e && i === t || (n.innerHTML = i), e = n, t = i
                    }, destroy: function () {
                        e.innerHTML = "", e = null, t = ""
                    }
                }
            }, domNodes: function () {
                var e = null, t = [];

                function n() {
                    t.forEach(Fe), t = [], e = null
                }

                return {
                    render: function (i, r) {
                        var o = Array.prototype.slice.call(r);
                        if (i !== e || !$t(t, o)) {
                            for (var a = 0, s = o; a < s.length; a++) {
                                var l = s[a];
                                i.appendChild(l)
                            }
                            n()
                        }
                        e = i, t = o
                    }, destroy: n
                }
            }
        }, propSetHandlers: {
            dateProfile: function (e, t) {
                t.emitter.trigger("datesSet", o(o({}, hi(e.activeRange, t.dateEnv)), {view: t.viewApi}))
            }, eventStore: function (e, t) {
                var n = t.emitter;
                n.hasHandlers("eventsSet") && n.trigger("eventsSet", Ei(e, t))
            }
        }
    })];
    var ho = function () {
        function e(e) {
            this.drainedOption = e, this.isRunning = !1, this.isDirty = !1, this.pauseDepths = {}, this.timeoutId = 0
        }

        return e.prototype.request = function (e) {
            this.isDirty = !0, this.isPaused() || (this.clearTimeout(), null == e ? this.tryDrain() : this.timeoutId = setTimeout(this.tryDrain.bind(this), e))
        }, e.prototype.pause = function (e) {
            void 0 === e && (e = "");
            var t = this.pauseDepths;
            t[e] = (t[e] || 0) + 1, this.clearTimeout()
        }, e.prototype.resume = function (e, t) {
            void 0 === e && (e = "");
            var n = this.pauseDepths;
            if (e in n) {
                if (t) delete n[e]; else n[e] -= 1, n[e] <= 0 && delete n[e];
                this.tryDrain()
            }
        }, e.prototype.isPaused = function () {
            return Object.keys(this.pauseDepths).length
        }, e.prototype.tryDrain = function () {
            if (!this.isRunning && !this.isPaused()) {
                for (this.isRunning = !0; this.isDirty;) this.isDirty = !1, this.drained();
                this.isRunning = !1
            }
        }, e.prototype.clear = function () {
            this.clearTimeout(), this.isDirty = !1, this.pauseDepths = {}
        }, e.prototype.clearTimeout = function () {
            this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0)
        }, e.prototype.drained = function () {
            this.drainedOption && this.drainedOption()
        }, e
    }(), po = function () {
        function e(e, t) {
            this.runTaskOption = e, this.drainedOption = t, this.queue = [], this.delayedRunner = new ho(this.drain.bind(this))
        }

        return e.prototype.request = function (e, t) {
            this.queue.push(e), this.delayedRunner.request(t)
        }, e.prototype.pause = function (e) {
            this.delayedRunner.pause(e)
        }, e.prototype.resume = function (e, t) {
            this.delayedRunner.resume(e, t)
        }, e.prototype.drain = function () {
            for (var e = this.queue; e.length;) {
                for (var t = [], n = void 0; n = e.shift();) this.runTask(n), t.push(n);
                this.drained(t)
            }
        }, e.prototype.runTask = function (e) {
            this.runTaskOption && this.runTaskOption(e)
        }, e.prototype.drained = function (e) {
            this.drainedOption && this.drainedOption(e)
        }, e
    }();

    function fo(e, t, n) {
        var i;
        return i = /^(year|month)$/.test(e.currentRangeUnit) ? e.currentRange : e.activeRange, n.formatRange(i.start, i.end, hn(t.titleFormat || function (e) {
            var t = e.currentRangeUnit;
            if ("year" === t) return {year: "numeric"};
            if ("month" === t) return {year: "numeric", month: "long"};
            var n = ft(e.currentRange.start, e.currentRange.end);
            if (null !== n && n > 1) return {year: "numeric", month: "short", day: "numeric"};
            return {year: "numeric", month: "long", day: "numeric"}
        }(e)), {isEndExclusive: e.isRangeAllDay, defaultSeparator: t.titleRangeSeparator})
    }

    var mo = function () {
        function e(e) {
            var t = this;
            this.computeOptionsData = Xt(this._computeOptionsData), this.computeCurrentViewData = Xt(this._computeCurrentViewData), this.organizeRawLocales = Xt(Fi), this.buildLocale = Xt(Bi), this.buildPluginHooks = kr(), this.buildDateEnv = Xt(_o), this.buildTheme = Xt(go), this.parseToolbars = Xt(ro), this.buildViewSpecs = Xt(Br), this.buildDateProfileGenerator = Jt(yo), this.buildViewApi = Xt(vo), this.buildViewUiProps = Jt(wo), this.buildEventUiBySource = Xt(xo, At), this.buildEventUiBases = Xt(bo), this.parseContextBusinessHours = Jt(To), this.buildTitle = Xt(fo), this.emitter = new cr, this.actionRunner = new po(this._handleAction.bind(this), this.updateData.bind(this)), this.currentCalendarOptionsInput = {}, this.currentCalendarOptionsRefined = {}, this.currentViewOptionsInput = {}, this.currentViewOptionsRefined = {}, this.currentCalendarOptionsRefiners = {}, this.getCurrentData = function () {
                return t.data
            }, this.dispatch = function (e) {
                t.actionRunner.request(e)
            }, this.props = e, this.actionRunner.pause();
            var n = {}, i = this.computeOptionsData(e.optionOverrides, n, e.calendarApi),
                r = i.calendarOptions.initialView || i.pluginHooks.initialView,
                a = this.computeCurrentViewData(r, i, e.optionOverrides, n);
            e.calendarApi.currentDataManager = this, this.emitter.setThisContext(e.calendarApi), this.emitter.setOptions(a.options);
            var s, l, c,
                u = (s = i.calendarOptions, l = i.dateEnv, null != (c = s.initialDate) ? l.createMarker(c) : ki(s.now, l)),
                d = a.dateProfileGenerator.build(u);
            $n(d.activeRange, u) || (u = d.currentRange.start);
            for (var h = {
                dateEnv: i.dateEnv,
                options: i.calendarOptions,
                pluginHooks: i.pluginHooks,
                calendarApi: e.calendarApi,
                dispatch: this.dispatch,
                emitter: this.emitter,
                getCurrentData: this.getCurrentData
            }, p = 0, f = i.pluginHooks.contextInit; p < f.length; p++) {
                (0, f[p])(h)
            }
            for (var m = Nr(i.calendarOptions, d, h), _ = {
                dynamicOptionOverrides: n,
                currentViewType: r,
                currentDate: u,
                dateProfile: d,
                businessHours: this.parseContextBusinessHours(h),
                eventSources: m,
                eventUiBases: {},
                eventStore: {defs: {}, instances: {}},
                renderableEventStore: {defs: {}, instances: {}},
                dateSelection: null,
                eventSelection: "",
                eventDrag: null,
                eventResize: null,
                selectionConfig: this.buildViewUiProps(h).selectionConfig
            }, g = o(o({}, h), _), y = 0, v = i.pluginHooks.reducers; y < v.length; y++) {
                var x = v[y];
                o(_, x(null, null, g))
            }
            Mo(_, h) && this.emitter.trigger("loading", !0), this.state = _, this.updateData(), this.actionRunner.resume()
        }

        return e.prototype.resetOptions = function (e, t) {
            var n = this.props;
            n.optionOverrides = t ? o(o({}, n.optionOverrides), e) : e, this.actionRunner.request({type: "NOTHING"})
        }, e.prototype._handleAction = function (e) {
            var t = this.props, n = this.state, i = this.emitter, r = function (e, t) {
                    var n;
                    switch (t.type) {
                        case"SET_OPTION":
                            return o(o({}, e), ((n = {})[t.optionName] = t.rawOptionValue, n));
                        default:
                            return e
                    }
                }(n.dynamicOptionOverrides, e), a = this.computeOptionsData(t.optionOverrides, r, t.calendarApi),
                s = function (e, t) {
                    switch (t.type) {
                        case"CHANGE_VIEW_TYPE":
                            e = t.viewType
                    }
                    return e
                }(n.currentViewType, e), l = this.computeCurrentViewData(s, a, t.optionOverrides, r);
            t.calendarApi.currentDataManager = this, i.setThisContext(t.calendarApi), i.setOptions(l.options);
            var c = {
                dateEnv: a.dateEnv,
                options: a.calendarOptions,
                pluginHooks: a.pluginHooks,
                calendarApi: t.calendarApi,
                dispatch: this.dispatch,
                emitter: i,
                getCurrentData: this.getCurrentData
            }, u = n.currentDate, d = n.dateProfile;
            this.data && this.data.dateProfileGenerator !== l.dateProfileGenerator && (d = l.dateProfileGenerator.build(u)), d = function (e, t, n, i) {
                var r;
                switch (t.type) {
                    case"CHANGE_VIEW_TYPE":
                        return i.build(t.dateMarker || n);
                    case"CHANGE_DATE":
                        return i.build(t.dateMarker);
                    case"PREV":
                        if ((r = i.buildPrev(e, n)).isValid) return r;
                        break;
                    case"NEXT":
                        if ((r = i.buildNext(e, n)).isValid) return r
                }
                return e
            }(d, e, u = function (e, t) {
                switch (t.type) {
                    case"CHANGE_DATE":
                        return t.dateMarker;
                    default:
                        return e
                }
            }(u, e), l.dateProfileGenerator), "PREV" !== e.type && "NEXT" !== e.type && $n(d.currentRange, u) || (u = d.currentRange.start);
            for (var h = Ur(n.eventSources, e, d, c), p = Jr(n.eventStore, e, h, d, c), f = Wr(h) && !l.options.progressiveEventRendering && n.renderableEventStore || p, m = this.buildViewUiProps(c), _ = m.eventUiSingleBase, g = m.selectionConfig, y = this.buildEventUiBySource(h), v = {
                dynamicOptionOverrides: r,
                currentViewType: s,
                currentDate: u,
                dateProfile: d,
                eventSources: h,
                eventStore: p,
                renderableEventStore: f,
                selectionConfig: g,
                eventUiBases: this.buildEventUiBases(f.defs, _, y),
                businessHours: this.parseContextBusinessHours(c),
                dateSelection: eo(n.dateSelection, e),
                eventSelection: to(n.eventSelection, e),
                eventDrag: no(n.eventDrag, e),
                eventResize: io(n.eventResize, e)
            }, x = o(o({}, c), v), b = 0, w = a.pluginHooks.reducers; b < w.length; b++) {
                var M = w[b];
                o(v, M(n, e, x))
            }
            var T = Mo(n, c), k = Mo(v, c);
            !T && k ? i.trigger("loading", !0) : T && !k && i.trigger("loading", !1), this.state = v, t.onAction && t.onAction(e)
        }, e.prototype.updateData = function () {
            var e, t, n, i, r, a, s, l, c, u = this.props, d = this.state, h = this.data,
                p = this.computeOptionsData(u.optionOverrides, d.dynamicOptionOverrides, u.calendarApi),
                f = this.computeCurrentViewData(d.currentViewType, p, u.optionOverrides, d.dynamicOptionOverrides),
                m = this.data = o(o(o({
                    viewTitle: this.buildTitle(d.dateProfile, f.options, p.dateEnv),
                    calendarApi: u.calendarApi,
                    dispatch: this.dispatch,
                    emitter: this.emitter,
                    getCurrentData: this.getCurrentData
                }, p), f), d), _ = p.pluginHooks.optionChangeHandlers, g = h && h.calendarOptions,
                y = p.calendarOptions;
            if (g && g !== y) for (var v in g.timeZone !== y.timeZone && (d.eventSources = m.eventSources = (a = m.eventSources, s = d.dateProfile, l = m, c = s ? s.activeRange : null, qr(a, $r(a, l), c, !0, l)), d.eventStore = m.eventStore = (e = m.eventStore, t = h.dateEnv, n = m.dateEnv, i = e.defs, r = Lt(e.instances, (function (e) {
                var r = i[e.defId];
                return r.allDay || r.recurringDef ? e : o(o({}, e), {
                    range: {
                        start: n.createMarker(t.toDate(e.range.start, e.forcedStartTzo)),
                        end: n.createMarker(t.toDate(e.range.end, e.forcedEndTzo))
                    },
                    forcedStartTzo: n.canComputeOffset ? null : e.forcedStartTzo,
                    forcedEndTzo: n.canComputeOffset ? null : e.forcedEndTzo
                })
            })), {defs: i, instances: r})), _) g[v] !== y[v] && _[v](y[v], m);
            u.onData && u.onData(m)
        }, e.prototype._computeOptionsData = function (e, t, n) {
            var i = this.processRawCalendarOptions(e, t), r = i.refinedOptions, o = i.pluginHooks, a = i.localeDefaults,
                s = i.availableLocaleData;
            ko(i.extra);
            var l = this.buildDateEnv(r.timeZone, r.locale, r.weekNumberCalculation, r.firstDay, r.weekText, o, s, r.defaultRangeSeparator),
                c = this.buildViewSpecs(o.views, e, t, a), u = this.buildTheme(r, o);
            return {
                calendarOptions: r,
                pluginHooks: o,
                dateEnv: l,
                viewSpecs: c,
                theme: u,
                toolbarConfig: this.parseToolbars(r, e, u, c, n),
                localeDefaults: a,
                availableRawLocales: s.map
            }
        }, e.prototype.processRawCalendarOptions = function (e, t) {
            var n = xn([fn, e, t]), i = n.locales, r = n.locale, a = this.organizeRawLocales(i), s = a.map,
                l = this.buildLocale(r || a.defaultCode, s).options, c = this.buildPluginHooks(e.plugins || [], uo),
                u = this.currentCalendarOptionsRefiners = o(o(o(o(o({}, pn), mn), _n), c.listenerRefiners), c.optionRefiners),
                d = {}, h = xn([fn, l, e, t]), p = {}, f = this.currentCalendarOptionsInput,
                m = this.currentCalendarOptionsRefined, _ = !1;
            for (var g in h) "plugins" !== g && (h[g] === f[g] || gn[g] && g in f && gn[g](f[g], h[g]) ? p[g] = m[g] : u[g] ? (p[g] = u[g](h[g]), _ = !0) : d[g] = f[g]);
            return _ && (this.currentCalendarOptionsInput = h, this.currentCalendarOptionsRefined = p), {
                rawOptions: this.currentCalendarOptionsInput,
                refinedOptions: this.currentCalendarOptionsRefined,
                pluginHooks: c,
                availableLocaleData: a,
                localeDefaults: l,
                extra: d
            }
        }, e.prototype._computeCurrentViewData = function (e, t, n, i) {
            var r = t.viewSpecs[e];
            if (!r) throw new Error('viewType "' + e + "\" is not available. Please make sure you've loaded all neccessary plugins");
            var o = this.processRawViewOptions(r, t.pluginHooks, t.localeDefaults, n, i), a = o.refinedOptions;
            return ko(o.extra), {
                viewSpec: r,
                options: a,
                dateProfileGenerator: this.buildDateProfileGenerator({
                    dateProfileGeneratorClass: r.optionDefaults.dateProfileGeneratorClass,
                    duration: r.duration,
                    durationUnit: r.durationUnit,
                    usesMinMaxTime: r.optionDefaults.usesMinMaxTime,
                    dateEnv: t.dateEnv,
                    calendarApi: this.props.calendarApi,
                    slotMinTime: a.slotMinTime,
                    slotMaxTime: a.slotMaxTime,
                    showNonCurrentDates: a.showNonCurrentDates,
                    dayCount: a.dayCount,
                    dateAlignment: a.dateAlignment,
                    dateIncrement: a.dateIncrement,
                    hiddenDays: a.hiddenDays,
                    weekends: a.weekends,
                    nowInput: a.now,
                    validRangeInput: a.validRange,
                    visibleRangeInput: a.visibleRange,
                    monthMode: a.monthMode,
                    fixedWeekCount: a.fixedWeekCount
                }),
                viewApi: this.buildViewApi(e, this.getCurrentData, t.dateEnv)
            }
        }, e.prototype.processRawViewOptions = function (e, t, n, i, r) {
            var a = xn([fn, e.optionDefaults, n, i, e.optionOverrides, r]),
                s = o(o(o(o(o(o({}, pn), mn), _n), vn), t.listenerRefiners), t.optionRefiners), l = {},
                c = this.currentViewOptionsInput, u = this.currentViewOptionsRefined, d = !1, h = {};
            for (var p in a) a[p] === c[p] ? l[p] = u[p] : (a[p] === this.currentCalendarOptionsInput[p] ? p in this.currentCalendarOptionsRefined && (l[p] = this.currentCalendarOptionsRefined[p]) : s[p] ? l[p] = s[p](a[p]) : h[p] = a[p], d = !0);
            return d && (this.currentViewOptionsInput = a, this.currentViewOptionsRefined = l), {
                rawOptions: this.currentViewOptionsInput,
                refinedOptions: this.currentViewOptionsRefined,
                extra: h
            }
        }, e
    }();

    function _o(e, t, n, i, r, o, a, s) {
        var l = Bi(t || a.defaultCode, a.map);
        return new Ri({
            calendarSystem: "gregory",
            timeZone: e,
            namedTimeZoneImpl: o.namedTimeZonedImpl,
            locale: l,
            weekNumberCalculation: n,
            firstDay: i,
            weekText: r,
            cmdFormatter: o.cmdFormatter,
            defaultSeparator: s
        })
    }

    function go(e, t) {
        return new (t.themeClasses[e.themeSystem] || Sr)(e)
    }

    function yo(e) {
        return new (e.dateProfileGeneratorClass || Hr)(e)
    }

    function vo(e, t, n) {
        return new bi(e, t, n)
    }

    function xo(e) {
        return Lt(e, (function (e) {
            return e.ui
        }))
    }

    function bo(e, t, n) {
        var i = {"": t};
        for (var r in e) {
            var o = e[r];
            o.sourceId && n[o.sourceId] && (i[r] = n[o.sourceId])
        }
        return i
    }

    function wo(e) {
        var t = e.options;
        return {
            eventUiSingleBase: An({
                display: t.eventDisplay,
                editable: t.editable,
                startEditable: t.eventStartEditable,
                durationEditable: t.eventDurationEditable,
                constraint: t.eventConstraint,
                overlap: "boolean" == typeof t.eventOverlap ? t.eventOverlap : void 0,
                allow: t.eventAllow,
                backgroundColor: t.eventBackgroundColor,
                borderColor: t.eventBorderColor,
                textColor: t.eventTextColor,
                color: t.eventColor
            }, e),
            selectionConfig: An({
                constraint: t.selectConstraint,
                overlap: "boolean" == typeof t.selectOverlap ? t.selectOverlap : void 0,
                allow: t.selectAllow
            }, e)
        }
    }

    function Mo(e, t) {
        for (var n = 0, i = t.pluginHooks.isLoadingFuncs; n < i.length; n++) {
            if ((0, i[n])(e)) return !0
        }
        return !1
    }

    function To(e) {
        return Ui(e.options.businessHours, e)
    }

    function ko(e, t) {
        for (var n in e) console.warn("Unknown option '" + n + "'" + (t ? " for view '" + t + "'" : ""))
    }

    !function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            return n.handleData = function (e) {
                n.dataManager ? n.setState(e) : n.state = e
            }, n.dataManager = new mo({
                optionOverrides: t.optionOverrides,
                calendarApi: t.calendarApi,
                onData: n.handleData
            }), n
        }

        r(t, e), t.prototype.render = function () {
            return this.props.children(this.state)
        }, t.prototype.componentDidUpdate = function (e) {
            var t = this.props.optionOverrides;
            t !== e.optionOverrides && this.dataManager.resetOptions(t)
        }
    }(Le);
    var So = function () {
        function e() {
            this.strictOrder = !1, this.allowReslicing = !1, this.maxCoord = -1, this.maxStackCnt = -1, this.levelCoords = [], this.entriesByLevel = [], this.stackCnts = {}
        }

        return e.prototype.addSegs = function (e) {
            for (var t = [], n = 0, i = e; n < i.length; n++) {
                var r = i[n];
                this.insertEntry(r, t)
            }
            return t
        }, e.prototype.insertEntry = function (e, t) {
            var n = this.findInsertion(e);
            return this.isInsertionValid(n, e) ? (this.insertEntryAt(e, n), 1) : this.handleInvalidInsertion(n, e, t)
        }, e.prototype.isInsertionValid = function (e, t) {
            return (-1 === this.maxCoord || e.levelCoord + t.thickness <= this.maxCoord) && (-1 === this.maxStackCnt || e.stackCnt < this.maxStackCnt)
        }, e.prototype.handleInvalidInsertion = function (e, t, n) {
            return this.allowReslicing && e.touchingEntry ? this.splitEntry(t, e.touchingEntry, n) : (n.push(t), 0)
        }, e.prototype.splitEntry = function (e, t, n) {
            var i = 0, r = [], o = e.span, s = t.span;
            return o.start < s.start && (i += this.insertEntry({
                index: e.index,
                thickness: e.thickness,
                span: {start: o.start, end: s.start}
            }, r)), o.end > s.end && (i += this.insertEntry({
                index: e.index,
                thickness: e.thickness,
                span: {start: s.end, end: o.end}
            }, r)), i ? (n.push.apply(n, a([{
                index: e.index,
                thickness: e.thickness,
                span: Eo(s, o)
            }], r)), i) : (n.push(e), 0)
        }, e.prototype.insertEntryAt = function (e, t) {
            var n = this.entriesByLevel, i = this.levelCoords;
            -1 === t.lateral ? (Co(i, t.level, t.levelCoord), Co(n, t.level, [e])) : Co(n[t.level], t.lateral, e), this.stackCnts[Lo(e)] = t.stackCnt
        }, e.prototype.findInsertion = function (e) {
            for (var t = this.levelCoords, n = this.entriesByLevel, i = this.strictOrder, r = this.stackCnts, o = t.length, a = 0, s = -1, l = -1, c = null, u = 0, d = 0; d < o; d += 1) {
                var h = t[d];
                if (!i && h >= a + e.thickness) break;
                for (var p = n[d], f = void 0, m = Ao(p, e.span.start, Do), _ = m[0] + m[1]; (f = p[_]) && f.span.start < e.span.end;) {
                    var g = h + f.thickness;
                    g > a && (a = g, c = f, s = d, l = _), g === a && (u = Math.max(u, r[Lo(f)] + 1)), _ += 1
                }
            }
            var y = 0;
            if (c) for (y = s + 1; y < o && t[y] < a;) y += 1;
            var v = -1;
            return y < o && t[y] === a && (v = Ao(n[y], e.span.end, Do)[0]), {
                touchingLevel: s,
                touchingLateral: l,
                touchingEntry: c,
                stackCnt: u,
                levelCoord: a,
                level: y,
                lateral: v
            }
        }, e.prototype.toRects = function () {
            for (var e = this.entriesByLevel, t = this.levelCoords, n = e.length, i = [], r = 0; r < n; r += 1) for (var a = e[r], s = t[r], l = 0, c = a; l < c.length; l++) {
                var u = c[l];
                i.push(o(o({}, u), {levelCoord: s}))
            }
            return i
        }, e
    }();

    function Do(e) {
        return e.span.end
    }

    function Lo(e) {
        return e.index + ":" + e.span.start
    }

    function Eo(e, t) {
        var n = Math.max(e.start, t.start), i = Math.min(e.end, t.end);
        return n < i ? {start: n, end: i} : null
    }

    function Co(e, t, n) {
        e.splice(t, 0, n)
    }

    function Ao(e, t, n) {
        var i = 0, r = e.length;
        if (!r || t < n(e[i])) return [0, 0];
        if (t > n(e[r - 1])) return [r, 0];
        for (; i < r;) {
            var o = Math.floor(i + (r - i) / 2), a = n(e[o]);
            if (t < a) r = o; else {
                if (!(t > a)) return [o, 1];
                i = o + 1
            }
        }
        return [i, 0]
    }

    var Io = function () {
        function e(e) {
            this.component = e.component, this.isHitComboAllowed = e.isHitComboAllowed || null
        }

        return e.prototype.destroy = function () {
        }, e
    }();

    function Po(e, t) {
        return {
            component: e,
            el: t.el,
            useEventCenter: null == t.useEventCenter || t.useEventCenter,
            isHitComboAllowed: t.isHitComboAllowed || null
        }
    }

    function Ro(e) {
        var t;
        return (t = {})[e.component.uid] = e, t
    }

    var Yo = {}, zo = function () {
        function e(e, t) {
            this.emitter = new cr
        }

        return e.prototype.destroy = function () {
        }, e.prototype.setMirrorIsVisible = function (e) {
        }, e.prototype.setMirrorNeedsRevert = function (e) {
        }, e.prototype.setAutoScrollEnabled = function (e) {
        }, e
    }(), Oo = {}, Fo = {startTime: Bt, duration: Bt, create: Boolean, sourceId: String};

    function Bo(e) {
        var t = bn(e, Fo), n = t.refined, i = t.extra;
        return {
            startTime: n.startTime || null,
            duration: n.duration || null,
            create: null == n.create || n.create,
            sourceId: n.sourceId,
            leftoverProps: i
        }
    }

    var jo = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props.widgetGroups.map((function (t) {
                return e.renderWidgetGroup(t)
            }));
            return Ee.apply(void 0, a(["div", {className: "fc-toolbar-chunk"}], t))
        }, t.prototype.renderWidgetGroup = function (e) {
            for (var t = this.props, n = this.context.theme, i = [], r = !0, o = 0, s = e; o < s.length; o++) {
                var l = s[o], c = l.buttonName, u = l.buttonClick, d = l.buttonText, h = l.buttonIcon, p = l.buttonHint;
                if ("title" === c) r = !1, i.push(Ee("h2", {
                    className: "fc-toolbar-title",
                    id: t.titleId
                }, t.title)); else {
                    var f = c === t.activeButton,
                        m = !t.isTodayEnabled && "today" === c || !t.isPrevEnabled && "prev" === c || !t.isNextEnabled && "next" === c,
                        _ = ["fc-" + c + "-button", n.getClass("button")];
                    f && _.push(n.getClass("buttonActive")), i.push(Ee("button", {
                        type: "button",
                        title: "function" == typeof p ? p(t.navUnit) : p,
                        disabled: m,
                        "aria-pressed": f,
                        className: _.join(" "),
                        onClick: u
                    }, d || (h ? Ee("span", {className: h}) : "")))
                }
            }
            if (i.length > 1) {
                var g = r && n.getClass("buttonGroup") || "";
                return Ee.apply(void 0, a(["div", {className: g}], i))
            }
            return i[0]
        }, t
    }(vr), Ho = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e, t, n = this.props, i = n.model, r = n.extraClassName, o = !1, a = i.sectionWidgets, s = a.center;
            return a.left ? (o = !0, e = a.left) : e = a.start, a.right ? (o = !0, t = a.right) : t = a.end, Ee("div", {className: [r || "", "fc-toolbar", o ? "fc-toolbar-ltr" : ""].join(" ")}, this.renderSection("start", e || []), this.renderSection("center", s || []), this.renderSection("end", t || []))
        }, t.prototype.renderSection = function (e, t) {
            var n = this.props;
            return Ee(jo, {
                key: e,
                widgetGroups: t,
                title: n.title,
                navUnit: n.navUnit,
                activeButton: n.activeButton,
                isTodayEnabled: n.isTodayEnabled,
                isPrevEnabled: n.isPrevEnabled,
                isNextEnabled: n.isNextEnabled,
                titleId: n.titleId
            })
        }, t
    }(vr), No = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.state = {availableWidth: null}, t.handleEl = function (e) {
                t.el = e, wr(t.props.elRef, e), t.updateAvailableWidth()
            }, t.handleResize = function () {
                t.updateAvailableWidth()
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.state, n = e.aspectRatio,
                i = ["fc-view-harness", n || e.liquid || e.height ? "fc-view-harness-active" : "fc-view-harness-passive"],
                r = "", o = "";
            return n ? null !== t.availableWidth ? r = t.availableWidth / n : o = 1 / n * 100 + "%" : r = e.height || "", Ee("div", {
                "aria-labelledby": e.labeledById,
                ref: this.handleEl,
                className: i.join(" "),
                style: {height: r, paddingBottom: o}
            }, e.children)
        }, t.prototype.componentDidMount = function () {
            this.context.addResizeHandler(this.handleResize)
        }, t.prototype.componentWillUnmount = function () {
            this.context.removeResizeHandler(this.handleResize)
        }, t.prototype.updateAvailableWidth = function () {
            this.el && this.props.aspectRatio && this.setState({availableWidth: this.el.offsetWidth})
        }, t
    }(vr), Uo = function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            return n.handleSegClick = function (e, t) {
                var i = n.component, r = i.context, o = Kn(t);
                if (o && i.isValidSegDownEl(e.target)) {
                    var a = Be(e.target, ".fc-event-forced-url"), s = a ? a.querySelector("a[href]").href : "";
                    r.emitter.trigger("eventClick", {
                        el: t,
                        event: new Di(i.context, o.eventRange.def, o.eventRange.instance),
                        jsEvent: e,
                        view: r.viewApi
                    }), s && !e.defaultPrevented && (window.location.href = s)
                }
            }, n.destroy = $e(t.el, "click", ".fc-event", n.handleSegClick), n
        }

        return r(t, e), t
    }(Io), Wo = function (e) {
        function t(t) {
            var n, i, r, o, a, s = e.call(this, t) || this;
            return s.handleEventElRemove = function (e) {
                e === s.currentSegEl && s.handleSegLeave(null, s.currentSegEl)
            }, s.handleSegEnter = function (e, t) {
                Kn(t) && (s.currentSegEl = t, s.triggerEvent("eventMouseEnter", e, t))
            }, s.handleSegLeave = function (e, t) {
                s.currentSegEl && (s.currentSegEl = null, s.triggerEvent("eventMouseLeave", e, t))
            }, s.removeHoverListeners = (n = t.el, i = ".fc-event", r = s.handleSegEnter, o = s.handleSegLeave, $e(n, "mouseover", i, (function (e, t) {
                if (t !== a) {
                    a = t, r(e, t);
                    var n = function (e) {
                        a = null, o(e, t), t.removeEventListener("mouseleave", n)
                    };
                    t.addEventListener("mouseleave", n)
                }
            }))), s
        }

        return r(t, e), t.prototype.destroy = function () {
            this.removeHoverListeners()
        }, t.prototype.triggerEvent = function (e, t, n) {
            var i = this.component, r = i.context, o = Kn(n);
            t && !i.isValidSegDownEl(t.target) || r.emitter.trigger(e, {
                el: n,
                event: new Di(r, o.eventRange.def, o.eventRange.instance),
                jsEvent: t,
                view: r.viewApi
            })
        }, t
    }(Io), Vo = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.buildViewContext = Xt(gr), t.buildViewPropTransformers = Xt(qo), t.buildToolbarProps = Xt(Go), t.headerRef = Ae(), t.footerRef = Ae(), t.interactionsStore = {}, t.state = {viewLabelId: qe()}, t.registerInteractiveComponent = function (e, n) {
                var i = Po(e, n), r = [Uo, Wo].concat(t.props.pluginHooks.componentInteractions).map((function (e) {
                    return new e(i)
                }));
                t.interactionsStore[e.uid] = r, Yo[e.uid] = i
            }, t.unregisterInteractiveComponent = function (e) {
                for (var n = 0, i = t.interactionsStore[e.uid]; n < i.length; n++) {
                    i[n].destroy()
                }
                delete t.interactionsStore[e.uid], delete Yo[e.uid]
            }, t.resizeRunner = new ho((function () {
                t.props.emitter.trigger("_resize", !0), t.props.emitter.trigger("windowResize", {view: t.props.viewApi})
            })), t.handleWindowResize = function (e) {
                var n = t.props.options;
                n.handleWindowResize && e.target === window && t.resizeRunner.request(n.windowResizeDelay)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e, t = this.props, n = t.toolbarConfig, i = t.options,
                r = this.buildToolbarProps(t.viewSpec, t.dateProfile, t.dateProfileGenerator, t.currentDate, ki(t.options.now, t.dateEnv), t.viewTitle),
                a = !1, s = "";
            t.isHeightAuto || t.forPrint ? s = "" : null != i.height ? a = !0 : null != i.contentHeight ? s = i.contentHeight : e = Math.max(i.aspectRatio, .5);
            var l = this.buildViewContext(t.viewSpec, t.viewApi, t.options, t.dateProfileGenerator, t.dateEnv, t.theme, t.pluginHooks, t.dispatch, t.getCurrentData, t.emitter, t.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent),
                c = n.header && n.header.hasTitle ? this.state.viewLabelId : "";
            return Ee(_r.Provider, {value: l}, n.header && Ee(Ho, o({
                ref: this.headerRef,
                extraClassName: "fc-header-toolbar",
                model: n.header,
                titleId: c
            }, r)), Ee(No, {
                liquid: a,
                height: s,
                aspectRatio: e,
                labeledById: c
            }, this.renderView(t), this.buildAppendContent()), n.footer && Ee(Ho, o({
                ref: this.footerRef,
                extraClassName: "fc-footer-toolbar",
                model: n.footer,
                titleId: ""
            }, r)))
        }, t.prototype.componentDidMount = function () {
            var e = this.props;
            this.calendarInteractions = e.pluginHooks.calendarInteractions.map((function (t) {
                return new t(e)
            })), window.addEventListener("resize", this.handleWindowResize);
            var t = e.pluginHooks.propSetHandlers;
            for (var n in t) t[n](e[n], e)
        }, t.prototype.componentDidUpdate = function (e) {
            var t = this.props, n = t.pluginHooks.propSetHandlers;
            for (var i in n) t[i] !== e[i] && n[i](t[i], t)
        }, t.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.handleWindowResize), this.resizeRunner.clear();
            for (var e = 0, t = this.calendarInteractions; e < t.length; e++) {
                t[e].destroy()
            }
            this.props.emitter.trigger("_unmount")
        }, t.prototype.buildAppendContent = function () {
            var e = this.props, t = e.pluginHooks.viewContainerAppends.map((function (t) {
                return t(e)
            }));
            return Ee.apply(void 0, a([Ie, {}], t))
        }, t.prototype.renderView = function (e) {
            for (var t = e.pluginHooks, n = e.viewSpec, i = {
                dateProfile: e.dateProfile,
                businessHours: e.businessHours,
                eventStore: e.renderableEventStore,
                eventUiBases: e.eventUiBases,
                dateSelection: e.dateSelection,
                eventSelection: e.eventSelection,
                eventDrag: e.eventDrag,
                eventResize: e.eventResize,
                isHeightAuto: e.isHeightAuto,
                forPrint: e.forPrint
            }, r = 0, a = this.buildViewPropTransformers(t.viewPropsTransformers); r < a.length; r++) {
                var s = a[r];
                o(i, s.transform(i, e))
            }
            var l = n.component;
            return Ee(l, o({}, i))
        }, t
    }(yr);

    function Go(e, t, n, i, r, o) {
        var a = n.build(r, void 0, !1), s = n.buildPrev(t, i, !1), l = n.buildNext(t, i, !1);
        return {
            title: o,
            activeButton: e.type,
            navUnit: e.singleUnit,
            isTodayEnabled: a.isValid && !$n(t.currentRange, r),
            isPrevEnabled: s.isValid,
            isNextEnabled: l.isValid
        }
    }

    function qo(e) {
        return e.map((function (e) {
            return new e
        }))
    }

    var Zo = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.state = {forPrint: !1}, t.handleBeforePrint = function () {
                t.setState({forPrint: !0})
            }, t.handleAfterPrint = function () {
                t.setState({forPrint: !1})
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = e.options, n = this.state.forPrint,
                i = n || "auto" === t.height || "auto" === t.contentHeight, r = i || null == t.height ? "" : t.height,
                o = ["fc", n ? "fc-media-print" : "fc-media-screen", "fc-direction-" + t.direction, e.theme.getClass("root")];
            return Gi() || o.push("fc-liquid-hack"), e.children(o, r, i, n)
        }, t.prototype.componentDidMount = function () {
            var e = this.props.emitter;
            e.on("_beforeprint", this.handleBeforePrint), e.on("_afterprint", this.handleAfterPrint)
        }, t.prototype.componentWillUnmount = function () {
            var e = this.props.emitter;
            e.off("_beforeprint", this.handleBeforePrint), e.off("_afterprint", this.handleAfterPrint)
        }, t
    }(vr);
    var $o = "fc-col-header-cell";

    function Xo(e) {
        return e.text
    }

    var Jo = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = e.dateEnv, n = e.options, i = e.theme, r = e.viewApi, a = this.props, s = a.date,
                l = a.dateProfile, c = Xi(s, a.todayRange, null, l), u = [$o].concat(Ji(c, i)),
                d = t.format(s, a.dayHeaderFormat), h = !c.isDisabled && a.colCnt > 1 ? er(this.context, s) : {},
                p = o(o(o({date: t.toDate(s), view: r}, a.extraHookProps), {text: d}), c);
            return Ee(Lr, {
                hookProps: p,
                classNames: n.dayHeaderClassNames,
                content: n.dayHeaderContent,
                defaultContent: Xo,
                didMount: n.dayHeaderDidMount,
                willUnmount: n.dayHeaderWillUnmount
            }, (function (e, t, n, i) {
                return Ee("th", o({
                    ref: e,
                    role: "columnheader",
                    className: u.concat(t).join(" "),
                    "data-date": c.isDisabled ? void 0 : qt(s),
                    colSpan: a.colSpan
                }, a.extraDataAttrs), Ee("div", {className: "fc-scrollgrid-sync-inner"}, !c.isDisabled && Ee("a", o({
                    ref: n,
                    className: ["fc-col-header-cell-cushion", a.isSticky ? "fc-sticky" : ""].join(" ")
                }, h), i)))
            }))
        }, t
    }(vr), Ko = hn({weekday: "long"}), Qo = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.dateEnv, i = t.theme, r = t.viewApi, a = t.options,
                s = dt(new Date(2592e5), e.dow),
                l = {dow: e.dow, isDisabled: !1, isFuture: !1, isPast: !1, isToday: !1, isOther: !1},
                c = [$o].concat(Ji(l, i), e.extraClassNames || []), u = n.format(s, e.dayHeaderFormat),
                d = o(o(o(o({date: s}, l), {view: r}), e.extraHookProps), {text: u});
            return Ee(Lr, {
                hookProps: d,
                classNames: a.dayHeaderClassNames,
                content: a.dayHeaderContent,
                defaultContent: Xo,
                didMount: a.dayHeaderDidMount,
                willUnmount: a.dayHeaderWillUnmount
            }, (function (t, i, r, a) {
                return Ee("th", o({
                    ref: t,
                    role: "columnheader",
                    className: c.concat(i).join(" "),
                    colSpan: e.colSpan
                }, e.extraDataAttrs), Ee("div", {className: "fc-scrollgrid-sync-inner"}, Ee("a", {
                    "aria-label": n.format(s, Ko),
                    className: ["fc-col-header-cell-cushion", e.isSticky ? "fc-sticky" : ""].join(" "),
                    ref: r
                }, a)))
            }))
        }, t
    }(vr), ea = function (e) {
        function t(t, n) {
            var i = e.call(this, t, n) || this;
            return i.initialNowDate = ki(n.options.now, n.dateEnv), i.initialNowQueriedMs = (new Date).valueOf(), i.state = i.computeTiming().currentState, i
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.state;
            return e.children(t.nowDate, t.todayRange)
        }, t.prototype.componentDidMount = function () {
            this.setTimeout()
        }, t.prototype.componentDidUpdate = function (e) {
            e.unit !== this.props.unit && (this.clearTimeout(), this.setTimeout())
        }, t.prototype.componentWillUnmount = function () {
            this.clearTimeout()
        }, t.prototype.computeTiming = function () {
            var e = this.props, t = this.context,
                n = ht(this.initialNowDate, (new Date).valueOf() - this.initialNowQueriedMs),
                i = t.dateEnv.startOf(n, e.unit), r = t.dateEnv.add(i, Bt(1, e.unit)), o = r.valueOf() - n.valueOf();
            return o = Math.min(864e5, o), {
                currentState: {nowDate: i, todayRange: ta(i)},
                nextState: {nowDate: r, todayRange: ta(r)},
                waitMs: o
            }
        }, t.prototype.setTimeout = function () {
            var e = this, t = this.computeTiming(), n = t.nextState, i = t.waitMs;
            this.timeoutId = setTimeout((function () {
                e.setState(n, (function () {
                    e.setTimeout()
                }))
            }), i)
        }, t.prototype.clearTimeout = function () {
            this.timeoutId && clearTimeout(this.timeoutId)
        }, t.contextType = _r, t
    }(Le);

    function ta(e) {
        var t = mt(e);
        return {start: t, end: dt(t, 1)}
    }

    var na = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.createDayHeaderFormatter = Xt(ia), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = this.props, n = t.dates, i = t.dateProfile, r = t.datesRepDistinctDays,
                o = t.renderIntro, a = this.createDayHeaderFormatter(e.options.dayHeaderFormat, r, n.length);
            return Ee(ea, {unit: "day"}, (function (e, t) {
                return Ee("tr", {role: "row"}, o && o("day"), n.map((function (e) {
                    return r ? Ee(Jo, {
                        key: e.toISOString(),
                        date: e,
                        dateProfile: i,
                        todayRange: t,
                        colCnt: n.length,
                        dayHeaderFormat: a
                    }) : Ee(Qo, {key: e.getUTCDay(), dow: e.getUTCDay(), dayHeaderFormat: a})
                })))
            }))
        }, t
    }(vr);

    function ia(e, t, n) {
        return e || function (e, t) {
            return hn(!e || t > 10 ? {weekday: "short"} : t > 1 ? {
                weekday: "short",
                month: "numeric",
                day: "numeric",
                omitCommas: !0
            } : {weekday: "long"})
        }(t, n)
    }

    var ra = function () {
        function e(e, t) {
            for (var n = e.start, i = e.end, r = [], o = [], a = -1; n < i;) t.isHiddenDay(n) ? r.push(a + .5) : (a += 1, r.push(a), o.push(n)), n = dt(n, 1);
            this.dates = o, this.indices = r, this.cnt = o.length
        }

        return e.prototype.sliceRange = function (e) {
            var t = this.getDateDayIndex(e.start), n = this.getDateDayIndex(dt(e.end, -1)), i = Math.max(0, t),
                r = Math.min(this.cnt - 1, n);
            return (i = Math.ceil(i)) <= (r = Math.floor(r)) ? {
                firstIndex: i,
                lastIndex: r,
                isStart: t === i,
                isEnd: n === r
            } : null
        }, e.prototype.getDateDayIndex = function (e) {
            var t = this.indices, n = Math.floor(pt(this.dates[0], e));
            return n < 0 ? t[0] - 1 : n >= t.length ? t[t.length - 1] + 1 : t[n]
        }, e
    }(), oa = function () {
        function e(e, t) {
            var n, i, r, o = e.dates;
            if (t) {
                for (i = o[0].getUTCDay(), n = 1; n < o.length && o[n].getUTCDay() !== i; n += 1) ;
                r = Math.ceil(o.length / n)
            } else r = 1, n = o.length;
            this.rowCnt = r, this.colCnt = n, this.daySeries = e, this.cells = this.buildCells(), this.headerDates = this.buildHeaderDates()
        }

        return e.prototype.buildCells = function () {
            for (var e = [], t = 0; t < this.rowCnt; t += 1) {
                for (var n = [], i = 0; i < this.colCnt; i += 1) n.push(this.buildCell(t, i));
                e.push(n)
            }
            return e
        }, e.prototype.buildCell = function (e, t) {
            var n = this.daySeries.dates[e * this.colCnt + t];
            return {key: n.toISOString(), date: n}
        }, e.prototype.buildHeaderDates = function () {
            for (var e = [], t = 0; t < this.colCnt; t += 1) e.push(this.cells[0][t].date);
            return e
        }, e.prototype.sliceRange = function (e) {
            var t = this.colCnt, n = this.daySeries.sliceRange(e), i = [];
            if (n) for (var r = n.firstIndex, o = n.lastIndex, a = r; a <= o;) {
                var s = Math.floor(a / t), l = Math.min((s + 1) * t, o + 1);
                i.push({
                    row: s,
                    firstCol: a % t,
                    lastCol: (l - 1) % t,
                    isStart: n.isStart && a === r,
                    isEnd: n.isEnd && l - 1 === o
                }), a = l
            }
            return i
        }, e
    }(), aa = function () {
        function e() {
            this.sliceBusinessHours = Xt(this._sliceBusinessHours), this.sliceDateSelection = Xt(this._sliceDateSpan), this.sliceEventStore = Xt(this._sliceEventStore), this.sliceEventDrag = Xt(this._sliceInteraction), this.sliceEventResize = Xt(this._sliceInteraction), this.forceDayIfListItem = !1
        }

        return e.prototype.sliceProps = function (e, t, n, i) {
            for (var r = [], o = 4; o < arguments.length; o++) r[o - 4] = arguments[o];
            var s = e.eventUiBases, l = this.sliceEventStore.apply(this, a([e.eventStore, s, t, n], r));
            return {
                dateSelectionSegs: this.sliceDateSelection.apply(this, a([e.dateSelection, s, i], r)),
                businessHourSegs: this.sliceBusinessHours.apply(this, a([e.businessHours, t, n, i], r)),
                fgEventSegs: l.fg,
                bgEventSegs: l.bg,
                eventDrag: this.sliceEventDrag.apply(this, a([e.eventDrag, s, t, n], r)),
                eventResize: this.sliceEventResize.apply(this, a([e.eventResize, s, t, n], r)),
                eventSelection: e.eventSelection
            }
        }, e.prototype.sliceNowDate = function (e, t) {
            for (var n = [], i = 2; i < arguments.length; i++) n[i - 2] = arguments[i];
            return this._sliceDateSpan.apply(this, a([{range: {start: e, end: ht(e, 1)}, allDay: !1}, {}, t], n))
        }, e.prototype._sliceBusinessHours = function (e, t, n, i) {
            for (var r = [], o = 4; o < arguments.length; o++) r[o - 4] = arguments[o];
            return e ? this._sliceEventStore.apply(this, a([Yt(e, sa(t, Boolean(n)), i), {}, t, n], r)).bg : []
        }, e.prototype._sliceEventStore = function (e, t, n, i) {
            for (var r = [], o = 4; o < arguments.length; o++) r[o - 4] = arguments[o];
            if (e) {
                var a = Xn(e, t, sa(n, Boolean(i)), i);
                return {bg: this.sliceEventRanges(a.bg, r), fg: this.sliceEventRanges(a.fg, r)}
            }
            return {bg: [], fg: []}
        }, e.prototype._sliceInteraction = function (e, t, n, i) {
            for (var r = [], o = 4; o < arguments.length; o++) r[o - 4] = arguments[o];
            if (!e) return null;
            var a = Xn(e.mutatedEvents, t, sa(n, Boolean(i)), i);
            return {
                segs: this.sliceEventRanges(a.fg, r),
                affectedInstances: e.affectedEvents.instances,
                isEvent: e.isEvent
            }
        }, e.prototype._sliceDateSpan = function (e, t, n) {
            for (var i = [], r = 3; r < arguments.length; r++) i[r - 3] = arguments[r];
            if (!e) return [];
            for (var o = fi(e, t, n), s = this.sliceRange.apply(this, a([e.range], i)), l = 0, c = s; l < c.length; l++) {
                var u = c[l];
                u.eventRange = o
            }
            return s
        }, e.prototype.sliceEventRanges = function (e, t) {
            for (var n = [], i = 0, r = e; i < r.length; i++) {
                var o = r[i];
                n.push.apply(n, this.sliceEventRange(o, t))
            }
            return n
        }, e.prototype.sliceEventRange = function (e, t) {
            var n = e.range;
            this.forceDayIfListItem && "list-item" === e.ui.display && (n = {start: n.start, end: dt(n.start, 1)});
            for (var i = this.sliceRange.apply(this, a([n], t)), r = 0, o = i; r < o.length; r++) {
                var s = o[r];
                s.eventRange = e, s.isStart = e.isStart && s.isStart, s.isEnd = e.isEnd && s.isEnd
            }
            return i
        }, e
    }();

    function sa(e, t) {
        var n = e.activeRange;
        return t ? n : {
            start: ht(n.start, e.slotMinTime.milliseconds),
            end: ht(n.end, e.slotMaxTime.milliseconds - 864e5)
        }
    }

    function la(e, t, n) {
        var i = e.mutatedEvents.instances;
        for (var r in i) if (!Zn(t.validRange, i[r].range)) return !1;
        return ca({eventDrag: e}, n)
    }

    function ca(e, t) {
        var n = t.getCurrentData(), i = o({
            businessHours: n.businessHours,
            dateSelection: "",
            eventStore: n.eventStore,
            eventUiBases: n.eventUiBases,
            eventSelection: "",
            eventDrag: null,
            eventResize: null
        }, e);
        return (t.pluginHooks.isPropsValid || ua)(i, t)
    }

    function ua(e, t, n, i) {
        return void 0 === n && (n = {}), !(e.eventDrag && !function (e, t, n, i) {
            var r = t.getCurrentData(), a = e.eventDrag, s = a.mutatedEvents, l = s.defs, c = s.instances,
                u = Qn(l, a.isEvent ? e.eventUiBases : {"": r.selectionConfig});
            i && (u = Lt(u, i));
            var d = (m = e.eventStore, _ = a.affectedEvents.instances, {
                defs: m.defs,
                instances: Dt(m.instances, (function (e) {
                    return !_[e.instanceId]
                }))
            }), h = d.defs, p = d.instances, f = Qn(h, e.eventUiBases);
            var m, _;
            for (var g in c) {
                var y = c[g], v = y.range, x = u[y.defId], b = l[y.defId];
                if (!da(x.constraints, v, d, e.businessHours, t)) return !1;
                var w = t.options.eventOverlap, M = "function" == typeof w ? w : null;
                for (var T in p) {
                    var k = p[T];
                    if (qn(v, k.range)) {
                        if (!1 === f[k.defId].overlap && a.isEvent) return !1;
                        if (!1 === x.overlap) return !1;
                        if (M && !M(new Di(t, h[k.defId], k), new Di(t, b, y))) return !1
                    }
                }
                for (var S = r.eventStore, D = 0, L = x.allows; D < L.length; D++) {
                    var E = L[D], C = o(o({}, n), {range: y.range, allDay: b.allDay}), A = S.defs[b.defId],
                        I = S.instances[g], P = void 0;
                    if (P = A ? new Di(t, A, I) : new Di(t, b), !E(_i(C, t), P)) return !1
                }
            }
            return !0
        }(e, t, n, i)) && !(e.dateSelection && !function (e, t, n, i) {
            var r = e.eventStore, a = r.defs, s = r.instances, l = e.dateSelection, c = l.range,
                u = t.getCurrentData().selectionConfig;
            i && (u = i(u));
            if (!da(u.constraints, c, r, e.businessHours, t)) return !1;
            var d = t.options.selectOverlap, h = "function" == typeof d ? d : null;
            for (var p in s) {
                var f = s[p];
                if (qn(c, f.range)) {
                    if (!1 === u.overlap) return !1;
                    if (h && !h(new Di(t, a[f.defId], f), null)) return !1
                }
            }
            for (var m = 0, _ = u.allows; m < _.length; m++) {
                var g = _[m], y = o(o({}, n), l);
                if (!g(_i(y, t), null)) return !1
            }
            return !0
        }(e, t, n, i))
    }

    function da(e, t, n, i, r) {
        for (var o = 0, a = e; o < a.length; o++) {
            if (!fa(ha(a[o], t, n, i, r), t)) return !1
        }
        return !0
    }

    function ha(e, t, n, i, r) {
        return "businessHours" === e ? pa(Yt(i, t, r)) : "string" == typeof e ? pa(Dn(n, (function (t) {
            return t.groupId === e
        }))) : "object" == typeof e && e ? pa(Yt(e, t, r)) : []
    }

    function pa(e) {
        var t = e.instances, n = [];
        for (var i in t) n.push(t[i].range);
        return n
    }

    function fa(e, t) {
        for (var n = 0, i = e; n < i.length; n++) {
            if (Zn(i[n], t)) return !0
        }
        return !1
    }

    var ma = /^(visible|hidden)$/, _a = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.handleEl = function (e) {
                t.el = e, wr(t.props.elRef, e)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = e.liquid, n = e.liquidIsAbsolute, i = t && n, r = ["fc-scroller"];
            return t && (n ? r.push("fc-scroller-liquid-absolute") : r.push("fc-scroller-liquid")), Ee("div", {
                ref: this.handleEl,
                className: r.join(" "),
                style: {
                    overflowX: e.overflowX,
                    overflowY: e.overflowY,
                    left: i && -(e.overcomeLeft || 0) || "",
                    right: i && -(e.overcomeRight || 0) || "",
                    bottom: i && -(e.overcomeBottom || 0) || "",
                    marginLeft: !i && -(e.overcomeLeft || 0) || "",
                    marginRight: !i && -(e.overcomeRight || 0) || "",
                    marginBottom: !i && -(e.overcomeBottom || 0) || "",
                    maxHeight: e.maxHeight || ""
                }
            }, e.children)
        }, t.prototype.needsXScrolling = function () {
            if (ma.test(this.props.overflowX)) return !1;
            for (var e = this.el, t = this.el.getBoundingClientRect().width - this.getYScrollbarWidth(), n = e.children, i = 0; i < n.length; i += 1) {
                if (n[i].getBoundingClientRect().width > t) return !0
            }
            return !1
        }, t.prototype.needsYScrolling = function () {
            if (ma.test(this.props.overflowY)) return !1;
            for (var e = this.el, t = this.el.getBoundingClientRect().height - this.getXScrollbarWidth(), n = e.children, i = 0; i < n.length; i += 1) {
                if (n[i].getBoundingClientRect().height > t) return !0
            }
            return !1
        }, t.prototype.getXScrollbarWidth = function () {
            return ma.test(this.props.overflowX) ? 0 : this.el.offsetHeight - this.el.clientHeight
        }, t.prototype.getYScrollbarWidth = function () {
            return ma.test(this.props.overflowY) ? 0 : this.el.offsetWidth - this.el.clientWidth
        }, t
    }(vr), ga = function () {
        function e(e) {
            var t = this;
            this.masterCallback = e, this.currentMap = {}, this.depths = {}, this.callbackMap = {}, this.handleValue = function (e, n) {
                var i = t, r = i.depths, o = i.currentMap, a = !1, s = !1;
                null !== e ? (a = n in o, o[n] = e, r[n] = (r[n] || 0) + 1, s = !0) : (r[n] -= 1, r[n] || (delete o[n], delete t.callbackMap[n], a = !0)), t.masterCallback && (a && t.masterCallback(null, String(n)), s && t.masterCallback(e, String(n)))
            }
        }

        return e.prototype.createRef = function (e) {
            var t = this, n = this.callbackMap[e];
            return n || (n = this.callbackMap[e] = function (n) {
                t.handleValue(n, String(e))
            }), n
        }, e.prototype.collect = function (e, t, n) {
            return function (e, t, n, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 1);
                var r = [];
                null == n && (n = Object.keys(e).length);
                for (var o = t; o < n; o += i) {
                    var a = e[o];
                    void 0 !== a && r.push(a)
                }
                return r
            }(this.currentMap, e, t, n)
        }, e.prototype.getAll = function () {
            return Ct(this.currentMap)
        }, e
    }();

    function ya(e) {
        for (var t = 0, n = 0, i = function (e, t) {
            for (var n = e instanceof HTMLElement ? [e] : e, i = [], r = 0; r < n.length; r += 1) for (var o = n[r].querySelectorAll(t), a = 0; a < o.length; a += 1) i.push(o[a]);
            return i
        }(e, ".fc-scrollgrid-shrink"); n < i.length; n++) {
            var r = i[n];
            t = Math.max(t, lt(r))
        }
        return Math.ceil(t)
    }

    function va(e, t) {
        return e.liquid && t.liquid
    }

    function xa(e, t) {
        return $t(e, t, At)
    }

    function ba(e, t) {
        for (var n = [], i = 0, r = e; i < r.length; i++) for (var o = r[i], s = o.span || 1, l = 0; l < s; l += 1) n.push(Ee("col", {
            style: {
                width: "shrink" === o.width ? wa(t) : o.width || "",
                minWidth: o.minWidth || ""
            }
        }));
        return Ee.apply(void 0, a(["colgroup", {}], n))
    }

    function wa(e) {
        return null == e ? 4 : e
    }

    function Ma(e, t) {
        var n = ["fc-scrollgrid-section", "fc-scrollgrid-section-" + e.type, e.className];
        return t && e.liquid && null == e.maxHeight && n.push("fc-scrollgrid-section-liquid"), e.isSticky && n.push("fc-scrollgrid-section-sticky"), n
    }

    function Ta(e) {
        return Ee("div", {
            className: "fc-scrollgrid-sticky-shim",
            style: {width: e.clientWidth, minWidth: e.tableMinWidth}
        })
    }

    function ka(e) {
        var t = e.stickyHeaderDates;
        return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t
    }

    function Sa(e) {
        var t = e.stickyFooterScrollbar;
        return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t
    }

    var Da = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.processCols = Xt((function (e) {
                return e
            }), xa), t.renderMicroColGroup = Xt(ba), t.scrollerRefs = new ga, t.scrollerElRefs = new ga(t._handleScrollerEl.bind(t)), t.state = {
                shrinkWidth: null,
                forceYScrollbars: !1,
                scrollerClientWidths: {},
                scrollerClientHeights: {}
            }, t.handleSizing = function () {
                t.setState(o({shrinkWidth: t.computeShrinkWidth()}, t.computeScrollerDims()))
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.state, n = this.context, i = e.sections || [], r = this.processCols(e.cols),
                o = this.renderMicroColGroup(r, t.shrinkWidth), s = function (e, t) {
                    var n = ["fc-scrollgrid", t.theme.getClass("table")];
                    return e && n.push("fc-scrollgrid-liquid"), n
                }(e.liquid, n);
            e.collapsibleWidth && s.push("fc-scrollgrid-collapsible");
            for (var l, c = i.length, u = 0, d = [], h = [], p = []; u < c && "header" === (l = i[u]).type;) d.push(this.renderSection(l, o, !0)), u += 1;
            for (; u < c && "body" === (l = i[u]).type;) h.push(this.renderSection(l, o, !1)), u += 1;
            for (; u < c && "footer" === (l = i[u]).type;) p.push(this.renderSection(l, o, !0)), u += 1;
            var f = !Gi(), m = {role: "rowgroup"};
            return Ee("table", {
                role: "grid",
                className: s.join(" "),
                style: {height: e.height}
            }, Boolean(!f && d.length) && Ee.apply(void 0, a(["thead", m], d)), Boolean(!f && h.length) && Ee.apply(void 0, a(["tbody", m], h)), Boolean(!f && p.length) && Ee.apply(void 0, a(["tfoot", m], p)), f && Ee.apply(void 0, a(a(a(["tbody", m], d), h), p)))
        }, t.prototype.renderSection = function (e, t, n) {
            return "outerContent" in e ? Ee(Ie, {key: e.key}, e.outerContent) : Ee("tr", {
                key: e.key,
                role: "presentation",
                className: Ma(e, this.props.liquid).join(" ")
            }, this.renderChunkTd(e, t, e.chunk, n))
        }, t.prototype.renderChunkTd = function (e, t, n, i) {
            if ("outerContent" in n) return n.outerContent;
            var r = this.props, o = this.state, a = o.forceYScrollbars, s = o.scrollerClientWidths,
                l = o.scrollerClientHeights, c = function (e, t) {
                    return null != t.maxHeight || va(e, t)
                }(r, e), u = va(r, e), d = r.liquid ? a ? "scroll" : c ? "auto" : "hidden" : "visible", h = e.key,
                p = function (e, t, n, i) {
                    var r = n.expandRows;
                    return "function" == typeof t.content ? t.content(n) : Ee("table", {
                        role: "presentation",
                        className: [t.tableClassName, e.syncRowHeights ? "fc-scrollgrid-sync-table" : ""].join(" "),
                        style: {minWidth: n.tableMinWidth, width: n.clientWidth, height: r ? n.clientHeight : ""}
                    }, n.tableColGroupNode, Ee(i ? "thead" : "tbody", {role: "presentation"}, "function" == typeof t.rowContent ? t.rowContent(n) : t.rowContent))
                }(e, n, {
                    tableColGroupNode: t,
                    tableMinWidth: "",
                    clientWidth: r.collapsibleWidth || void 0 === s[h] ? null : s[h],
                    clientHeight: void 0 !== l[h] ? l[h] : null,
                    expandRows: e.expandRows,
                    syncRowHeights: !1,
                    rowSyncHeights: [],
                    reportRowHeightChange: function () {
                    }
                }, i);
            return Ee(i ? "th" : "td", {
                ref: n.elRef,
                role: "presentation"
            }, Ee("div", {className: "fc-scroller-harness" + (u ? " fc-scroller-harness-liquid" : "")}, Ee(_a, {
                ref: this.scrollerRefs.createRef(h),
                elRef: this.scrollerElRefs.createRef(h),
                overflowY: d,
                overflowX: r.liquid ? "hidden" : "visible",
                maxHeight: e.maxHeight,
                liquid: u,
                liquidIsAbsolute: !0
            }, p)))
        }, t.prototype._handleScrollerEl = function (e, t) {
            var n = function (e, t) {
                for (var n = 0, i = e; n < i.length; n++) {
                    var r = i[n];
                    if (r.key === t) return r
                }
                return null
            }(this.props.sections, t);
            n && wr(n.chunk.scrollerElRef, e)
        }, t.prototype.componentDidMount = function () {
            this.handleSizing(), this.context.addResizeHandler(this.handleSizing)
        }, t.prototype.componentDidUpdate = function () {
            this.handleSizing()
        }, t.prototype.componentWillUnmount = function () {
            this.context.removeResizeHandler(this.handleSizing)
        }, t.prototype.computeShrinkWidth = function () {
            return function (e) {
                for (var t = 0, n = e; t < n.length; t++) {
                    if ("shrink" === n[t].width) return !0
                }
                return !1
            }(this.props.cols) ? ya(this.scrollerElRefs.getAll()) : 0
        }, t.prototype.computeScrollerDims = function () {
            var e = rr(), t = this.scrollerRefs, n = this.scrollerElRefs, i = !1, r = {}, o = {};
            for (var a in t.currentMap) {
                var s = t.currentMap[a];
                if (s && s.needsYScrolling()) {
                    i = !0;
                    break
                }
            }
            for (var l = 0, c = this.props.sections; l < c.length; l++) {
                a = c[l].key;
                var u = n.currentMap[a];
                if (u) {
                    var d = u.parentNode;
                    r[a] = Math.floor(d.getBoundingClientRect().width - (i ? e.y : 0)), o[a] = Math.floor(d.getBoundingClientRect().height)
                }
            }
            return {forceYScrollbars: i, scrollerClientWidths: r, scrollerClientHeights: o}
        }, t
    }(vr);
    Da.addStateEquality({scrollerClientWidths: At, scrollerClientHeights: At});
    var La = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.elRef = Ae(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options, i = e.seg, r = i.eventRange, o = r.ui, a = {
                event: new Di(t, r.def, r.instance),
                view: t.viewApi,
                timeText: e.timeText,
                textColor: o.textColor,
                backgroundColor: o.backgroundColor,
                borderColor: o.borderColor,
                isDraggable: !e.disableDragging && ii(i, t),
                isStartResizable: !e.disableResizing && ri(i, t),
                isEndResizable: !e.disableResizing && oi(i),
                isMirror: Boolean(e.isDragging || e.isResizing || e.isDateSelecting),
                isStart: Boolean(i.isStart),
                isEnd: Boolean(i.isEnd),
                isPast: Boolean(e.isPast),
                isFuture: Boolean(e.isFuture),
                isToday: Boolean(e.isToday),
                isSelected: Boolean(e.isSelected),
                isDragging: Boolean(e.isDragging),
                isResizing: Boolean(e.isResizing)
            }, s = function (e) {
                var t = ["fc-event"];
                return e.isMirror && t.push("fc-event-mirror"), e.isDraggable && t.push("fc-event-draggable"), (e.isStartResizable || e.isEndResizable) && t.push("fc-event-resizable"), e.isDragging && t.push("fc-event-dragging"), e.isResizing && t.push("fc-event-resizing"), e.isSelected && t.push("fc-event-selected"), e.isStart && t.push("fc-event-start"), e.isEnd && t.push("fc-event-end"), e.isPast && t.push("fc-event-past"), e.isToday && t.push("fc-event-today"), e.isFuture && t.push("fc-event-future"), t
            }(a).concat(o.classNames);
            return Ee(Lr, {
                hookProps: a,
                classNames: n.eventClassNames,
                content: n.eventContent,
                defaultContent: e.defaultContent,
                didMount: n.eventDidMount,
                willUnmount: n.eventWillUnmount,
                elRef: this.elRef
            }, (function (t, n, i, r) {
                return e.children(t, s.concat(n), i, r, a)
            }))
        }, t.prototype.componentDidMount = function () {
            Jn(this.elRef.current, this.props.seg)
        }, t.prototype.componentDidUpdate = function (e) {
            var t = this.props.seg;
            t !== e.seg && Jn(this.elRef.current, t)
        }, t
    }(vr), Ea = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = e.seg, i = t.options.eventTimeFormat || e.defaultTimeFormat,
                r = ai(n, i, t, e.defaultDisplayEventTime, e.defaultDisplayEventEnd);
            return Ee(La, {
                seg: n,
                timeText: r,
                disableDragging: e.disableDragging,
                disableResizing: e.disableResizing,
                defaultContent: e.defaultContent || Ca,
                isDragging: e.isDragging,
                isResizing: e.isResizing,
                isDateSelecting: e.isDateSelecting,
                isSelected: e.isSelected,
                isPast: e.isPast,
                isFuture: e.isFuture,
                isToday: e.isToday
            }, (function (i, r, a, s, l) {
                return Ee("a", o({
                    className: e.extraClassNames.concat(r).join(" "),
                    style: {borderColor: l.borderColor, backgroundColor: l.backgroundColor},
                    ref: i
                }, ci(n, t)), Ee("div", {
                    className: "fc-event-main",
                    ref: a,
                    style: {color: l.textColor}
                }, s), l.isStartResizable && Ee("div", {className: "fc-event-resizer fc-event-resizer-start"}), l.isEndResizable && Ee("div", {className: "fc-event-resizer fc-event-resizer-end"}))
            }))
        }, t
    }(vr);

    function Ca(e) {
        return Ee("div", {className: "fc-event-main-frame"}, e.timeText && Ee("div", {className: "fc-event-time"}, e.timeText), Ee("div", {className: "fc-event-title-container"}, Ee("div", {className: "fc-event-title fc-sticky"}, e.event.title || Ee(Ie, null, ""))))
    }

    var Aa = function (e) {
        return Ee(_r.Consumer, null, (function (t) {
            var n = t.options, i = {isAxis: e.isAxis, date: t.dateEnv.toDate(e.date), view: t.viewApi};
            return Ee(Lr, {
                hookProps: i,
                classNames: n.nowIndicatorClassNames,
                content: n.nowIndicatorContent,
                didMount: n.nowIndicatorDidMount,
                willUnmount: n.nowIndicatorWillUnmount
            }, e.children)
        }))
    }, Ia = hn({day: "numeric"}), Pa = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options, i = Ra({
                date: e.date,
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                showDayNumber: e.showDayNumber,
                extraProps: e.extraHookProps,
                viewApi: t.viewApi,
                dateEnv: t.dateEnv
            });
            return Ee(Cr, {hookProps: i, content: n.dayCellContent, defaultContent: e.defaultContent}, e.children)
        }, t
    }(vr);

    function Ra(e) {
        var t = e.date, n = e.dateEnv, i = Xi(t, e.todayRange, null, e.dateProfile);
        return o(o(o({
            date: n.toDate(t),
            view: e.viewApi
        }, i), {dayNumberText: e.showDayNumber ? n.format(t, Ia) : ""}), e.extraProps)
    }

    var Ya = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.refineHookProps = Jt(Ra), t.normalizeClassNames = Pr(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options, i = this.refineHookProps({
                    date: e.date,
                    dateProfile: e.dateProfile,
                    todayRange: e.todayRange,
                    showDayNumber: e.showDayNumber,
                    extraProps: e.extraHookProps,
                    viewApi: t.viewApi,
                    dateEnv: t.dateEnv
                }), r = Ji(i, t.theme).concat(i.isDisabled ? [] : this.normalizeClassNames(n.dayCellClassNames, i)),
                o = i.isDisabled ? {} : {"data-date": qt(e.date)};
            return Ee(Ir, {
                hookProps: i,
                didMount: n.dayCellDidMount,
                willUnmount: n.dayCellWillUnmount,
                elRef: e.elRef
            }, (function (t) {
                return e.children(t, r, o, i.isDisabled)
            }))
        }, t
    }(vr);

    function za(e) {
        return Ee("div", {className: "fc-" + e})
    }

    var Oa = function (e) {
        return Ee(La, {
            defaultContent: Fa,
            seg: e.seg,
            timeText: "",
            disableDragging: !0,
            disableResizing: !0,
            isDragging: !1,
            isResizing: !1,
            isDateSelecting: !1,
            isSelected: !1,
            isPast: e.isPast,
            isFuture: e.isFuture,
            isToday: e.isToday
        }, (function (e, t, n, i, r) {
            return Ee("div", {
                ref: e,
                className: ["fc-bg-event"].concat(t).join(" "),
                style: {backgroundColor: r.backgroundColor}
            }, i)
        }))
    };

    function Fa(e) {
        return e.event.title && Ee("div", {className: "fc-event-title"}, e.event.title)
    }

    var Ba = function (e) {
        return Ee(_r.Consumer, null, (function (t) {
            var n = t.dateEnv, i = t.options, r = e.date, o = i.weekNumberFormat || e.defaultFormat,
                a = n.computeWeekNumber(r), s = n.format(r, o);
            return Ee(Lr, {
                hookProps: {num: a, text: s, date: r},
                classNames: i.weekNumberClassNames,
                content: i.weekNumberContent,
                defaultContent: ja,
                didMount: i.weekNumberDidMount,
                willUnmount: i.weekNumberWillUnmount
            }, e.children)
        }))
    };

    function ja(e) {
        return e.text
    }

    var Ha = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.state = {titleId: qe()}, t.handleRootEl = function (e) {
                t.rootEl = e, t.props.elRef && wr(t.props.elRef, e)
            }, t.handleDocumentMouseDown = function (e) {
                var n = We(e);
                t.rootEl.contains(n) || t.handleCloseClick()
            }, t.handleDocumentKeyDown = function (e) {
                "Escape" === e.key && t.handleCloseClick()
            }, t.handleCloseClick = function () {
                var e = t.props.onClose;
                e && e()
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = e.theme, n = e.options, i = this.props, r = this.state,
                a = ["fc-popover", t.getClass("popover")].concat(i.extraClassNames || []);
            return Re(Ee("div", o({
                id: i.id,
                className: a.join(" "),
                "aria-labelledby": r.titleId
            }, i.extraAttrs, {ref: this.handleRootEl}), Ee("div", {className: "fc-popover-header " + t.getClass("popoverHeader")}, Ee("span", {
                className: "fc-popover-title",
                id: r.titleId
            }, i.title), Ee("span", {
                className: "fc-popover-close " + t.getIconClass("close"),
                title: n.closeHint,
                onClick: this.handleCloseClick
            })), Ee("div", {className: "fc-popover-body " + t.getClass("popoverContent")}, i.children)), i.parentEl)
        }, t.prototype.componentDidMount = function () {
            document.addEventListener("mousedown", this.handleDocumentMouseDown), document.addEventListener("keydown", this.handleDocumentKeyDown), this.updateSize()
        }, t.prototype.componentWillUnmount = function () {
            document.removeEventListener("mousedown", this.handleDocumentMouseDown), document.removeEventListener("keydown", this.handleDocumentKeyDown)
        }, t.prototype.updateSize = function () {
            var e = this.context.isRtl, t = this.props, n = t.alignmentEl, i = t.alignGridTop, r = this.rootEl,
                o = function (e) {
                    for (var t = lr(e), n = e.getBoundingClientRect(), i = 0, r = t; i < r.length; i++) {
                        var o = Vi(n, r[i].getBoundingClientRect());
                        if (!o) return null;
                        n = o
                    }
                    return n
                }(n);
            if (o) {
                var a = r.getBoundingClientRect(), s = i ? Be(n, ".fc-scrollgrid").getBoundingClientRect().top : o.top,
                    l = e ? o.right - a.width : o.left;
                s = Math.max(s, 10), l = Math.min(l, document.documentElement.clientWidth - 10 - a.width), l = Math.max(l, 10);
                var c = r.offsetParent.getBoundingClientRect();
                Ne(r, {top: s - c.top, left: l - c.left})
            }
        }, t
    }(vr), Na = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.handleRootEl = function (e) {
                t.rootEl = e, e ? t.context.registerInteractiveComponent(t, {
                    el: e,
                    useEventCenter: !1
                }) : t.context.unregisterInteractiveComponent(t)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = e.options, n = e.dateEnv, i = this.props, r = i.startDate, o = i.todayRange,
                a = i.dateProfile, s = n.format(r, t.dayPopoverFormat);
            return Ee(Ya, {date: r, dateProfile: a, todayRange: o, elRef: this.handleRootEl}, (function (e, t, n) {
                return Ee(Ha, {
                    elRef: e,
                    id: i.id,
                    title: s,
                    extraClassNames: ["fc-more-popover"].concat(t),
                    extraAttrs: n,
                    parentEl: i.parentEl,
                    alignmentEl: i.alignmentEl,
                    alignGridTop: i.alignGridTop,
                    onClose: i.onClose
                }, Ee(Pa, {date: r, dateProfile: a, todayRange: o}, (function (e, t) {
                    return t && Ee("div", {className: "fc-more-popover-misc", ref: e}, t)
                })), i.children)
            }))
        }, t.prototype.queryHit = function (e, t, n, i) {
            var r = this.rootEl, a = this.props;
            return e >= 0 && e < n && t >= 0 && t < i ? {
                dateProfile: a.dateProfile,
                dateSpan: o({allDay: !0, range: {start: a.startDate, end: a.endDate}}, a.extraDateSpan),
                dayEl: r,
                rect: {left: 0, top: 0, right: n, bottom: i},
                layer: 1
            } : null
        }, t
    }(Mr), Ua = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.linkElRef = Ae(), t.state = {isPopoverOpen: !1, popoverId: qe()}, t.handleClick = function (e) {
                var n = t, i = n.props, r = n.context, o = r.options.moreLinkClick, a = Va(i).start;

                function s(e) {
                    var t = e.eventRange, n = t.def, i = t.instance, o = t.range;
                    return {
                        event: new Di(r, n, i),
                        start: r.dateEnv.toDate(o.start),
                        end: r.dateEnv.toDate(o.end),
                        isStart: e.isStart,
                        isEnd: e.isEnd
                    }
                }

                "function" == typeof o && (o = o({
                    date: a,
                    allDay: Boolean(i.allDayDate),
                    allSegs: i.allSegs.map(s),
                    hiddenSegs: i.hiddenSegs.map(s),
                    jsEvent: e,
                    view: r.viewApi
                })), o && "popover" !== o ? "string" == typeof o && r.calendarApi.zoomTo(a, o) : t.setState({isPopoverOpen: !0})
            }, t.handlePopoverClose = function () {
                t.setState({isPopoverOpen: !1})
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = this.state;
            return Ee(_r.Consumer, null, (function (i) {
                var r = i.viewApi, o = i.options, a = i.calendarApi, s = o.moreLinkText, l = t.moreCnt, c = Va(t),
                    u = "function" == typeof s ? s.call(a, l) : "+" + l + " " + s, d = ot(o.moreLinkHint, [l], u),
                    h = {num: l, shortText: "+" + l, text: u, view: r};
                return Ee(Ie, null, Boolean(t.moreCnt) && Ee(Lr, {
                    elRef: e.linkElRef,
                    hookProps: h,
                    classNames: o.moreLinkClassNames,
                    content: o.moreLinkContent,
                    defaultContent: t.defaultContent || Wa,
                    didMount: o.moreLinkDidMount,
                    willUnmount: o.moreLinkWillUnmount
                }, (function (i, r, o, a) {
                    return t.children(i, ["fc-more-link"].concat(r), o, a, e.handleClick, d, n.isPopoverOpen, n.isPopoverOpen ? n.popoverId : "")
                })), n.isPopoverOpen && Ee(Na, {
                    id: n.popoverId,
                    startDate: c.start,
                    endDate: c.end,
                    dateProfile: t.dateProfile,
                    todayRange: t.todayRange,
                    extraDateSpan: t.extraDateSpan,
                    parentEl: e.parentEl,
                    alignmentEl: t.alignmentElRef.current,
                    alignGridTop: t.alignGridTop,
                    onClose: e.handlePopoverClose
                }, t.popoverContent()))
            }))
        }, t.prototype.componentDidMount = function () {
            this.updateParentEl()
        }, t.prototype.componentDidUpdate = function () {
            this.updateParentEl()
        }, t.prototype.updateParentEl = function () {
            this.linkElRef.current && (this.parentEl = Be(this.linkElRef.current, ".fc-view-harness"))
        }, t
    }(vr);

    function Wa(e) {
        return e.text
    }

    function Va(e) {
        if (e.allDayDate) return {start: e.allDayDate, end: dt(e.allDayDate, 1)};
        var t, n = e.hiddenSegs;
        return {start: Ga(n), end: (t = n, t.reduce(Za).eventRange.range.end)}
    }

    function Ga(e) {
        return e.reduce(qa).eventRange.range.start
    }

    function qa(e, t) {
        return e.eventRange.range.start < t.eventRange.range.start ? e : t
    }

    function Za(e, t) {
        return e.eventRange.range.end > t.eventRange.range.end ? e : t
    }

    var $a = function (e) {
        function t(t, n) {
            void 0 === n && (n = {});
            var i = e.call(this) || this;
            return i.isRendering = !1, i.isRendered = !1, i.currentClassNames = [], i.customContentRenderId = 0, i.handleAction = function (e) {
                switch (e.type) {
                    case"SET_EVENT_DRAG":
                    case"SET_EVENT_RESIZE":
                        i.renderRunner.tryDrain()
                }
            }, i.handleData = function (e) {
                i.currentData = e, i.renderRunner.request(e.calendarOptions.rerenderDelay)
            }, i.handleRenderRequest = function () {
                if (i.isRendering) {
                    i.isRendered = !0;
                    var e = i.currentData;
                    Ce(Ee(Zo, {options: e.calendarOptions, theme: e.theme, emitter: e.emitter}, (function (t, n, r, a) {
                        return i.setClassNames(t), i.setHeight(n), Ee(Er.Provider, {value: i.customContentRenderId}, Ee(Vo, o({
                            isHeightAuto: r,
                            forPrint: a
                        }, e)))
                    })), i.el)
                } else i.isRendered && (i.isRendered = !1, ze(i.el), i.setClassNames([]), i.setHeight(""));
                Ye()
            }, i.el = t, i.renderRunner = new ho(i.handleRenderRequest), new mo({
                optionOverrides: n,
                calendarApi: i,
                onAction: i.handleAction,
                onData: i.handleData
            }), i
        }

        return r(t, e), Object.defineProperty(t.prototype, "view", {
            get: function () {
                return this.currentData.viewApi
            }, enumerable: !1, configurable: !0
        }), t.prototype.render = function () {
            var e = this.isRendering;
            e ? this.customContentRenderId += 1 : this.isRendering = !0, this.renderRunner.request(), e && this.updateSize()
        }, t.prototype.destroy = function () {
            this.isRendering && (this.isRendering = !1, this.renderRunner.request())
        }, t.prototype.updateSize = function () {
            e.prototype.updateSize.call(this), Ye()
        }, t.prototype.batchRendering = function (e) {
            this.renderRunner.pause("batchRendering"), e(), this.renderRunner.resume("batchRendering")
        }, t.prototype.pauseRendering = function () {
            this.renderRunner.pause("pauseRendering")
        }, t.prototype.resumeRendering = function () {
            this.renderRunner.resume("pauseRendering", !0)
        }, t.prototype.resetOptions = function (e, t) {
            this.currentDataManager.resetOptions(e, t)
        }, t.prototype.setClassNames = function (e) {
            if (!$t(e, this.currentClassNames)) {
                for (var t = this.el.classList, n = 0, i = this.currentClassNames; n < i.length; n++) {
                    var r = i[n];
                    t.remove(r)
                }
                for (var o = 0, a = e; o < a.length; o++) {
                    r = a[o];
                    t.add(r)
                }
                this.currentClassNames = e
            }
        }, t.prototype.setHeight = function (e) {
            Ue(this.el, "height", e)
        }, t
    }(Si);
    /*!
FullCalendar v5.10.1
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/
    /*!
FullCalendar v5.10.1
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/
    Oo.touchMouseIgnoreWait = 500;
    var Xa = 0, Ja = 0, Ka = !1, Qa = function () {
        function e(e) {
            var t = this;
            this.subjectEl = null, this.selector = "", this.handleSelector = "", this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = function (e) {
                if (!t.shouldIgnoreMouse() && function (e) {
                    return 0 === e.button && !e.ctrlKey
                }(e) && t.tryStart(e)) {
                    var n = t.createEventFromMouse(e, !0);
                    t.emitter.trigger("pointerdown", n), t.initScrollWatch(n), t.shouldIgnoreMove || document.addEventListener("mousemove", t.handleMouseMove), document.addEventListener("mouseup", t.handleMouseUp)
                }
            }, this.handleMouseMove = function (e) {
                var n = t.createEventFromMouse(e);
                t.recordCoords(n), t.emitter.trigger("pointermove", n)
            }, this.handleMouseUp = function (e) {
                document.removeEventListener("mousemove", t.handleMouseMove), document.removeEventListener("mouseup", t.handleMouseUp), t.emitter.trigger("pointerup", t.createEventFromMouse(e)), t.cleanup()
            }, this.handleTouchStart = function (e) {
                if (t.tryStart(e)) {
                    t.isTouchDragging = !0;
                    var n = t.createEventFromTouch(e, !0);
                    t.emitter.trigger("pointerdown", n), t.initScrollWatch(n);
                    var i = e.target;
                    t.shouldIgnoreMove || i.addEventListener("touchmove", t.handleTouchMove), i.addEventListener("touchend", t.handleTouchEnd), i.addEventListener("touchcancel", t.handleTouchEnd), window.addEventListener("scroll", t.handleTouchScroll, !0)
                }
            }, this.handleTouchMove = function (e) {
                var n = t.createEventFromTouch(e);
                t.recordCoords(n), t.emitter.trigger("pointermove", n)
            }, this.handleTouchEnd = function (e) {
                if (t.isDragging) {
                    var n = e.target;
                    n.removeEventListener("touchmove", t.handleTouchMove), n.removeEventListener("touchend", t.handleTouchEnd), n.removeEventListener("touchcancel", t.handleTouchEnd), window.removeEventListener("scroll", t.handleTouchScroll, !0), t.emitter.trigger("pointerup", t.createEventFromTouch(e)), t.cleanup(), t.isTouchDragging = !1, Xa += 1, setTimeout((function () {
                        Xa -= 1
                    }), Oo.touchMouseIgnoreWait)
                }
            }, this.handleTouchScroll = function () {
                t.wasTouchScroll = !0
            }, this.handleScroll = function (e) {
                if (!t.shouldIgnoreMove) {
                    var n = window.pageXOffset - t.prevScrollX + t.prevPageX,
                        i = window.pageYOffset - t.prevScrollY + t.prevPageY;
                    t.emitter.trigger("pointermove", {
                        origEvent: e,
                        isTouch: t.isTouchDragging,
                        subjectEl: t.subjectEl,
                        pageX: n,
                        pageY: i,
                        deltaX: n - t.origPageX,
                        deltaY: i - t.origPageY
                    })
                }
            }, this.containerEl = e, this.emitter = new cr, e.addEventListener("mousedown", this.handleMouseDown), e.addEventListener("touchstart", this.handleTouchStart, {passive: !0}), 1 === (Ja += 1) && window.addEventListener("touchmove", es, {passive: !1})
        }

        return e.prototype.destroy = function () {
            this.containerEl.removeEventListener("mousedown", this.handleMouseDown), this.containerEl.removeEventListener("touchstart", this.handleTouchStart, {passive: !0}), (Ja -= 1) || window.removeEventListener("touchmove", es, {passive: !1})
        }, e.prototype.tryStart = function (e) {
            var t = this.querySubjectEl(e), n = e.target;
            return !(!t || this.handleSelector && !Be(n, this.handleSelector)) && (this.subjectEl = t, this.isDragging = !0, this.wasTouchScroll = !1, !0)
        }, e.prototype.cleanup = function () {
            Ka = !1, this.isDragging = !1, this.subjectEl = null, this.destroyScrollWatch()
        }, e.prototype.querySubjectEl = function (e) {
            return this.selector ? Be(e.target, this.selector) : this.containerEl
        }, e.prototype.shouldIgnoreMouse = function () {
            return Xa || this.isTouchDragging
        }, e.prototype.cancelTouchScroll = function () {
            this.isDragging && (Ka = !0)
        }, e.prototype.initScrollWatch = function (e) {
            this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener("scroll", this.handleScroll, !0))
        }, e.prototype.recordCoords = function (e) {
            this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.pageXOffset, this.prevScrollY = window.pageYOffset)
        }, e.prototype.destroyScrollWatch = function () {
            this.shouldWatchScroll && window.removeEventListener("scroll", this.handleScroll, !0)
        }, e.prototype.createEventFromMouse = function (e, t) {
            var n = 0, i = 0;
            return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (n = e.pageX - this.origPageX, i = e.pageY - this.origPageY), {
                origEvent: e,
                isTouch: !1,
                subjectEl: this.subjectEl,
                pageX: e.pageX,
                pageY: e.pageY,
                deltaX: n,
                deltaY: i
            }
        }, e.prototype.createEventFromTouch = function (e, t) {
            var n, i, r = e.touches, o = 0, a = 0;
            return r && r.length ? (n = r[0].pageX, i = r[0].pageY) : (n = e.pageX, i = e.pageY), t ? (this.origPageX = n, this.origPageY = i) : (o = n - this.origPageX, a = i - this.origPageY), {
                origEvent: e,
                isTouch: !0,
                subjectEl: this.subjectEl,
                pageX: n,
                pageY: i,
                deltaX: o,
                deltaY: a
            }
        }, e
    }();

    function es(e) {
        Ka && e.preventDefault()
    }

    var ts = function () {
        function e() {
            this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0
        }

        return e.prototype.start = function (e, t, n) {
            this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.pageXOffset, this.origScreenY = n - window.pageYOffset, this.deltaX = 0, this.deltaY = 0, this.updateElPosition()
        }, e.prototype.handleMove = function (e, t) {
            this.deltaX = e - window.pageXOffset - this.origScreenX, this.deltaY = t - window.pageYOffset - this.origScreenY, this.updateElPosition()
        }, e.prototype.setIsVisible = function (e) {
            e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ""), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = "none"), this.isVisible = e)
        }, e.prototype.stop = function (e, t) {
            var n = this, i = function () {
                n.cleanup(), t()
            };
            e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(i, this.revertDuration) : setTimeout(i, 0)
        }, e.prototype.doRevertAnimation = function (e, t) {
            var n = this.mirrorEl, i = this.sourceEl.getBoundingClientRect();
            n.style.transition = "top " + t + "ms,left " + t + "ms", Ne(n, {
                left: i.left,
                top: i.top
            }), function (e, t) {
                var n = function (i) {
                    t(i), Xe.forEach((function (t) {
                        e.removeEventListener(t, n)
                    }))
                };
                Xe.forEach((function (t) {
                    e.addEventListener(t, n)
                }))
            }(n, (function () {
                n.style.transition = "", e()
            }))
        }, e.prototype.cleanup = function () {
            this.mirrorEl && (Fe(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null
        }, e.prototype.updateElPosition = function () {
            this.sourceEl && this.isVisible && Ne(this.getMirrorEl(), {
                left: this.sourceElRect.left + this.deltaX,
                top: this.sourceElRect.top + this.deltaY
            })
        }, e.prototype.getMirrorEl = function () {
            var e = this.sourceElRect, t = this.mirrorEl;
            return t || ((t = this.mirrorEl = this.sourceEl.cloneNode(!0)).classList.add("fc-unselectable"), t.classList.add("fc-event-dragging"), Ne(t, {
                position: "fixed",
                zIndex: this.zIndex,
                visibility: "",
                boxSizing: "border-box",
                width: e.right - e.left,
                height: e.bottom - e.top,
                right: "auto",
                bottom: "auto",
                margin: 0
            }), this.parentNode.appendChild(t)), t
        }, e
    }(), ns = function (e) {
        function t(t, n) {
            var i = e.call(this) || this;
            return i.handleScroll = function () {
                i.scrollTop = i.scrollController.getScrollTop(), i.scrollLeft = i.scrollController.getScrollLeft(), i.handleScrollChange()
            }, i.scrollController = t, i.doesListening = n, i.scrollTop = i.origScrollTop = t.getScrollTop(), i.scrollLeft = i.origScrollLeft = t.getScrollLeft(), i.scrollWidth = t.getScrollWidth(), i.scrollHeight = t.getScrollHeight(), i.clientWidth = t.getClientWidth(), i.clientHeight = t.getClientHeight(), i.clientRect = i.computeClientRect(), i.doesListening && i.getEventTarget().addEventListener("scroll", i.handleScroll), i
        }

        return r(t, e), t.prototype.destroy = function () {
            this.doesListening && this.getEventTarget().removeEventListener("scroll", this.handleScroll)
        }, t.prototype.getScrollTop = function () {
            return this.scrollTop
        }, t.prototype.getScrollLeft = function () {
            return this.scrollLeft
        }, t.prototype.setScrollTop = function (e) {
            this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange())
        }, t.prototype.setScrollLeft = function (e) {
            this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange())
        }, t.prototype.getClientWidth = function () {
            return this.clientWidth
        }, t.prototype.getClientHeight = function () {
            return this.clientHeight
        }, t.prototype.getScrollWidth = function () {
            return this.scrollWidth
        }, t.prototype.getScrollHeight = function () {
            return this.scrollHeight
        }, t.prototype.handleScrollChange = function () {
        }, t
    }(dr), is = function (e) {
        function t(t, n) {
            return e.call(this, new hr(t), n) || this
        }

        return r(t, e), t.prototype.getEventTarget = function () {
            return this.scrollController.el
        }, t.prototype.computeClientRect = function () {
            return ar(this.scrollController.el)
        }, t
    }(ns), rs = function (e) {
        function t(t) {
            return e.call(this, new pr, t) || this
        }

        return r(t, e), t.prototype.getEventTarget = function () {
            return window
        }, t.prototype.computeClientRect = function () {
            return {
                left: this.scrollLeft,
                right: this.scrollLeft + this.clientWidth,
                top: this.scrollTop,
                bottom: this.scrollTop + this.clientHeight
            }
        }, t.prototype.handleScrollChange = function () {
            this.clientRect = this.computeClientRect()
        }, t
    }(ns), os = "function" == typeof performance ? performance.now : Date.now, as = function () {
        function e() {
            var e = this;
            this.isEnabled = !0, this.scrollQuery = [window, ".fc-scroller"], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = function () {
                if (e.isAnimating) {
                    var t = e.computeBestEdge(e.pointerScreenX + window.pageXOffset, e.pointerScreenY + window.pageYOffset);
                    if (t) {
                        var n = os();
                        e.handleSide(t, (n - e.msSinceRequest) / 1e3), e.requestAnimation(n)
                    } else e.isAnimating = !1
                }
            }
        }

        return e.prototype.start = function (e, t, n) {
            this.isEnabled && (this.scrollCaches = this.buildCaches(n), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t))
        }, e.prototype.handleMove = function (e, t) {
            if (this.isEnabled) {
                var n = e - window.pageXOffset, i = t - window.pageYOffset,
                    r = null === this.pointerScreenY ? 0 : i - this.pointerScreenY,
                    o = null === this.pointerScreenX ? 0 : n - this.pointerScreenX;
                r < 0 ? this.everMovedUp = !0 : r > 0 && (this.everMovedDown = !0), o < 0 ? this.everMovedLeft = !0 : o > 0 && (this.everMovedRight = !0), this.pointerScreenX = n, this.pointerScreenY = i, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(os()))
            }
        }, e.prototype.stop = function () {
            if (this.isEnabled) {
                this.isAnimating = !1;
                for (var e = 0, t = this.scrollCaches; e < t.length; e++) {
                    t[e].destroy()
                }
                this.scrollCaches = null
            }
        }, e.prototype.requestAnimation = function (e) {
            this.msSinceRequest = e, requestAnimationFrame(this.animate)
        }, e.prototype.handleSide = function (e, t) {
            var n = e.scrollCache, i = this.edgeThreshold, r = i - e.distance,
                o = r * r / (i * i) * this.maxVelocity * t, a = 1;
            switch (e.name) {
                case"left":
                    a = -1;
                case"right":
                    n.setScrollLeft(n.getScrollLeft() + o * a);
                    break;
                case"top":
                    a = -1;
                case"bottom":
                    n.setScrollTop(n.getScrollTop() + o * a)
            }
        }, e.prototype.computeBestEdge = function (e, t) {
            for (var n = this.edgeThreshold, i = null, r = 0, o = this.scrollCaches; r < o.length; r++) {
                var a = o[r], s = a.clientRect, l = e - s.left, c = s.right - e, u = t - s.top, d = s.bottom - t;
                l >= 0 && c >= 0 && u >= 0 && d >= 0 && (u <= n && this.everMovedUp && a.canScrollUp() && (!i || i.distance > u) && (i = {
                    scrollCache: a,
                    name: "top",
                    distance: u
                }), d <= n && this.everMovedDown && a.canScrollDown() && (!i || i.distance > d) && (i = {
                    scrollCache: a,
                    name: "bottom",
                    distance: d
                }), l <= n && this.everMovedLeft && a.canScrollLeft() && (!i || i.distance > l) && (i = {
                    scrollCache: a,
                    name: "left",
                    distance: l
                }), c <= n && this.everMovedRight && a.canScrollRight() && (!i || i.distance > c) && (i = {
                    scrollCache: a,
                    name: "right",
                    distance: c
                }))
            }
            return i
        }, e.prototype.buildCaches = function (e) {
            return this.queryScrollEls(e).map((function (e) {
                return e === window ? new rs(!1) : new is(e, !1)
            }))
        }, e.prototype.queryScrollEls = function (e) {
            for (var t = [], n = 0, i = this.scrollQuery; n < i.length; n++) {
                var r = i[n];
                "object" == typeof r ? t.push(r) : t.push.apply(t, Array.prototype.slice.call(Ve(e).querySelectorAll(r)))
            }
            return t
        }, e
    }(), ss = function (e) {
        function t(t, n) {
            var i = e.call(this, t) || this;
            i.containerEl = t, i.delay = null, i.minDistance = 0, i.touchScrollAllowed = !0, i.mirrorNeedsRevert = !1, i.isInteracting = !1, i.isDragging = !1, i.isDelayEnded = !1, i.isDistanceSurpassed = !1, i.delayTimeoutId = null, i.onPointerDown = function (e) {
                var t;
                i.isDragging || (i.isInteracting = !0, i.isDelayEnded = !1, i.isDistanceSurpassed = !1, (t = document.body).classList.add("fc-unselectable"), t.addEventListener("selectstart", Ze), function (e) {
                    e.addEventListener("contextmenu", Ze)
                }(document.body), e.isTouch || e.origEvent.preventDefault(), i.emitter.trigger("pointerdown", e), i.isInteracting && !i.pointer.shouldIgnoreMove && (i.mirror.setIsVisible(!1), i.mirror.start(e.subjectEl, e.pageX, e.pageY), i.startDelay(e), i.minDistance || i.handleDistanceSurpassed(e)))
            }, i.onPointerMove = function (e) {
                if (i.isInteracting) {
                    if (i.emitter.trigger("pointermove", e), !i.isDistanceSurpassed) {
                        var t = i.minDistance, n = e.deltaX, r = e.deltaY;
                        n * n + r * r >= t * t && i.handleDistanceSurpassed(e)
                    }
                    i.isDragging && ("scroll" !== e.origEvent.type && (i.mirror.handleMove(e.pageX, e.pageY), i.autoScroller.handleMove(e.pageX, e.pageY)), i.emitter.trigger("dragmove", e))
                }
            }, i.onPointerUp = function (e) {
                var t;
                i.isInteracting && (i.isInteracting = !1, (t = document.body).classList.remove("fc-unselectable"), t.removeEventListener("selectstart", Ze), function (e) {
                    e.removeEventListener("contextmenu", Ze)
                }(document.body), i.emitter.trigger("pointerup", e), i.isDragging && (i.autoScroller.stop(), i.tryStopDrag(e)), i.delayTimeoutId && (clearTimeout(i.delayTimeoutId), i.delayTimeoutId = null))
            };
            var r = i.pointer = new Qa(t);
            return r.emitter.on("pointerdown", i.onPointerDown), r.emitter.on("pointermove", i.onPointerMove), r.emitter.on("pointerup", i.onPointerUp), n && (r.selector = n), i.mirror = new ts, i.autoScroller = new as, i
        }

        return r(t, e), t.prototype.destroy = function () {
            this.pointer.destroy(), this.onPointerUp({})
        }, t.prototype.startDelay = function (e) {
            var t = this;
            "number" == typeof this.delay ? this.delayTimeoutId = setTimeout((function () {
                t.delayTimeoutId = null, t.handleDelayEnd(e)
            }), this.delay) : this.handleDelayEnd(e)
        }, t.prototype.handleDelayEnd = function (e) {
            this.isDelayEnded = !0, this.tryStartDrag(e)
        }, t.prototype.handleDistanceSurpassed = function (e) {
            this.isDistanceSurpassed = !0, this.tryStartDrag(e)
        }, t.prototype.tryStartDrag = function (e) {
            this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY, this.containerEl), this.emitter.trigger("dragstart", e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll()))
        }, t.prototype.tryStopDrag = function (e) {
            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e))
        }, t.prototype.stopDrag = function (e) {
            this.isDragging = !1, this.emitter.trigger("dragend", e)
        }, t.prototype.setIgnoreMove = function (e) {
            this.pointer.shouldIgnoreMove = e
        }, t.prototype.setMirrorIsVisible = function (e) {
            this.mirror.setIsVisible(e)
        }, t.prototype.setMirrorNeedsRevert = function (e) {
            this.mirrorNeedsRevert = e
        }, t.prototype.setAutoScrollEnabled = function (e) {
            this.autoScroller.isEnabled = e
        }, t
    }(zo), ls = function () {
        function e(e) {
            this.origRect = sr(e), this.scrollCaches = lr(e).map((function (e) {
                return new is(e, !0)
            }))
        }

        return e.prototype.destroy = function () {
            for (var e = 0, t = this.scrollCaches; e < t.length; e++) {
                t[e].destroy()
            }
        }, e.prototype.computeLeft = function () {
            for (var e = this.origRect.left, t = 0, n = this.scrollCaches; t < n.length; t++) {
                var i = n[t];
                e += i.origScrollLeft - i.getScrollLeft()
            }
            return e
        }, e.prototype.computeTop = function () {
            for (var e = this.origRect.top, t = 0, n = this.scrollCaches; t < n.length; t++) {
                var i = n[t];
                e += i.origScrollTop - i.getScrollTop()
            }
            return e
        }, e.prototype.isWithinClipping = function (e, t) {
            for (var n, i, r = {left: e, top: t}, o = 0, a = this.scrollCaches; o < a.length; o++) {
                var s = a[o];
                if (n = s.getEventTarget(), i = void 0, "HTML" !== (i = n.tagName) && "BODY" !== i && !Wi(r, s.clientRect)) return !1
            }
            return !0
        }, e
    }();
    var cs = function () {
        function e(e, t) {
            var n = this;
            this.useSubjectCenter = !1, this.requireInitial = !0, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = function (e) {
                var t = n.dragging;
                n.initialHit = null, n.movingHit = null, n.finalHit = null, n.prepareHits(), n.processFirstCoord(e), n.initialHit || !n.requireInitial ? (t.setIgnoreMove(!1), n.emitter.trigger("pointerdown", e)) : t.setIgnoreMove(!0)
            }, this.handleDragStart = function (e) {
                n.emitter.trigger("dragstart", e), n.handleMove(e, !0)
            }, this.handleDragMove = function (e) {
                n.emitter.trigger("dragmove", e), n.handleMove(e)
            }, this.handlePointerUp = function (e) {
                n.releaseHits(), n.emitter.trigger("pointerup", e)
            }, this.handleDragEnd = function (e) {
                n.movingHit && n.emitter.trigger("hitupdate", null, !0, e), n.finalHit = n.movingHit, n.movingHit = null, n.emitter.trigger("dragend", e)
            }, this.droppableStore = t, e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragstart", this.handleDragStart), e.emitter.on("dragmove", this.handleDragMove), e.emitter.on("pointerup", this.handlePointerUp), e.emitter.on("dragend", this.handleDragEnd), this.dragging = e, this.emitter = new cr
        }

        return e.prototype.processFirstCoord = function (e) {
            var t, n, i, r = {left: e.pageX, top: e.pageY}, o = r, a = e.subjectEl;
            a instanceof HTMLElement && (t = sr(a), n = o, i = t, o = {
                left: Math.min(Math.max(n.left, i.left), i.right),
                top: Math.min(Math.max(n.top, i.top), i.bottom)
            });
            var s, l, c = this.initialHit = this.queryHitForOffset(o.left, o.top);
            if (c) {
                if (this.useSubjectCenter && t) {
                    var u = Vi(t, c.rect);
                    u && (o = function (e) {
                        return {left: (e.left + e.right) / 2, top: (e.top + e.bottom) / 2}
                    }(u))
                }
                this.coordAdjust = (l = r, {left: (s = o).left - l.left, top: s.top - l.top})
            } else this.coordAdjust = {left: 0, top: 0}
        }, e.prototype.handleMove = function (e, t) {
            var n = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top);
            !t && us(this.movingHit, n) || (this.movingHit = n, this.emitter.trigger("hitupdate", n, !1, e))
        }, e.prototype.prepareHits = function () {
            this.offsetTrackers = Lt(this.droppableStore, (function (e) {
                return e.component.prepareHits(), new ls(e.el)
            }))
        }, e.prototype.releaseHits = function () {
            var e = this.offsetTrackers;
            for (var t in e) e[t].destroy();
            this.offsetTrackers = {}
        }, e.prototype.queryHitForOffset = function (e, t) {
            var n = this.droppableStore, i = this.offsetTrackers, r = null;
            for (var o in n) {
                var a = n[o].component, s = i[o];
                if (s && s.isWithinClipping(e, t)) {
                    var l = s.computeLeft(), c = s.computeTop(), u = e - l, d = t - c, h = s.origRect,
                        p = h.right - h.left, f = h.bottom - h.top;
                    if (u >= 0 && u < p && d >= 0 && d < f) {
                        var m = a.queryHit(u, d, p, f);
                        m && Zn(m.dateProfile.activeRange, m.dateSpan.range) && (!r || m.layer > r.layer) && (m.componentId = o, m.context = a.context, m.rect.left += l, m.rect.right += l, m.rect.top += c, m.rect.bottom += c, r = m)
                    }
                }
            }
            return r
        }, e
    }();

    function us(e, t) {
        return !e && !t || Boolean(e) === Boolean(t) && (n = e.dateSpan, i = t.dateSpan, r = n.range, o = i.range, (null === r.start ? null : r.start.valueOf()) === (null === o.start ? null : o.start.valueOf()) && (null === r.end ? null : r.end.valueOf()) === (null === o.end ? null : o.end.valueOf()) && n.allDay === i.allDay && function (e, t) {
            for (var n in t) if ("range" !== n && "allDay" !== n && e[n] !== t[n]) return !1;
            for (var n in e) if (!(n in t)) return !1;
            return !0
        }(n, i));
        var n, i, r, o
    }

    function ds(e, t) {
        for (var n, i, r = {}, a = 0, s = t.pluginHooks.datePointTransforms; a < s.length; a++) {
            var l = s[a];
            o(r, l(e, t))
        }
        return o(r, (n = e, {
            date: (i = t.dateEnv).toDate(n.range.start),
            dateStr: i.formatIso(n.range.start, {omitTime: n.allDay}),
            allDay: n.allDay
        })), r
    }

    var hs = function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            n.handlePointerDown = function (e) {
                var t = n.dragging, i = e.origEvent.target;
                t.setIgnoreMove(!n.component.isValidDateDownEl(i))
            }, n.handleDragEnd = function (e) {
                var t = n.component;
                if (!n.dragging.pointer.wasTouchScroll) {
                    var i = n.hitDragging, r = i.initialHit, a = i.finalHit;
                    if (r && a && us(r, a)) {
                        var s = t.context, l = o(o({}, ds(r.dateSpan, s)), {
                            dayEl: r.dayEl,
                            jsEvent: e.origEvent,
                            view: s.viewApi || s.calendarApi.view
                        });
                        s.emitter.trigger("dateClick", l)
                    }
                }
            }, n.dragging = new ss(t.el), n.dragging.autoScroller.isEnabled = !1;
            var i = n.hitDragging = new cs(n.dragging, Ro(t));
            return i.emitter.on("pointerdown", n.handlePointerDown), i.emitter.on("dragend", n.handleDragEnd), n
        }

        return r(t, e), t.prototype.destroy = function () {
            this.dragging.destroy()
        }, t
    }(Io), ps = function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            n.dragSelection = null, n.handlePointerDown = function (e) {
                var t = n, i = t.component, r = t.dragging,
                    o = i.context.options.selectable && i.isValidDateDownEl(e.origEvent.target);
                r.setIgnoreMove(!o), r.delay = e.isTouch ? function (e) {
                    var t = e.context.options, n = t.selectLongPressDelay;
                    null == n && (n = t.longPressDelay);
                    return n
                }(i) : null
            }, n.handleDragStart = function (e) {
                n.component.context.calendarApi.unselect(e)
            }, n.handleHitUpdate = function (e, t) {
                var i = n.component.context, r = null, a = !1;
                if (e) {
                    var s = n.hitDragging.initialHit;
                    e.componentId === s.componentId && n.isHitComboAllowed && !n.isHitComboAllowed(s, e) || (r = function (e, t, n) {
                        var i = e.dateSpan, r = t.dateSpan,
                            a = [i.range.start, i.range.end, r.range.start, r.range.end];
                        a.sort(at);
                        for (var s = {}, l = 0, c = n; l < c.length; l++) {
                            var u = (0, c[l])(e, t);
                            if (!1 === u) return null;
                            u && o(s, u)
                        }
                        return s.range = {start: a[0], end: a[3]}, s.allDay = i.allDay, s
                    }(s, e, i.pluginHooks.dateSelectionTransformers)), r && function (e, t, n) {
                        return !!Zn(t.validRange, e.range) && ca({dateSelection: e}, n)
                    }(r, e.dateProfile, i) || (a = !0, r = null)
                }
                r ? i.dispatch({
                    type: "SELECT_DATES",
                    selection: r
                }) : t || i.dispatch({type: "UNSELECT_DATES"}), a ? tt() : nt(), t || (n.dragSelection = r)
            }, n.handlePointerUp = function (e) {
                n.dragSelection && (mi(n.dragSelection, e, n.component.context), n.dragSelection = null)
            };
            var i = t.component.context.options, r = n.dragging = new ss(t.el);
            r.touchScrollAllowed = !1, r.minDistance = i.selectMinDistance || 0, r.autoScroller.isEnabled = i.dragScroll;
            var a = n.hitDragging = new cs(n.dragging, Ro(t));
            return a.emitter.on("pointerdown", n.handlePointerDown), a.emitter.on("dragstart", n.handleDragStart), a.emitter.on("hitupdate", n.handleHitUpdate), a.emitter.on("pointerup", n.handlePointerUp), n
        }

        return r(t, e), t.prototype.destroy = function () {
            this.dragging.destroy()
        }, t
    }(Io);
    var fs = function (e) {
        function t(n) {
            var i = e.call(this, n) || this;
            i.subjectEl = null, i.subjectSeg = null, i.isDragging = !1, i.eventRange = null, i.relevantEvents = null, i.receivingContext = null, i.validMutation = null, i.mutatedRelevantEvents = null, i.handlePointerDown = function (e) {
                var t = e.origEvent.target, n = i, r = n.component, o = n.dragging, a = o.mirror, s = r.context.options,
                    l = r.context;
                i.subjectEl = e.subjectEl;
                var c = i.subjectSeg = Kn(e.subjectEl), u = (i.eventRange = c.eventRange).instance.instanceId;
                i.relevantEvents = kn(l.getCurrentData().eventStore, u), o.minDistance = e.isTouch ? 0 : s.eventDragMinDistance, o.delay = e.isTouch && u !== r.props.eventSelection ? function (e) {
                    var t = e.context.options, n = t.eventLongPressDelay;
                    null == n && (n = t.longPressDelay);
                    return n
                }(r) : null, s.fixedMirrorParent ? a.parentNode = s.fixedMirrorParent : a.parentNode = Be(t, ".fc"), a.revertDuration = s.dragRevertDuration;
                var d = r.isValidSegDownEl(t) && !Be(t, ".fc-event-resizer");
                o.setIgnoreMove(!d), i.isDragging = d && e.subjectEl.classList.contains("fc-event-draggable")
            }, i.handleDragStart = function (e) {
                var t = i.component.context, n = i.eventRange, r = n.instance.instanceId;
                e.isTouch ? r !== i.component.props.eventSelection && t.dispatch({
                    type: "SELECT_EVENT",
                    eventInstanceId: r
                }) : t.dispatch({type: "UNSELECT_EVENT"}), i.isDragging && (t.calendarApi.unselect(e), t.emitter.trigger("eventDragStart", {
                    el: i.subjectEl,
                    event: new Di(t, n.def, n.instance),
                    jsEvent: e.origEvent,
                    view: t.viewApi
                }))
            }, i.handleHitUpdate = function (e, t) {
                if (i.isDragging) {
                    var n = i.relevantEvents, r = i.hitDragging.initialHit, o = i.component.context, a = null, s = null,
                        l = null, c = !1,
                        u = {affectedEvents: n, mutatedEvents: {defs: {}, instances: {}}, isEvent: !0};
                    if (e) {
                        var d = (a = e.context).options;
                        o === a || d.editable && d.droppable ? (s = function (e, t, n) {
                            var i = e.dateSpan, r = t.dateSpan, o = i.range.start, a = r.range.start, s = {};
                            i.allDay !== r.allDay && (s.allDay = r.allDay, s.hasEnd = t.context.options.allDayMaintainDuration, r.allDay && (o = mt(o)));
                            var l = Un(o, a, e.context.dateEnv, e.componentId === t.componentId ? e.largeUnit : null);
                            l.milliseconds && (s.allDay = !1);
                            for (var c = {datesDelta: l, standardProps: s}, u = 0, d = n; u < d.length; u++) {
                                (0, d[u])(c, e, t)
                            }
                            return c
                        }(r, e, a.getCurrentData().pluginHooks.eventDragMutationMassagers)) && (l = yi(n, a.getCurrentData().eventUiBases, s, a), u.mutatedEvents = l, la(u, e.dateProfile, a) || (c = !0, s = null, l = null, u.mutatedEvents = {
                            defs: {},
                            instances: {}
                        })) : a = null
                    }
                    i.displayDrag(a, u), c ? tt() : nt(), t || (o === a && us(r, e) && (s = null), i.dragging.setMirrorNeedsRevert(!s), i.dragging.setMirrorIsVisible(!e || !Ve(i.subjectEl).querySelector(".fc-event-mirror")), i.receivingContext = a, i.validMutation = s, i.mutatedRelevantEvents = l)
                }
            }, i.handlePointerUp = function () {
                i.isDragging || i.cleanup()
            }, i.handleDragEnd = function (e) {
                if (i.isDragging) {
                    var t = i.component.context, n = t.viewApi, r = i, a = r.receivingContext, s = r.validMutation,
                        l = i.eventRange.def, c = i.eventRange.instance, u = new Di(t, l, c), d = i.relevantEvents,
                        h = i.mutatedRelevantEvents, p = i.hitDragging.finalHit;
                    if (i.clearDrag(), t.emitter.trigger("eventDragStop", {
                        el: i.subjectEl,
                        event: u,
                        jsEvent: e.origEvent,
                        view: n
                    }), s) {
                        if (a === t) {
                            var f = new Di(t, h.defs[l.defId], c ? h.instances[c.instanceId] : null);
                            t.dispatch({type: "MERGE_EVENTS", eventStore: h});
                            for (var m = {
                                oldEvent: u, event: f, relatedEvents: Ei(h, t, c), revert: function () {
                                    t.dispatch({type: "MERGE_EVENTS", eventStore: d})
                                }
                            }, _ = {}, g = 0, y = t.getCurrentData().pluginHooks.eventDropTransformers; g < y.length; g++) {
                                var v = y[g];
                                o(_, v(s, t))
                            }
                            t.emitter.trigger("eventDrop", o(o(o({}, m), _), {
                                el: e.subjectEl,
                                delta: s.datesDelta,
                                jsEvent: e.origEvent,
                                view: n
                            })), t.emitter.trigger("eventChange", m)
                        } else if (a) {
                            var x = {
                                event: u, relatedEvents: Ei(d, t, c), revert: function () {
                                    t.dispatch({type: "MERGE_EVENTS", eventStore: d})
                                }
                            };
                            t.emitter.trigger("eventLeave", o(o({}, x), {
                                draggedEl: e.subjectEl,
                                view: n
                            })), t.dispatch({
                                type: "REMOVE_EVENTS",
                                eventStore: d
                            }), t.emitter.trigger("eventRemove", x);
                            var b = h.defs[l.defId], w = h.instances[c.instanceId], M = new Di(a, b, w);
                            a.dispatch({type: "MERGE_EVENTS", eventStore: h});
                            var T = {
                                event: M, relatedEvents: Ei(h, a, w), revert: function () {
                                    a.dispatch({type: "REMOVE_EVENTS", eventStore: h})
                                }
                            };
                            a.emitter.trigger("eventAdd", T), e.isTouch && a.dispatch({
                                type: "SELECT_EVENT",
                                eventInstanceId: c.instanceId
                            }), a.emitter.trigger("drop", o(o({}, ds(p.dateSpan, a)), {
                                draggedEl: e.subjectEl,
                                jsEvent: e.origEvent,
                                view: p.context.viewApi
                            })), a.emitter.trigger("eventReceive", o(o({}, T), {
                                draggedEl: e.subjectEl,
                                view: p.context.viewApi
                            }))
                        }
                    } else t.emitter.trigger("_noEventDrop")
                }
                i.cleanup()
            };
            var r = i.component.context.options, a = i.dragging = new ss(n.el);
            a.pointer.selector = t.SELECTOR, a.touchScrollAllowed = !1, a.autoScroller.isEnabled = r.dragScroll;
            var s = i.hitDragging = new cs(i.dragging, Yo);
            return s.useSubjectCenter = n.useEventCenter, s.emitter.on("pointerdown", i.handlePointerDown), s.emitter.on("dragstart", i.handleDragStart), s.emitter.on("hitupdate", i.handleHitUpdate), s.emitter.on("pointerup", i.handlePointerUp), s.emitter.on("dragend", i.handleDragEnd), i
        }

        return r(t, e), t.prototype.destroy = function () {
            this.dragging.destroy()
        }, t.prototype.displayDrag = function (e, t) {
            var n = this.component.context, i = this.receivingContext;
            i && i !== e && (i === n ? i.dispatch({
                type: "SET_EVENT_DRAG",
                state: {affectedEvents: t.affectedEvents, mutatedEvents: {defs: {}, instances: {}}, isEvent: !0}
            }) : i.dispatch({type: "UNSET_EVENT_DRAG"})), e && e.dispatch({type: "SET_EVENT_DRAG", state: t})
        }, t.prototype.clearDrag = function () {
            var e = this.component.context, t = this.receivingContext;
            t && t.dispatch({type: "UNSET_EVENT_DRAG"}), e !== t && e.dispatch({type: "UNSET_EVENT_DRAG"})
        }, t.prototype.cleanup = function () {
            this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null
        }, t.SELECTOR = ".fc-event-draggable, .fc-event-resizable", t
    }(Io);
    var ms = function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            n.draggingSegEl = null, n.draggingSeg = null, n.eventRange = null, n.relevantEvents = null, n.validMutation = null, n.mutatedRelevantEvents = null, n.handlePointerDown = function (e) {
                var t = n.component, i = Kn(n.querySegEl(e)), r = n.eventRange = i.eventRange;
                n.dragging.minDistance = t.context.options.eventDragMinDistance, n.dragging.setIgnoreMove(!n.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && n.component.props.eventSelection !== r.instance.instanceId)
            }, n.handleDragStart = function (e) {
                var t = n.component.context, i = n.eventRange;
                n.relevantEvents = kn(t.getCurrentData().eventStore, n.eventRange.instance.instanceId);
                var r = n.querySegEl(e);
                n.draggingSegEl = r, n.draggingSeg = Kn(r), t.calendarApi.unselect(), t.emitter.trigger("eventResizeStart", {
                    el: r,
                    event: new Di(t, i.def, i.instance),
                    jsEvent: e.origEvent,
                    view: t.viewApi
                })
            }, n.handleHitUpdate = function (e, t, i) {
                var r = n.component.context, o = n.relevantEvents, a = n.hitDragging.initialHit,
                    s = n.eventRange.instance, l = null, c = null, u = !1,
                    d = {affectedEvents: o, mutatedEvents: {defs: {}, instances: {}}, isEvent: !0};
                e && (e.componentId === a.componentId && n.isHitComboAllowed && !n.isHitComboAllowed(a, e) || (l = function (e, t, n, i) {
                    var r = e.context.dateEnv, o = e.dateSpan.range.start, a = t.dateSpan.range.start,
                        s = Un(o, a, r, e.largeUnit);
                    if (n) {
                        if (r.add(i.start, s) < i.end) return {startDelta: s}
                    } else if (r.add(i.end, s) > i.start) return {endDelta: s};
                    return null
                }(a, e, i.subjectEl.classList.contains("fc-event-resizer-start"), s.range)));
                l && (c = yi(o, r.getCurrentData().eventUiBases, l, r), d.mutatedEvents = c, la(d, e.dateProfile, r) || (u = !0, l = null, c = null, d.mutatedEvents = null)), c ? r.dispatch({
                    type: "SET_EVENT_RESIZE",
                    state: d
                }) : r.dispatch({type: "UNSET_EVENT_RESIZE"}), u ? tt() : nt(), t || (l && us(a, e) && (l = null), n.validMutation = l, n.mutatedRelevantEvents = c)
            }, n.handleDragEnd = function (e) {
                var t = n.component.context, i = n.eventRange.def, r = n.eventRange.instance, a = new Di(t, i, r),
                    s = n.relevantEvents, l = n.mutatedRelevantEvents;
                if (t.emitter.trigger("eventResizeStop", {
                    el: n.draggingSegEl,
                    event: a,
                    jsEvent: e.origEvent,
                    view: t.viewApi
                }), n.validMutation) {
                    var c = new Di(t, l.defs[i.defId], r ? l.instances[r.instanceId] : null);
                    t.dispatch({type: "MERGE_EVENTS", eventStore: l});
                    var u = {
                        oldEvent: a, event: c, relatedEvents: Ei(l, t, r), revert: function () {
                            t.dispatch({type: "MERGE_EVENTS", eventStore: s})
                        }
                    };
                    t.emitter.trigger("eventResize", o(o({}, u), {
                        el: n.draggingSegEl,
                        startDelta: n.validMutation.startDelta || Bt(0),
                        endDelta: n.validMutation.endDelta || Bt(0),
                        jsEvent: e.origEvent,
                        view: t.viewApi
                    })), t.emitter.trigger("eventChange", u)
                } else t.emitter.trigger("_noEventResize");
                n.draggingSeg = null, n.relevantEvents = null, n.validMutation = null
            };
            var i = t.component, r = n.dragging = new ss(t.el);
            r.pointer.selector = ".fc-event-resizer", r.touchScrollAllowed = !1, r.autoScroller.isEnabled = i.context.options.dragScroll;
            var a = n.hitDragging = new cs(n.dragging, Ro(t));
            return a.emitter.on("pointerdown", n.handlePointerDown), a.emitter.on("dragstart", n.handleDragStart), a.emitter.on("hitupdate", n.handleHitUpdate), a.emitter.on("dragend", n.handleDragEnd), n
        }

        return r(t, e), t.prototype.destroy = function () {
            this.dragging.destroy()
        }, t.prototype.querySegEl = function (e) {
            return Be(e.subjectEl, ".fc-event")
        }, t
    }(Io);
    var _s = function () {
        function e(e) {
            var t = this;
            this.context = e, this.isRecentPointerDateSelect = !1, this.matchesCancel = !1, this.matchesEvent = !1, this.onSelect = function (e) {
                e.jsEvent && (t.isRecentPointerDateSelect = !0)
            }, this.onDocumentPointerDown = function (e) {
                var n = t.context.options.unselectCancel, i = We(e.origEvent);
                t.matchesCancel = !!Be(i, n), t.matchesEvent = !!Be(i, fs.SELECTOR)
            }, this.onDocumentPointerUp = function (e) {
                var n = t.context, i = t.documentPointer, r = n.getCurrentData();
                if (!i.wasTouchScroll) {
                    if (r.dateSelection && !t.isRecentPointerDateSelect) {
                        var o = n.options.unselectAuto;
                        !o || o && t.matchesCancel || n.calendarApi.unselect(e)
                    }
                    r.eventSelection && !t.matchesEvent && n.dispatch({type: "UNSELECT_EVENT"})
                }
                t.isRecentPointerDateSelect = !1
            };
            var n = this.documentPointer = new Qa(document);
            n.shouldIgnoreMove = !0, n.shouldWatchScroll = !1, n.emitter.on("pointerdown", this.onDocumentPointerDown), n.emitter.on("pointerup", this.onDocumentPointerUp), e.emitter.on("select", this.onSelect)
        }

        return e.prototype.destroy = function () {
            this.context.emitter.off("select", this.onSelect), this.documentPointer.destroy()
        }, e
    }(), gs = {fixedMirrorParent: wn}, ys = {
        dateClick: wn,
        eventDragStart: wn,
        eventDragStop: wn,
        eventDrop: wn,
        eventResizeStart: wn,
        eventResizeStop: wn,
        eventResize: wn,
        drop: wn,
        eventReceive: wn,
        eventLeave: wn
    }, vs = function () {
        function e(e, t) {
            var n = this;
            this.receivingContext = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = function (e) {
                n.dragMeta = n.buildDragMeta(e.subjectEl)
            }, this.handleHitUpdate = function (e, t, i) {
                var r = n.hitDragging.dragging, a = null, s = null, l = !1, c = {
                    affectedEvents: {defs: {}, instances: {}},
                    mutatedEvents: {defs: {}, instances: {}},
                    isEvent: n.dragMeta.create
                };
                e && (a = e.context, n.canDropElOnCalendar(i.subjectEl, a) && (s = function (e, t, n) {
                    for (var i = o({}, t.leftoverProps), r = 0, a = n.pluginHooks.externalDefTransforms; r < a.length; r++) {
                        var s = a[r];
                        o(i, s(e, t))
                    }
                    var l = Fn(i, n), c = l.refined, u = l.extra,
                        d = jn(c, u, t.sourceId, e.allDay, n.options.forceEventDuration || Boolean(t.duration), n),
                        h = e.range.start;
                    e.allDay && t.startTime && (h = n.dateEnv.add(h, t.startTime));
                    var p = t.duration ? n.dateEnv.add(h, t.duration) : gi(e.allDay, h, n),
                        f = Tt(d.defId, {start: h, end: p});
                    return {def: d, instance: f}
                }(e.dateSpan, n.dragMeta, a), c.mutatedEvents = Tn(s), (l = !la(c, e.dateProfile, a)) && (c.mutatedEvents = {
                    defs: {},
                    instances: {}
                }, s = null))), n.displayDrag(a, c), r.setMirrorIsVisible(t || !s || !document.querySelector(".fc-event-mirror")), l ? tt() : nt(), t || (r.setMirrorNeedsRevert(!s), n.receivingContext = a, n.droppableEvent = s)
            }, this.handleDragEnd = function (e) {
                var t = n, i = t.receivingContext, r = t.droppableEvent;
                if (n.clearDrag(), i && r) {
                    var a = n.hitDragging.finalHit, s = a.context.viewApi, l = n.dragMeta;
                    if (i.emitter.trigger("drop", o(o({}, ds(a.dateSpan, i)), {
                        draggedEl: e.subjectEl,
                        jsEvent: e.origEvent,
                        view: s
                    })), l.create) {
                        var c = Tn(r);
                        i.dispatch({
                            type: "MERGE_EVENTS",
                            eventStore: c
                        }), e.isTouch && i.dispatch({
                            type: "SELECT_EVENT",
                            eventInstanceId: r.instance.instanceId
                        }), i.emitter.trigger("eventReceive", {
                            event: new Di(i, r.def, r.instance),
                            relatedEvents: [],
                            revert: function () {
                                i.dispatch({type: "REMOVE_EVENTS", eventStore: c})
                            },
                            draggedEl: e.subjectEl,
                            view: s
                        })
                    }
                }
                n.receivingContext = null, n.droppableEvent = null
            };
            var i = this.hitDragging = new cs(e, Yo);
            i.requireInitial = !1, i.emitter.on("dragstart", this.handleDragStart), i.emitter.on("hitupdate", this.handleHitUpdate), i.emitter.on("dragend", this.handleDragEnd), this.suppliedDragMeta = t
        }

        return e.prototype.buildDragMeta = function (e) {
            return "object" == typeof this.suppliedDragMeta ? Bo(this.suppliedDragMeta) : "function" == typeof this.suppliedDragMeta ? Bo(this.suppliedDragMeta(e)) : Bo((t = function (e, t) {
                var n = Oo.dataAttrPrefix, i = (n ? n + "-" : "") + t;
                return e.getAttribute("data-" + i) || ""
            }(e, "event")) ? JSON.parse(t) : {create: !1});
            var t
        }, e.prototype.displayDrag = function (e, t) {
            var n = this.receivingContext;
            n && n !== e && n.dispatch({type: "UNSET_EVENT_DRAG"}), e && e.dispatch({type: "SET_EVENT_DRAG", state: t})
        }, e.prototype.clearDrag = function () {
            this.receivingContext && this.receivingContext.dispatch({type: "UNSET_EVENT_DRAG"})
        }, e.prototype.canDropElOnCalendar = function (e, t) {
            var n = t.options.dropAccept;
            return "function" == typeof n ? n.call(t.calendarApi, e) : "string" != typeof n || !n || Boolean(je(e, n))
        }, e
    }();
    Oo.dataAttrPrefix = "";
    !function () {
        function e(e, t) {
            var n = this;
            void 0 === t && (t = {}), this.handlePointerDown = function (e) {
                var t = n.dragging, i = n.settings, r = i.minDistance, o = i.longPressDelay;
                t.minDistance = null != r ? r : e.isTouch ? 0 : fn.eventDragMinDistance, t.delay = e.isTouch ? null != o ? o : fn.longPressDelay : 0
            }, this.handleDragStart = function (e) {
                e.isTouch && n.dragging.delay && e.subjectEl.classList.contains("fc-event") && n.dragging.mirror.getMirrorEl().classList.add("fc-event-selected")
            }, this.settings = t;
            var i = this.dragging = new ss(e);
            i.touchScrollAllowed = !1, null != t.itemSelector && (i.pointer.selector = t.itemSelector), null != t.appendTo && (i.mirror.parentNode = t.appendTo), i.emitter.on("pointerdown", this.handlePointerDown), i.emitter.on("dragstart", this.handleDragStart), new vs(i, t.eventData)
        }

        e.prototype.destroy = function () {
            this.dragging.destroy()
        }
    }();
    var xs = function (e) {
        function t(t) {
            var n = e.call(this, t) || this;
            n.shouldIgnoreMove = !1, n.mirrorSelector = "", n.currentMirrorEl = null, n.handlePointerDown = function (e) {
                n.emitter.trigger("pointerdown", e), n.shouldIgnoreMove || n.emitter.trigger("dragstart", e)
            }, n.handlePointerMove = function (e) {
                n.shouldIgnoreMove || n.emitter.trigger("dragmove", e)
            }, n.handlePointerUp = function (e) {
                n.emitter.trigger("pointerup", e), n.shouldIgnoreMove || n.emitter.trigger("dragend", e)
            };
            var i = n.pointer = new Qa(t);
            return i.emitter.on("pointerdown", n.handlePointerDown), i.emitter.on("pointermove", n.handlePointerMove), i.emitter.on("pointerup", n.handlePointerUp), n
        }

        return r(t, e), t.prototype.destroy = function () {
            this.pointer.destroy()
        }, t.prototype.setIgnoreMove = function (e) {
            this.shouldIgnoreMove = e
        }, t.prototype.setMirrorIsVisible = function (e) {
            if (e) this.currentMirrorEl && (this.currentMirrorEl.style.visibility = "", this.currentMirrorEl = null); else {
                var t = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;
                t && (this.currentMirrorEl = t, t.style.visibility = "hidden")
            }
        }, t
    }(zo), bs = (function () {
        function e(e, t) {
            var n = document;
            e === document || e instanceof Element ? (n = e, t = t || {}) : t = e || {};
            var i = this.dragging = new xs(n);
            "string" == typeof t.itemSelector ? i.pointer.selector = t.itemSelector : n === document && (i.pointer.selector = "[data-event]"), "string" == typeof t.mirrorSelector && (i.mirrorSelector = t.mirrorSelector), new vs(i, t.eventData)
        }

        e.prototype.destroy = function () {
            this.dragging.destroy()
        }
    }(), Tr({
        componentInteractions: [hs, ps, fs, ms],
        calendarInteractions: [_s],
        elementDraggingImpl: ss,
        optionRefiners: gs,
        listenerRefiners: ys
    })), ws = (n(174), function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.headerElRef = Ae(), t
        }

        return r(t, e), t.prototype.renderSimpleLayout = function (e, t) {
            var n = this.props, i = this.context, r = [], o = ka(i.options);
            return e && r.push({
                type: "header",
                key: "header",
                isSticky: o,
                chunk: {elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e}
            }), r.push({
                type: "body",
                key: "body",
                liquid: !0,
                chunk: {content: t}
            }), Ee(zr, {viewSpec: i.viewSpec}, (function (e, t) {
                return Ee("div", {
                    ref: e,
                    className: ["fc-daygrid"].concat(t).join(" ")
                }, Ee(Da, {
                    liquid: !n.isHeightAuto && !n.forPrint,
                    collapsibleWidth: n.forPrint,
                    cols: [],
                    sections: r
                }))
            }))
        }, t.prototype.renderHScrollLayout = function (e, t, n, i) {
            var r = this.context.pluginHooks.scrollGridImpl;
            if (!r) throw new Error("No ScrollGrid implementation");
            var o = this.props, a = this.context, s = !o.forPrint && ka(a.options), l = !o.forPrint && Sa(a.options),
                c = [];
            return e && c.push({
                type: "header",
                key: "header",
                isSticky: s,
                chunks: [{key: "main", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e}]
            }), c.push({
                type: "body",
                key: "body",
                liquid: !0,
                chunks: [{key: "main", content: t}]
            }), l && c.push({
                type: "footer",
                key: "footer",
                isSticky: !0,
                chunks: [{key: "main", content: Ta}]
            }), Ee(zr, {viewSpec: a.viewSpec}, (function (e, t) {
                return Ee("div", {
                    ref: e,
                    className: ["fc-daygrid"].concat(t).join(" ")
                }, Ee(r, {
                    liquid: !o.isHeightAuto && !o.forPrint,
                    collapsibleWidth: o.forPrint,
                    colGroups: [{cols: [{span: n, minWidth: i}]}],
                    sections: c
                }))
            }))
        }, t
    }(Mr));

    function Ms(e, t) {
        for (var n = [], i = 0; i < t; i += 1) n[i] = [];
        for (var r = 0, o = e; r < o.length; r++) {
            var a = o[r];
            n[a.row].push(a)
        }
        return n
    }

    function Ts(e, t) {
        for (var n = [], i = 0; i < t; i += 1) n[i] = [];
        for (var r = 0, o = e; r < o.length; r++) {
            var a = o[r];
            n[a.firstCol].push(a)
        }
        return n
    }

    function ks(e, t) {
        var n = [];
        if (e) {
            for (a = 0; a < t; a += 1) n[a] = {affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: []};
            for (var i = 0, r = e.segs; i < r.length; i++) {
                var o = r[i];
                n[o.row].segs.push(o)
            }
        } else for (var a = 0; a < t; a += 1) n[a] = null;
        return n
    }

    var Ss = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = er(this.context, e.date);
            return Ee(Pa, {
                date: e.date,
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                showDayNumber: e.showDayNumber,
                extraHookProps: e.extraHookProps,
                defaultContent: Ds
            }, (function (n, i) {
                return (i || e.forceDayTop) && Ee("div", {
                    className: "fc-daygrid-day-top",
                    ref: n
                }, Ee("a", o({id: e.dayNumberId, className: "fc-daygrid-day-number"}, t), i || Ee(Ie, null, "")))
            }))
        }, t
    }(vr);

    function Ds(e) {
        return e.dayNumberText
    }

    var Ls = hn({hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "narrow"});

    function Es(e) {
        var t = e.eventRange.ui.display;
        return "list-item" === t || "auto" === t && !e.eventRange.def.allDay && e.firstCol === e.lastCol && e.isStart && e.isEnd
    }

    var Cs = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props;
            return Ee(Ea, o({}, e, {
                extraClassNames: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"],
                defaultTimeFormat: Ls,
                defaultDisplayEventEnd: e.defaultDisplayEventEnd,
                disableResizing: !e.seg.eventRange.def.allDay
            }))
        }, t
    }(vr), As = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options.eventTimeFormat || Ls,
                i = ai(e.seg, n, t, !0, e.defaultDisplayEventEnd);
            return Ee(La, {
                seg: e.seg,
                timeText: i,
                defaultContent: Is,
                isDragging: e.isDragging,
                isResizing: !1,
                isDateSelecting: !1,
                isSelected: e.isSelected,
                isPast: e.isPast,
                isFuture: e.isFuture,
                isToday: e.isToday
            }, (function (n, i, r, a) {
                return Ee("a", o({
                    className: ["fc-daygrid-event", "fc-daygrid-dot-event"].concat(i).join(" "),
                    ref: n
                }, ci(e.seg, t)), a)
            }))
        }, t
    }(vr);

    function Is(e) {
        return Ee(Ie, null, Ee("div", {
            className: "fc-daygrid-event-dot",
            style: {borderColor: e.borderColor || e.backgroundColor}
        }), e.timeText && Ee("div", {className: "fc-event-time"}, e.timeText), Ee("div", {className: "fc-event-title"}, e.event.title || Ee(Ie, null, "")))
    }

    var Ps = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.compileSegs = Xt(Rs), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.compileSegs(e.singlePlacements), n = t.allSegs, i = t.invisibleSegs;
            return Ee(Ua, {
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                allDayDate: e.allDayDate,
                moreCnt: e.moreCnt,
                allSegs: n,
                hiddenSegs: i,
                alignmentElRef: e.alignmentElRef,
                alignGridTop: e.alignGridTop,
                extraDateSpan: e.extraDateSpan,
                popoverContent: function () {
                    var t = (e.eventDrag ? e.eventDrag.affectedInstances : null) || (e.eventResize ? e.eventResize.affectedInstances : null) || {};
                    return Ee(Ie, null, n.map((function (n) {
                        var i = n.eventRange.instance.instanceId;
                        return Ee("div", {
                            className: "fc-daygrid-event-harness",
                            key: i,
                            style: {visibility: t[i] ? "hidden" : ""}
                        }, Es(n) ? Ee(As, o({
                            seg: n,
                            isDragging: !1,
                            isSelected: i === e.eventSelection,
                            defaultDisplayEventEnd: !1
                        }, si(n, e.todayRange))) : Ee(Cs, o({
                            seg: n,
                            isDragging: !1,
                            isResizing: !1,
                            isDateSelecting: !1,
                            isSelected: i === e.eventSelection,
                            defaultDisplayEventEnd: !1
                        }, si(n, e.todayRange))))
                    })))
                }
            }, (function (e, t, n, i, r, a, s, l) {
                return Ee("a", o({
                    ref: e,
                    className: ["fc-daygrid-more-link"].concat(t).join(" "),
                    title: a,
                    "aria-expanded": s,
                    "aria-controls": l
                }, Je(r)), i)
            }))
        }, t
    }(vr);

    function Rs(e) {
        for (var t = [], n = [], i = 0, r = e; i < r.length; i++) {
            var o = r[i];
            t.push(o.seg), o.isVisible || n.push(o.seg)
        }
        return {allSegs: t, invisibleSegs: n}
    }

    var Ys = hn({week: "narrow"}), zs = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.rootElRef = Ae(), t.state = {dayNumberId: qe()}, t.handleRootEl = function (e) {
                wr(t.rootElRef, e), wr(t.props.elRef, e)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = this.props, n = this.state, i = this.rootElRef, r = t.date, a = t.dateProfile,
                s = er(e, r, "week");
            return Ee(Ya, {
                date: r,
                dateProfile: a,
                todayRange: t.todayRange,
                showDayNumber: t.showDayNumber,
                extraHookProps: t.extraHookProps,
                elRef: this.handleRootEl
            }, (function (e, l, c, u) {
                return Ee("td", o({
                    ref: e,
                    role: "gridcell",
                    className: ["fc-daygrid-day"].concat(l, t.extraClassNames || []).join(" ")
                }, c, t.extraDataAttrs, t.showDayNumber ? {"aria-labelledby": n.dayNumberId} : {}), Ee("div", {
                    className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
                    ref: t.innerElRef
                }, t.showWeekNumber && Ee(Ba, {date: r, defaultFormat: Ys}, (function (e, t, n, i) {
                    return Ee("a", o({ref: e, className: ["fc-daygrid-week-number"].concat(t).join(" ")}, s), i)
                })), !u && Ee(Ss, {
                    date: r,
                    dateProfile: a,
                    showDayNumber: t.showDayNumber,
                    dayNumberId: n.dayNumberId,
                    forceDayTop: t.forceDayTop,
                    todayRange: t.todayRange,
                    extraHookProps: t.extraHookProps
                }), Ee("div", {
                    className: "fc-daygrid-day-events",
                    ref: t.fgContentElRef
                }, t.fgContent, Ee("div", {
                    className: "fc-daygrid-day-bottom",
                    style: {marginTop: t.moreMarginTop}
                }, Ee(Ps, {
                    allDayDate: r,
                    singlePlacements: t.singlePlacements,
                    moreCnt: t.moreCnt,
                    alignmentElRef: i,
                    alignGridTop: !t.showDayNumber,
                    extraDateSpan: t.extraDateSpan,
                    dateProfile: t.dateProfile,
                    eventSelection: t.eventSelection,
                    eventDrag: t.eventDrag,
                    eventResize: t.eventResize,
                    todayRange: t.todayRange
                }))), Ee("div", {className: "fc-daygrid-day-bg"}, t.bgContent)))
            }))
        }, t
    }(Mr);

    function Os(e, t, n, i, r, o, a) {
        var s = new Bs;
        s.allowReslicing = !0, s.strictOrder = i, !0 === t || !0 === n ? (s.maxCoord = o, s.hiddenConsumes = !0) : "number" == typeof t ? s.maxStackCnt = t : "number" == typeof n && (s.maxStackCnt = n, s.hiddenConsumes = !0);
        for (var l = [], c = [], u = 0; u < e.length; u += 1) {
            var d = r[(k = e[u]).eventRange.instance.instanceId];
            null != d ? l.push({index: u, thickness: d, span: {start: k.firstCol, end: k.lastCol + 1}}) : c.push(k)
        }
        for (var h = s.addSegs(l), p = function (e, t, n) {
            for (var i = function (e, t) {
                for (var n = [], i = 0; i < t; i += 1) n.push([]);
                for (var r = 0, o = e; r < o.length; r++) {
                    var a = o[r];
                    for (i = a.span.start; i < a.span.end; i += 1) n[i].push(a)
                }
                return n
            }(e, n.length), r = [], o = [], a = [], s = 0; s < n.length; s += 1) {
                for (var l = i[s], c = [], u = 0, d = 0, h = 0, p = l; h < p.length; h++) {
                    var f = p[h], m = t[f.index];
                    c.push({
                        seg: Fs(m, s, s + 1, n),
                        isVisible: !0,
                        isAbsolute: !1,
                        absoluteTop: f.levelCoord,
                        marginTop: f.levelCoord - u
                    }), u = f.levelCoord + f.thickness
                }
                var _ = [];
                u = 0, d = 0;
                for (var g = 0, y = l; g < y.length; g++) {
                    f = y[g], m = t[f.index];
                    var v = f.span.end - f.span.start > 1, x = f.span.start === s;
                    d += f.levelCoord - u, u = f.levelCoord + f.thickness, v ? (d += f.thickness, x && _.push({
                        seg: Fs(m, f.span.start, f.span.end, n),
                        isVisible: !0,
                        isAbsolute: !0,
                        absoluteTop: f.levelCoord,
                        marginTop: 0
                    })) : x && (_.push({
                        seg: Fs(m, f.span.start, f.span.end, n),
                        isVisible: !0,
                        isAbsolute: !1,
                        absoluteTop: f.levelCoord,
                        marginTop: d
                    }), d = 0)
                }
                r.push(c), o.push(_), a.push(d)
            }
            return {singleColPlacements: r, multiColPlacements: o, leftoverMargins: a}
        }(s.toRects(), e, a), f = p.singleColPlacements, m = p.multiColPlacements, _ = p.leftoverMargins, g = [], y = [], v = 0, x = c; v < x.length; v++) {
            m[(k = x[v]).firstCol].push({seg: k, isVisible: !1, isAbsolute: !0, absoluteTop: 0, marginTop: 0});
            for (var b = k.firstCol; b <= k.lastCol; b += 1) f[b].push({
                seg: Fs(k, b, b + 1, a),
                isVisible: !1,
                isAbsolute: !1,
                absoluteTop: 0,
                marginTop: 0
            })
        }
        for (b = 0; b < a.length; b += 1) g.push(0);
        for (var w = 0, M = h; w < M.length; w++) {
            var T = M[w], k = e[T.index], S = T.span;
            m[S.start].push({
                seg: Fs(k, S.start, S.end, a),
                isVisible: !1,
                isAbsolute: !0,
                absoluteTop: 0,
                marginTop: 0
            });
            for (b = S.start; b < S.end; b += 1) g[b] += 1, f[b].push({
                seg: Fs(k, b, b + 1, a),
                isVisible: !1,
                isAbsolute: !1,
                absoluteTop: 0,
                marginTop: 0
            })
        }
        for (b = 0; b < a.length; b += 1) y.push(_[b]);
        return {singleColPlacements: f, multiColPlacements: m, moreCnts: g, moreMarginTops: y}
    }

    function Fs(e, t, n, i) {
        if (e.firstCol === t && e.lastCol === n - 1) return e;
        var r = e.eventRange, a = r.range, s = Gn(a, {start: i[t].date, end: dt(i[n - 1].date, 1)});
        return o(o({}, e), {
            firstCol: t,
            lastCol: n - 1,
            eventRange: {def: r.def, ui: o(o({}, r.ui), {durationEditable: !1}), instance: r.instance, range: s},
            isStart: e.isStart && s.start.valueOf() === a.start.valueOf(),
            isEnd: e.isEnd && s.end.valueOf() === a.end.valueOf()
        })
    }

    var Bs = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.hiddenConsumes = !1, t.forceHidden = {}, t
        }

        return r(t, e), t.prototype.addSegs = function (t) {
            for (var n = this, i = e.prototype.addSegs.call(this, t), r = this.entriesByLevel, o = function (e) {
                return !n.forceHidden[Lo(e)]
            }, a = 0; a < r.length; a += 1) r[a] = r[a].filter(o);
            return i
        }, t.prototype.handleInvalidInsertion = function (t, n, i) {
            var r = this.entriesByLevel, a = this.forceHidden, s = t.touchingEntry, l = t.touchingLevel,
                c = t.touchingLateral;
            if (this.hiddenConsumes && s) {
                var u = Lo(s);
                if (!a[u]) if (this.allowReslicing) {
                    var d = o(o({}, s), {span: Eo(s.span, n.span)});
                    a[Lo(d)] = !0, r[l][c] = d, this.splitEntry(s, n, i)
                } else a[u] = !0, i.push(s)
            }
            return e.prototype.handleInvalidInsertion.call(this, t, n, i)
        }, t
    }(So), js = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.cellElRefs = new ga, t.frameElRefs = new ga, t.fgElRefs = new ga, t.segHarnessRefs = new ga, t.rootElRef = Ae(), t.state = {
                framePositions: null,
                maxContentHeight: null,
                eventInstanceHeights: {}
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = this.state, i = this.context.options, r = t.cells.length,
                o = Ts(t.businessHourSegs, r), a = Ts(t.bgEventSegs, r), s = Ts(this.getHighlightSegs(), r),
                l = Ts(this.getMirrorSegs(), r),
                c = Os(ti(t.fgEventSegs, i.eventOrder), t.dayMaxEvents, t.dayMaxEventRows, i.eventOrderStrict, n.eventInstanceHeights, n.maxContentHeight, t.cells),
                u = c.singleColPlacements, d = c.multiColPlacements, h = c.moreCnts, p = c.moreMarginTops,
                f = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {};
            return Ee("tr", {
                ref: this.rootElRef,
                role: "row"
            }, t.renderIntro && t.renderIntro(), t.cells.map((function (n, i) {
                var r = e.renderFgSegs(i, t.forPrint ? u[i] : d[i], t.todayRange, f),
                    c = e.renderFgSegs(i, function (e, t) {
                        if (!e.length) return [];
                        var n = function (e) {
                            for (var t = {}, n = 0, i = e; n < i.length; n++) for (var r = i[n], o = 0, a = r; o < a.length; o++) {
                                var s = a[o];
                                t[s.seg.eventRange.instance.instanceId] = s.absoluteTop
                            }
                            return t
                        }(t);
                        return e.map((function (e) {
                            return {
                                seg: e,
                                isVisible: !0,
                                isAbsolute: !0,
                                absoluteTop: n[e.eventRange.instance.instanceId],
                                marginTop: 0
                            }
                        }))
                    }(l[i], d), t.todayRange, {}, Boolean(t.eventDrag), Boolean(t.eventResize), !1);
                return Ee(zs, {
                    key: n.key,
                    elRef: e.cellElRefs.createRef(n.key),
                    innerElRef: e.frameElRefs.createRef(n.key),
                    dateProfile: t.dateProfile,
                    date: n.date,
                    showDayNumber: t.showDayNumbers,
                    showWeekNumber: t.showWeekNumbers && 0 === i,
                    forceDayTop: t.showWeekNumbers,
                    todayRange: t.todayRange,
                    eventSelection: t.eventSelection,
                    eventDrag: t.eventDrag,
                    eventResize: t.eventResize,
                    extraHookProps: n.extraHookProps,
                    extraDataAttrs: n.extraDataAttrs,
                    extraClassNames: n.extraClassNames,
                    extraDateSpan: n.extraDateSpan,
                    moreCnt: h[i],
                    moreMarginTop: p[i],
                    singlePlacements: u[i],
                    fgContentElRef: e.fgElRefs.createRef(n.key),
                    fgContent: Ee(Ie, null, Ee(Ie, null, r), Ee(Ie, null, c)),
                    bgContent: Ee(Ie, null, e.renderFillSegs(s[i], "highlight"), e.renderFillSegs(o[i], "non-business"), e.renderFillSegs(a[i], "bg-event"))
                })
            })))
        }, t.prototype.componentDidMount = function () {
            this.updateSizing(!0)
        }, t.prototype.componentDidUpdate = function (e, t) {
            var n = this.props;
            this.updateSizing(!At(e, n))
        }, t.prototype.getHighlightSegs = function () {
            var e = this.props;
            return e.eventDrag && e.eventDrag.segs.length ? e.eventDrag.segs : e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : e.dateSelectionSegs
        }, t.prototype.getMirrorSegs = function () {
            var e = this.props;
            return e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : []
        }, t.prototype.renderFgSegs = function (e, t, n, i, r, a, s) {
            var l = this.context, c = this.props.eventSelection, u = this.state.framePositions,
                d = 1 === this.props.cells.length, h = r || a || s, p = [];
            if (u) for (var f = 0, m = t; f < m.length; f++) {
                var _ = m[f], g = _.seg, y = g.eventRange.instance.instanceId, v = y + ":" + e,
                    x = _.isVisible && !i[y], b = _.isAbsolute, w = "", M = "";
                b && (l.isRtl ? (M = 0, w = u.lefts[g.lastCol] - u.lefts[g.firstCol]) : (w = 0, M = u.rights[g.firstCol] - u.rights[g.lastCol])), p.push(Ee("div", {
                    className: "fc-daygrid-event-harness" + (b ? " fc-daygrid-event-harness-abs" : ""),
                    key: v,
                    ref: h ? null : this.segHarnessRefs.createRef(v),
                    style: {
                        visibility: x ? "" : "hidden",
                        marginTop: b ? "" : _.marginTop,
                        top: b ? _.absoluteTop : "",
                        left: w,
                        right: M
                    }
                }, Es(g) ? Ee(As, o({
                    seg: g,
                    isDragging: r,
                    isSelected: y === c,
                    defaultDisplayEventEnd: d
                }, si(g, n))) : Ee(Cs, o({
                    seg: g,
                    isDragging: r,
                    isResizing: a,
                    isDateSelecting: s,
                    isSelected: y === c,
                    defaultDisplayEventEnd: d
                }, si(g, n)))))
            }
            return p
        }, t.prototype.renderFillSegs = function (e, t) {
            var n = this.context.isRtl, i = this.props.todayRange, r = this.state.framePositions, s = [];
            if (r) for (var l = 0, c = e; l < c.length; l++) {
                var u = c[l], d = n ? {right: 0, left: r.lefts[u.lastCol] - r.lefts[u.firstCol]} : {
                    left: 0,
                    right: r.rights[u.firstCol] - r.rights[u.lastCol]
                };
                s.push(Ee("div", {
                    key: li(u.eventRange),
                    className: "fc-daygrid-bg-harness",
                    style: d
                }, "bg-event" === t ? Ee(Oa, o({seg: u}, si(u, i))) : za(t)))
            }
            return Ee.apply(void 0, a([Ie, {}], s))
        }, t.prototype.updateSizing = function (e) {
            var t = this.props, n = this.frameElRefs;
            if (!t.forPrint && null !== t.clientWidth) {
                if (e) {
                    var i = t.cells.map((function (e) {
                        return n.currentMap[e.key]
                    }));
                    if (i.length) {
                        var r = this.rootElRef.current;
                        this.setState({framePositions: new ur(r, i, !0, !1)})
                    }
                }
                var a = this.state.eventInstanceHeights, s = this.queryEventInstanceHeights(),
                    l = !0 === t.dayMaxEvents || !0 === t.dayMaxEventRows;
                this.setState({
                    eventInstanceHeights: o(o({}, a), s),
                    maxContentHeight: l ? this.computeMaxContentHeight() : null
                })
            }
        }, t.prototype.queryEventInstanceHeights = function () {
            var e = this.segHarnessRefs.currentMap, t = {};
            for (var n in e) {
                var i = Math.round(e[n].getBoundingClientRect().height), r = n.split(":")[0];
                t[r] = Math.max(t[r] || 0, i)
            }
            return t
        }, t.prototype.computeMaxContentHeight = function () {
            var e = this.props.cells[0].key, t = this.cellElRefs.currentMap[e], n = this.fgElRefs.currentMap[e];
            return t.getBoundingClientRect().bottom - n.getBoundingClientRect().top
        }, t.prototype.getCellEls = function () {
            var e = this.cellElRefs.currentMap;
            return this.props.cells.map((function (t) {
                return e[t.key]
            }))
        }, t
    }(Mr);
    js.addStateEquality({eventInstanceHeights: At});
    var Hs = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.splitBusinessHourSegs = Xt(Ms), t.splitBgEventSegs = Xt(Ms), t.splitFgEventSegs = Xt(Ms), t.splitDateSelectionSegs = Xt(Ms), t.splitEventDrag = Xt(ks), t.splitEventResize = Xt(ks), t.rowRefs = new ga, t.handleRootEl = function (e) {
                t.rootEl = e, e ? t.context.registerInteractiveComponent(t, {
                    el: e,
                    isHitComboAllowed: t.props.isHitComboAllowed
                }) : t.context.unregisterInteractiveComponent(t)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = t.dateProfile, i = t.dayMaxEventRows, r = t.dayMaxEvents,
                o = t.expandRows, a = t.cells.length, s = this.splitBusinessHourSegs(t.businessHourSegs, a),
                l = this.splitBgEventSegs(t.bgEventSegs, a), c = this.splitFgEventSegs(t.fgEventSegs, a),
                u = this.splitDateSelectionSegs(t.dateSelectionSegs, a), d = this.splitEventDrag(t.eventDrag, a),
                h = this.splitEventResize(t.eventResize, a), p = !0 === r || !0 === i;
            return p && !o && (p = !1, i = null, r = null), Ee("div", {
                className: ["fc-daygrid-body", p ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced", o ? "" : "fc-daygrid-body-natural"].join(" "),
                ref: this.handleRootEl,
                style: {width: t.clientWidth, minWidth: t.tableMinWidth}
            }, Ee(ea, {unit: "day"}, (function (p, f) {
                return Ee(Ie, null, Ee("table", {
                    role: "presentation",
                    className: "fc-scrollgrid-sync-table",
                    style: {width: t.clientWidth, minWidth: t.tableMinWidth, height: o ? t.clientHeight : ""}
                }, t.colGroupNode, Ee("tbody", {role: "presentation"}, t.cells.map((function (o, p) {
                    return Ee(js, {
                        ref: e.rowRefs.createRef(p),
                        key: o.length ? o[0].date.toISOString() : p,
                        showDayNumbers: a > 1,
                        showWeekNumbers: t.showWeekNumbers,
                        todayRange: f,
                        dateProfile: n,
                        cells: o,
                        renderIntro: t.renderRowIntro,
                        businessHourSegs: s[p],
                        eventSelection: t.eventSelection,
                        bgEventSegs: l[p].filter(Ns),
                        fgEventSegs: c[p],
                        dateSelectionSegs: u[p],
                        eventDrag: d[p],
                        eventResize: h[p],
                        dayMaxEvents: r,
                        dayMaxEventRows: i,
                        clientWidth: t.clientWidth,
                        clientHeight: t.clientHeight,
                        forPrint: t.forPrint
                    })
                })))))
            })))
        }, t.prototype.prepareHits = function () {
            this.rowPositions = new ur(this.rootEl, this.rowRefs.collect().map((function (e) {
                return e.getCellEls()[0]
            })), !1, !0), this.colPositions = new ur(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), !0, !1)
        }, t.prototype.queryHit = function (e, t) {
            var n = this.colPositions, i = this.rowPositions, r = n.leftToIndex(e), a = i.topToIndex(t);
            if (null != a && null != r) {
                var s = this.props.cells[a][r];
                return {
                    dateProfile: this.props.dateProfile,
                    dateSpan: o({range: this.getCellRange(a, r), allDay: !0}, s.extraDateSpan),
                    dayEl: this.getCellEl(a, r),
                    rect: {left: n.lefts[r], right: n.rights[r], top: i.tops[a], bottom: i.bottoms[a]},
                    layer: 0
                }
            }
            return null
        }, t.prototype.getCellEl = function (e, t) {
            return this.rowRefs.currentMap[e].getCellEls()[t]
        }, t.prototype.getCellRange = function (e, t) {
            var n = this.props.cells[e][t].date;
            return {start: n, end: dt(n, 1)}
        }, t
    }(Mr);

    function Ns(e) {
        return e.eventRange.def.allDay
    }

    var Us = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.forceDayIfListItem = !0, t
        }

        return r(t, e), t.prototype.sliceRange = function (e, t) {
            return t.sliceRange(e)
        }, t
    }(aa), Ws = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.slicer = new Us, t.tableRef = Ae(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context;
            return Ee(Hs, o({ref: this.tableRef}, this.slicer.sliceProps(e, e.dateProfile, e.nextDayThreshold, t, e.dayTableModel), {
                dateProfile: e.dateProfile,
                cells: e.dayTableModel.cells,
                colGroupNode: e.colGroupNode,
                tableMinWidth: e.tableMinWidth,
                renderRowIntro: e.renderRowIntro,
                dayMaxEvents: e.dayMaxEvents,
                dayMaxEventRows: e.dayMaxEventRows,
                showWeekNumbers: e.showWeekNumbers,
                expandRows: e.expandRows,
                headerAlignElRef: e.headerAlignElRef,
                clientWidth: e.clientWidth,
                clientHeight: e.clientHeight,
                forPrint: e.forPrint
            }))
        }, t
    }(Mr);

    function Vs(e, t) {
        var n = new ra(e.renderRange, t);
        return new oa(n, /year|month|week/.test(e.currentRangeUnit))
    }

    var Gs = Tr({
        initialView: "dayGridMonth", views: {
            dayGrid: {
                component: function (e) {
                    function t() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.buildDayTableModel = Xt(Vs), t.headerRef = Ae(), t.tableRef = Ae(), t
                    }

                    return r(t, e), t.prototype.render = function () {
                        var e = this, t = this.context, n = t.options, i = t.dateProfileGenerator, r = this.props,
                            o = this.buildDayTableModel(r.dateProfile, i), a = n.dayHeaders && Ee(na, {
                                ref: this.headerRef,
                                dateProfile: r.dateProfile,
                                dates: o.headerDates,
                                datesRepDistinctDays: 1 === o.rowCnt
                            }), s = function (t) {
                                return Ee(Ws, {
                                    ref: e.tableRef,
                                    dateProfile: r.dateProfile,
                                    dayTableModel: o,
                                    businessHours: r.businessHours,
                                    dateSelection: r.dateSelection,
                                    eventStore: r.eventStore,
                                    eventUiBases: r.eventUiBases,
                                    eventSelection: r.eventSelection,
                                    eventDrag: r.eventDrag,
                                    eventResize: r.eventResize,
                                    nextDayThreshold: n.nextDayThreshold,
                                    colGroupNode: t.tableColGroupNode,
                                    tableMinWidth: t.tableMinWidth,
                                    dayMaxEvents: n.dayMaxEvents,
                                    dayMaxEventRows: n.dayMaxEventRows,
                                    showWeekNumbers: n.weekNumbers,
                                    expandRows: !r.isHeightAuto,
                                    headerAlignElRef: e.headerElRef,
                                    clientWidth: t.clientWidth,
                                    clientHeight: t.clientHeight,
                                    forPrint: r.forPrint
                                })
                            };
                        return n.dayMinWidth ? this.renderHScrollLayout(a, s, o.colCnt, n.dayMinWidth) : this.renderSimpleLayout(a, s)
                    }, t
                }(ws), dateProfileGeneratorClass: function (e) {
                    function t() {
                        return null !== e && e.apply(this, arguments) || this
                    }

                    return r(t, e), t.prototype.buildRenderRange = function (t, n, i) {
                        var r, o = this.props.dateEnv, a = e.prototype.buildRenderRange.call(this, t, n, i),
                            s = a.start, l = a.end;
                        (/^(year|month)$/.test(n) && (s = o.startOfWeek(s), (r = o.startOfWeek(l)).valueOf() !== l.valueOf() && (l = ut(r, 1))), this.props.monthMode && this.props.fixedWeekCount) && (l = ut(l, 6 - Math.ceil(pt(s, l) / 7)));
                        return {start: s, end: l}
                    }, t
                }(Hr)
            },
            dayGridDay: {type: "dayGrid", duration: {days: 1}},
            dayGridWeek: {type: "dayGrid", duration: {weeks: 1}},
            dayGridMonth: {type: "dayGrid", duration: {months: 1}, monthMode: !0, fixedWeekCount: !0}
        }
    }), qs = (n(175), function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.getKeyInfo = function () {
            return {allDay: {}, timed: {}}
        }, t.prototype.getKeysForDateSpan = function (e) {
            return e.allDay ? ["allDay"] : ["timed"]
        }, t.prototype.getKeysForEventDef = function (e) {
            return e.allDay ? "background" === (t = e).ui.display || "inverse-background" === t.ui.display ? ["timed", "allDay"] : ["allDay"] : ["timed"];
            var t
        }, t
    }(Zi)), Zs = hn({hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "short"});

    function $s(e) {
        var t = ["fc-timegrid-slot", "fc-timegrid-slot-label", e.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"];
        return Ee(_r.Consumer, null, (function (n) {
            if (!e.isLabeled) return Ee("td", {className: t.join(" "), "data-time": e.isoTimeStr});
            var i = n.dateEnv, r = n.options, o = n.viewApi,
                a = null == r.slotLabelFormat ? Zs : Array.isArray(r.slotLabelFormat) ? hn(r.slotLabelFormat[0]) : hn(r.slotLabelFormat),
                s = {level: 0, time: e.time, date: i.toDate(e.date), view: o, text: i.format(e.date, a)};
            return Ee(Lr, {
                hookProps: s,
                classNames: r.slotLabelClassNames,
                content: r.slotLabelContent,
                defaultContent: Xs,
                didMount: r.slotLabelDidMount,
                willUnmount: r.slotLabelWillUnmount
            }, (function (n, i, r, o) {
                return Ee("td", {
                    ref: n,
                    className: t.concat(i).join(" "),
                    "data-time": e.isoTimeStr
                }, Ee("div", {className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame"}, Ee("div", {
                    className: "fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion",
                    ref: r
                }, o)))
            }))
        }))
    }

    function Xs(e) {
        return e.text
    }

    var Js = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            return this.props.slatMetas.map((function (e) {
                return Ee("tr", {key: e.key}, Ee($s, o({}, e)))
            }))
        }, t
    }(vr), Ks = hn({week: "short"}), Qs = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.allDaySplitter = new qs, t.headerElRef = Ae(), t.rootElRef = Ae(), t.scrollerElRef = Ae(), t.state = {slatCoords: null}, t.handleScrollTopRequest = function (e) {
                var n = t.scrollerElRef.current;
                n && (n.scrollTop = e)
            }, t.renderHeadAxis = function (e, n) {
                void 0 === n && (n = "");
                var i = t.context.options, r = t.props.dateProfile.renderRange,
                    a = 1 === pt(r.start, r.end) ? er(t.context, r.start, "week") : {};
                return i.weekNumbers && "day" === e ? Ee(Ba, {
                    date: r.start,
                    defaultFormat: Ks
                }, (function (e, t, i, r) {
                    return Ee("th", {
                        ref: e,
                        "aria-hidden": !0,
                        className: ["fc-timegrid-axis", "fc-scrollgrid-shrink"].concat(t).join(" ")
                    }, Ee("div", {
                        className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid",
                        style: {height: n}
                    }, Ee("a", o({
                        ref: i,
                        className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner"
                    }, a), r)))
                })) : Ee("th", {
                    "aria-hidden": !0,
                    className: "fc-timegrid-axis"
                }, Ee("div", {className: "fc-timegrid-axis-frame", style: {height: n}}))
            }, t.renderTableRowAxis = function (e) {
                var n = t.context, i = n.options, r = n.viewApi, o = {text: i.allDayText, view: r};
                return Ee(Lr, {
                    hookProps: o,
                    classNames: i.allDayClassNames,
                    content: i.allDayContent,
                    defaultContent: el,
                    didMount: i.allDayDidMount,
                    willUnmount: i.allDayWillUnmount
                }, (function (t, n, i, r) {
                    return Ee("td", {
                        ref: t,
                        "aria-hidden": !0,
                        className: ["fc-timegrid-axis", "fc-scrollgrid-shrink"].concat(n).join(" ")
                    }, Ee("div", {
                        className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame" + (null == e ? " fc-timegrid-axis-frame-liquid" : ""),
                        style: {height: e}
                    }, Ee("span", {
                        className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner",
                        ref: i
                    }, r)))
                }))
            }, t.handleSlatCoords = function (e) {
                t.setState({slatCoords: e})
            }, t
        }

        return r(t, e), t.prototype.renderSimpleLayout = function (e, t, n) {
            var i = this.context, r = this.props, o = [], a = ka(i.options);
            return e && o.push({
                type: "header",
                key: "header",
                isSticky: a,
                chunk: {elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e}
            }), t && (o.push({type: "body", key: "all-day", chunk: {content: t}}), o.push({
                type: "body",
                key: "all-day-divider",
                outerContent: Ee("tr", {
                    role: "presentation",
                    className: "fc-scrollgrid-section"
                }, Ee("td", {className: "fc-timegrid-divider " + i.theme.getClass("tableCellShaded")}))
            })), o.push({
                type: "body",
                key: "body",
                liquid: !0,
                expandRows: Boolean(i.options.expandRows),
                chunk: {scrollerElRef: this.scrollerElRef, content: n}
            }), Ee(zr, {viewSpec: i.viewSpec, elRef: this.rootElRef}, (function (e, t) {
                return Ee("div", {
                    className: ["fc-timegrid"].concat(t).join(" "),
                    ref: e
                }, Ee(Da, {
                    liquid: !r.isHeightAuto && !r.forPrint,
                    collapsibleWidth: r.forPrint,
                    cols: [{width: "shrink"}],
                    sections: o
                }))
            }))
        }, t.prototype.renderHScrollLayout = function (e, t, n, i, r, o, a) {
            var s = this, l = this.context.pluginHooks.scrollGridImpl;
            if (!l) throw new Error("No ScrollGrid implementation");
            var c = this.context, u = this.props, d = !u.forPrint && ka(c.options), h = !u.forPrint && Sa(c.options),
                p = [];
            e && p.push({
                type: "header",
                key: "header",
                isSticky: d,
                syncRowHeights: !0,
                chunks: [{
                    key: "axis", rowContent: function (e) {
                        return Ee("tr", {role: "presentation"}, s.renderHeadAxis("day", e.rowSyncHeights[0]))
                    }
                }, {key: "cols", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e}]
            }), t && (p.push({
                type: "body",
                key: "all-day",
                syncRowHeights: !0,
                chunks: [{
                    key: "axis", rowContent: function (e) {
                        return Ee("tr", {role: "presentation"}, s.renderTableRowAxis(e.rowSyncHeights[0]))
                    }
                }, {key: "cols", content: t}]
            }), p.push({
                key: "all-day-divider",
                type: "body",
                outerContent: Ee("tr", {role: "presentation", className: "fc-scrollgrid-section"}, Ee("td", {
                    colSpan: 2,
                    className: "fc-timegrid-divider " + c.theme.getClass("tableCellShaded")
                }))
            }));
            var f = c.options.nowIndicator;
            return p.push({
                type: "body",
                key: "body",
                liquid: !0,
                expandRows: Boolean(c.options.expandRows),
                chunks: [{
                    key: "axis", content: function (e) {
                        return Ee("div", {className: "fc-timegrid-axis-chunk"}, Ee("table", {
                            "aria-hidden": !0,
                            style: {height: e.expandRows ? e.clientHeight : ""}
                        }, e.tableColGroupNode, Ee("tbody", null, Ee(Js, {slatMetas: o}))), Ee("div", {className: "fc-timegrid-now-indicator-container"}, Ee(ea, {unit: f ? "minute" : "day"}, (function (e) {
                            var t = f && a && a.safeComputeTop(e);
                            return "number" == typeof t ? Ee(Aa, {isAxis: !0, date: e}, (function (e, n, i, r) {
                                return Ee("div", {
                                    ref: e,
                                    className: ["fc-timegrid-now-indicator-arrow"].concat(n).join(" "),
                                    style: {top: t}
                                }, r)
                            })) : null
                        }))))
                    }
                }, {key: "cols", scrollerElRef: this.scrollerElRef, content: n}]
            }), h && p.push({
                key: "footer",
                type: "footer",
                isSticky: !0,
                chunks: [{key: "axis", content: Ta}, {key: "cols", content: Ta}]
            }), Ee(zr, {viewSpec: c.viewSpec, elRef: this.rootElRef}, (function (e, t) {
                return Ee("div", {
                    className: ["fc-timegrid"].concat(t).join(" "),
                    ref: e
                }, Ee(l, {
                    liquid: !u.isHeightAuto && !u.forPrint,
                    collapsibleWidth: !1,
                    colGroups: [{width: "shrink", cols: [{width: "shrink"}]}, {cols: [{span: i, minWidth: r}]}],
                    sections: p
                }))
            }))
        }, t.prototype.getAllDayMaxEventProps = function () {
            var e = this.context.options, t = e.dayMaxEvents, n = e.dayMaxEventRows;
            return !0 !== t && !0 !== n || (t = void 0, n = 5), {dayMaxEvents: t, dayMaxEventRows: n}
        }, t
    }(Mr);

    function el(e) {
        return e.text
    }

    var tl = function () {
        function e(e, t, n) {
            this.positions = e, this.dateProfile = t, this.slotDuration = n
        }

        return e.prototype.safeComputeTop = function (e) {
            var t = this.dateProfile;
            if ($n(t.currentRange, e)) {
                var n = mt(e), i = e.valueOf() - n.valueOf();
                if (i >= Ut(t.slotMinTime) && i < Ut(t.slotMaxTime)) return this.computeTimeTop(Bt(i))
            }
            return null
        }, e.prototype.computeDateTop = function (e, t) {
            return t || (t = mt(e)), this.computeTimeTop(Bt(e.valueOf() - t.valueOf()))
        }, e.prototype.computeTimeTop = function (e) {
            var t, n, i = this.positions, r = this.dateProfile, o = i.els.length,
                a = (e.milliseconds - Ut(r.slotMinTime)) / Ut(this.slotDuration);
            return a = Math.max(0, a), a = Math.min(o, a), t = Math.floor(a), n = a - (t = Math.min(t, o - 1)), i.tops[t] + i.getHeight(t) * n
        }, e
    }(), nl = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = t.options, i = e.slatElRefs;
            return Ee("tbody", null, e.slatMetas.map((function (r, a) {
                var s = {time: r.time, date: t.dateEnv.toDate(r.date), view: t.viewApi},
                    l = ["fc-timegrid-slot", "fc-timegrid-slot-lane", r.isLabeled ? "" : "fc-timegrid-slot-minor"];
                return Ee("tr", {key: r.key, ref: i.createRef(r.key)}, e.axis && Ee($s, o({}, r)), Ee(Lr, {
                    hookProps: s,
                    classNames: n.slotLaneClassNames,
                    content: n.slotLaneContent,
                    didMount: n.slotLaneDidMount,
                    willUnmount: n.slotLaneWillUnmount
                }, (function (e, t, n, i) {
                    return Ee("td", {ref: e, className: l.concat(t).join(" "), "data-time": r.isoTimeStr}, i)
                })))
            })))
        }, t
    }(vr), il = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.rootElRef = Ae(), t.slatElRefs = new ga, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context;
            return Ee("div", {ref: this.rootElRef, className: "fc-timegrid-slots"}, Ee("table", {
                "aria-hidden": !0,
                className: t.theme.getClass("table"),
                style: {minWidth: e.tableMinWidth, width: e.clientWidth, height: e.minHeight}
            }, e.tableColGroupNode, Ee(nl, {slatElRefs: this.slatElRefs, axis: e.axis, slatMetas: e.slatMetas})))
        }, t.prototype.componentDidMount = function () {
            this.updateSizing()
        }, t.prototype.componentDidUpdate = function () {
            this.updateSizing()
        }, t.prototype.componentWillUnmount = function () {
            this.props.onCoords && this.props.onCoords(null)
        }, t.prototype.updateSizing = function () {
            var e, t = this.context, n = this.props;
            n.onCoords && null !== n.clientWidth && (this.rootElRef.current.offsetHeight && n.onCoords(new tl(new ur(this.rootElRef.current, (e = this.slatElRefs.currentMap, n.slatMetas.map((function (t) {
                return e[t.key]
            }))), !1, !0), this.props.dateProfile, t.options.slotDuration)))
        }, t
    }(vr);

    function rl(e, t) {
        var n, i = [];
        for (n = 0; n < t; n += 1) i.push([]);
        if (e) for (n = 0; n < e.length; n += 1) i[e[n].col].push(e[n]);
        return i
    }

    function ol(e, t) {
        var n = [];
        if (e) {
            for (a = 0; a < t; a += 1) n[a] = {affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: []};
            for (var i = 0, r = e.segs; i < r.length; i++) {
                var o = r[i];
                n[o.col].segs.push(o)
            }
        } else for (var a = 0; a < t; a += 1) n[a] = null;
        return n
    }

    var al = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.rootElRef = Ae(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props;
            return Ee(Ua, {
                allDayDate: null,
                moreCnt: t.hiddenSegs.length,
                allSegs: t.hiddenSegs,
                hiddenSegs: t.hiddenSegs,
                alignmentElRef: this.rootElRef,
                defaultContent: sl,
                extraDateSpan: t.extraDateSpan,
                dateProfile: t.dateProfile,
                todayRange: t.todayRange,
                popoverContent: function () {
                    return yl(t.hiddenSegs, t)
                }
            }, (function (n, i, r, o, a, s, l, c) {
                return Ee("a", {
                    ref: function (t) {
                        wr(n, t), wr(e.rootElRef, t)
                    },
                    className: ["fc-timegrid-more-link"].concat(i).join(" "),
                    style: {top: t.top, bottom: t.bottom},
                    onClick: a,
                    title: s,
                    "aria-expanded": l,
                    "aria-controls": c
                }, Ee("div", {ref: r, className: "fc-timegrid-more-link-inner fc-sticky"}, o))
            }))
        }, t
    }(vr);

    function sl(e) {
        return e.shortText
    }

    function ll(e, t, n) {
        var i = new So;
        null != t && (i.strictOrder = t), null != n && (i.maxStackCnt = n);
        var r, a, s, l = function (e) {
            for (var t, n, i = [], r = 0, o = e; r < o.length; r++) {
                for (var a = o[r], s = [], l = {span: a.span, entries: [a]}, c = 0, u = i; c < u.length; c++) {
                    var d = u[c];
                    Eo(d.span, l.span) ? l = {
                        entries: d.entries.concat(l.entries),
                        span: (t = d.span, n = l.span, {start: Math.min(t.start, n.start), end: Math.max(t.end, n.end)})
                    } : s.push(d)
                }
                s.push(l), i = s
            }
            return i
        }(i.addSegs(e)), c = function (e) {
            var t = e.entriesByLevel, n = hl((function (e, t) {
                return e + ":" + t
            }), (function (i, r) {
                var a = cl(function (e, t, n) {
                    for (var i = e.levelCoords, r = e.entriesByLevel, o = r[t][n], a = i[t] + o.thickness, s = i.length, l = t; l < s && i[l] < a; l += 1) ;
                    for (; l < s; l += 1) {
                        for (var c = r[l], u = void 0, d = Ao(c, o.span.start, Do), h = d[0] + d[1], p = h; (u = c[p]) && u.span.start < o.span.end;) p += 1;
                        if (h < p) return {level: l, lateralStart: h, lateralEnd: p}
                    }
                    return null
                }(e, i, r), n), s = t[i][r];
                return [o(o({}, s), {nextLevelNodes: a[0]}), s.thickness + a[1]]
            }));
            return cl(t.length ? {level: 0, lateralStart: 0, lateralEnd: t[0].length} : null, n)[0]
        }(i);
        return r = c, a = 1, s = hl((function (e, t, n) {
            return Lo(e)
        }), (function (e, t, n) {
            var i, r = e.nextLevelNodes, l = e.thickness, c = l + n, u = l / c, d = [];
            if (r.length) for (var h = 0, p = r; h < p.length; h++) {
                var f = p[h];
                if (void 0 === i) i = (m = s(f, t, c))[0], d.push(m[1]); else {
                    var m = s(f, i, 0);
                    d.push(m[1])
                }
            } else i = a;
            var _ = (i - t) * u;
            return [i - _, o(o({}, e), {thickness: _, nextLevelNodes: d})]
        })), {
            segRects: function (e) {
                var t = [], n = hl((function (e, t, n) {
                    return Lo(e)
                }), (function (e, n, r) {
                    var a = o(o({}, e), {levelCoord: n, stackDepth: r, stackForward: 0});
                    return t.push(a), a.stackForward = i(e.nextLevelNodes, n + e.thickness, r + 1) + 1
                }));

                function i(e, t, i) {
                    for (var r = 0, o = 0, a = e; o < a.length; o++) {
                        var s = a[o];
                        r = Math.max(n(s, t, i), r)
                    }
                    return r
                }

                return i(e, 0, 0), t
            }(c = r.map((function (e) {
                return s(e, 0, 0)[1]
            }))), hiddenGroups: l
        }
    }

    function cl(e, t) {
        if (!e) return [[], 0];
        for (var n = e.level, i = e.lateralStart, r = e.lateralEnd, o = i, a = []; o < r;) a.push(t(n, o)), o += 1;
        return a.sort(ul), [a.map(dl), a[0][1]]
    }

    function ul(e, t) {
        return t[1] - e[1]
    }

    function dl(e) {
        return e[0]
    }

    function hl(e, t) {
        var n = {};
        return function () {
            for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r];
            var o = e.apply(void 0, i);
            return o in n ? n[o] : n[o] = t.apply(void 0, i)
        }
    }

    function pl(e, t, n, i) {
        void 0 === n && (n = null), void 0 === i && (i = 0);
        var r = [];
        if (n) for (var o = 0; o < e.length; o += 1) {
            var a = e[o], s = n.computeDateTop(a.start, t), l = Math.max(s + (i || 0), n.computeDateTop(a.end, t));
            r.push({start: Math.round(s), end: Math.round(l)})
        }
        return r
    }

    var fl = hn({hour: "numeric", minute: "2-digit", meridiem: !1}), ml = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = ["fc-timegrid-event", "fc-v-event"];
            return this.props.isShort && e.push("fc-timegrid-event-short"), Ee(Ea, o({}, this.props, {
                defaultTimeFormat: fl,
                extraClassNames: e
            }))
        }, t
    }(vr), _l = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props;
            return Ee(Pa, {
                date: e.date,
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                extraHookProps: e.extraHookProps
            }, (function (e, t) {
                return t && Ee("div", {className: "fc-timegrid-col-misc", ref: e}, t)
            }))
        }, t
    }(vr), gl = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.sortEventSegs = Xt(ti), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = this.context, i = n.options.selectMirror,
                r = t.eventDrag && t.eventDrag.segs || t.eventResize && t.eventResize.segs || i && t.dateSelectionSegs || [],
                a = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {},
                s = this.sortEventSegs(t.fgEventSegs, n.options.eventOrder);
            return Ee(Ya, {
                elRef: t.elRef,
                date: t.date,
                dateProfile: t.dateProfile,
                todayRange: t.todayRange,
                extraHookProps: t.extraHookProps
            }, (function (n, l, c) {
                return Ee("td", o({
                    ref: n,
                    role: "gridcell",
                    className: ["fc-timegrid-col"].concat(l, t.extraClassNames || []).join(" ")
                }, c, t.extraDataAttrs), Ee("div", {className: "fc-timegrid-col-frame"}, Ee("div", {className: "fc-timegrid-col-bg"}, e.renderFillSegs(t.businessHourSegs, "non-business"), e.renderFillSegs(t.bgEventSegs, "bg-event"), e.renderFillSegs(t.dateSelectionSegs, "highlight")), Ee("div", {className: "fc-timegrid-col-events"}, e.renderFgSegs(s, a, !1, !1, !1)), Ee("div", {className: "fc-timegrid-col-events"}, e.renderFgSegs(r, {}, Boolean(t.eventDrag), Boolean(t.eventResize), Boolean(i))), Ee("div", {className: "fc-timegrid-now-indicator-container"}, e.renderNowIndicator(t.nowIndicatorSegs)), Ee(_l, {
                    date: t.date,
                    dateProfile: t.dateProfile,
                    todayRange: t.todayRange,
                    extraHookProps: t.extraHookProps
                })))
            }))
        }, t.prototype.renderFgSegs = function (e, t, n, i, r) {
            var o = this.props;
            return o.forPrint ? yl(e, o) : this.renderPositionedFgSegs(e, t, n, i, r)
        }, t.prototype.renderPositionedFgSegs = function (e, t, n, i, r) {
            var a = this, s = this.context.options, l = s.eventMaxStack, c = s.eventShortHeight, u = s.eventOrderStrict,
                d = s.eventMinHeight, h = this.props, p = h.date, f = h.slatCoords, m = h.eventSelection,
                _ = h.todayRange, g = h.nowDate, y = n || i || r, v = function (e, t, n, i) {
                    for (var r = [], o = [], a = 0; a < e.length; a += 1) {
                        var s = t[a];
                        s ? r.push({index: a, thickness: 1, span: s}) : o.push(e[a])
                    }
                    for (var l = ll(r, n, i), c = l.segRects, u = l.hiddenGroups, d = [], h = 0, p = c; h < p.length; h++) {
                        var f = p[h];
                        d.push({seg: e[f.index], rect: f})
                    }
                    for (var m = 0, _ = o; m < _.length; m++) {
                        var g = _[m];
                        d.push({seg: g, rect: null})
                    }
                    return {segPlacements: d, hiddenGroups: u}
                }(e, pl(e, p, f, d), u, l), x = v.segPlacements, b = v.hiddenGroups;
            return Ee(Ie, null, this.renderHiddenGroups(b, e), x.map((function (e) {
                var s = e.seg, l = e.rect, u = s.eventRange.instance.instanceId, d = y || Boolean(!t[u] && l),
                    h = vl(l && l.span), p = !y && l ? a.computeSegHStyle(l) : {left: 0, right: 0},
                    f = Boolean(l) && l.stackForward > 0, v = Boolean(l) && l.span.end - l.span.start < c;
                return Ee("div", {
                    className: "fc-timegrid-event-harness" + (f ? " fc-timegrid-event-harness-inset" : ""),
                    key: u,
                    style: o(o({visibility: d ? "" : "hidden"}, h), p)
                }, Ee(ml, o({
                    seg: s,
                    isDragging: n,
                    isResizing: i,
                    isDateSelecting: r,
                    isSelected: u === m,
                    isShort: v
                }, si(s, _, g))))
            })))
        }, t.prototype.renderHiddenGroups = function (e, t) {
            var n = this.props, i = n.extraDateSpan, r = n.dateProfile, o = n.todayRange, a = n.nowDate,
                s = n.eventSelection, l = n.eventDrag, c = n.eventResize;
            return Ee(Ie, null, e.map((function (e) {
                var n, u, d = vl(e.span), h = (n = e.entries, u = t, n.map((function (e) {
                    return u[e.index]
                })));
                return Ee(al, {
                    key: Gt(Ga(h)),
                    hiddenSegs: h,
                    top: d.top,
                    bottom: d.bottom,
                    extraDateSpan: i,
                    dateProfile: r,
                    todayRange: o,
                    nowDate: a,
                    eventSelection: s,
                    eventDrag: l,
                    eventResize: c
                })
            })))
        }, t.prototype.renderFillSegs = function (e, t) {
            var n = this.props, i = this.context,
                r = pl(e, n.date, n.slatCoords, i.options.eventMinHeight).map((function (i, r) {
                    var a = e[r];
                    return Ee("div", {
                        key: li(a.eventRange),
                        className: "fc-timegrid-bg-harness",
                        style: vl(i)
                    }, "bg-event" === t ? Ee(Oa, o({seg: a}, si(a, n.todayRange, n.nowDate))) : za(t))
                }));
            return Ee(Ie, null, r)
        }, t.prototype.renderNowIndicator = function (e) {
            var t = this.props, n = t.slatCoords, i = t.date;
            return n ? e.map((function (e, t) {
                return Ee(Aa, {isAxis: !1, date: i, key: t}, (function (t, r, o, a) {
                    return Ee("div", {
                        ref: t,
                        className: ["fc-timegrid-now-indicator-line"].concat(r).join(" "),
                        style: {top: n.computeDateTop(e.start, i)}
                    }, a)
                }))
            })) : null
        }, t.prototype.computeSegHStyle = function (e) {
            var t, n, i = this.context, r = i.isRtl, o = i.options.slotEventOverlap, a = e.levelCoord,
                s = e.levelCoord + e.thickness;
            o && (s = Math.min(1, a + 2 * (s - a))), r ? (t = 1 - s, n = a) : (t = a, n = 1 - s);
            var l = {zIndex: e.stackDepth + 1, left: 100 * t + "%", right: 100 * n + "%"};
            return o && !e.stackForward && (l[r ? "marginLeft" : "marginRight"] = 20), l
        }, t
    }(vr);

    function yl(e, t) {
        var n = t.todayRange, i = t.nowDate, r = t.eventSelection, a = t.eventDrag, s = t.eventResize,
            l = (a ? a.affectedInstances : null) || (s ? s.affectedInstances : null) || {};
        return Ee(Ie, null, e.map((function (e) {
            var t = e.eventRange.instance.instanceId;
            return Ee("div", {key: t, style: {visibility: l[t] ? "hidden" : ""}}, Ee(ml, o({
                seg: e,
                isDragging: !1,
                isResizing: !1,
                isDateSelecting: !1,
                isSelected: t === r,
                isShort: !1
            }, si(e, n, i))))
        })))
    }

    function vl(e) {
        return e ? {top: e.start, bottom: -e.end} : {top: "", bottom: ""}
    }

    var xl = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.splitFgEventSegs = Xt(rl), t.splitBgEventSegs = Xt(rl), t.splitBusinessHourSegs = Xt(rl), t.splitNowIndicatorSegs = Xt(rl), t.splitDateSelectionSegs = Xt(rl), t.splitEventDrag = Xt(ol), t.splitEventResize = Xt(ol), t.rootElRef = Ae(), t.cellElRefs = new ga, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props,
                n = this.context.options.nowIndicator && t.slatCoords && t.slatCoords.safeComputeTop(t.nowDate),
                i = t.cells.length, r = this.splitFgEventSegs(t.fgEventSegs, i),
                o = this.splitBgEventSegs(t.bgEventSegs, i), a = this.splitBusinessHourSegs(t.businessHourSegs, i),
                s = this.splitNowIndicatorSegs(t.nowIndicatorSegs, i),
                l = this.splitDateSelectionSegs(t.dateSelectionSegs, i), c = this.splitEventDrag(t.eventDrag, i),
                u = this.splitEventResize(t.eventResize, i);
            return Ee("div", {className: "fc-timegrid-cols", ref: this.rootElRef}, Ee("table", {
                role: "presentation",
                style: {minWidth: t.tableMinWidth, width: t.clientWidth}
            }, t.tableColGroupNode, Ee("tbody", {role: "presentation"}, Ee("tr", {role: "row"}, t.axis && Ee("td", {
                "aria-hidden": !0,
                className: "fc-timegrid-col fc-timegrid-axis"
            }, Ee("div", {className: "fc-timegrid-col-frame"}, Ee("div", {className: "fc-timegrid-now-indicator-container"}, "number" == typeof n && Ee(Aa, {
                isAxis: !0,
                date: t.nowDate
            }, (function (e, t, i, r) {
                return Ee("div", {
                    ref: e,
                    className: ["fc-timegrid-now-indicator-arrow"].concat(t).join(" "),
                    style: {top: n}
                }, r)
            }))))), t.cells.map((function (n, i) {
                return Ee(gl, {
                    key: n.key,
                    elRef: e.cellElRefs.createRef(n.key),
                    dateProfile: t.dateProfile,
                    date: n.date,
                    nowDate: t.nowDate,
                    todayRange: t.todayRange,
                    extraHookProps: n.extraHookProps,
                    extraDataAttrs: n.extraDataAttrs,
                    extraClassNames: n.extraClassNames,
                    extraDateSpan: n.extraDateSpan,
                    fgEventSegs: r[i],
                    bgEventSegs: o[i],
                    businessHourSegs: a[i],
                    nowIndicatorSegs: s[i],
                    dateSelectionSegs: l[i],
                    eventDrag: c[i],
                    eventResize: u[i],
                    slatCoords: t.slatCoords,
                    eventSelection: t.eventSelection,
                    forPrint: t.forPrint
                })
            }))))))
        }, t.prototype.componentDidMount = function () {
            this.updateCoords()
        }, t.prototype.componentDidUpdate = function () {
            this.updateCoords()
        }, t.prototype.updateCoords = function () {
            var e, t = this.props;
            t.onColCoords && null !== t.clientWidth && t.onColCoords(new ur(this.rootElRef.current, (e = this.cellElRefs.currentMap, t.cells.map((function (t) {
                return e[t.key]
            }))), !0, !1))
        }, t
    }(vr);
    var bl = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.processSlotOptions = Xt(wl), t.state = {slatCoords: null}, t.handleRootEl = function (e) {
                e ? t.context.registerInteractiveComponent(t, {
                    el: e,
                    isHitComboAllowed: t.props.isHitComboAllowed
                }) : t.context.unregisterInteractiveComponent(t)
            }, t.handleScrollRequest = function (e) {
                var n = t.props.onScrollTopRequest, i = t.state.slatCoords;
                if (n && i) {
                    if (e.time) {
                        var r = i.computeTimeTop(e.time);
                        (r = Math.ceil(r)) && (r += 1), n(r)
                    }
                    return !0
                }
                return !1
            }, t.handleColCoords = function (e) {
                t.colCoords = e
            }, t.handleSlatCoords = function (e) {
                t.setState({slatCoords: e}), t.props.onSlatCoords && t.props.onSlatCoords(e)
            }, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.state;
            return Ee("div", {
                className: "fc-timegrid-body",
                ref: this.handleRootEl,
                style: {width: e.clientWidth, minWidth: e.tableMinWidth}
            }, Ee(il, {
                axis: e.axis,
                dateProfile: e.dateProfile,
                slatMetas: e.slatMetas,
                clientWidth: e.clientWidth,
                minHeight: e.expandRows ? e.clientHeight : "",
                tableMinWidth: e.tableMinWidth,
                tableColGroupNode: e.axis ? e.tableColGroupNode : null,
                onCoords: this.handleSlatCoords
            }), Ee(xl, {
                cells: e.cells,
                axis: e.axis,
                dateProfile: e.dateProfile,
                businessHourSegs: e.businessHourSegs,
                bgEventSegs: e.bgEventSegs,
                fgEventSegs: e.fgEventSegs,
                dateSelectionSegs: e.dateSelectionSegs,
                eventSelection: e.eventSelection,
                eventDrag: e.eventDrag,
                eventResize: e.eventResize,
                todayRange: e.todayRange,
                nowDate: e.nowDate,
                nowIndicatorSegs: e.nowIndicatorSegs,
                clientWidth: e.clientWidth,
                tableMinWidth: e.tableMinWidth,
                tableColGroupNode: e.tableColGroupNode,
                slatCoords: t.slatCoords,
                onColCoords: this.handleColCoords,
                forPrint: e.forPrint
            }))
        }, t.prototype.componentDidMount = function () {
            this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)
        }, t.prototype.componentDidUpdate = function (e) {
            this.scrollResponder.update(e.dateProfile !== this.props.dateProfile)
        }, t.prototype.componentWillUnmount = function () {
            this.scrollResponder.detach()
        }, t.prototype.queryHit = function (e, t) {
            var n = this.context, i = n.dateEnv, r = n.options, a = this.colCoords, s = this.props.dateProfile,
                l = this.state.slatCoords, c = this.processSlotOptions(this.props.slotDuration, r.snapDuration),
                u = c.snapDuration, d = c.snapsPerSlot, h = a.leftToIndex(e), p = l.positions.topToIndex(t);
            if (null != h && null != p) {
                var f = this.props.cells[h], m = l.positions.tops[p], _ = l.positions.getHeight(p), g = (t - m) / _,
                    y = p * d + Math.floor(g * d), v = this.props.cells[h].date, x = Ht(s.slotMinTime, function (e, t) {
                        return {
                            years: e.years * t,
                            months: e.months * t,
                            days: e.days * t,
                            milliseconds: e.milliseconds * t
                        }
                    }(u, y)), b = i.add(v, x), w = i.add(b, u);
                return {
                    dateProfile: s,
                    dateSpan: o({range: {start: b, end: w}, allDay: !1}, f.extraDateSpan),
                    dayEl: a.els[h],
                    rect: {left: a.lefts[h], right: a.rights[h], top: m, bottom: m + _},
                    layer: 0
                }
            }
            return null
        }, t
    }(Mr);

    function wl(e, t) {
        var n = t || e, i = Wt(e, n);
        return null === i && (n = e, i = 1), {snapDuration: n, snapsPerSlot: i}
    }

    var Ml = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.sliceRange = function (e, t) {
            for (var n = [], i = 0; i < t.length; i += 1) {
                var r = Gn(e, t[i]);
                r && n.push({
                    start: r.start,
                    end: r.end,
                    isStart: r.start.valueOf() === e.start.valueOf(),
                    isEnd: r.end.valueOf() === e.end.valueOf(),
                    col: i
                })
            }
            return n
        }, t
    }(aa), Tl = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.buildDayRanges = Xt(kl), t.slicer = new Ml, t.timeColsRef = Ae(), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.props, n = this.context, i = t.dateProfile, r = t.dayTableModel,
                a = n.options.nowIndicator, s = this.buildDayRanges(r, i, n.dateEnv);
            return Ee(ea, {unit: a ? "minute" : "day"}, (function (l, c) {
                return Ee(bl, o({ref: e.timeColsRef}, e.slicer.sliceProps(t, i, null, n, s), {
                    forPrint: t.forPrint,
                    axis: t.axis,
                    dateProfile: i,
                    slatMetas: t.slatMetas,
                    slotDuration: t.slotDuration,
                    cells: r.cells[0],
                    tableColGroupNode: t.tableColGroupNode,
                    tableMinWidth: t.tableMinWidth,
                    clientWidth: t.clientWidth,
                    clientHeight: t.clientHeight,
                    expandRows: t.expandRows,
                    nowDate: l,
                    nowIndicatorSegs: a && e.slicer.sliceNowDate(l, n, s),
                    todayRange: c,
                    onScrollTopRequest: t.onScrollTopRequest,
                    onSlatCoords: t.onSlatCoords
                }))
            }))
        }, t
    }(Mr);

    function kl(e, t, n) {
        for (var i = [], r = 0, o = e.headerDates; r < o.length; r++) {
            var a = o[r];
            i.push({start: n.add(a, t.slotMinTime), end: n.add(a, t.slotMaxTime)})
        }
        return i
    }

    var Sl = [{hours: 1}, {minutes: 30}, {minutes: 15}, {seconds: 30}, {seconds: 15}];

    function Dl(e, t, n, i, r) {
        for (var o, a = new Date(0), s = e, l = Bt(0), c = n || function (e) {
            var t, n, i;
            for (t = Sl.length - 1; t >= 0; t -= 1) if (n = Bt(Sl[t]), null !== (i = Wt(n, e)) && i > 1) return n;
            return e
        }(i), u = []; Ut(s) < Ut(t);) {
            var d = r.add(a, s), h = null !== Wt(l, c);
            u.push({
                date: d,
                time: s,
                key: d.toISOString(),
                isoTimeStr: (o = d, rt(o.getUTCHours(), 2) + ":" + rt(o.getUTCMinutes(), 2) + ":" + rt(o.getUTCSeconds(), 2)),
                isLabeled: h
            }), s = Ht(s, i), l = Ht(l, i)
        }
        return u
    }

    var Ll = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.buildTimeColsModel = Xt(El), t.buildSlatMetas = Xt(Dl), t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this, t = this.context, n = t.options, i = t.dateEnv, r = t.dateProfileGenerator, a = this.props,
                s = a.dateProfile, l = this.buildTimeColsModel(s, r), c = this.allDaySplitter.splitProps(a),
                u = this.buildSlatMetas(s.slotMinTime, s.slotMaxTime, n.slotLabelInterval, n.slotDuration, i),
                d = n.dayMinWidth, h = !d, p = d, f = n.dayHeaders && Ee(na, {
                    dates: l.headerDates,
                    dateProfile: s,
                    datesRepDistinctDays: !0,
                    renderIntro: h ? this.renderHeadAxis : null
                }), m = !1 !== n.allDaySlot && function (t) {
                    return Ee(Ws, o({}, c.allDay, {
                        dateProfile: s,
                        dayTableModel: l,
                        nextDayThreshold: n.nextDayThreshold,
                        tableMinWidth: t.tableMinWidth,
                        colGroupNode: t.tableColGroupNode,
                        renderRowIntro: h ? e.renderTableRowAxis : null,
                        showWeekNumbers: !1,
                        expandRows: !1,
                        headerAlignElRef: e.headerElRef,
                        clientWidth: t.clientWidth,
                        clientHeight: t.clientHeight,
                        forPrint: a.forPrint
                    }, e.getAllDayMaxEventProps()))
                }, _ = function (t) {
                    return Ee(Tl, o({}, c.timed, {
                        dayTableModel: l,
                        dateProfile: s,
                        axis: h,
                        slotDuration: n.slotDuration,
                        slatMetas: u,
                        forPrint: a.forPrint,
                        tableColGroupNode: t.tableColGroupNode,
                        tableMinWidth: t.tableMinWidth,
                        clientWidth: t.clientWidth,
                        clientHeight: t.clientHeight,
                        onSlatCoords: e.handleSlatCoords,
                        expandRows: t.expandRows,
                        onScrollTopRequest: e.handleScrollTopRequest
                    }))
                };
            return p ? this.renderHScrollLayout(f, m, _, l.colCnt, d, u, this.state.slatCoords) : this.renderSimpleLayout(f, m, _)
        }, t
    }(Qs);

    function El(e, t) {
        var n = new ra(e.renderRange, t);
        return new oa(n, !1)
    }

    var Cl = Tr({
        initialView: "timeGridWeek",
        optionRefiners: {allDaySlot: Boolean},
        views: {
            timeGrid: {
                component: Ll,
                usesMinMaxTime: !0,
                allDaySlot: !0,
                slotDuration: "00:30:00",
                slotEventOverlap: !0
            },
            timeGridDay: {type: "timeGrid", duration: {days: 1}},
            timeGridWeek: {type: "timeGrid", duration: {weeks: 1}}
        }
    }), Al = (n(176), function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.state = {textId: qe()}, t
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.context, t = e.theme, n = e.dateEnv, i = e.options, r = e.viewApi, a = this.props,
                s = a.cellId, l = a.dayDate, c = a.todayRange, u = this.state.textId, d = Xi(l, c),
                h = i.listDayFormat ? n.format(l, i.listDayFormat) : "",
                p = i.listDaySideFormat ? n.format(l, i.listDaySideFormat) : "", f = o({
                    date: n.toDate(l),
                    view: r,
                    textId: u,
                    text: h,
                    sideText: p,
                    navLinkAttrs: er(this.context, l),
                    sideNavLinkAttrs: er(this.context, l, "day", !1)
                }, d), m = ["fc-list-day"].concat(Ji(d, t));
            return Ee(Lr, {
                hookProps: f,
                classNames: i.dayHeaderClassNames,
                content: i.dayHeaderContent,
                defaultContent: Il,
                didMount: i.dayHeaderDidMount,
                willUnmount: i.dayHeaderWillUnmount
            }, (function (e, n, i, r) {
                return Ee("tr", {
                    ref: e,
                    className: m.concat(n).join(" "),
                    "data-date": qt(l)
                }, Ee("th", {
                    scope: "colgroup",
                    colSpan: 3,
                    id: s,
                    "aria-labelledby": u
                }, Ee("div", {className: "fc-list-day-cushion " + t.getClass("tableCellShaded"), ref: i}, r)))
            }))
        }, t
    }(vr));

    function Il(e) {
        return Ee(Ie, null, e.text && Ee("a", o({
            id: e.textId,
            className: "fc-list-day-text"
        }, e.navLinkAttrs), e.text), e.sideText && Ee("a", o({
            "aria-hidden": !0,
            className: "fc-list-day-side-text"
        }, e.sideNavLinkAttrs), e.sideText))
    }

    var Pl = hn({hour: "numeric", minute: "2-digit", meridiem: "short"}), Rl = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return r(t, e), t.prototype.render = function () {
            var e = this.props, t = this.context, n = e.seg, i = e.timeHeaderId, r = e.eventHeaderId,
                a = e.dateHeaderId, s = t.options.eventTimeFormat || Pl;
            return Ee(La, {
                seg: n,
                timeText: "",
                disableDragging: !0,
                disableResizing: !0,
                defaultContent: function () {
                    return function (e, t) {
                        var n = ci(e, t);
                        return Ee("a", o({}, n), e.eventRange.def.title)
                    }(n, t)
                },
                isPast: e.isPast,
                isFuture: e.isFuture,
                isToday: e.isToday,
                isSelected: e.isSelected,
                isDragging: e.isDragging,
                isResizing: e.isResizing,
                isDateSelecting: e.isDateSelecting
            }, (function (e, o, l, c, u) {
                return Ee("tr", {
                    className: ["fc-list-event", u.event.url ? "fc-event-forced-url" : ""].concat(o).join(" "),
                    ref: e
                }, function (e, t, n, i, r) {
                    var o = n.options;
                    if (!1 !== o.displayEventTime) {
                        var a = e.eventRange.def, s = e.eventRange.instance, l = !1, c = void 0;
                        if (a.allDay ? l = !0 : (d = e.eventRange.range, pt((h = Nn(d)).start, h.end) > 1 ? e.isStart ? c = ai(e, t, n, null, null, s.range.start, e.end) : e.isEnd ? c = ai(e, t, n, null, null, e.start, s.range.end) : l = !0 : c = ai(e, t, n)), l) {
                            var u = {text: n.options.allDayText, view: n.viewApi};
                            return Ee(Lr, {
                                hookProps: u,
                                classNames: o.allDayClassNames,
                                content: o.allDayContent,
                                defaultContent: Yl,
                                didMount: o.allDayDidMount,
                                willUnmount: o.allDayWillUnmount
                            }, (function (e, t, n, o) {
                                return Ee("td", {
                                    ref: e,
                                    headers: i + " " + r,
                                    className: ["fc-list-event-time"].concat(t).join(" ")
                                }, o)
                            }))
                        }
                        return Ee("td", {className: "fc-list-event-time"}, c)
                    }
                    var d, h;
                    return null
                }(n, s, t, i, a), Ee("td", {
                    "aria-hidden": !0,
                    className: "fc-list-event-graphic"
                }, Ee("span", {
                    className: "fc-list-event-dot",
                    style: {borderColor: u.borderColor || u.backgroundColor}
                })), Ee("td", {ref: l, headers: r + " " + a, className: "fc-list-event-title"}, c))
            }))
        }, t
    }(vr);

    function Yl(e) {
        return e.text
    }

    function zl(e) {
        return e.text
    }

    function Ol(e) {
        for (var t = mt(e.renderRange.start), n = e.renderRange.end, i = [], r = []; t < n;) i.push(t), r.push({
            start: t,
            end: dt(t, 1)
        }), t = dt(t, 1);
        return {dayDates: i, dayRanges: r}
    }

    function Fl(e) {
        return !1 === e ? null : hn(e)
    }

    var Bl = Tr({
        optionRefiners: {
            listDayFormat: Fl,
            listDaySideFormat: Fl,
            noEventsClassNames: wn,
            noEventsContent: wn,
            noEventsDidMount: wn,
            noEventsWillUnmount: wn
        }, views: {
            list: {
                component: function (e) {
                    function t() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.computeDateVars = Xt(Ol), t.eventStoreToSegs = Xt(t._eventStoreToSegs), t.state = {
                            timeHeaderId: qe(),
                            eventHeaderId: qe(),
                            dateHeaderIdRoot: qe()
                        }, t.setRootEl = function (e) {
                            e ? t.context.registerInteractiveComponent(t, {el: e}) : t.context.unregisterInteractiveComponent(t)
                        }, t
                    }

                    return r(t, e), t.prototype.render = function () {
                        var e = this, t = this.props, n = this.context,
                            i = ["fc-list", n.theme.getClass("table"), !1 !== n.options.stickyHeaderDates ? "fc-list-sticky" : ""],
                            r = this.computeDateVars(t.dateProfile), o = r.dayDates, a = r.dayRanges,
                            s = this.eventStoreToSegs(t.eventStore, t.eventUiBases, a);
                        return Ee(zr, {viewSpec: n.viewSpec, elRef: this.setRootEl}, (function (n, r) {
                            return Ee("div", {
                                ref: n,
                                className: i.concat(r).join(" ")
                            }, Ee(_a, {
                                liquid: !t.isHeightAuto,
                                overflowX: t.isHeightAuto ? "visible" : "hidden",
                                overflowY: t.isHeightAuto ? "visible" : "auto"
                            }, s.length > 0 ? e.renderSegList(s, o) : e.renderEmptyMessage()))
                        }))
                    }, t.prototype.renderEmptyMessage = function () {
                        var e = this.context, t = e.options, n = e.viewApi, i = {text: t.noEventsText, view: n};
                        return Ee(Lr, {
                            hookProps: i,
                            classNames: t.noEventsClassNames,
                            content: t.noEventsContent,
                            defaultContent: zl,
                            didMount: t.noEventsDidMount,
                            willUnmount: t.noEventsWillUnmount
                        }, (function (e, t, n, i) {
                            return Ee("div", {
                                className: ["fc-list-empty"].concat(t).join(" "),
                                ref: e
                            }, Ee("div", {className: "fc-list-empty-cushion", ref: n}, i))
                        }))
                    }, t.prototype.renderSegList = function (e, t) {
                        var n = this.context, i = n.theme, r = n.options, a = this.state, s = a.timeHeaderId,
                            l = a.eventHeaderId, c = a.dateHeaderIdRoot, u = function (e) {
                                var t, n, i = [];
                                for (t = 0; t < e.length; t += 1) n = e[t], (i[n.dayIndex] || (i[n.dayIndex] = [])).push(n);
                                return i
                            }(e);
                        return Ee(ea, {unit: "day"}, (function (e, n) {
                            for (var a = [], d = 0; d < u.length; d += 1) {
                                var h = u[d];
                                if (h) {
                                    var p = qt(t[d]), f = c + "-" + p;
                                    a.push(Ee(Al, {key: p, cellId: f, dayDate: t[d], todayRange: n}));
                                    for (var m = 0, _ = h = ti(h, r.eventOrder); m < _.length; m++) {
                                        var g = _[m];
                                        a.push(Ee(Rl, o({
                                            key: p + ":" + g.eventRange.instance.instanceId,
                                            seg: g,
                                            isDragging: !1,
                                            isResizing: !1,
                                            isDateSelecting: !1,
                                            isSelected: !1,
                                            timeHeaderId: s,
                                            eventHeaderId: l,
                                            dateHeaderId: f
                                        }, si(g, n, e))))
                                    }
                                }
                            }
                            return Ee("table", {className: "fc-list-table " + i.getClass("table")}, Ee("thead", null, Ee("tr", null, Ee("th", {
                                scope: "col",
                                id: s
                            }, r.timeHint), Ee("th", {scope: "col", "aria-hidden": !0}), Ee("th", {
                                scope: "col",
                                id: l
                            }, r.eventHint))), Ee("tbody", null, a))
                        }))
                    }, t.prototype._eventStoreToSegs = function (e, t, n) {
                        return this.eventRangesToSegs(Xn(e, t, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, n)
                    }, t.prototype.eventRangesToSegs = function (e, t) {
                        for (var n = [], i = 0, r = e; i < r.length; i++) {
                            var o = r[i];
                            n.push.apply(n, this.eventRangeToSegs(o, t))
                        }
                        return n
                    }, t.prototype.eventRangeToSegs = function (e, t) {
                        var n, i, r, o = this.context.dateEnv, a = this.context.options.nextDayThreshold, s = e.range,
                            l = e.def.allDay, c = [];
                        for (n = 0; n < t.length; n += 1) if ((i = Gn(s, t[n])) && (r = {
                            component: this,
                            eventRange: e,
                            start: i.start,
                            end: i.end,
                            isStart: e.isStart && i.start.valueOf() === s.start.valueOf(),
                            isEnd: e.isEnd && i.end.valueOf() === s.end.valueOf(),
                            dayIndex: n
                        }, c.push(r), !r.isEnd && !l && n + 1 < t.length && s.end < o.add(t[n + 1].start, a))) {
                            r.end = s.end, r.isEnd = !0;
                            break
                        }
                        return c
                    }, t
                }(Mr), buttonTextKey: "list", listDayFormat: {month: "long", day: "numeric", year: "numeric"}
            },
            listDay: {type: "list", duration: {days: 1}, listDayFormat: {weekday: "long"}},
            listWeek: {
                type: "list",
                duration: {weeks: 1},
                listDayFormat: {weekday: "long"},
                listDaySideFormat: {month: "long", day: "numeric", year: "numeric"}
            },
            listMonth: {type: "list", duration: {month: 1}, listDaySideFormat: {weekday: "long"}},
            listYear: {type: "list", duration: {year: 1}, listDaySideFormat: {weekday: "long"}}
        }
    });
    document.addEventListener("DOMContentLoaded", (function () {
        var e = document.getElementById("calendar");
        new $a(e, {
            plugins: [bs, Gs, Cl, Bl],
            headerToolbar: {
                left: "prev,next today",
                center: "title",
                right: "dayGridMonth,timeGridWeek,timeGridDay,listWeek"
            },
            initialDate: "2018-01-12",
            navLinks: !0,
            editable: !0,
            dayMaxEvents: !0,
            events: [{title: "All Day Event", start: "2018-01-01"}, {
                title: "Long Event",
                start: "2018-01-07",
                end: "2018-01-10"
            }, {groupId: 999, title: "Repeating Event", start: "2018-01-09T16:00:00"}, {
                groupId: 999,
                title: "Repeating Event",
                start: "2018-01-16T16:00:00"
            }, {title: "Conference", start: "2018-01-11", end: "2018-01-13"}, {
                title: "Meeting",
                start: "2018-01-12T10:30:00",
                end: "2018-01-12T12:30:00"
            }, {title: "Lunch", start: "2018-01-12T12:00:00"}, {
                title: "Meeting",
                start: "2018-01-12T14:30:00"
            }, {title: "Happy Hour", start: "2018-01-12T17:30:00"}, {
                title: "Dinner",
                start: "2018-01-12T20:00:00"
            }, {title: "Birthday Party", start: "2018-01-13T07:00:00"}, {
                title: "Click for Google",
                url: "http://google.com/",
                start: "2018-01-28"
            }]
        }).render()
    }))
}, , , , function (e, t) {
}, , , , , , , , , , , , , , , function (e, t) {
}, function (e, t) {
}, function (e, t) {
}, function (e, t) {
}]);
